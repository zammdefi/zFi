<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>DAICO</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><rect width='16' height='16' fill='%230a0a0a'/><rect x='3' y='1' width='1' height='1' fill='%23e8e8e0'/><rect x='5' y='2' width='1' height='1' fill='%23e8e8e0'/><rect x='10' y='2' width='1' height='1' fill='%23e8e8e0'/><rect x='12' y='1' width='1' height='1' fill='%23e8e8e0'/><rect x='4' y='4' width='8' height='1' fill='%23e8e8e0'/><rect x='3' y='5' width='10' height='1' fill='%23e8e8e0'/><rect x='2' y='6' width='12' height='3' fill='%23e8e8e0'/><rect x='3' y='9' width='10' height='1' fill='%23e8e8e0'/><rect x='4' y='10' width='8' height='1' fill='%23e8e8e0'/><rect x='3' y='6' width='3' height='2' fill='%230a0a0a'/><rect x='10' y='6' width='3' height='2' fill='%230a0a0a'/><rect x='5' y='11' width='2' height='1' fill='%23e8e8e0'/><rect x='9' y='11' width='2' height='1' fill='%23e8e8e0'/><rect x='2' y='12' width='3' height='1' fill='%23e8e8e0'/><rect x='7' y='12' width='2' height='1' fill='%23e8e8e0'/><rect x='11' y='12' width='3' height='1' fill='%23e8e8e0'/><rect x='1' y='13' width='2' height='1' fill='%23e8e8e0'/><rect x='13' y='13' width='2' height='1' fill='%23e8e8e0'/></svg>" type="image/svg+xml">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body {
  font-family: Helvetica, Arial, sans-serif;
  background: #fff;
  color: #000;
  min-height: 100vh;
  padding: 60px 20px 20px;
  max-width: 620px;
  margin: 0 auto;
}
h1 {
  font-size: 14px;
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  margin-bottom: 20px;
}
a { color: #000; }
label {
  display: block;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 8px;
  color: #666;
}
input {
  width: 100%;
  padding: 12px 0;
  font-size: 16px;
  font-family: inherit;
  border: none;
  border-bottom: 1px solid #000;
  outline: none;
  background: transparent;
  color: #000;
}
input::placeholder { color: #ccc; }
input:focus { border-bottom-width: 2px; }
button {
  display: inline-block;
  padding: 12px 24px;
  font-size: 12px;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  background: #000;
  color: #fff;
  border: 1px solid #000;
  cursor: pointer;
  margin-right: 8px;
  margin-top: 8px;
  transition: background 0.2s, border-color 0.2s, color 0.2s;
}
button:hover { background: #333; }
button:disabled { background: #ccc; border-color: #ccc; cursor: not-allowed; }
button.secondary {
  background: #fff;
  color: #000;
}
button.secondary:hover { background: #f5f5f5; }

/* Wallet */
.wallet {
  position: fixed;
  top: max(20px, env(safe-area-inset-top, 0px));
  right: max(20px, env(safe-area-inset-right, 0px));
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  z-index: 100;
}
.wallet button { margin: 0; padding: 8px 16px; text-transform: none; }

/* Nav links */
.nav-links {
  font-size: 12px;
  margin-bottom: 24px;
}
.nav-links a {
  color: #000;
  text-decoration: underline;
}
.nav-links a:hover { opacity: 0.5; }

/* Form */
.form-group {
  margin-bottom: 20px;
}
.form-hint {
  font-size: 12px;
  color: #999;
  margin-top: 4px;
}

/* Raise buttons */
.raise-options {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-top: 24px;
}
.raise-btn {
  width: 100%;
  padding: 20px 24px;
  font-size: 14px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  background: #000;
  color: #fff;
  border: 1px solid #000;
  cursor: pointer;
  margin: 0;
  transition: background 0.2s, border-color 0.2s;
}
.raise-btn:hover:not(:disabled) { background: #333; }
.raise-btn:disabled { background: #ccc; border-color: #ccc; cursor: not-allowed; }

/* Status */
.status-message {
  font-size: 13px;
  line-height: 1.6;
  padding: 12px;
  background: #f9f9f9;
  margin-top: 16px;
  animation: fadeIn 0.3s ease;
}
.status-message a { color: #000; text-decoration: underline; }
.status-message a:hover { opacity: 0.5; }
.status-message.error-message { background: #fff0f0; }
.status-message.success { background: #f0fff0; }
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

/* Spinner */
.spinner {
  display: inline-block;
  width: 12px;
  height: 12px;
  border: 2px solid #ccc;
  border-top: 2px solid #000;
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  vertical-align: middle;
  margin-right: 8px;
}
@keyframes spin { 0% { transform: rotate(0); } 100% { transform: rotate(360deg); } }

/* Info box */
.info-box {
  padding: 12px;
  background: #f9f9f9;
  border: 1px solid #ddd;
  margin-bottom: 12px;
  font-size: 13px;
  line-height: 1.5;
}

/* Modal */
.wallet-modal-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  backdrop-filter: blur(4px);
  z-index: 2000;
  justify-content: center;
  align-items: center;
  padding: 20px;
  overflow-y: auto;
}
.wallet-modal-overlay.active { display: flex; }
body.modal-open { overflow: hidden; }
.wallet-modal {
  background: #fff;
  border: 2px solid #000;
  padding: 20px;
  width: 100%;
  max-width: 400px;
}
.wallet-modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}
.wallet-modal-title {
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}
.wallet-modal-close {
  background: none;
  border: none;
  color: #000;
  font-size: 24px;
  cursor: pointer;
  line-height: 1;
  padding: 0;
  margin: 0;
}
.wallet-modal-close:hover { opacity: 0.5; }
.wallet-option {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: #fff;
  border: 1px solid #000;
  cursor: pointer;
  margin-bottom: 8px;
  transition: background 0.15s, color 0.15s;
}
.wallet-option:hover { background: #000; color: #fff; }
.wallet-icon { font-size: 1.5rem; }
.wallet-name { font-weight: 600; }
.wallet-status { font-size: 11px; color: #999; }
.wallet-status.installed { color: #2d8a2d; }
.wallet-option.disconnect {
  border-color: #e74c3c;
  color: #e74c3c;
  justify-content: center;
}
.wallet-option.disconnect:hover { background: #e74c3c; color: #fff; }

/* Tracker */
.tracker {
  margin-top: 40px;
  padding-top: 24px;
  border-top: 1px solid #ddd;
}
.tracker-bar {
  font-family: 'Courier New', Courier, monospace;
  font-size: 13px;
  line-height: 1.6;
  background: #f9f9f9;
  padding: 16px;
  margin-top: 12px;
  white-space: pre;
  overflow-x: auto;
}
.tracker-bar .label {
  color: #666;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}
.tracker-bar .bar-fill { color: #000; }
.tracker-bar .bar-empty { color: #ddd; }
.tracker-bar .pct { color: #000; font-weight: bold; }

/* Footer */
.site-footer {
  position: relative;
  text-align: center;
  padding: 40px 20px;
  font-size: 11px;
  opacity: 0.4;
  letter-spacing: 0.5px;
}
.site-footer a {
  color: inherit;
  text-decoration: underline;
}
.site-footer a:hover { opacity: 0.7; }

/* Responsive */
@media (max-width: 700px) {
  body { padding: 80px 16px 20px; }
  .wallet { top: 16px; right: 16px; }
  .wallet button { padding: 10px 14px; font-size: 11px; }
  h1 { font-size: 12px; margin-bottom: 16px; }
  button { padding: 14px 20px; }
}
@media (max-width: 380px) {
  body { padding: 70px 12px 20px; }
  h1 { font-size: 12px; }
  .raise-options { grid-template-columns: 1fr; }
}
</style>
</head>
<body>

<!-- Wallet -->
<div class="wallet">
  <button id="walletBtn" onclick="connectWallet()">connect</button>
</div>

<h1>DAICO</h1>

<div class="nav-links">
  <a href="../dao/">DAO</a> &middot;
  <a href="../">Swap</a> &middot;
  <a href="https://github.com/z0r0z/majeur" target="_blank" rel="noopener">GitHub</a>
</div>

<div class="info-box">
  Raise ETH with a token sale and tap. You operate, buyers can ragequit. Funds release over 3 months to ops. Holders exit anytime with their pro-rata share. 3 day timelock on all proposals.
</div>

<!-- Wallet Selection Modal -->
<div class="wallet-modal-overlay" id="walletModal">
  <div class="wallet-modal">
    <div class="wallet-modal-header">
      <h2 class="wallet-modal-title">Connect Wallet</h2>
      <button class="wallet-modal-close" onclick="closeWalletModal()">&times;</button>
    </div>
    <div id="walletOptions"></div>
  </div>
</div>

<div class="form-group">
  <label>Name</label>
  <input type="text" id="daoName" placeholder="e.g., MyCoin" maxlength="50">
</div>

<div class="form-group">
  <label>Symbol</label>
  <input type="text" id="daoSymbol" placeholder="e.g., MC" maxlength="10">
</div>

<div class="form-group">
  <label>Vision <span style="text-transform: none; color: #999;">(optional)</span></label>
  <textarea id="daoDescription" placeholder="Describe the goal of this raise..." rows="2" style="width:100%;padding:10px;font-size:14px;font-family:inherit;border:1px solid #ddd;outline:none;background:transparent;color:#000;resize:vertical;min-height:50px;"></textarea>
  <div class="form-hint">defaults to <a href="https://github.com/z0r0z/majeur?tab=readme-ov-file#wyoming-duna" target="_blank" rel="noopener" style="color:#000;text-decoration:underline;">DUNA</a> charter</div>
</div>

<div id="previewBox" class="info-box" style="display:none; background:#f9f9f9; border-left:3px solid #000; font-size:13px; line-height:1.7;"></div>

<div class="raise-options">
  <button class="raise-btn" id="raise1" onclick="selectRaise(1)" disabled>Raise 1 ETH</button>
  <button class="raise-btn" id="raise3" onclick="selectRaise(3)" disabled>Raise 3 ETH</button>
  <button class="raise-btn" id="raise5" onclick="selectRaise(5)" disabled>Raise 5 ETH</button>
  <button class="raise-btn" id="raise10" onclick="selectRaise(10)" disabled>Raise 10 ETH</button>
</div>

<button id="launchBtn" onclick="launch(selectedRaise)" style="display:none; width:100%; padding:16px 24px; font-size:13px; font-weight:600; margin-top:16px;">LAUNCH DAICO</button>

<div id="statusMessage"></div>

<div class="tracker">
  <label>Track DAICO</label>
  <div style="display:flex; gap:8px; align-items:flex-end;">
    <input type="text" id="trackAddress" placeholder="DAO address (0x...)" style="flex:1;">
    <button class="secondary" onclick="trackDAICO()" id="trackBtn" style="margin:0; white-space:nowrap;">Track</button>
  </div>
  <div id="trackerOutput"></div>
</div>

<div class="site-footer">
  <a href="../">Swap</a> &middot;
  <a href="../domains/">Domains</a> &middot;
  <a href="../dao/">DAO</a> &middot;
  built by <a href="https://opensea.io/collection/zorgz" target="_blank" rel="noopener"><svg width="14" height="14" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin:0 2px;image-rendering:pixelated"><rect width="16" height="16" fill="#0a0a0a"/><rect x="3" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="5" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="10" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="12" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="4" y="4" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="5" width="10" height="1" fill="#e8e8e0"/><rect x="2" y="6" width="12" height="3" fill="#e8e8e0"/><rect x="3" y="9" width="10" height="1" fill="#e8e8e0"/><rect x="4" y="10" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="10" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="5" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="9" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="2" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="7" y="12" width="2" height="1" fill="#e8e8e0"/><rect x="11" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="1" y="13" width="2" height="1" fill="#e8e8e0"/><rect x="13" y="13" width="2" height="1" fill="#e8e8e0"/></svg></a><a href="../dao/#/dao/1/0x5E58BA0e06ED0F5558f83bE732a4b899a674053E">zOrg</a> &middot;
  <a href="https://x.com/z_fi_" target="_blank" rel="noopener" title="X"><svg width="14" height="14" viewBox="0 0 300 300.251" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;fill:currentColor"><path d="M178.57 127.15 290.27 0h-26.46l-97.03 110.38L89.34 0H0l117.13 166.93L0 300.25h26.46l102.4-116.59 81.8 116.59h89.34M36.01 19.54H76.66l187.13 262.13h-40.66"/></svg></a>
  <div style="margin-top:8px;letter-spacing:1px"><a href="https://github.com/z-fi/zFi" target="_blank" rel="noopener" style="text-decoration:none;color:inherit">zfi.wei</a></div>
</div>

<script src="../ethers.min.js"></script>
<script src="../walletconnect.min.js"></script>
<script>
  // ==================== CONSTANTS ====================
  const SUMMONER_ADDRESS = '0x0000000000330B8df9E3bc5E553074DA58eE9138';
  const SUMMONER_ABI = [{
    "inputs": [
      {"internalType": "string", "name": "orgName", "type": "string"},
      {"internalType": "string", "name": "orgSymbol", "type": "string"},
      {"internalType": "string", "name": "orgURI", "type": "string"},
      {"internalType": "uint16", "name": "quorumBps", "type": "uint16"},
      {"internalType": "bool", "name": "ragequittable", "type": "bool"},
      {"internalType": "address", "name": "renderer", "type": "address"},
      {"internalType": "bytes32", "name": "salt", "type": "bytes32"},
      {"internalType": "address[]", "name": "initHolders", "type": "address[]"},
      {"internalType": "uint256[]", "name": "initShares", "type": "uint256[]"},
      {"components": [
        {"internalType": "address", "name": "target", "type": "address"},
        {"internalType": "uint256", "name": "value", "type": "uint256"},
        {"internalType": "bytes", "name": "data", "type": "bytes"}
      ], "internalType": "struct Call[]", "name": "initCalls", "type": "tuple[]"}
    ],
    "name": "summon",
    "outputs": [{"internalType": "contract Moloch", "name": "dao", "type": "address"}],
    "stateMutability": "payable",
    "type": "function"
  }, {
    "anonymous": false,
    "inputs": [
      {"indexed": true, "internalType": "address", "name": "summoner", "type": "address"},
      {"indexed": true, "internalType": "contract Moloch", "name": "dao", "type": "address"}
    ],
    "name": "NewDAO",
    "type": "event"
  }];

  const DAICO_ADDRESS = '0x000000000033e92DB97B4B3beCD2c255126C60aC';
  const RENDERER_ADDRESS = '0x000000000011C799980827F52d3137b4abD6E654';
  const EXPLORER = 'https://etherscan.io';

  const IMPLEMENTATIONS = {
    moloch: '0x643A45B599D81be3f3A68F37EB3De55fF10673C1',
    shares: '0x71E9b38d301b5A58cb998C1295045FE276Acf600',
    badges: '0x47C175Ce83B6B931ccBedD5ce95e701984eD96d5',
    loot: '0x6f1f2aF76a3aDD953277e9F369242697C87bc6A5'
  };

  const CLONE_PREFIX = '0x602d5f8160095f39f35f5f365f5f37365f73';
  const CLONE_SUFFIX = '0x5af43d5f5f3e6029573d5ffd5b3d5ff3';

  const INTERFACES = {
    mintFromMoloch: new ethers.Interface(['function mintFromMoloch(address,uint256)']),
    erc20Approve: new ethers.Interface(['function approve(address spender, uint256 amount)']),
    daicoSetSaleWithTap: new ethers.Interface(['function setSaleWithTap(address tribTkn, uint256 tribAmt, address forTkn, uint256 forAmt, uint40 deadline, address ops, uint128 ratePerSec)']),
    setAllowance: new ethers.Interface(['function setAllowance(address,address,uint256)']),
    setProposalTTL: new ethers.Interface(['function setProposalTTL(uint64)']),
    setTimelockDelay: new ethers.Interface(['function setTimelockDelay(uint64)'])
  };

  // Governance defaults for ungovern template
  const PROPOSAL_TTL = 7 * 86400;   // 7 days voting period
  const TIMELOCK_DELAY = 3 * 86400; // 3 days before execution (ragequit window)

  const RPCS = ['https://eth.llamarpc.com', 'https://ethereum.publicnode.com', 'https://1rpc.io/eth', 'https://eth.drpc.org'];
  const MAINNET = ethers.Network.from(1);
  let _readRpc = null;
  async function getReadRpc() {
    if (_readRpc) return _readRpc;
    const race = RPCS.map(async url => {
      const p = new ethers.JsonRpcProvider(url, MAINNET, { staticNetwork: true, batchMaxCount: 1 });
      await Promise.race([p.getBlockNumber(), new Promise((_, r) => setTimeout(() => r('timeout'), 3500))]);
      return p;
    });
    _readRpc = await Promise.any(race);
    return _readRpc;
  }
  const WEINS_ADDRESS = '0x0000000000696760E15f265e828DB644A0c242EB';

  async function resolveWeiName(address) {
    try {
      const rpc = await getReadRpc();
      const ns = new ethers.Contract(WEINS_ADDRESS, ['function reverseResolve(address) view returns (string)'], rpc);
      const name = await ns.reverseResolve(address);
      if (name && connectedAddress === address) getEl('walletBtn').textContent = name.toLowerCase();
    } catch {}
  }
  function escHtml(s) { return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
  function safeIconUrl(url) { if (!url) return ''; try { const u = new URL(url); if (u.protocol === 'https:' || u.protocol === 'data:') return url; } catch {} return ''; }

  // ==================== STATE ====================
  let provider = null;
  let signer = null;
  let connectedWallet = null;
  let connectedAddress = null;
  let connectedWalletProvider = null;
  let walletConnectProvider = null;
  let isConnecting = false;
  let isLaunching = false;
  let eip6963Providers = new Map();
  let walletEventHandlers = null;

  // ==================== UTILITIES ====================
  function getEl(id) { return document.getElementById(id); }

  let statusTimeout = null;
  function showStatus(message, isError = false) {
    const statusEl = getEl('statusMessage');
    if (statusTimeout) { clearTimeout(statusTimeout); statusTimeout = null; }

    let cls = 'status-message';
    if (isError) cls += ' error-message';
    else if (message.includes('\u2728')) cls += ' success';

    const spinner = message.includes('...') && !message.includes('\u2728') && !message.includes('href=')
      ? '<span class="spinner"></span>' : '';

    statusEl.innerHTML = `<div class="${cls}">${spinner}${message}</div>`;

    if (!isError) {
      const delay = message.includes('\u2728') ? 15000 : 6000;
      statusTimeout = setTimeout(() => {
        const msgEl = statusEl.querySelector('.status-message');
        if (msgEl) {
          msgEl.style.animation = 'fadeOut 0.3s ease-out forwards';
          setTimeout(() => { statusEl.innerHTML = ''; }, 300);
        }
      }, delay);
    }
  }

  function isUserRejection(error) {
    if (!error) return false;
    if (error.code === 4001 || error.code === -32603 || error.code === 'ACTION_REJECTED') return true;
    const message = (error.message || '').toLowerCase();
    if (message.includes('user rejected') || message.includes('user denied') ||
        message.includes('transaction cancelled') || message.includes('user closed') ||
        message.includes('qr code modal closed')) return true;
    if (error.error) return isUserRejection(error.error);
    return false;
  }

  function buildContractURI(name, symbol, description) {
    const metadata = { name: name || '', symbol: symbol || '' };
    if (description) metadata.description = description;
    if (!description) return ''; // triggers default DUNA charter
    return 'data:application/json;utf8,' + JSON.stringify(metadata);
  }

  // ==================== ADDRESS PREDICTION ====================
  function minimalProxyInitCode(implementation) {
    const impl = implementation.toLowerCase().replace(/^0x/, '');
    return ethers.concat([CLONE_PREFIX, '0x' + impl, CLONE_SUFFIX]);
  }

  function computeCreate2Address(deployer, salt, implementation) {
    const initCode = minimalProxyInitCode(implementation);
    const initCodeHash = ethers.keccak256(initCode);
    const encoded = ethers.solidityPacked(
      ['bytes1', 'address', 'bytes32', 'bytes32'],
      ['0xff', deployer, salt, initCodeHash]
    );
    const hash = ethers.keccak256(encoded);
    return ethers.getAddress('0x' + hash.slice(-40));
  }

  function predictAddresses(initHolders, initShares, userSalt) {
    const abiCoder = new ethers.AbiCoder();
    const summonerSalt = ethers.keccak256(
      abiCoder.encode(['address[]', 'uint256[]', 'bytes32'], [initHolders, initShares, userSalt])
    );
    const dao = computeCreate2Address(SUMMONER_ADDRESS, summonerSalt, IMPLEMENTATIONS.moloch);
    const daoNoPrefix = dao.toLowerCase().replace(/^0x/, '');
    if (daoNoPrefix.length !== 40) throw new Error('Invalid DAO address length');
    const childSalt = '0x' + daoNoPrefix + '000000000000000000000000';
    const shares = computeCreate2Address(dao, childSalt, IMPLEMENTATIONS.shares);
    const loot = computeCreate2Address(dao, childSalt, IMPLEMENTATIONS.loot);
    return { dao, shares, loot };
  }

  // ==================== WALLET ====================
  const WALLET_CONFIG = {
    metamask: { name: 'MetaMask', icon: '\uD83E\uDD8A', detect: () => findProvider(p => p.isMetaMask), getProvider: () => findProvider(p => p.isMetaMask) },
    coinbase: { name: 'Coinbase', icon: '\uD83D\uDD35', detect: () => findProvider(p => p.isCoinbaseWallet), getProvider: () => findProvider(p => p.isCoinbaseWallet) },
    rabby: { name: 'Rabby', icon: '\uD83D\uDC30', detect: () => findProvider(p => p.isRabby), getProvider: () => findProvider(p => p.isRabby) },
    rainbow: { name: 'Rainbow', icon: '\uD83C\uDF08', detect: () => findProvider(p => p.isRainbow), getProvider: () => findProvider(p => p.isRainbow) },
    walletconnect: { name: 'WalletConnect', icon: '\uD83D\uDCF1' }
  };

  function findProvider(checkFn) {
    if (window.ethereum?.providers?.length) {
      for (const p of window.ethereum.providers) {
        if (checkFn(p)) return p;
      }
    }
    if (window.ethereum && checkFn(window.ethereum)) return window.ethereum;
    return null;
  }

  function initEIP6963() {
    if (typeof window === 'undefined') return;
    window.addEventListener('eip6963:announceProvider', (event) => {
      const { info, provider: p } = event.detail;
      if (info?.uuid && p) eip6963Providers.set(info.uuid, { info, provider: p });
    });
    window.dispatchEvent(new Event('eip6963:requestProvider'));
  }

  function connectWallet() { showWalletModal(); }

  function showWalletModal() {
    const modalOverlay = getEl('walletModal');
    const walletOptions = getEl('walletOptions');

    if (connectedAddress) {
      walletOptions.innerHTML = `
        <div style="padding: 12px; background: #f9f9f9; margin-bottom: 12px; font-size: 13px; word-break: break-all; font-family: monospace;">
          ${connectedAddress}
        </div>
        <div class="wallet-option disconnect" onclick="disconnectWallet()">
          Disconnect
        </div>`;
      modalOverlay.classList.add('active');
      document.body.classList.add('modal-open');
      return;
    }

    let html = '';
    const seen = new Set();

    // EIP-6963 wallets
    for (const [uuid, { info, provider: p }] of eip6963Providers) {
      const name = escHtml(info.name || 'Unknown Wallet');
      const safeIcon = safeIconUrl(info.icon);
      const icon = safeIcon
        ? `<img src="${escHtml(safeIcon)}" style="width: 1.2rem; height: 1.2rem;"/>`
        : '\uD83D\uDD0C';
      const safeUuid = escHtml(uuid);
      html += `<div class="wallet-option" onclick="connectSpecificWallet('eip6963_${safeUuid}')">
        <span class="wallet-icon">${icon}</span>
        <span class="wallet-name">${name}</span>
        <span class="wallet-status installed">Detected</span>
      </div>`;
      const lower = name.toLowerCase();
      if (lower.includes('metamask')) seen.add('metamask');
      if (lower.includes('coinbase')) seen.add('coinbase');
      if (lower.includes('rabby')) seen.add('rabby');
      if (lower.includes('rainbow')) seen.add('rainbow');
    }

    // Legacy wallets
    for (const [key, wallet] of Object.entries(WALLET_CONFIG)) {
      if (key === 'walletconnect' || seen.has(key)) continue;
      if (wallet.detect && wallet.detect()) {
        html += `<div class="wallet-option" onclick="connectSpecificWallet('${key}')">
          <span class="wallet-icon">${wallet.icon}</span>
          <span class="wallet-name">${wallet.name}</span>
          <span class="wallet-status installed">Detected</span>
        </div>`;
      }
    }

    // WalletConnect
    html += `<div class="wallet-option" onclick="connectSpecificWallet('walletconnect')">
      <span class="wallet-icon">\uD83D\uDCF1</span>
      <span class="wallet-name">WalletConnect</span>
      <span class="wallet-status">QR Code</span>
    </div>`;

    walletOptions.innerHTML = html;
    modalOverlay.classList.add('active');
    document.body.classList.add('modal-open');
  }

  function closeWalletModal() {
    getEl('walletModal').classList.remove('active');
    document.body.classList.remove('modal-open');
  }

  async function connectSpecificWallet(walletKey) {
    if (isConnecting) return;
    isConnecting = true;
    closeWalletModal();

    let wallet;
    let walletProvider;

    try {
      if (walletKey === 'walletconnect') {
        const WCProvider = window.WalletConnectEthereumProvider?.default || window.WalletConnectEthereumProvider;
        if (!WCProvider?.init) { showStatus('WalletConnect not available', true); return; }

        if (walletConnectProvider) {
          try { await walletConnectProvider.disconnect?.(); } catch (e) {}
          walletConnectProvider = null;
        }

        walletConnectProvider = await WCProvider.init({
          projectId: '1e8390ef1c1d8a185e035912a1409749',
          chains: [1],
          showQrModal: true,
          rpcMap: { 1: 'https://1rpc.io/eth' },
          metadata: { name: 'DAICO', description: 'Launch DAICOs', url: window.location.origin, icons: ['https://daico.wtf/icon.png'] }
        });

        await walletConnectProvider.enable();
        walletProvider = walletConnectProvider;
        wallet = WALLET_CONFIG.walletconnect;
      } else if (walletKey.startsWith('eip6963_')) {
        const uuid = walletKey.replace('eip6963_', '');
        const eip6963Wallet = eip6963Providers.get(uuid);
        if (!eip6963Wallet) { showStatus('Wallet not found', true); return; }
        wallet = { name: eip6963Wallet.info.name, icon: eip6963Wallet.info.icon || '\uD83D\uDD0C' };
        walletProvider = eip6963Wallet.provider;
        await walletProvider.request({ method: 'eth_requestAccounts' });
      } else {
        wallet = WALLET_CONFIG[walletKey];
        if (!wallet) return;
        walletProvider = wallet.getProvider();
        if (!walletProvider) { showStatus(`${wallet.name} not found`, true); return; }
        await walletProvider.request({ method: 'eth_requestAccounts' });
      }

      // Enforce mainnet
      const chainIdHex = await walletProvider.request({ method: 'eth_chainId' });
      if (BigInt(chainIdHex) !== 1n) {
        try {
          await walletProvider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x1' }] });
          const newChainId = await walletProvider.request({ method: 'eth_chainId' });
          if (BigInt(newChainId) !== 1n) throw new Error('Chain switch failed');
        } catch (switchErr) {
          showStatus('Please switch to Ethereum Mainnet', true);
          if (walletKey === 'walletconnect') {
            try { walletConnectProvider?.disconnect(); } catch (e) {}
            walletConnectProvider = null;
          }
          return;
        }
      }

      provider = new ethers.BrowserProvider(walletProvider);
      signer = await provider.getSigner();
      const address = await signer.getAddress();

      connectedWallet = walletKey;
      connectedAddress = address;
      connectedWalletProvider = walletProvider;

      const walletBtn = getEl('walletBtn');
      walletBtn.textContent = address.slice(0, 6) + '...' + address.slice(-4);
      resolveWeiName(address);

      // Enable raise buttons
      document.querySelectorAll('.raise-btn').forEach(btn => btn.disabled = false);

      // Listen for changes
      if (connectedWalletProvider && walletEventHandlers) {
        try {
          connectedWalletProvider.removeListener('accountsChanged', walletEventHandlers.accountsChanged);
          connectedWalletProvider.removeListener('chainChanged', walletEventHandlers.chainChanged);
        } catch (e) {}
      }
      walletEventHandlers = {
        accountsChanged: () => window.location.reload(),
        chainChanged: () => window.location.reload()
      };
      walletProvider.on('accountsChanged', walletEventHandlers.accountsChanged);
      walletProvider.on('chainChanged', walletEventHandlers.chainChanged);

      showStatus(`Connected to ${wallet?.name || 'wallet'}`);
    } catch (error) {
      if (isUserRejection(error)) { showStatus('', false); return; }
      let msg = `Failed to connect ${wallet?.name || 'wallet'}`;
      if (error.code === -32002) msg = `Please check ${wallet?.name || 'wallet'} - a connection request is pending`;
      else if (error.shortMessage) msg = error.shortMessage;
      else if (error.message) { const m = error.message.split('\n')[0]; if (m.length < 100) msg = m; }
      showStatus(msg, true);
    } finally {
      isConnecting = false;
    }
  }

  function disconnectWallet() {
    if (connectedWalletProvider && walletEventHandlers) {
      try {
        connectedWalletProvider.removeListener('accountsChanged', walletEventHandlers.accountsChanged);
        connectedWalletProvider.removeListener('chainChanged', walletEventHandlers.chainChanged);
      } catch (e) {}
    }
    walletEventHandlers = null;
    if (walletConnectProvider) { try { walletConnectProvider.disconnect(); } catch (e) {} walletConnectProvider = null; }

    provider = null; signer = null; connectedWallet = null; connectedAddress = null; connectedWalletProvider = null;

    getEl('walletBtn').textContent = 'connect';
    document.querySelectorAll('.raise-btn').forEach(btn => btn.disabled = true);
    closeWalletModal();
    showStatus('Wallet disconnected');
  }

  // ==================== LAUNCH ====================
  // Sale ratio: 1 ETH = 1,000,000 LOOT (0.01 ETH per 10,000 tokens)
  const TOKENS_PER_ETH = 1_000_000n;
  const TAP_MONTHS = 3;
  const SECONDS_PER_MONTH = 2_629_746n; // ~30.44 days

  let selectedRaise = null;

  function selectRaise(eth) {
    selectedRaise = eth;

    // Highlight selected button
    document.querySelectorAll('.raise-btn').forEach(btn => {
      btn.style.background = '';
      btn.style.borderColor = '';
      btn.style.color = '';
    });
    const btn = getEl('raise' + eth);
    btn.style.background = '#333';

    // Show preview
    const supply = (BigInt(eth) * TOKENS_PER_ETH);
    const dailyTap = (eth / (TAP_MONTHS * 30.44));
    const pricePerMillion = (1 / Number(TOKENS_PER_ETH)) * 1_000_000;

    const preview = getEl('previewBox');
    preview.style.display = 'block';
    preview.innerHTML =
      `Raise <strong>${eth} ETH</strong> selling <strong>${Number(supply).toLocaleString()} Loot</strong>.<br>` +
      `Tap 100% over ${TAP_MONTHS} months to ops.<br>` +
      `${pricePerMillion} ETH per 1M tokens.<br>` +
      `\u2248 ${dailyTap.toFixed(4)} ETH/day to ops.<br>` +
      `No governance. Tap releases funds to ops. Holders can ragequit.` +
      `<br><span style="color:#666">7 day voting \u00b7 3 day timelock (ragequit window before any proposal executes)</span>`;

    getEl('launchBtn').style.display = 'block';
  }

  async function launch(raiseEth) {
    if (isLaunching || !raiseEth) return;
    if (!signer) { await connectWallet(); if (!signer) return; }

    const name = getEl('daoName').value.trim();
    const symbol = getEl('daoSymbol').value.trim();
    const description = getEl('daoDescription').value.trim();

    if (!name || name.length < 2) { showStatus('Please enter a name (at least 2 characters)', true); return; }
    if (!symbol || symbol.length < 1) { showStatus('Please enter a symbol', true); return; }

    isLaunching = true;
    let btns = document.querySelectorAll('.raise-btn');
    btns.forEach(btn => { btn.disabled = true; });
    getEl('launchBtn').disabled = true;

    try {
      // Verify mainnet
      const walletChainIdHex = await connectedWalletProvider.request({ method: 'eth_chainId' });
      if (BigInt(walletChainIdHex) !== 1n) throw new Error('Please switch to Ethereum Mainnet');

      provider = new ethers.BrowserProvider(connectedWalletProvider);
      signer = await provider.getSigner();
      const address = await signer.getAddress();

      showStatus('Preparing ungovern DAICO...');

      const daoURI = buildContractURI(name, symbol, description);
      const quorumBps = 5000; // 50%
      const ragequittable = true;
      const salt = ethers.randomBytes(32);

      const initHolders = [address];
      const initShares = [ethers.parseEther('1')];

      // Predict addresses
      const predictions = predictAddresses(initHolders, initShares, salt);
      const predictedDao = predictions.dao;
      const predictedLoot = predictions.loot;

      // Calculate sale parameters
      const saleSupply = ethers.parseEther((BigInt(raiseEth) * TOKENS_PER_ETH).toString());
      const tribAmt = ethers.parseEther('1'); // 1 ETH per ratio unit
      const forAmt = ethers.parseEther(TOKENS_PER_ETH.toString()); // 1,000,000 LOOT per ratio unit

      // Calculate tap: full raise over 3 months
      const tapBudget = ethers.parseEther(raiseEth.toString());
      const totalTapSeconds = SECONDS_PER_MONTH * BigInt(TAP_MONTHS);
      let tapRatePerSec = tapBudget / totalTapSeconds;
      if (tapRatePerSec === 0n && tapBudget > 0n) tapRatePerSec = 1n;

      const initCalls = [];

      // 0a. Set proposal TTL (7 day voting window)
      initCalls.push({
        target: predictedDao,
        value: 0n,
        data: INTERFACES.setProposalTTL.encodeFunctionData('setProposalTTL', [PROPOSAL_TTL])
      });

      // 0b. Set timelock delay (3 day ragequit window before execution)
      initCalls.push({
        target: predictedDao,
        value: 0n,
        data: INTERFACES.setTimelockDelay.encodeFunctionData('setTimelockDelay', [TIMELOCK_DELAY])
      });

      // 1. Mint loot supply to DAO
      initCalls.push({
        target: predictedLoot,
        value: 0n,
        data: INTERFACES.mintFromMoloch.encodeFunctionData('mintFromMoloch', [predictedDao, saleSupply])
      });

      // 2. Approve DAICO contract to spend loot
      initCalls.push({
        target: predictedLoot,
        value: 0n,
        data: INTERFACES.erc20Approve.encodeFunctionData('approve', [DAICO_ADDRESS, saleSupply])
      });

      // 3. Set tap allowance (DAICO can pull ETH from treasury)
      initCalls.push({
        target: predictedDao,
        value: 0n,
        data: INTERFACES.setAllowance.encodeFunctionData('setAllowance', [
          DAICO_ADDRESS,
          ethers.ZeroAddress, // ETH
          tapBudget
        ])
      });

      // 4. Configure DAICO sale with tap (ETH -> LOOT, tap to deployer)
      initCalls.push({
        target: DAICO_ADDRESS,
        value: 0n,
        data: INTERFACES.daicoSetSaleWithTap.encodeFunctionData('setSaleWithTap', [
          ethers.ZeroAddress, // tribTkn = ETH
          tribAmt,            // 1 ETH
          predictedLoot,      // forTkn = LOOT
          forAmt,             // 1,000,000 LOOT
          0,                  // no deadline
          address,            // ops = deployer
          tapRatePerSec       // rate
        ])
      });

      showStatus('Please confirm the transaction in your wallet...');

      const summoner = new ethers.Contract(SUMMONER_ADDRESS, SUMMONER_ABI, signer);

      const txOptions = {};
      if (walletConnectProvider) txOptions.gasLimit = 2_000_000n;

      const tx = await summoner.summon(
        name,
        symbol,
        daoURI,
        quorumBps,
        ragequittable,
        RENDERER_ADDRESS,
        salt,
        initHolders,
        initShares,
        initCalls,
        txOptions
      );

      showStatus(`Transaction submitted. <a href="${EXPLORER}/tx/${tx.hash}" target="_blank" rel="noopener">${tx.hash.slice(0, 10)}...</a> Waiting for confirmation...`);

      const receipt = await tx.wait();

      const event = receipt.logs
        .map(log => { try { return summoner.interface.parseLog(log); } catch { return null; } })
        .find(e => e && e.name === 'NewDAO');

      const daoAddress = event?.args?.dao || predictedDao;
      const supply = BigInt(raiseEth) * TOKENS_PER_ETH;
      const dailyTap = (raiseEth / (TAP_MONTHS * 30.44));

      showStatus(
        `\u2728 DAICO launched!` +
        `<br><br><strong>${name}</strong> ($${symbol})` +
        `<br>DAO: <a href="${EXPLORER}/address/${daoAddress}" target="_blank" rel="noopener">${daoAddress}</a>` +
        `<br>Sale: ${raiseEth} ETH \u2192 ${Number(supply).toLocaleString()} LOOT` +
        `<br>Tap: 100% over ${TAP_MONTHS} months (\u2248 ${dailyTap.toFixed(4)} ETH/day to ops)` +
        `<br><br><a href="${EXPLORER}/tx/${tx.hash}" target="_blank" rel="noopener">View transaction</a>` +
        ` \u00b7 <a href="../dao/#/dao/1/${daoAddress}">Manage DAO</a>` +
        ` \u00b7 <a href="#" onclick="getEl('trackAddress').value='${daoAddress}';trackDAICO();return false;">Track progress</a>`
      );

    } catch (error) {
      if (isUserRejection(error)) {
        showStatus('Launch cancelled');
      } else {
        let msg = 'Launch failed';
        if (error.code === -32000 || error.message?.includes('insufficient funds')) msg = 'Insufficient funds for transaction';
        else if (error.shortMessage) msg = error.shortMessage;
        else if (error.reason) msg = error.reason;
        else if (error.message) { const m = error.message.split('\n')[0]; if (m.length < 100) msg = m; }
        showStatus(msg, true);
      }
    } finally {
      isLaunching = false;
      getEl('launchBtn').disabled = false;
      if (connectedAddress) btns.forEach(btn => btn.disabled = false);
    }
  }

  // ==================== TRACKER ====================
  function asciiBar(pct, width = 24) {
    const filled = Math.round((pct / 100) * width);
    const empty = width - filled;
    return '<span class="bar-fill">' + '\u2588'.repeat(filled) + '</span>' +
           '<span class="bar-empty">' + '\u2591'.repeat(empty) + '</span>' +
           ' <span class="pct">' + pct.toFixed(1) + '%</span>';
  }

  async function trackDAICO() {
    const addr = getEl('trackAddress').value.trim();
    if (!addr || !addr.startsWith('0x') || addr.length !== 42) {
      getEl('trackerOutput').innerHTML = '<div class="status-message error-message">Enter a valid DAO address</div>';
      return;
    }

    getEl('trackBtn').disabled = true;
    getEl('trackerOutput').innerHTML = '<div class="status-message"><span class="spinner"></span>Loading...</div>';

    try {
      const rpc = await getReadRpc();

      // Get DAO info
      const daoContract = new ethers.Contract(addr, [
        'function loot() view returns (address)',
        'function shares() view returns (address)',
        'function allowance(address,address) view returns (uint256)'
      ], rpc);

      const lootAddr = await daoContract.loot();
      const lootToken = new ethers.Contract(lootAddr, [
        'function totalSupply() view returns (uint256)',
        'function balanceOf(address) view returns (uint256)',
        'function name() view returns (string)',
        'function symbol() view returns (string)'
      ], rpc);

      // Get DAICO sale and tap info
      const daicoContract = new ethers.Contract(DAICO_ADDRESS, [
        'function sales(address,address) view returns (uint256 tribAmt, uint256 forAmt, address forTkn, uint40 deadline)',
        'function taps(address) view returns (address ops, address tribTkn, uint128 ratePerSec, uint64 lastClaim)'
      ], rpc);

      // Fetch all data in parallel
      const [sale, tap, treasury, lootSupply, lootInDAO, name, symbol] = await Promise.all([
        daicoContract.sales(addr, ethers.ZeroAddress),
        daicoContract.taps(addr),
        rpc.getBalance(addr),
        lootToken.totalSupply(),
        lootToken.balanceOf(addr),
        lootToken.name().catch(() => '?'),
        lootToken.symbol().catch(() => '?')
      ]);

      const [tribAmt, forAmt, forTkn, deadline] = sale;
      const [ops, tribTkn, ratePerSec, lastClaim] = tap;

      // Compute sale progress
      // Use tap budget to derive original sale supply (resilient to ragequit burns reducing totalSupply)
      let originalSupply = lootSupply;
      if (ratePerSec > 0n && tribAmt > 0n) {
        const totalTapSeconds = SECONDS_PER_MONTH * BigInt(TAP_MONTHS);
        const tapBudget = ratePerSec * totalTapSeconds;
        originalSupply = (tapBudget * forAmt) / tribAmt;
      }
      // Fallback: if no tap data, original supply >= current supply, use max of supply and DAO balance
      if (originalSupply < lootInDAO) originalSupply = lootInDAO;
      const lootSold = originalSupply >= lootInDAO ? originalSupply - lootInDAO : 0n;
      const salePct = originalSupply > 0n ? Number((lootSold * 10000n) / originalSupply) / 100 : (forAmt > 0n ? 100 : 0);

      // Compute tap progress
      let tapPct = 0;
      let tapClaimed = 0;
      let tapTotal = 0;
      let dailyRate = 0;
      if (ratePerSec > 0n) {
        const totalTapSeconds = SECONDS_PER_MONTH * BigInt(TAP_MONTHS);
        const tapBudget = ratePerSec * totalTapSeconds;

        // Check allowance remaining to estimate how much has been claimed
        const allowanceLeft = await daoContract.allowance(ethers.ZeroAddress, DAICO_ADDRESS);
        // Use max of tapBudget and allowanceLeft as total (rounding can make tapBudget < original allowance)
        const totalBudget = tapBudget > allowanceLeft ? tapBudget : allowanceLeft;
        const claimed = totalBudget - allowanceLeft;
        tapClaimed = Number(ethers.formatEther(claimed));
        tapTotal = Number(ethers.formatEther(totalBudget));
        tapPct = tapTotal > 0 ? Math.min((tapClaimed / tapTotal) * 100, 100) : 0;
        dailyRate = Number(ethers.formatEther(ratePerSec * 86400n));
      }

      const treasuryEth = Number(ethers.formatEther(treasury));
      const lootSoldFmt = Number(ethers.formatEther(lootSold)).toLocaleString(undefined, {maximumFractionDigits: 0});
      const lootTotalFmt = Number(ethers.formatEther(originalSupply)).toLocaleString(undefined, {maximumFractionDigits: 0});

      const saleActive = lootInDAO > 0n && forAmt > 0n;

      let html = '<div class="tracker-bar">';
      html += `<strong>${name}</strong> ($${symbol})\n`;
      html += `<a href="${EXPLORER}/address/${addr}" target="_blank" rel="noopener" style="color:#666;font-size:11px;">${addr}</a>\n\n`;
      html += `<span class="label">SALE ${saleActive ? '(LIVE)' : '(ENDED)'}</span>\n`;
      html += asciiBar(salePct) + '\n';
      html += `${lootSoldFmt} / ${lootTotalFmt} LOOT sold\n\n`;

      if (ratePerSec > 0n) {
        html += `<span class="label">TAP</span>\n`;
        html += asciiBar(tapPct) + '\n';
        html += `${tapClaimed.toFixed(4)} / ${tapTotal.toFixed(4)} ETH claimed\n`;
        html += `\u2248 ${dailyRate.toFixed(4)} ETH/day to ops\n\n`;
      }

      html += `<span class="label">TREASURY</span>\n`;
      html += `${treasuryEth.toFixed(4)} ETH`;
      html += '</div>';

      html += `<div style="margin-top:8px; font-size:12px;">`;
      html += `<a href="../dao/#/dao/1/${addr}">Manage DAO</a>`;
      html += ` \u00b7 <a href="${EXPLORER}/address/${addr}" target="_blank" rel="noopener">Etherscan</a>`;
      html += `</div>`;

      getEl('trackerOutput').innerHTML = html;

    } catch (error) {
      let msg = 'Failed to load DAICO data';
      if (error.message?.includes('call revert')) msg = 'Not a valid DAO address or no DAICO configured';
      else if (error.message) { const m = error.message.split('\n')[0]; if (m.length < 80) msg = m; }
      getEl('trackerOutput').innerHTML = `<div class="status-message error-message">${msg}</div>`;
    } finally {
      getEl('trackBtn').disabled = false;
    }
  }

  // Auto-track from URL hash
  function checkHashTrack() {
    const hash = window.location.hash;
    if (hash && hash.startsWith('#0x') && hash.length === 43) {
      getEl('trackAddress').value = hash.slice(1);
      trackDAICO();
    }
  }

  // ==================== INIT ====================
  window.addEventListener('load', async () => {
    initEIP6963();
    checkHashTrack();
    await new Promise(resolve => setTimeout(resolve, 100));

    // Auto-reconnect
    if (window.ethereum) {
      try {
        const accounts = await window.ethereum.request({ method: 'eth_accounts' });
        if (accounts?.length > 0) {
          const chainIdHex = await window.ethereum.request({ method: 'eth_chainId' });
          if (BigInt(chainIdHex) !== 1n) throw new Error('Not mainnet');
          provider = new ethers.BrowserProvider(window.ethereum);
          signer = await provider.getSigner();
          connectedAddress = await signer.getAddress();
          connectedWallet = 'metamask';
          connectedWalletProvider = window.ethereum;

          getEl('walletBtn').textContent = connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
          resolveWeiName(connectedAddress);
          document.querySelectorAll('.raise-btn').forEach(btn => btn.disabled = false);

          walletEventHandlers = {
            accountsChanged: () => window.location.reload(),
            chainChanged: () => window.location.reload()
          };
          window.ethereum.on('accountsChanged', walletEventHandlers.accountsChanged);
          window.ethereum.on('chainChanged', walletEventHandlers.chainChanged);
        }
      } catch (e) {}
    }
  });
</script>
</body>
</html>
