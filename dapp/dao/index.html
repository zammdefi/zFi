<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>DAO</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 400' width='400' height='400'%3E%3Crect width='400' height='400' fill='%23000'/%3E%3CclipPath id='frame'%3E%3Crect width='400' height='400'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23frame)'%3E%3Cpath d='M-60-20L460-20L460 90L80 310L460 310L460 420L-60 420L-60 310L320 90L-60 90Z' fill='white'/%3E%3C/g%3E%3C/svg%3E" type="image/svg+xml">
<script>
(function(){var d=localStorage.getItem('dark');if(d==='1'||(d===null&&matchMedia('(prefers-color-scheme:dark)').matches))document.documentElement.classList.add('dark')})();
</script>
<style>
:root {
  --bg:#fff;--fg:#000;--fg-muted:#666;--fg-dim:#999;
  --border:#000;--border-muted:#ddd;
  --surface:#f9f9f9;--surface-hover:#f5f5f5;
  --btn-bg:#000;--btn-fg:#fff;--btn-hover:#333;
  --btn-dis-bg:#ccc;--btn-dis-fg:#fff;
  --link-fg:inherit;
  --modal-overlay:rgba(0,0,0,0.8);--modal-bg:#fff;--modal-border:#000;
  --status-error:#fff0f0;--status-success:#f0fff0;
  --green:#2d8a2d;--red:#e74c3c;--amber:#b8860b;
  --divider:#f0f0f0;
}
.dark {
  --bg:#0a0a0a;--fg:#e8e8e0;--fg-muted:#888;--fg-dim:#666;
  --border:#e8e8e0;--border-muted:#333;
  --surface:#111;--surface-hover:#1a1a1a;
  --btn-bg:#e8e8e0;--btn-fg:#0a0a0a;--btn-hover:#ccc;
  --btn-dis-bg:#333;--btn-dis-fg:#666;
  --link-fg:#e8e8e0;
  --modal-overlay:rgba(0,0,0,0.85);--modal-bg:#0a0a0a;--modal-border:#333;
  --status-error:#1a0000;--status-success:#001a00;
  --green:#4ade80;--red:#ef4444;--amber:#f59e0b;
  --divider:#222;
}
.zorg-bg{fill:#fff}.zorg-fg{fill:#000}
.dark .zorg-bg{fill:#000}.dark .zorg-fg{fill:#fff}
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body {
  font-family: Helvetica, Arial, sans-serif;
  background: var(--bg);
  color: var(--fg);
  min-height: 100vh;
  padding: 60px 20px 20px;
  max-width: 620px;
  margin: 0 auto;
}
h1 {
  font-size: 14px;
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  margin-bottom: 24px;
}
h2 {
  font-size: 14px;
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  margin-bottom: 16px;
}
h3 {
  font-size: 13px;
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  margin-bottom: 12px;
}
h4 {
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  margin-bottom: 8px;
}
a { color: var(--link-fg); }
label {
  display: block;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 8px;
  color: var(--fg-muted);
}
input, textarea, select {
  width: 100%;
  padding: 12px 0;
  font-size: 16px;
  font-family: inherit;
  border: none;
  border-bottom: 1px solid var(--border);
  outline: none;
  background: transparent;
  color: var(--fg);
}
input::placeholder, textarea::placeholder { color: var(--fg-dim); }
input:focus, textarea:focus, select:focus { border-bottom-width: 2.5px; margin-bottom: -1px; }
select { padding: 10px 0; cursor: pointer; -webkit-appearance: none; appearance: none; }
textarea { resize: vertical; min-height: 60px; border: 1px solid var(--border-muted); padding: 10px; }
button {
  display: inline-block;
  padding: 12px 24px;
  font-size: 12px;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  background: var(--btn-bg);
  color: var(--btn-fg);
  border: 1px solid var(--btn-bg);
  cursor: pointer;
  margin-right: 8px;
  margin-top: 8px;
  transition: background 0.2s, border-color 0.2s, color 0.2s;
}
button:hover { background: var(--btn-hover); }
button:disabled { background: var(--btn-dis-bg); border-color: var(--btn-dis-bg); color: var(--btn-dis-fg); cursor: not-allowed; }
button.secondary {
  background: var(--surface);
  color: var(--fg);
}
button.secondary:hover { background: var(--surface-hover); }

/* Wallet */
.wallet {
  position: fixed;
  top: max(20px, env(safe-area-inset-top, 0px));
  right: max(20px, env(safe-area-inset-right, 0px));
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  z-index: 100;
}
.wallet button { margin: 0; padding: 8px 16px; text-transform: none; }

/* Dark toggle */
.dark-toggle {
  position:fixed;
  top:max(22px, env(safe-area-inset-top, 0px));
  left:max(20px, env(safe-area-inset-left, 0px));
  border:none; cursor:pointer; padding:13px; margin:-13px;
  opacity:0.5; transition:opacity 0.2s; z-index:100;
  background:#000; border-radius:50%; width:40px; height:40px;
  background-clip: content-box;
}
:root.dark .dark-toggle { background:#fff; }
.dark-toggle:hover { opacity:1; }
.home-btn {
  position: fixed;
  bottom: max(20px, env(safe-area-inset-bottom, 0px));
  right: max(20px, env(safe-area-inset-right, 0px));
  z-index: 100;
  opacity: 0.4;
  transition: opacity 0.2s;
  line-height: 0;
}
.home-btn:hover { opacity: 1; }

/* Dark mode â€” semantic color overrides (elements not using CSS vars) */
.dark .wallet-option:hover { background:var(--btn-bg); color:var(--btn-fg); }
.dark .wallet-connected-info { background:var(--surface); border-color:var(--border-muted); }
.dark .wallet-connected-addr { color:var(--fg-dim); }
.dark .wallet-disconnect { background:var(--surface); border-color:var(--border-muted); }
.dark .wallet-status.installed { color:var(--green); }
.dark .proposal-state.active { border-color:var(--green); background:#0a1a0a; }
.dark .proposal-state.succeeded { border-color:var(--green); background:#0a1a0a; }
.dark .proposal-state.queued { border-color:var(--amber); background:#1a1500; }
.dark .proposal-state.defeated { border-color:var(--red); background:#1a0000; }
.dark .proposal-state.expired { border-color:var(--fg-dim); background:var(--surface); }
.dark .proposal-state.executed { border-color:var(--fg); color:var(--fg); background:var(--surface-hover); }
.dark .proposal-state.unopened { border-color:var(--fg-dim); background:var(--surface); }
.dark .proposal-button { border-color:var(--border-muted); background:var(--bg); color:var(--fg); }
.dark .proposal-button:hover { border-color:var(--fg); }
.dark .proposal-button.execute { background:var(--btn-bg); color:var(--btn-fg); border-color:var(--btn-bg); }
.dark .proposal-button.execute:hover { background:var(--btn-hover); }
.dark .proposal-button.queue { background:#1a1500; border-color:var(--amber); color:var(--amber); }
.dark .proposal-button.claim { background:#0a1a0a; }
.dark .proposal-button.claim:hover { background:var(--green); color:#fff; }
.dark .futarchy-reward-box { background:#0a1a0a; border-color:var(--border-muted); }
.dark .delegation-warning { background:#1a0000; border-color:#3a1111; }
.dark .delegation-type-option.selected { border-color:var(--fg); background:var(--surface); }
.dark .deposit-button { border-color:var(--border-muted); background:var(--surface); }
.dark .deposit-button:hover { border-color:var(--fg); }
.dark .tribute-accept-button { background:#0a1a0a; border-color:var(--border-muted); color:var(--fg); }
.dark .tribute-accept-button:hover { border-color:var(--fg); }

/* Nav links */
.nav-links {
  font-size: 12px;
  margin-bottom: 24px;
}
.nav-links a, .nav-links button {
  background: none;
  border: none;
  color: var(--fg);
  font-size: 12px;
  font-family: inherit;
  cursor: pointer;
  padding: 0;
  margin: 0;
  text-decoration: underline;
  text-transform: none;
  letter-spacing: normal;
}
.nav-links a:hover, .nav-links button:hover { opacity: 0.5; }

/* Status */
.status {
  font-size: 13px;
  margin-top: 16px;
  padding: 12px;
  background: var(--surface);
  display: none;
}
.status.show { display: block; }
.status.error { background: var(--status-error); }
.status.success { background: var(--status-success); }

/* Toast */
.toast-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.toast {
  background: var(--bg);
  border: 1px solid var(--border);
  padding: 12px 16px;
  font-size: 13px;
  max-width: 320px;
  animation: toastIn 0.3s ease;
}
@keyframes toastIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: none; } }
@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

/* Modal */
.wallet-modal-overlay, .modal-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--modal-overlay);
  backdrop-filter: blur(4px);
  z-index: 2000;
  justify-content: center;
  align-items: center;
  padding: 20px;
  overflow-y: auto;
}
.wallet-modal-overlay.active, .modal-overlay.active { display: flex; }
body.modal-open { overflow: hidden; }
.wallet-modal, .modal {
  background: var(--modal-bg);
  border: 2px solid var(--modal-border);
  padding: 16px;
  width: 100%;
  max-width: 400px;
}
.wallet-modal-header, .modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}
.wallet-modal-title, .modal-title {
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}
.wallet-modal-close, .modal-close {
  background: none;
  border: none;
  color: var(--fg);
  font-size: 24px;
  cursor: pointer;
  line-height: 1;
  padding: 0;
  margin: 0;
}
.wallet-modal-close:hover, .modal-close:hover { opacity: 0.5; }

/* Wallet modal options */
.wallet-option {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: var(--modal-bg);
  border: 1px solid var(--modal-border);
  cursor: pointer;
  margin-bottom: 8px;
  transition: background 0.15s, color 0.15s;
}
.wallet-option:hover { background: #000; color: #fff; }
.wallet-icon { font-size: 1.5rem; }
.wallet-name { font-weight: 600; }
.wallet-status { font-size: 11px; color: var(--fg-dim); }
.wallet-status.installed { color: var(--green); }
.wallet-option.disconnect {
  border-color: #e74c3c;
  color: #e74c3c;
  justify-content: center;
}
.wallet-option.disconnect:hover { background: #e74c3c; color: #fff; }
.wallet-connected-info {
  padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); margin-bottom: 1rem;
}
.wallet-connected-addr { color: var(--fg); font-size: 0.9rem; word-break: break-all; }
.wallet-disconnect { background: #f9f9f9; border-color: #ddd; justify-content: center; }

/* Info box (replaces purple tint boxes) */
.info-box {
  padding: 12px;
  background: var(--surface);
  border: 1px solid var(--border-muted);
  margin-bottom: 12px;
  font-size: 13px;
}
.form-hint {
  font-size: 12px;
  color: var(--fg-dim);
  margin-top: 4px;
}

/* Custom dropdown */
.custom-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  margin-top: 4px;
  background: var(--bg);
  border: 1px solid var(--border);
  max-height: 250px;
  overflow-y: auto;
  z-index: 1000;
}

/* Summoner */
.summoner-section {
  margin-bottom: 40px;
}
.summoner-container {
  max-width: 100%;
}
.summoner-title {
  font-size: 14px;
  font-weight: 400;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 8px;
}
.summoner-subtitle {
  font-size: 13px;
  color: var(--fg-muted);
  margin-bottom: 24px;
}
.form-group {
  margin-bottom: 20px;
}
.form-label {
  display: block;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--fg-muted);
  margin-bottom: 8px;
}
.form-input {
  width: 100%;
  padding: 10px 0;
  font-size: 16px;
  font-family: inherit;
  border: none;
  border-bottom: 1px solid var(--border);
  outline: none;
  background: transparent;
  color: var(--fg);
}
.form-input:focus { border-bottom-width: 2.5px; margin-bottom: -1px; }
.form-input::placeholder { color: var(--fg-dim); }
.checkbox-group {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
}
.checkbox-group input[type="checkbox"] { width: auto; }
.members-container {
  border: 1px solid var(--border-muted);
  padding: 12px;
}
/* Member rows in summoner */
.member-row {
  display: grid;
  grid-template-columns: 1fr 100px auto;
  gap: 8px;
  align-items: end;
  margin-bottom: 8px;
}
.member-row .form-input { margin-bottom: 0; }
.remove-member {
  background: none;
  border: 1px solid var(--border-muted);
  color: var(--fg-dim);
  font-size: 16px;
  cursor: pointer;
  padding: 8px 12px;
  margin: 0;
  line-height: 1;
}
.remove-member:hover { color: var(--red); border-color: var(--red); }
.add-member-btn {
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border-muted);
  padding: 8px 16px;
  font-size: 12px;
  cursor: pointer;
  margin-top: 8px;
}
.add-member-btn:hover { background: var(--surface-hover); }

/* Sale config */
.sale-config {
  margin-top: 16px;
  padding: 16px;
  background: var(--surface);
  border: 1px solid var(--border-muted);
}
.sale-info-box {
  margin-bottom: 16px;
  padding: 12px;
  background: var(--surface);
  border-left: 3px solid var(--fg);
  font-size: 13px;
  line-height: 1.5;
}
.sale-summary {
  margin-top: 8px;
  padding: 12px;
  background: var(--surface);
  border: 1px solid var(--border-muted);
  font-size: 13px;
  line-height: 1.6;
}
.sale-ratio-grid {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 8px;
  align-items: end;
  margin-bottom: 16px;
}
.sale-ratio-arrow {
  padding-bottom: 24px;
  font-size: 16px;
  color: var(--fg);
}

/* Token dropdown */
.token-select {
  width: 100%;
  padding: 10px;
  background: transparent;
  border: 1px solid var(--border-muted);
  color: var(--fg);
  font-size: 13px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
}
.token-select:hover { border-color: var(--fg); }
.token-dropdown-item {
  padding: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  transition: background 0.15s;
  font-size: 13px;
}
.token-dropdown-item:hover { background: var(--surface-hover); }
.token-dropdown-item + .token-dropdown-item { border-top: 1px solid var(--divider); }
.token-dropdown-icon {
  width: 24px;
  height: 24px;
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: center;
}
.token-dropdown-icon svg {
  width: 24px;
  height: 24px;
}

/* Advanced settings */
.advanced-toggle {
  font-size: 12px;
  cursor: pointer;
  padding: 12px 0;
  color: var(--fg-muted);
  user-select: none;
}
.advanced-toggle:hover { color: var(--fg); }
.advanced-settings {
  display: none;
  padding-top: 12px;
}
.advanced-settings.show { display: block; }
.summon-button {
  width: 100%;
  padding: 14px 24px;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  background: var(--btn-bg);
  color: var(--btn-fg);
  border: 1px solid var(--btn-bg);
  cursor: pointer;
  margin-top: 16px;
}
.summon-button:hover:not(:disabled) { background: var(--btn-hover); }
.summon-button:disabled { background: var(--btn-dis-bg); border-color: var(--btn-dis-bg); color: var(--btn-dis-fg); cursor: not-allowed; }

/* DAO Gallery */
.dao-gallery-section, .all-daos-section {
  display: none;
  margin-bottom: 40px;
}
.dao-gallery-section.show, .all-daos-section.show { display: block; }
.dao-gallery-header, .all-daos-header { margin-bottom: 16px; }
.dao-gallery-title, .all-daos-title {
  font-size: 14px;
  font-weight: 400;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 4px;
}
.dao-gallery-subtitle, .all-daos-subtitle {
  font-size: 13px;
  color: var(--fg-muted);
}
.dao-search {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
}
.dao-search-input {
  flex: 1;
  padding: 10px 0;
  font-size: 14px;
  font-family: inherit;
  border: none;
  border-bottom: 1px solid var(--border);
  outline: none;
  background: transparent;
  color: var(--fg);
}
.dao-search-btn {
  padding: 8px 20px;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  background: var(--btn-bg);
  color: var(--btn-fg);
  border: 1px solid var(--btn-bg);
  cursor: pointer;
}
.dao-search-btn:hover { background: var(--btn-hover); }
.dao-tiles {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 12px;
}
.dao-tile {
  border: 1px solid var(--border-muted);
  padding: 16px;
  cursor: pointer;
  transition: border-color 0.2s;
}
.dao-tile:hover { border-color: var(--fg); }
.dao-tile-emblem {
  width: 40px;
  height: 40px;
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.dao-tile-emblem img, .dao-tile-emblem svg { max-width: 100%; max-height: 100%; }
.dao-tile-name {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 4px;
}
.dao-tile-symbol {
  font-size: 11px;
  color: var(--fg-dim);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 8px;
}
.dao-tile-stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}
.dao-stat { font-size: 12px; overflow: hidden; }
.dao-stat-label { color: var(--fg-dim); font-size: 11px; }
.dao-stat-value { font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* DAO Dashboard */
.dao-dashboard {
  display: none;
  margin-bottom: 40px;
}
.dao-dashboard.show { display: block; }
.dao-dashboard-header { margin-bottom: 16px; }
.dao-dashboard-title {
  font-size: 14px;
  font-weight: 400;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}
.dao-emblem {
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  cursor: pointer;
  overflow: hidden;
}
.dao-emblem img, .dao-emblem svg { max-width: 100%; max-height: 100%; display: block; }
.dao-emblem.url-image {
  width: 48px;
  height: 48px;
  border: 1px solid var(--border-muted);
}
.dao-emblem.url-image img { width: 100%; height: 100%; object-fit: cover; }
.dao-emblem.description-only {
  width: auto;
  height: auto;
  max-width: 200px;
}
.dao-emblem-description {
  font-size: 11px;
  color: var(--fg-muted);
  line-height: 1.4;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
}
.dao-etherscan-link {
  font-size: 12px;
  color: var(--fg-muted);
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}
.dao-etherscan-link:hover { color: var(--fg); }
.dao-copy-link-btn {
  background: none;
  border: none;
  cursor: pointer;
  padding: 4px;
  margin: 0;
  color: var(--fg-muted);
}
.dao-copy-link-btn:hover { color: var(--fg); }
.dao-copy-link-btn svg { width: 16px; height: 16px; }
.dao-stats-bar {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 8px;
  font-size: 12px;
}
.back-button {
  background: none;
  color: var(--fg-dim);
  border: none;
  padding: 4px 0;
  font-size: 11px;
  margin-top: 0;
  margin-bottom: 12px;
  text-transform: none;
  letter-spacing: normal;
}
.back-button:hover { background: none; color: var(--fg); }

/* View Toggle */
.dao-view-toggle {
  display: flex;
  gap: 0;
  margin-bottom: 20px;
  border: 1px solid var(--border);
  width: fit-content;
}
.view-toggle-btn {
  padding: 8px 16px;
  font-size: 11px;
  background: var(--bg);
  color: var(--fg);
  border: none;
  cursor: pointer;
  margin: 0;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}
.view-toggle-btn + .view-toggle-btn { border-left: 1px solid var(--border); }
.view-toggle-btn:hover { background: var(--surface-hover); }
.view-toggle-btn.active { background: var(--btn-bg); color: var(--btn-fg); }

/* DAO Panel */
.dao-panel {
  border: 1px solid var(--border-muted);
  padding: 16px;
  margin-bottom: 16px;
}
.dao-panel-title {
  font-size: 13px;
  font-weight: 400;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 12px;
}

/* Dashboard content toggle */
.dao-dashboard-content, .dao-membership-content, .dao-members-content {
  display: none;
}
.dao-dashboard-content.show, .dao-membership-content.show, .dao-members-content.show {
  display: block;
}

/* Chatroom */
.chatroom-messages {
  max-height: 400px;
  overflow-y: auto;
  margin-bottom: 12px;
  font-size: 13px;
}
.chatroom-send {
  display: flex;
  gap: 8px;
  align-items: center;
  margin-bottom: 16px;
}
.chatroom-input {
  flex: 1;
  padding: 10px 0;
  font-size: 14px;
  border: none;
  border-bottom: 1px solid var(--border);
  outline: none;
  background: transparent;
  color: var(--fg);
}
.chatroom-input:focus { border-bottom-width: 2.5px; margin-bottom: -1px; }
.chatroom-button {
  padding: 10px 20px;
  font-size: 12px;
  background: var(--btn-bg);
  color: var(--btn-fg);
  border: 1px solid var(--btn-bg);
  cursor: pointer;
  margin: 0;
  white-space: nowrap;
}
.chatroom-button:hover { background: var(--btn-hover); }

/* Treasury */
.treasury-section {
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--border-muted);
}
.treasury-title {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 8px;
}
.treasury-assets {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 8px;
  font-size: 13px;
}
.treasury-asset {
  border: 1px solid var(--border-muted);
  padding: 12px 8px;
  text-align: center;
  transition: border-color 0.2s;
}
.treasury-asset:hover { border-color: var(--fg); }
.treasury-asset-icon {
  width: 24px;
  height: 24px;
  margin: 0 auto 6px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.treasury-asset-icon svg {
  width: 24px;
  height: 24px;
  display: block;
}
.treasury-asset-symbol {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 4px;
}
.treasury-asset-balance {
  font-size: 12px;
  color: var(--fg-muted);
}
.deposit-button {
  background: var(--bg);
  border: 1px solid var(--border-muted);
  padding: 6px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  margin: 0;
}
.deposit-button:hover { border-color: var(--fg); }
.deposit-button svg { color: var(--fg); }
.ragequit-button {
  margin-top: 12px;
  padding: 10px 20px;
  font-size: 11px;
  background: var(--bg);
  color: var(--red);
  border: 1px solid var(--red);
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}
.ragequit-button:hover { background: var(--red); color: #fff; }

/* Tribute offers */
.tribute-offers {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 8px;
  font-size: 13px;
}
.tribute-card {
  border: 1px solid var(--border-muted);
  padding: 12px;
  text-align: center;
  transition: border-color 0.2s;
}
.tribute-card:hover { border-color: var(--fg); }
.tribute-icon {
  width: 24px;
  height: 24px;
  margin: 0 auto 6px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.tribute-icon svg {
  width: 24px;
  height: 24px;
  display: block;
}
.tribute-proposer {
  font-size: 11px;
  color: var(--fg-dim);
  margin-bottom: 6px;
  overflow: hidden;
  text-overflow: ellipsis;
}
.tribute-amount {
  font-size: 13px;
  font-weight: 600;
  margin-bottom: 2px;
}
.tribute-request {
  font-size: 11px;
  color: var(--fg-muted);
  margin-bottom: 8px;
}
.tribute-buttons {
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.tribute-accept-button {
  width: 100%;
  padding: 6px 8px;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  background: var(--status-success);
  color: var(--fg);
  border: 1px solid var(--border-muted);
  cursor: pointer;
  margin: 0;
}
.tribute-accept-button:hover { border-color: var(--fg); }

/* Proposals */
.proposal-form {
  border: 1px solid var(--border-muted);
  padding: 16px;
  margin-bottom: 16px;
}
.proposal-form-title {
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 12px;
}
.proposal-form-group { margin-bottom: 12px; }
.proposal-form-label {
  display: block;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--fg-muted);
  margin-bottom: 6px;
}
.proposal-form-input {
  width: 100%;
  padding: 10px 0;
  font-size: 14px;
  font-family: inherit;
  border: none;
  border-bottom: 1px solid var(--border);
  outline: none;
  background: transparent;
  color: var(--fg);
}
.proposal-form-input:focus { border-bottom-width: 2.5px; margin-bottom: -1px; }
.proposal-form-textarea {
  border: 1px solid var(--border-muted);
  padding: 10px;
  min-height: 80px;
  resize: vertical;
}
.proposal-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

/* Proposal list items */
.proposal-item {
  border: 1px solid var(--border-muted);
  padding: 20px;
  margin-bottom: 12px;
  overflow: hidden;
  transition: border-color 0.2s;
}
.proposal-item:hover { border-color: var(--fg-dim); }
.proposal-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
  gap: 8px;
  min-width: 0;
}
.proposal-header-left {
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-width: 0;
  flex: 1;
}
.proposal-state {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  padding: 3px 8px;
  border: 1px solid var(--border-muted);
  white-space: nowrap;
  flex-shrink: 0;
}
.proposal-state.active { border-color: var(--green); color: var(--green); background: var(--status-success); }
.proposal-state.succeeded { border-color: var(--green); color: var(--green); background: var(--status-success); }
.proposal-state.queued { border-color: #b8860b; color: #b8860b; background: #fffaf0; }
.proposal-state.defeated { border-color: #e74c3c; color: #e74c3c; background: #fff5f5; }
.proposal-state.expired { border-color: var(--fg-dim); color: var(--fg-dim); background: #fafafa; }
.proposal-state.executed { border-color: var(--fg); color: var(--fg); background: var(--surface-hover); }
.proposal-state.unopened { border-color: var(--fg-dim); color: var(--fg-dim); background: #fafafa; }
.proposal-description {
  font-size: 14px;
  line-height: 1.6;
  color: var(--fg);
}
.proposal-meta {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--fg-dim);
  font-family: monospace;
  letter-spacing: 0.02em;
}
.proposal-meta a { color: var(--fg-dim); text-decoration: none; }
.proposal-meta a:hover { color: var(--fg); }
.proposal-meta-sep { color: var(--border-muted); }
.proposal-vote-bar {
  display: flex;
  height: 4px;
  border-radius: 2px;
  overflow: hidden;
  background: var(--divider);
  margin-bottom: 8px;
}
.proposal-vote-bar-for { background: var(--green); }
.proposal-vote-bar-against { background: #e74c3c; }
.proposal-vote-bar-abstain { background: #ccc; }
.proposal-votes {
  display: flex;
  gap: 20px;
  margin-bottom: 14px;
  flex-wrap: wrap;
}
.proposal-vote-stat {
  font-size: 12px;
  display: flex;
  align-items: baseline;
  gap: 5px;
}
.proposal-vote-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--fg-dim);
}
.proposal-vote-label.for { color: var(--green); }
.proposal-vote-label.against { color: #e74c3c; }
.proposal-vote-value { font-weight: 600; }
.proposal-button {
  padding: 8px 16px;
  font-size: 10px;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  border: 1px solid var(--border-muted);
  background: var(--bg);
  color: var(--fg);
  cursor: pointer;
  margin: 0;
  transition: background 0.2s, border-color 0.2s, color 0.2s;
}
.proposal-button:hover { border-color: var(--fg); }
.proposal-button.for { border-color: var(--green); color: var(--green); }
.proposal-button.for:hover { background: var(--green); color: var(--btn-fg); }
.proposal-button.against { border-color: #e74c3c; color: #e74c3c; }
.proposal-button.against:hover { background: #e74c3c; color: #fff; }
.proposal-button.execute { background: #000; color: #fff; border-color: #000; }
.proposal-button.execute:hover { background: #333; }
.proposal-button.queue { background: #fffaf0; border-color: #b8860b; color: #b8860b; }
.proposal-button.cancel { border-color: #e74c3c; color: #e74c3c; }
.proposal-button.cancel:hover { background: #e74c3c; color: #fff; }
.proposal-button.claim { background: var(--status-success); border-color: var(--green); color: var(--green); margin-top: 8px; }
.proposal-button.claim:hover { background: var(--green); color: #fff; }
.user-vote-indicator {
  font-size: 11px;
  color: var(--fg-muted);
  display: flex;
  align-items: center;
  padding: 4px 0;
}

/* Futarchy rewards */
.futarchy-reward-box {
  margin-top: 12px;
  padding: 12px;
  background: var(--status-success);
  border: 1px solid var(--border-muted);
}
.futarchy-reward-title {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--green);
  margin-bottom: 6px;
}
.futarchy-reward-info {
  font-size: 12px;
  color: var(--fg);
  line-height: 1.5;
}

/* Chatroom messages */
.chatroom-message {
  padding: 10px 0;
  border-bottom: 1px solid var(--divider);
}
.chatroom-message:last-child { border-bottom: none; }
.chatroom-message.proposal {
  padding: 12px;
  background: var(--surface);
  border: 1px solid var(--border-muted);
  margin-bottom: 8px;
}
.chatroom-message-header {
  font-size: 11px;
  color: var(--fg-dim);
  margin-bottom: 4px;
}
.chatroom-message-header a { color: var(--fg-muted); font-size: 11px; }
.chatroom-message-header a:hover { color: var(--fg); }
.chatroom-message-text {
  font-size: 13px;
  line-height: 1.5;
  word-break: break-word;
}
.chatroom-message-more {
  background: none;
  border: none;
  color: var(--fg-muted);
  font-size: 11px;
  cursor: pointer;
  padding: 0;
  margin: 0 0 0 4px;
  text-decoration: underline;
  text-transform: none;
  letter-spacing: normal;
}
.chatroom-message-more:hover { color: var(--fg); }
.chatroom-sender-link {
  color: var(--fg-muted);
  text-decoration: none;
}
.chatroom-sender-link:hover { text-decoration: underline; }

/* Membership */
.membership-grid {
  display: grid;
  gap: 16px;
}
.badge-card, .balance-card, .delegation-card {
  border: 1px solid var(--border-muted);
  padding: 16px;
}
.balance-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 0;
  border-bottom: 1px solid var(--divider);
}
.balance-item:last-child { border-bottom: none; }
.balance-label {
  font-size: 12px;
  color: var(--fg-muted);
  display: flex;
  align-items: center;
}
.balance-value {
  font-size: 14px;
  font-weight: 600;
}
.token-explorer-link {
  display: none;
  margin-left: 6px;
  color: var(--fg-muted);
  opacity: 0.7;
  transition: opacity 0.2s, transform 0.2s;
}
.token-explorer-link.visible {
  display: inline;
}
.token-explorer-link:hover {
  opacity: 1;
  transform: translateY(-1px);
}
.token-mint-link {
  display: inline;
  margin-left: 6px;
  color: var(--fg-muted);
  opacity: 0.5;
  font-size: 12px;
  text-decoration: none;
  transition: opacity 0.2s;
}
.token-mint-link:hover {
  opacity: 1;
}
.token-mint-link svg {
  vertical-align: middle;
}

/* Voting Power */
.voting-power-summary {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-bottom: 12px;
}
.voting-power-item {
  padding: 12px;
  background: var(--surface);
}
.voting-power-label {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--fg-muted);
  margin-bottom: 4px;
}
.voting-power-value {
  font-size: 18px;
  font-weight: 600;
}
.voting-power-breakdown {
  font-size: 11px;
  color: var(--fg-dim);
  margin-top: 2px;
}

/* Delegation */
.delegation-status {
  padding: 12px;
  background: var(--surface);
  margin-bottom: 12px;
}
.delegation-status-label {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--fg-muted);
  margin-bottom: 4px;
}
.delegation-status-value {
  font-size: 13px;
  word-break: break-all;
}
.delegation-muted {
  color: var(--fg-dim);
}
.delegation-received {
  color: var(--green);
}
.delegation-delegate {
  cursor: help;
}
.delegation-delegate.ens-name {
  color: var(--green);
}
.delegation-split-list {
  margin-top: 6px;
}
.delegation-type-selector {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-bottom: 16px;
}
.delegation-type-option {
  border: 1px solid var(--border-muted);
  padding: 12px;
  cursor: pointer;
  text-align: center;
  transition: border-color 0.2s, background 0.2s;
}
.delegation-type-option:hover { border-color: var(--fg); }
.delegation-type-option.selected { border-color: var(--fg); background: var(--surface); }
.delegation-type-option input[type="radio"] { display: none; }
.delegation-type-icon { font-size: 1.5rem; margin-bottom: 4px; }
.delegation-type-title { font-size: 12px; font-weight: 600; }
.delegation-type-description { font-size: 11px; color: var(--fg-muted); }
.delegate-input-group { margin-bottom: 12px; }
.delegate-input-label {
  display: block;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--fg-muted);
  margin-bottom: 6px;
}
.modal-input {
  width: 100%;
  padding: 10px 0;
  font-size: 14px;
  font-family: inherit;
  border: none;
  border-bottom: 1px solid var(--border);
  outline: none;
  background: transparent;
}
.add-delegate-btn {
  background: var(--bg);
  color: var(--fg);
  border: 1px solid var(--border-muted);
  padding: 8px 16px;
  font-size: 12px;
  cursor: pointer;
  margin: 0;
}
.add-delegate-btn:hover { border-color: var(--fg); }
.delegation-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 12px;
}
.delegation-button {
  padding: 10px 16px;
  font-size: 11px;
  background: var(--btn-bg);
  color: var(--btn-fg);
  border: 1px solid var(--btn-bg);
  cursor: pointer;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin: 0;
}
.delegation-button:hover { background: var(--btn-hover); }
.delegation-form {
  display: none;
}
.delegation-form.visible {
  display: block;
}
.delegation-section-hidden {
  display: none;
}
.delegation-manage {
  margin-top: 12px;
}
.delegation-manage.hidden {
  display: none;
}
.delegation-manage-btn {
  width: 100%;
}
.delegation-total {
  margin-top: 12px;
  padding: 10px;
  background: var(--surface);
}
.delegation-total-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}
.delegation-total-label {
  color: var(--fg);
  font-size: 13px;
}
.delegation-total-value {
  font-weight: 600;
  font-size: 15px;
}
.delegation-total-value.over {
  color: #e74c3c;
}
.delegation-total-value.exact {
  color: var(--green);
}
.delegation-self-row {
  padding-top: 6px;
  border-top: 1px solid var(--border-muted);
  margin-bottom: 0;
  display: none;
}
.delegation-self-row.visible {
  display: flex;
}
.delegation-self-label {
  color: var(--fg-dim);
  font-size: 12px;
}
.delegation-self-value {
  color: var(--green);
  font-weight: 600;
}
.delegation-warning {
  display: none;
  margin-top: 6px;
  padding: 6px;
  background: #fff5f5;
  border: 1px solid #f5d5d5;
  color: #e74c3c;
  font-size: 12px;
  text-align: center;
}
.delegation-warning.visible {
  display: block;
}
.delegation-hint {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid var(--border-muted);
  font-size: 11px;
  color: var(--fg-dim);
  font-style: italic;
}

/* Received delegations */
.received-delegations-container {
  display: none;
}
.received-delegations-container.visible {
  display: block;
}
.received-delegations { margin-top: 12px; }
.received-delegations-title {
  font-size: 12px;
  font-weight: 600;
  margin-bottom: 8px;
}
.received-delegations-list { font-size: 13px; }
.received-delegation-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 0;
  border-bottom: 1px solid var(--divider);
}
.received-delegation-item:last-child { border-bottom: none; }
.delegator-info {
  display: flex;
  align-items: center;
  gap: 8px;
}
.delegator-badge {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: var(--divider);
  border: 1px solid var(--border-muted);
  font-size: 11px;
  font-weight: 600;
}
.delegator-address {
  font-size: 13px;
}
.delegator-address.ens-name {
  color: var(--green);
}
.delegated-amount {
  font-size: 12px;
  color: var(--fg-muted);
}

/* Receipts */
.receipts-panel {
  border: 1px solid var(--border-muted);
  padding: 16px;
  margin-top: 16px;
}
.receipts-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 10px;
}
.receipt-card {
  border: 1px solid var(--border-muted);
  padding: 10px;
  cursor: pointer;
  transition: border-color 0.2s;
  overflow: hidden;
}
.receipt-card:hover { border-color: var(--fg); }
.receipt-image {
  width: 100%;
  aspect-ratio: 1;
  object-fit: cover;
  display: block;
  margin-bottom: 8px;
}
.receipt-name {
  font-size: 11px;
  font-weight: 600;
  margin-bottom: 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.receipt-proposal {
  font-size: 10px;
  color: var(--fg-dim);
  font-family: monospace;
  margin-bottom: 2px;
}
.receipt-vote {
  font-size: 11px;
  font-weight: 600;
  margin-bottom: 2px;
}
.receipt-amount {
  font-size: 10px;
  color: var(--fg-muted);
}

/* Members */
.members-panel {
  border: 1px solid var(--border-muted);
  padding: 16px;
}
.members-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  flex-wrap: wrap;
  gap: 8px;
}
.members-stats {
  display: flex;
  gap: 16px;
}
.members-stat { font-size: 12px; }
.members-stat-label { color: var(--fg-muted); margin-right: 4px; }
.members-stat-value { font-weight: 600; }
.members-list { font-size: 13px; }

/* Member list items */
.member-item {
  display: grid;
  grid-template-columns: 1fr auto auto auto auto auto;
  gap: 12px;
  align-items: center;
  padding: 10px 0;
  border-bottom: 1px solid var(--divider);
  font-size: 12px;
}
.member-item:last-child { border-bottom: none; }
.member-address { min-width: 0; }
.member-ens {
  font-weight: 600;
  font-size: 13px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.member-address-hex {
  font-size: 11px;
  color: var(--fg-dim);
  font-family: monospace;
}
.member-shares, .member-loot, .member-badge, .member-ownership { text-align: right; }
.member-label {
  font-size: 9px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--fg-dim);
}
.member-value {
  font-size: 12px;
  font-weight: 600;
}
.member-link {
  color: var(--fg-dim);
  display: flex;
  align-items: center;
}
.member-link:hover { color: var(--fg); }
.member-link svg { width: 14px; height: 14px; }

/* Badge image */
.badge-image {
  max-width: 200px;
  height: auto;
  display: block;
  margin: 0 auto;
  border: 1px solid var(--border-muted);
}
.badge-image-link {
  cursor: pointer;
}
.badge-info {
  margin-top: 12px;
  text-align: center;
}
.badge-name {
  font-size: 14px;
  margin-bottom: 4px;
}
.badge-description {
  font-size: 13px;
  color: var(--fg-muted);
  margin-bottom: 8px;
}
.badge-attributes {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  justify-content: center;
  margin-top: 8px;
}
.badge-attribute {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 6px 10px;
  background: var(--surface);
  border: 1px solid var(--border-muted);
  min-width: 70px;
}
.badge-attribute-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--fg-dim);
}
.badge-attribute-value {
  font-size: 13px;
  color: var(--fg);
  margin-top: 2px;
}
.badge-links {
  display: flex;
  gap: 8px;
  justify-content: center;
  margin-top: 10px;
}
.badge-link {
  font-size: 12px;
  color: var(--fg-muted);
  text-decoration: none;
}
.badge-link:hover {
  color: var(--fg);
}
.badge-empty {
  text-align: center;
  color: var(--fg-dim);
  font-style: italic;
  margin-top: 12px;
}
.badge-fallback {
  text-align: center;
  padding: 2rem;
}
.badge-fallback-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
}

/* DAO stats bar items */
.dao-stat-item {
  display: inline-flex;
  gap: 4px;
  align-items: baseline;
}
.dao-stat-item .dao-stat-label {
  font-size: 11px;
  color: var(--fg-dim);
}
.dao-stat-item .dao-stat-value {
  font-size: 12px;
  font-weight: 600;
}

/* NFT Modal */
.nft-modal {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--modal-overlay);
  backdrop-filter: blur(4px);
  z-index: 3000;
  justify-content: center;
  align-items: center;
  padding: 20px;
}
.nft-modal.active { display: flex; }
.nft-modal-content {
  background: var(--modal-bg);
  border: 2px solid var(--modal-border);
  padding: 20px;
  max-width: 500px;
  width: 100%;
  max-height: 90vh;
  overflow-y: auto;
  position: relative;
}
.nft-modal-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: none;
  font-size: 24px;
  cursor: pointer;
  padding: 0;
  margin: 0;
  color: var(--fg);
}
.nft-modal-close:hover { opacity: 0.5; }
.nft-modal-body { font-size: 13px; }
.nft-modal-image {
  max-width: 100%;
  height: auto;
  display: block;
  margin-bottom: 12px;
  border: 1px solid var(--border-muted);
}
.nft-modal-image.url-image { max-height: 300px; object-fit: contain; }
.nft-modal-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 8px;
}
.nft-modal-description {
  font-size: 13px;
  color: var(--fg-muted);
  line-height: 1.5;
  margin-bottom: 12px;
}
.nft-modal-attributes {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-top: 12px;
}
.nft-modal-attribute {
  padding: 8px;
  background: var(--surface);
  border: 1px solid var(--border-muted);
}
.nft-modal-attribute-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--fg-dim);
  margin-bottom: 2px;
}
.nft-modal-attribute-value {
  font-size: 12px;
  font-weight: 600;
}

/* Loading */
.loading {
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid var(--border-muted);
  border-top: 2px solid var(--fg);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  vertical-align: middle;
}
@keyframes spin { 0% { transform: rotate(0); } 100% { transform: rotate(360deg); } }

/* Summoner toggle */
.summoner-toggle {
  font-size: 12px;
  color: var(--fg-muted);
  cursor: pointer;
  padding: 12px 0;
  user-select: none;
  letter-spacing: 0.05em;
}
.summoner-toggle:hover { color: var(--fg); }
.summoner-toggle.open { margin-bottom: 16px; }

/* Footer */
.site-footer {
  position: relative;
  text-align: center;
  padding: 48px 20px;
  font-size: 11px;
  opacity: 0.55;
  margin-top: 40px;
  letter-spacing: 0.5px;
  font-weight: 300;
}
.site-footer a {
  color: inherit;
  text-decoration: underline;
  margin: 0 2px;
}
.site-footer a:hover { opacity: 0.7; }
.site-footer .tagline { opacity:1; color:#000; font-weight:500; }
.dark .site-footer .tagline { opacity:1; color:#fff; font-weight:500; }

/* Responsive */
@media (max-width: 700px) {
  body { padding: 80px 16px 20px; }
  .dark-toggle { top: 18px; left: 16px; }
  .wallet { top: 16px; right: 16px; }
  .wallet button { padding: 10px 14px; font-size: 11px; }
  h1 { font-size: 13px; margin-bottom: 16px; }
  .dao-tiles { grid-template-columns: 1fr; }
  .dao-view-toggle { width: 100%; }
  .view-toggle-btn { flex: 1; padding: 8px 8px; font-size: 10px; }
  .voting-power-summary { grid-template-columns: 1fr; }
  .delegation-type-selector { grid-template-columns: 1fr; }
  .nft-modal-attributes { grid-template-columns: 1fr; }
  .modal, .wallet-modal { max-width: 100%; margin: 0 10px; }
  button { padding: 14px 20px; }
  .member-item {
    grid-template-columns: 1fr 1fr;
    gap: 6px 12px;
  }
  .member-shares, .member-loot, .member-badge, .member-ownership { text-align: left; }
  .proposal-votes { gap: 12px; }
  .proposal-item { padding: 16px; }
  .proposal-header { flex-direction: column; gap: 10px; }
  .proposal-state { align-self: flex-start; }
  .tribute-offers { grid-template-columns: 1fr 1fr; }
  .treasury-assets { grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); }
  .member-row { grid-template-columns: 1fr 80px auto; }
  .sale-ratio-grid { grid-template-columns: 1fr; gap: 4px; }
  .sale-ratio-arrow { display: none; }
}
@media (max-width: 380px) {
  body { padding: 70px 12px 20px; }
  h1 { font-size: 12px; }
  .dao-stats-bar { flex-direction: column; gap: 4px; }
}
.fire-loading { display: flex; justify-content: center; align-items: center; padding: 40px 0; }
.fire-loading canvas { image-rendering: pixelated; image-rendering: crisp-edges; }
#fireHero { display: flex; justify-content: center; align-items: center; min-height: 60vh; }
#fireHero.hide { display: none; }
</style>
</head>
<body>

<button class="dark-toggle" onclick="toggleDark()" title="Toggle dark mode"></button>
<a href="../" class="home-btn" title="Home"><svg width="28" height="28" viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg"><rect class="zorg-bg" width="400" height="400"/><clipPath id="zh"><rect width="400" height="400"/></clipPath><g clip-path="url(#zh)"><path class="zorg-fg" d="M-60-20L460-20L460 90L80 310L460 310L460 420L-60 420L-60 310L320 90L-60 90Z"/></g></svg></a>

<!-- Toast Notifications -->
<div class="toast-container" id="toastContainer"></div>

<!-- Wallet & Network -->
<div class="wallet">
  <button id="walletBtn" onclick="connectWallet()">connect</button>
</div>

<h1>DAO</h1>

<div class="nav-links">
  <button onclick="getEl('summoner').scrollIntoView({ behavior: 'smooth' });">Summon</button> &middot;
  <button onclick="scrollToYourDAOs()">Your DAOs</button> &middot;
  <button onclick="scrollToAllDAOs()">Find DAO</button> &middot;
  <a href="https://wp.majeurdao.eth.limo" target="_blank" rel="noopener noreferrer">Lite Paper</a> &middot;
  <a href="https://github.com/z0r0z/majeur" target="_blank" rel="noopener noreferrer">GitHub</a>
</div>

<div id="fireHero">
  <canvas id="fireCanvas"></canvas>
</div>

<!-- Wallet Selection Modal -->
<div class="wallet-modal-overlay" id="walletModal">
  <div class="wallet-modal">
    <div class="wallet-modal-header">
      <h2 class="wallet-modal-title">Connect Wallet</h2>
      <button class="wallet-modal-close" onclick="closeWalletModal()">&times;</button>
    </div>
    <div id="walletOptions"></div>
  </div>
</div>

<!-- TRANSFER RECEIPT MODAL -->
<div class="wallet-modal-overlay" id="transferReceiptModal">
  <div class="wallet-modal" style="max-width: 480px;">
    <div class="wallet-modal-header">
      <h2 class="wallet-modal-title">Transfer Receipt</h2>
      <button class="wallet-modal-close" onclick="closeTransferReceiptModal()">&times;</button>
    </div>
    <div class="wallet-modal-content">
      <div style="padding: 16px;">
        <div class="info-box" style="margin-bottom: 16px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <label style="margin: 0;">RECEIPT ID (uint256)</label>
            <button class="secondary" onclick="copyReceiptId()" id="copyReceiptBtn" style="padding: 4px 10px; font-size: 11px; margin: 0;">Copy</button>
          </div>
          <div id="transferReceiptId" data-full-id="" style="font-size: 13px; font-family: monospace; cursor: pointer; user-select: all;" title="Click to view full ID"></div>
          <div class="form-hint">Click ID or Copy button to get full value</div>
        </div>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
          <div class="info-box" style="margin: 0;">
            <label style="margin-bottom: 4px;">PROPOSAL</label>
            <div id="transferProposalId" data-full-id="" style="font-size: 14px; font-weight: 600; font-family: monospace; cursor: pointer; user-select: all;" title="Click to toggle full ID"></div>
          </div>
          <div class="info-box" style="margin: 0;">
            <label style="margin-bottom: 4px;">AVAILABLE</label>
            <div id="transferAvailableAmount" style="font-size: 14px; font-weight: 600;"></div>
          </div>
        </div>

        <div style="margin-bottom: 16px;">
          <h4>TRANSFER DETAILS</h4>
          <div style="margin-bottom: 12px;">
            <label>Recipient Address or ENS</label>
            <input type="text" id="transferRecipient" placeholder="0x... or vitalik.eth">
          </div>
          <div style="margin-bottom: 12px;">
            <label>Amount to Transfer</label>
            <input type="text" id="transferAmount" placeholder="0.0" inputmode="decimal">
            <div class="form-hint">Click <span onclick="setTransferMaxAmount()" style="cursor: pointer; text-decoration: underline;">here</span> to transfer all</div>
          </div>
        </div>

        <div style="display: flex; gap: 12px; padding-top: 12px; border-top: 1px solid var(--border-muted);">
          <button class="secondary" onclick="closeTransferReceiptModal()" style="flex: 1;">Cancel</button>
          <button onclick="executeReceiptTransfer()" style="flex: 1;">Transfer Receipt</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- DEPOSIT MODAL -->
<div class="wallet-modal-overlay" id="depositModal">
  <div class="wallet-modal" style="max-width: 480px;">
    <div class="wallet-modal-header">
      <h2 class="wallet-modal-title">Deposit to Treasury</h2>
      <button class="wallet-modal-close" onclick="closeDepositModal()">&times;</button>
    </div>
    <div class="wallet-modal-content">
      <div style="padding: 16px;">
        <div style="margin-bottom: 16px;">
          <label>SELECT ASSET</label>
          <div style="position: relative;">
            <div id="depositAssetDisplay" onclick="toggleDepositAssetDropdown()" style="width: 100%; padding: 10px 0; border-bottom: 1px solid #000; cursor: pointer; display: flex; align-items: center; gap: 8px;">
              <span>Choose an asset...</span>
            </div>
            <div id="depositAssetDropdown" class="custom-dropdown" style="display: none;"></div>
          </div>
        </div>

        <div style="margin-bottom: 16px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <label style="margin: 0;">AMOUNT</label>
            <div class="form-hint" style="margin: 0;">Balance: <span id="depositUserBalance">0</span></div>
          </div>
          <input type="text" id="depositAmount" placeholder="0.0" inputmode="decimal">
          <div class="form-hint">Click <span id="depositMaxButton" onclick="setDepositMax()" style="cursor: pointer; text-decoration: underline;">here</span> to deposit max</div>
        </div>

        <div class="info-box" style="margin-bottom: 16px;">
          <label style="margin-bottom: 4px;">DEPOSITING TO</label>
          <div id="depositDaoAddress" style="font-size: 12px; word-break: break-all; font-family: monospace;">-</div>
        </div>

        <div style="display: flex; gap: 12px; padding-top: 12px; border-top: 1px solid var(--border-muted);">
          <button class="secondary" onclick="closeDepositModal()" style="flex: 1;">Cancel</button>
          <button onclick="executeDeposit()" style="flex: 1;">Deposit</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- TRIBUTE MODAL -->
<div class="wallet-modal-overlay" id="tributeModal">
  <div class="wallet-modal" style="max-width: 520px;">
    <div class="wallet-modal-header">
      <h2 class="wallet-modal-title">Make Tribute Offer</h2>
      <button class="wallet-modal-close" onclick="closeTributeModal()">&times;</button>
    </div>
    <div class="wallet-modal-content">
      <div style="padding: 16px;">
        <div class="info-box" style="margin-bottom: 16px; line-height: 1.5;">
          Create an OTC offer by locking up your assets. DAO members can accept your tribute in exchange for assets from the treasury.
        </div>

        <div style="margin-bottom: 16px; padding: 16px; background: #f9f9f9;">
          <h4>YOU OFFER</h4>
          <div style="margin-bottom: 12px;">
            <label>ASSET</label>
            <div style="position: relative;">
              <div id="tributeAssetDisplay" onclick="toggleTributeAssetDropdown()" style="width: 100%; padding: 10px 0; border-bottom: 1px solid #000; cursor: pointer; display: flex; align-items: center; gap: 8px;">
                <span>Choose asset to offer...</span>
              </div>
              <div id="tributeAssetDropdown" class="custom-dropdown" style="display: none;"></div>
            </div>
          </div>
          <div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <label style="margin: 0;">AMOUNT</label>
              <div class="form-hint" style="margin: 0;">Balance: <span id="tributeUserBalance">0</span></div>
            </div>
            <input type="text" id="tributeAmount" placeholder="0.0" inputmode="decimal">
          </div>
        </div>

        <div style="margin-bottom: 16px; padding: 16px; background: var(--surface-hover);">
          <h4>YOU REQUEST</h4>
          <div style="margin-bottom: 12px;">
            <label>ASSET</label>
            <div style="position: relative;">
              <div id="requestAssetDisplay" onclick="toggleRequestAssetDropdown()" style="width: 100%; padding: 10px 0; border-bottom: 1px solid #000; cursor: pointer; display: flex; align-items: center; gap: 8px;">
                <span>Choose asset to request...</span>
              </div>
              <div id="requestAssetDropdown" class="custom-dropdown" style="display: none;"></div>
            </div>
          </div>
          <div>
            <label>AMOUNT</label>
            <input type="text" id="requestAmount" placeholder="0.0" inputmode="decimal">
          </div>
        </div>

        <div style="display: flex; gap: 12px; padding-top: 12px; border-top: 1px solid var(--border-muted);">
          <button class="secondary" onclick="closeTributeModal()" style="flex: 1;">Cancel</button>
          <button onclick="executeTribute()" style="flex: 1;">Create Tribute</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- RAGEQUIT MODAL -->
<div class="wallet-modal-overlay" id="ragequitModal">
  <div class="wallet-modal" style="max-width: 540px;">
    <div class="wallet-modal-header">
      <h2 class="wallet-modal-title">Ragequit DAO</h2>
      <button class="wallet-modal-close" onclick="closeRagequitModal()">&times;</button>
    </div>
    <div class="wallet-modal-content">
      <div style="padding: 16px;">
        <div style="margin-bottom: 16px;">
          <h4>YOUR BALANCES</h4>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <div class="info-box" style="margin: 0;">
              <label style="margin-bottom: 4px;">SHARES</label>
              <div id="ragequitUserShares" style="font-size: 18px; font-weight: 600;">0</div>
            </div>
            <div class="info-box" style="margin: 0;">
              <label style="margin-bottom: 4px;">LOOT</label>
              <div id="ragequitUserLoot" style="font-size: 18px; font-weight: 600;">0</div>
            </div>
          </div>
        </div>

        <div style="margin-bottom: 16px;">
          <h4>BURN AMOUNTS</h4>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <div>
              <label>Shares to Burn</label>
              <input type="text" id="ragequitSharesInput" placeholder="0.0" inputmode="decimal">
              <div class="form-hint"><span onclick="setRagequitMaxShares()" style="cursor: pointer; text-decoration: underline;">Max</span></div>
            </div>
            <div>
              <label>Loot to Burn</label>
              <input type="text" id="ragequitLootInput" placeholder="0.0" inputmode="decimal">
              <div class="form-hint"><span onclick="setRagequitMaxLoot()" style="cursor: pointer; text-decoration: underline;">Max</span></div>
            </div>
          </div>
        </div>

        <div style="margin-bottom: 16px;">
          <h4>TOKENS TO CLAIM</h4>
          <div id="ragequitTokenList" style="display: flex; flex-direction: column; gap: 8px; max-height: 200px; overflow-y: auto;">
          </div>
          <div class="info-box" style="margin-top: 12px;">
            <label style="margin-bottom: 6px;">Add Custom Token</label>
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
              <input type="text" id="ragequitCustomTokenInput" placeholder="Token address (0x...)" style="flex: 1; min-width: 200px;">
              <button onclick="addCustomRagequitToken()" style="margin: 0;">Add</button>
            </div>
            <div class="form-hint">For tokens not in the list. Auto-sorted by address.</div>
          </div>
        </div>

        <div style="display: flex; gap: 12px; padding-top: 12px; border-top: 1px solid var(--border-muted);">
          <button class="secondary" onclick="closeRagequitModal()" style="flex: 1;">Cancel</button>
          <button onclick="executeRagequit()" style="flex: 1; background: #e74c3c; border-color: #e74c3c;">Execute Ragequit</button>
        </div>
      </div>
    </div>
  </div>
</div>

    <!-- SUMMONER SECTION -->
    <section class="summoner-section" id="summoner">
      <div class="summoner-container">
        <div class="summoner-toggle" onclick="toggleSummoner()">&#9654; Summon New DAO</div>
        <div id="summonerBody" style="display: none;">

        <form id="summonForm">
          <!-- Basic Info -->
          <div class="form-group">
            <label class="form-label">DAO Name</label>
            <input type="text" class="form-input" id="daoName" placeholder="e.g., MetaGuild" required minlength="2" maxlength="50">
            <span class="form-hint">2-50 characters</span>
          </div>

          <div class="form-group">
            <label class="form-label">DAO Symbol</label>
            <input type="text" class="form-input" id="daoSymbol" placeholder="e.g., META" maxlength="10" required>
          </div>

          <div class="form-group">
            <label class="form-label">Description <span class="form-hint" style="display: inline; text-transform: none;">(optional)</span></label>
            <textarea class="form-input" id="daoDescription" placeholder="Describe your DAO's purpose, mission, or governance structure..." rows="3"></textarea>
            <small class="form-hint">If empty, defaults to <a href="https://github.com/z0r0z/majeur?tab=readme-ov-file#wyoming-duna" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">Wyoming DUNA</a> charter among members</small>
          </div>

          <!-- Quorum Settings -->
          <div class="form-group">
            <label class="form-label">Quorum %</label>
            <input type="number" class="form-input" id="quorumBps" placeholder="50" min="0" max="100" value="50">
            <small class="form-hint">Percentage of votes needed for proposal validity</small>
            <div id="quorumVotesDisplay" class="info-box" style="display: none; margin-top: 8px;">
              Required votes for quorum: <strong id="quorumVotesValue">0</strong> / <span id="quorumTotalSupply">0</span>
            </div>
            <div id="quorumWarning" class="info-box" style="display: none; margin-top: 8px; background: var(--status-error); border-color: var(--red); color: var(--red);">
              <strong>Warning:</strong> With this quorum % and initial supply, required quorum rounds down to <strong>0 votes</strong>. Increase quorum %, increase initial supply, or set an absolute quorum.
            </div>
          </div>

          <!-- Members -->
          <div class="form-group">
            <label class="form-label">Founding Members</label>
            <div class="members-container">
              <div id="foundingMembersList">
                <!-- Initial member (connected wallet) will be added by JS -->
              </div>
              <button type="button" class="add-member-btn" onclick="addMemberRow()">+ Add Member</button>
            </div>
          </div>

          <!-- Advanced Settings -->
          <div class="advanced-toggle" onclick="toggleAdvanced()">
            â–¼ Advanced Settings
          </div>

          <div class="advanced-settings" id="advancedSettings">
            <div class="form-group">
              <label class="form-label checkbox-group">
                <input type="checkbox" id="ragequittable" checked>
                <span>Enable Ragequit</span>
              </label>
              <small class="form-hint">Allow members to exit with pro-rata treasury</small>
            </div>

            <div class="form-group">
              <label class="form-label checkbox-group">
                <input type="checkbox" id="distributeLoot">
                <span>Distribute Loot to Founders</span>
              </label>
              <div id="lootDistribution" style="display: none; margin-top: 8px;">
                <div style="margin-bottom: 8px;">
                  <label class="form-label checkbox-group">
                    <input type="checkbox" id="equalLoot" checked>
                    <span>Equal distribution</span>
                  </label>
                </div>
                <input type="number" class="form-input" id="lootPerMember" placeholder="100" value="100" min="0.000000000000000001" step="any">
                <small class="form-hint">Loot tokens per member (or total if custom)</small>
                <div id="customLootAmounts" style="margin-top: 16px; display: none;">
                  <!-- Will be populated with inputs for each member -->
                </div>
              </div>
            </div>

            <div class="form-group">
              <label class="form-label">Proposal TTL</label>
              <div style="display: grid; grid-template-columns: 1fr auto; gap: 8px;">
                <input type="number" class="form-input" id="proposalTTL" placeholder="7" value="7">
                <select class="form-input" id="proposalTTLUnit" style="width: auto;">
                  <option value="86400" selected>Days</option>
                  <option value="3600">Hours</option>
                  <option value="60">Minutes</option>
                  <option value="1">Seconds</option>
                </select>
              </div>
              <small class="form-hint">Time until proposals expire</small>
            </div>

            <div class="form-group">
              <label class="form-label">Timelock Delay</label>
              <div style="display: grid; grid-template-columns: 1fr auto; gap: 8px;">
                <input type="number" class="form-input" id="timelockDelay" placeholder="1" value="1">
                <select class="form-input" id="timelockDelayUnit" style="width: auto;">
                  <option value="86400" selected>Days</option>
                  <option value="3600">Hours</option>
                  <option value="60">Minutes</option>
                  <option value="1">Seconds</option>
                </select>
              </div>
              <small class="form-hint">Delay between proposal passing and execution</small>
            </div>

            <div class="form-group">
              <label class="form-label">Proposal Threshold (optional)</label>
              <input type="number" class="form-input" id="proposalThreshold" placeholder="0" min="0" step="1">
              <small class="form-hint">Minimum shares required to create a proposal (cannot exceed total initial shares)</small>
            </div>

            <div class="form-group">
              <label class="form-label">Emblem/Logo URL (optional)</label>
              <input type="text" class="form-input" id="daoImageURI" placeholder="https://example.com/logo.svg or ipfs://...">
              <small class="form-hint">Direct image URL for DAO emblem (SVG, PNG, JPG, etc.) or IPFS</small>
            </div>

            <div class="form-group">
              <label class="form-label">Initial ETH Deposit (optional)</label>
              <input type="number" class="form-input" id="initialEthDeposit" placeholder="0" min="0" step="any">
              <small class="form-hint">Amount of ETH to deposit into treasury during summoning</small>
            </div>

            <div class="form-group">
              <label class="form-label checkbox-group">
                <input type="checkbox" id="enableSharesTransfer">
                <span>Enable Shares Transferability</span>
              </label>
              <small class="form-hint">Allow shares to be transferred</small>
            </div>

            <div class="form-group">
              <label class="form-label checkbox-group">
                <input type="checkbox" id="enableLootTransfer">
                <span>Enable Loot Transferability</span>
              </label>
              <small class="form-hint">Allow loot to be transferred</small>
            </div>

            <div class="form-group">
              <label class="form-label">Auto-Futarchy (Voter Rewards)</label>
              <select class="form-input" id="autoFutarchyPreset">
                <option value="off" selected>Off</option>
                <option value="low">Low: 0.05% supply, 2 LOOT cap</option>
                <option value="standard">Standard: 0.1% supply, 5 LOOT cap</option>
                <option value="high">High: 0.5% supply, 10 LOOT cap</option>
              </select>
              <small class="form-hint">Mint LOOT rewards for winning voters (% of shares+loot supply, capped per proposal)</small>
            </div>

            <div class="form-group">
              <label class="form-label">Initial Token Sale</label>
              <select class="form-input" id="initialSalePreset" onchange="toggleSaleConfig()">
                <option value="off" selected>Off (No initial sale)</option>
                <option value="internal">Token Wrapping (1:1 mint)</option>
                <option value="daico">Token Sale (DAICO)</option>
              </select>
              <small class="form-hint">Configure how users can acquire DAO tokens</small>
            </div>

            <div id="saleConfigSection" class="sale-config" style="display: none;">
              <div id="saleTypeDescription" class="sale-info-box">
                <span id="saleTypeDescText"></span>
              </div>

              <!-- Internal Sale Payment Token (simplified: Custom or DAI only) -->
              <div class="form-group" id="internalPaymentTokenGroup">
                <label class="form-label">Wrap Token</label>
                <div style="position: relative;">
                  <div id="internalPaymentTokenDisplay" onclick="toggleInternalPaymentTokenDropdown()" class="token-select">
                    <div class="token-dropdown-icon" id="internalPaymentTokenIcon"></div>
                    <span id="internalPaymentTokenLabel">Custom Token (18 decimals)</span>
                  </div>
                  <div id="internalPaymentTokenDropdown" class="custom-dropdown" style="display: none;">
                    <div onclick="selectInternalPaymentToken('custom')" class="token-dropdown-item">
                      <div class="token-dropdown-icon" data-token="defaultCoin"></div>
                      <div>
                        <div>Custom Token (18 decimals)</div>
                        <small class="form-hint" style="margin: 0;">Wrap any 18-decimal ERC20 into DAO shares 1:1</small>
                      </div>
                    </div>
                    <div onclick="selectInternalPaymentToken('dai')" class="token-dropdown-item">
                      <div class="token-dropdown-icon" data-token="dai"></div>
                      <div>
                        <div>DAI</div>
                        <small class="form-hint" style="margin: 0;">Accept DAI stablecoin 1:1 for DAO shares</small>
                      </div>
                    </div>
                  </div>
                  <input type="hidden" class="form-input" id="internalPaymentToken" value="custom">
                </div>
                <small id="internalPaymentTokenHint" class="form-hint">1 token in = 1 share out. Ideal for token upgrades or migrations.</small>
              </div>

              <!-- DAICO Sale Payment Token (full options) -->
              <div class="form-group" id="daicoPaymentTokenGroup" style="display: none;">
                <label class="form-label">Payment Token</label>
                <div style="position: relative;">
                  <div id="salePaymentTokenDisplay" onclick="toggleSalePaymentTokenDropdown()" class="token-select">
                    <div class="token-dropdown-icon" id="salePaymentTokenIcon"></div>
                    <span id="salePaymentTokenLabel">ETH</span>
                  </div>
                  <div id="salePaymentTokenDropdown" class="custom-dropdown" style="display: none;">
                    <div onclick="selectSalePaymentToken('eth')" class="token-dropdown-item">
                      <div class="token-dropdown-icon" data-token="eth"></div>
                      <span>ETH</span>
                    </div>
                    <div onclick="selectSalePaymentToken('usdc')" id="saleUsdcOption" class="token-dropdown-item">
                      <div class="token-dropdown-icon" data-token="usdc"></div>
                      <span>USDC</span>
                    </div>
                    <div onclick="selectSalePaymentToken('usdt')" id="saleUsdtOption" class="token-dropdown-item">
                      <div class="token-dropdown-icon" data-token="usdt"></div>
                      <span>USDT</span>
                    </div>
                    <div onclick="selectSalePaymentToken('dai')" class="token-dropdown-item">
                      <div class="token-dropdown-icon" data-token="dai"></div>
                      <span>DAI</span>
                    </div>
                    <div onclick="selectSalePaymentToken('wsteth')" class="token-dropdown-item">
                      <div class="token-dropdown-icon" data-token="wsteth"></div>
                      <span>wstETH</span>
                    </div>
                    <div onclick="selectSalePaymentToken('reth')" class="token-dropdown-item">
                      <div class="token-dropdown-icon" data-token="reth"></div>
                      <span>rETH</span>
                    </div>
                    <div onclick="selectSalePaymentToken('custom')" class="token-dropdown-item">
                      <div class="token-dropdown-icon" data-token="defaultCoin"></div>
                      <span>Custom Token</span>
                    </div>
                  </div>
                  <input type="hidden" class="form-input" id="salePaymentToken" value="eth">
                </div>
                <small id="salePaymentTokenHint" class="form-hint">Accept any token: ETH, stablecoins (USDC/USDT/DAI), or custom ERC20.</small>
              </div>

              <div class="form-group" id="customTokenFields" style="display: none;">
                <label class="form-label">Custom Token Address</label>
                <input type="text" class="form-input" id="customTokenAddress" placeholder="0x..." oninput="validateCustomPaymentToken()">
                <small class="form-hint">Enter the ERC20 token contract address. Decimals will be detected automatically.</small>
                <div id="customPaymentTokenInfo" style="margin-top: 0.5rem; font-size: 0.85rem;"></div>
              </div>

              <!-- Hidden field for auto-detected decimals -->
              <input type="hidden" id="customTokenDecimals" value="18">

              <div class="form-group">
                <label class="form-label">Token Type</label>
                <select class="form-input" id="saleTokenType" onchange="updateSaleThresholdWarning(); updateDaicoLabels(); updateDaicoSaleSummary(); updateSummonerSaleHint();">
                  <option value="shares">Shares (voting power)</option>
                  <option value="loot">Loot (non-voting)</option>
                </select>
              </div>

              <!-- DAICO-specific: Sale Supply (for minting to DAO and approving) -->
              <div class="form-group" id="daicoSupplyField" style="display: none;">
                <label class="form-label">Total Sale Supply</label>
                <input type="text" class="form-input daico-formatted-input" id="daicoSaleSupply" placeholder="100,000,000" oninput="formatDaicoNumberInput(this); updateDaicoSaleSummary();">
                <small class="form-hint">Total tokens to mint for sale (e.g., 100,000,000). This is the maximum that can be sold.</small>
              </div>

              <div id="internalSaleFields">
                <input type="hidden" id="salePrice" value="1">
                <input type="hidden" id="saleCap" value="0">
                <input type="hidden" id="saleMinting" value="true">
                <div class="sale-summary">
                  <strong>How it works:</strong>
                  <div id="internalWrapSummary" style="margin-top: 4px;">
                    Users deposit tokens â†’ receive DAO shares 1:1<br>
                    <span class="form-hint">With ragequit enabled, users can burn shares to reclaim tokens anytime.</span>
                  </div>
                </div>
              </div>

              <!-- DAICO-specific: Ratio pricing with clear explanations -->
              <div id="daicoSaleFields" style="display: none;">
                <!-- Sale ratio explanation -->
                <div class="sale-info-box" style="margin-bottom: 16px; color: var(--fg-muted);">
                  <strong>Set your sale price:</strong> Define how many tokens buyers receive for their payment.
                </div>

                <div class="sale-ratio-grid">
                  <div class="form-group" style="margin-bottom: 0;">
                    <label class="form-label">Pay <span id="daicoPayTokenLabel">(ETH)</span></label>
                    <input type="text" class="form-input daico-formatted-input" id="daicoTribAmt" placeholder="1" oninput="formatDaicoNumberInput(this); updateDaicoSaleSummary();">
                    <small class="form-hint">Payment amount</small>
                  </div>
                  <div class="sale-ratio-arrow">â†’</div>
                  <div class="form-group" style="margin-bottom: 0;">
                    <label class="form-label">Receive <span id="daicoReceiveLabel">(Shares)</span></label>
                    <input type="text" class="form-input daico-formatted-input" id="daicoForAmt" placeholder="1,000,000" oninput="formatDaicoNumberInput(this); updateDaicoSaleSummary();">
                    <small class="form-hint">Tokens received</small>
                  </div>
                </div>

                <!-- Live sale summary -->
                <div id="daicoSaleSummaryBox" class="sale-summary" style="display: none; margin-bottom: 16px;">
                  <div class="form-hint" style="margin-bottom: 6px;">Sale Terms:</div>
                  <div id="daicoSaleSummaryText" style="font-weight: 600; line-height: 1.5;"></div>
                  <div id="daicoSalePriceText" class="form-hint" style="margin-top: 6px;"></div>
                </div>

                <!-- DAICO LP Configuration (Optional) -->
                <div id="daicoSummonLPSection" class="info-box" style="display: none; margin-bottom: 16px;">
                  <label class="form-label checkbox-group" style="margin-bottom: 8px;">
                    <input type="checkbox" id="daicoSummonEnableLP" onchange="toggleDaicoSummonLPFields(); updateDaicoSaleSummary();">
                    <span>Enable Liquidity Provision (LP)</span>
                  </label>
                  <div id="daicoSummonLPFields" style="display: none;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                      <div class="form-group" style="margin-bottom: 0;">
                        <label class="form-label">LP %</label>
                        <input type="number" class="form-input" id="daicoSummonLpBps" placeholder="50" min="1" max="99" step="1" value="50" oninput="updateDaicoSaleSummary();">
                        <small class="form-hint">% of tribute to LP (1-99)</small>
                      </div>
                      <div class="form-group" style="margin-bottom: 0;">
                        <label class="form-label">Pool Fee (bps)</label>
                        <input type="number" class="form-input" id="daicoSummonFeeOrHook" placeholder="30" min="1" max="10000" step="1" value="30">
                        <small class="form-hint">ZAMM pool fee (30 = 0.3%)</small>
                      </div>
                    </div>
                    <small class="form-hint"><strong>Note:</strong> Buyers receive (100% - LP%) of quoted rate. LP shares go to DAO treasury.</small>
                  </div>
                </div>

                <!-- DAICO Tap Configuration (Optional) -->
                <div id="daicoSummonTapSection" class="info-box" style="display: none; margin-bottom: 16px;">
                  <label class="form-label checkbox-group" style="margin-bottom: 8px;">
                    <input type="checkbox" id="daicoSummonEnableTap" onchange="toggleDaicoSummonTapFields(); updateDaicoSaleSummary();">
                    <span>Enable Tap (Continuous Funding)</span>
                  </label>
                  <div id="daicoSummonTapFields" style="display: none;">
                    <div class="form-group">
                      <label class="form-label">Ops Address (Tap Beneficiary)</label>
                      <input type="text" class="form-input" id="daicoSummonTapOps" placeholder="0x...">
                      <small class="form-hint">Address that can claim tap funds</small>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                      <div class="form-group" style="margin-bottom: 0;">
                        <label class="form-label">Tap Rate (per month)</label>
                        <input type="text" class="form-input daico-formatted-input" id="daicoSummonTapRate" placeholder="1,000" oninput="formatDaicoNumberInput(this); updateDaicoSummonTapPreview();">
                        <small class="form-hint">Payment tokens/month</small>
                      </div>
                      <div class="form-group" style="margin-bottom: 0;">
                        <label class="form-label">Total Tap Budget</label>
                        <input type="text" class="form-input daico-formatted-input" id="daicoSummonTapBudget" placeholder="100,000" oninput="formatDaicoNumberInput(this); updateDaicoSummonTapPreview();">
                        <small class="form-hint">Max claimable amount</small>
                      </div>
                    </div>
                    <div id="daicoSummonTapPreview" class="form-hint" style="display: none;"></div>
                  </div>
                </div>
              </div>

              <div id="summonerSaleHint" class="sale-info-box" style="display: none; margin-top: 8px;">
                <strong>Sale Preview:</strong> <span id="summonerSaleHintText"></span>
              </div>

              <!-- Proposal threshold warning for shares sales -->
              <div id="saleThresholdWarning" style="display: none; margin-top: 0.5rem; padding: 0.75rem; background: #fdf8f0; border-left: 3px solid #ddc040; font-size: 0.8rem; color: #b8860b; line-height: 1.5;">
                <strong style="color: #ddc040;">Governance Warning:</strong> <span id="saleThresholdWarningText">Selling voting shares with a proposal threshold may allow buyers to accumulate enough shares to pass proposals. Consider selling LOOT (non-voting) for public sales, or ensure the sale cap is appropriately limited.</span>
              </div>

              <div id="upgradePathHint" class="sale-info-box" style="display: none; margin-top: 8px; color: var(--fg-muted);">
                <strong>Token Upgrade Path:</strong> With 1:1 pricing and ragequit enabled, users can upgrade their tokens to DAO shares, then burn shares to reclaim tokens if desired, lowering risk.
              </div>
            </div>
          </div>

          <button type="submit" class="summon-button" id="summonBtn" disabled>
            CONNECT WALLET TO SUMMON
          </button>
        </form>

        <div id="statusMessage"></div>
        </div>
      </div>
    </section>

    <!-- PURCHASE MODAL -->
    <div class="wallet-modal-overlay" id="purchaseModal">
      <div class="wallet-modal" style="max-width: 500px;">
        <div class="wallet-modal-header">
          <h3>Purchase Tokens</h3>
          <button onclick="closePurchaseModal()" class="wallet-modal-close">&times;</button>
        </div>
        <div style="padding: 16px;">
          <div id="purchaseModalContent"></div>
        </div>
      </div>
    </div>

    <!-- DAO GALLERY SECTION -->
    <section class="dao-gallery-section" id="daoGallery">
      <div class="dao-gallery-header">
        <h2 class="dao-gallery-title">Your DAOs</h2>
        <p class="dao-gallery-subtitle">Majeur organizations you belong to</p>
      </div>
      <div class="dao-tiles" id="daoTiles">
        <!-- DAO tiles will be dynamically rendered here -->
      </div>
    </section>

    <!-- DAO SEARCH SECTION -->
    <section class="all-daos-section" id="allDaosGallery">
      <div class="all-daos-header">
        <h2 class="all-daos-title">Find a DAO</h2>
        <p class="all-daos-subtitle">Search by name, symbol, or address</p>
      </div>
      <div class="dao-search">
        <input type="text" id="daoSearchInput" class="dao-search-input" placeholder="Name, symbol, or 0x..." onkeydown="if(event.key==='Enter') searchDAO()" />
        <button class="dao-search-btn" onclick="searchDAO()">Search</button>
      </div>
      <div class="dao-tiles" id="allDaosTiles">
        <!-- Search results will be rendered here -->
      </div>
    </section>

    <!-- DAO DASHBOARD SECTION -->
    <section class="dao-dashboard" id="daoDashboard">
      <div class="dao-dashboard-header">
        <div style="display: flex; align-items: center; gap: 1rem;">
          <div id="daoEmblem" class="dao-emblem" style="display: none;" title="DAO Contract URI">
            <!-- DAO emblem will be rendered here -->
          </div>
          <div>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <h2 class="dao-dashboard-title" id="dashboardTitle">DAO Dashboard</h2>
              <button
                onclick="manualRefreshDAO()"
                id="refreshButton"
                title="Refresh DAO state"
                style="background: none; border: none; color: #bbb; cursor: pointer; padding: 0.15rem; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease;"
                onmouseover="this.style.color='#666'; this.style.transform='rotate(90deg)';"
                onmouseout="this.style.color='#bbb'; this.style.transform='rotate(0deg)';">
                <svg width="13" height="13" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <polyline points="23 4 23 10 17 10"></polyline>
                  <polyline points="1 20 1 14 7 14"></polyline>
                  <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                </svg>
              </button>
            </div>
            <a class="dao-etherscan-link" id="daoEtherscanLink" href="#" target="_blank" rel="noopener noreferrer">
              <span id="daoAddressText">0x...</span>
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
              </svg>
            </a>
            <button class="dao-copy-link-btn" id="daoCopyLinkBtn" onclick="copyDAOLink()" title="Copy shareable link to this DAO">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
              </svg>
              <span>Copy Link</span>
            </button>
            <div class="dao-stats-bar" id="daoStatsBar">
              <!-- Stats will be dynamically rendered here -->
            </div>
          </div>
        </div>
        <button class="back-button" onclick="backToGallery()">â† Back to Gallery</button>
      </div>

      <!-- View Toggle -->
      <div class="dao-view-toggle">
        <button class="view-toggle-btn active" id="viewToggleDao" onclick="switchDaoView('dao')">DAO Dashboard</button>
        <button class="view-toggle-btn" id="viewToggleMembership" onclick="switchDaoView('membership')">My Membership</button>
        <button class="view-toggle-btn" id="viewToggleMembers" onclick="switchDaoView('members')">Members</button>
      </div>

      <!-- DAO Dashboard Content -->
      <div class="dao-dashboard-content show" id="daoDashboardView">
        <!-- Chatroom Panel -->
        <div class="dao-panel">
          <h3 class="dao-panel-title">Chatroom</h3>
          <div class="chatroom-messages" id="chatroomMessages">
            <!-- Messages will be dynamically rendered here -->
          </div>
          <div class="chatroom-send">
            <input
              type="text"
              id="chatInput"
              class="chatroom-input"
              placeholder="Type a message..."
            />
            <button class="chatroom-button" onclick="sendChatMessage()">Send</button>
          </div>

          <!-- Treasury Section -->
          <div class="treasury-section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
              <h4 class="treasury-title" style="margin-bottom: 0;">Treasury</h4>
              <div style="display: flex; gap: 0.5rem;">
                <button onclick="prepareInternalSaleProposal()" class="deposit-button" title="Internal sale: 1:1 upgrade or DAI continuous" style="background: #f9f9f9; border-color: var(--fg-muted);">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 19V5M5 12l7-7 7 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
                <button onclick="prepareNewDaicoSaleProposal()" class="deposit-button" title="DAICO sale: external OTC fundraise" style="background: var(--status-success); border-color: var(--green);">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 2L2 7l10 5 10-5-10-5z" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round" fill="none"/>
                    <path d="M2 17l10 5 10-5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M2 12l10 5 10-5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
                <button onclick="openDepositModal()" class="deposit-button" title="Deposit assets to treasury">
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                  </svg>
                </button>
              </div>
            </div>
            <div class="treasury-assets" id="treasuryAssets">
              <!-- Treasury assets will be dynamically rendered here -->
            </div>
            <button class="ragequit-button" id="ragequitBtn" onclick="openRagequitModal()">Ragequit</button>
          </div>

          <!-- Tributes Section -->
          <div class="treasury-section" style="margin-top: 1.5rem;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
              <h4 class="treasury-title" style="margin-bottom: 0;">Incoming Tributes</h4>
              <button onclick="openTributeModal()" class="deposit-button" title="Make a tribute offer">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M7 7h10l-4 5 4 5H7l4-5-4-5z" stroke="currentColor" stroke-width="2" stroke-linejoin="round" fill="none"/>
                  <circle cx="12" cy="12" r="9" stroke="currentColor" stroke-width="1.5" fill="none"/>
                </svg>
              </button>
            </div>
            <div class="tribute-offers" id="tributeOffers">
              <!-- Tributes will be dynamically rendered here -->
            </div>
          </div>

          <!-- Governance Info Section -->
          <div class="treasury-section" style="margin-top: 1.5rem;">
            <h4 class="treasury-title">Governance</h4>
            <div id="governanceInfo" style="font-size: 0.85rem; color: var(--fg); line-height: 1.6;">
              <!-- Governance info will be dynamically rendered here -->
            </div>
          </div>

          <!-- Sales Section -->
          <div id="salesSection" class="treasury-section" style="margin-top: 1.5rem; display: none;">
            <h4 class="treasury-title">Active Sales</h4>
            <div id="salesInfo">
              <!-- Active sales will be dynamically rendered here -->
            </div>
          </div>

          <!-- Allowances Section (My Spending Allowances) -->
          <div id="allowancesSection" class="treasury-section" style="margin-top: 1.5rem; display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
              <h4 class="treasury-title" style="margin-bottom: 0;">
                My Allowances
                <a href="#" onclick="event.preventDefault(); prepareAllowanceProposal(); switchDaoView('dao');" title="Propose new allowance" onmouseover="this.style.opacity='1';" onmouseout="this.style.opacity='0.5';" style="margin-left: 0.5rem; color: #000; opacity: 0.5; transition: all 0.2s; font-size: 0.75rem; text-decoration: none;">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle;">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                  </svg>
                </a>
              </h4>
            </div>
            <div id="allowancesInfo" style="font-size: 0.85rem; color: var(--fg);">
              <!-- User's allowances will be dynamically rendered here -->
            </div>
          </div>
        </div>

        <!-- Proposals Panel -->
        <div class="dao-panel">
          <h3 class="dao-panel-title">Proposals</h3>

          <!-- New Proposal Form -->
          <div class="proposal-form">
            <h4 class="proposal-form-title">Create Proposal</h4>
            <input type="hidden" id="proposalOp" value="0" />
            <div class="proposal-form-group">
              <label class="proposal-form-label">Target Address</label>
              <input type="text" id="proposalTo" class="proposal-form-input" placeholder="0x..." oninput="updateTargetAddressHint()" />
              <div id="targetAddressHint" style="margin-top: 0.35rem; display: none;">
                <span id="targetAddressHintBadge" style="display: inline-block; padding: 0.25rem 0.5rem; background: var(--surface); border: 1px solid var(--border-muted); font-size: 0.7rem; color: var(--fg); letter-spacing: 0.1em;"></span>
              </div>
            </div>
            <div class="proposal-form-group" id="proposalValueGroup">
              <label class="proposal-form-label">Value (ETH)</label>
              <input type="text" id="proposalValue" class="proposal-form-input" placeholder="0" />
            </div>
            <div class="proposal-form-group">
              <label class="proposal-form-label">Data (hex)</label>
              <input type="text" id="proposalData" class="proposal-form-input" placeholder="0x" oninput="updateCalldataPreview(); updateCalldataTranslation();" />
              <div id="calldataTranslation" style="margin-top: 0.5rem; display: none; padding: 0.75rem; background: var(--surface); border-left: 3px solid var(--fg); font-size: 0.85rem;"></div>
              <div id="calldataPreview" style="margin-top: 0.5rem; display: none;">
                <a id="calldataPreviewLink" href="#" target="_blank" rel="noopener noreferrer"
                   style="font-size: 0.75rem; color: var(--fg); text-decoration: none; display: inline-flex; align-items: center; gap: 0.35rem; opacity: 0.75; transition: opacity 0.3s ease;"
                   onmouseover="this.style.opacity='1'"
                   onmouseout="this.style.opacity='0.75'">
                  <span>ðŸ”</span> Decode calldata on SwissKnife
                </a>
              </div>
            </div>
            <div class="proposal-form-group">
              <label class="proposal-form-label">Description</label>
              <!-- Locked description preview (shown when populated by helper) -->
              <div id="proposalDescriptionLocked" style="display: none; margin-bottom: 0.75rem;">
                <div style="padding: 0.75rem; background: var(--surface); border: 1px solid var(--border-muted); font-size: 0.85rem; color: var(--fg-muted); line-height: 1.5; white-space: pre-wrap; ">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                    <span style="font-size: 0.7rem; color: var(--fg-muted); text-transform: uppercase; letter-spacing: 0.1em;">Proposal Summary (auto-generated)</span>
                    <button onclick="clearLockedDescription()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 0.75rem; padding: 0.2rem 0.4rem;" title="Clear and edit manually">âœ• Clear</button>
                  </div>
                  <div id="proposalDescriptionLockedText"></div>
                </div>
                <label class="proposal-form-label" style="margin-top: 0.75rem; font-size: 0.8rem;">Additional Notes (optional)</label>
                <textarea id="proposalDescriptionNotes" class="proposal-form-input proposal-form-textarea" placeholder="Add any additional context or notes..." style="min-height: 60px;"></textarea>
              </div>
              <!-- Regular description textarea (shown when no locked description) -->
              <textarea id="proposalDescription" class="proposal-form-input proposal-form-textarea" placeholder="Describe the proposal..."></textarea>
              <!-- Hidden field to store the full description for submission -->
              <input type="hidden" id="proposalDescriptionFull" value="">
            </div>
            <div id="proposalTTLInfo" style="margin-bottom: 0.75rem; padding: 0.65rem; background: #f9f9f9; border-left: 3px solid #ccc; display: none;">
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="opacity: 0.7; flex-shrink: 0;">
                  <circle cx="12" cy="12" r="10"></circle>
                  <polyline points="12 6 12 12 16 14"></polyline>
                </svg>
                <span id="proposalTTLInfoText" style="font-size: 0.8rem; color: var(--fg); line-height: 1.4;"></span>
              </div>
            </div>
            <button class="chatroom-button" onclick="createProposal()">Create & Publish</button>
          </div>

          <!-- Proposals List -->
          <div id="proposalsList">
            <!-- Proposals will be dynamically rendered here -->
          </div>
        </div>
      </div>

      <!-- Membership Dashboard Content -->
      <div class="dao-membership-content" id="daoMembershipView">
        <div class="membership-grid">
          <!-- Badge Card -->
          <div class="badge-card">
            <h3 class="dao-panel-title">Member Badge</h3>
            <div id="badgeContent">
              <p class="badge-empty">Loading...</p>
            </div>
          </div>

          <!-- Balances Card -->
          <div class="balance-card">
            <h3 class="dao-panel-title">Your Balances</h3>
            <div class="balance-item">
              <div class="balance-label">
                Voting Shares
                <a id="sharesEtherscanLink" href="#" target="_blank" rel="noopener noreferrer" class="token-explorer-link">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                    <polyline points="15 3 21 3 21 9"></polyline>
                    <line x1="10" y1="14" x2="21" y2="3"></line>
                  </svg>
                </a>
                <a href="#" onclick="event.preventDefault(); prepareMintProposal('shares'); switchDaoView('dao');" title="Create mint shares proposal" class="token-mint-link">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                  </svg>
                </a>
              </div>
              <div class="balance-value" id="membershipShares">0</div>
            </div>
            <div class="balance-item">
              <div class="balance-label">
                Loot
                <a id="lootEtherscanLink" href="#" target="_blank" rel="noopener noreferrer" class="token-explorer-link">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                    <polyline points="15 3 21 3 21 9"></polyline>
                    <line x1="10" y1="14" x2="21" y2="3"></line>
                  </svg>
                </a>
                <a href="#" onclick="event.preventDefault(); prepareMintProposal('loot'); switchDaoView('dao');" title="Create mint loot proposal" class="token-mint-link">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                  </svg>
                </a>
              </div>
              <div class="balance-value" id="membershipLoot">0</div>
            </div>
            <div class="balance-item">
              <div class="balance-label">
                Badge Seat
                <a id="badgeEtherscanLink" href="#" target="_blank" rel="noopener noreferrer" class="token-explorer-link">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                    <polyline points="15 3 21 3 21 9"></polyline>
                    <line x1="10" y1="14" x2="21" y2="3"></line>
                  </svg>
                </a>
              </div>
              <div class="balance-value" id="membershipBadge">None</div>
            </div>
          </div>

          <!-- Delegation Card -->
          <div class="delegation-card">
            <h3 class="dao-panel-title">Vote Delegation</h3>

            <!-- Voting Power Summary -->
            <div class="voting-power-summary">
              <div class="voting-power-item">
                <div class="voting-power-label">Your Shares</div>
                <div class="voting-power-value" id="ownedSharesDisplay">0</div>
                <div class="voting-power-breakdown">Direct ownership</div>
              </div>
              <div class="voting-power-item">
                <div class="voting-power-label">Total Voting Power</div>
                <div class="voting-power-value" id="totalVotesDisplay">0</div>
                <div class="voting-power-breakdown" id="votingPowerBreakdown">Shares + delegations</div>
              </div>
            </div>

            <div class="delegation-status" id="delegationStatus">
              <div class="delegation-status-label">Your Outgoing Delegation</div>
              <div class="delegation-status-value" id="currentDelegationDisplay">Loading...</div>
            </div>

            <!-- Received Delegations Section -->
            <div id="receivedDelegationsContainer" class="received-delegations-container">
              <div class="received-delegations">
                <div class="received-delegations-title">
                  â¬‡ï¸ Delegations Received
                </div>
                <div class="received-delegations-list" id="receivedDelegationsList">
                  <!-- Dynamically populated -->
                </div>
              </div>
            </div>

            <div id="delegationForm" class="delegation-form">
              <div class="delegation-type-selector">
                <label class="delegation-type-option selected" data-type="single">
                  <input type="radio" name="delegationType" value="single" checked>
                  <div class="delegation-type-icon">ðŸ‘¤</div>
                  <div class="delegation-type-title">Single Delegate</div>
                  <div class="delegation-type-description">Delegate all voting power to one address</div>
                </label>
                <label class="delegation-type-option" data-type="split">
                  <input type="radio" name="delegationType" value="split">
                  <div class="delegation-type-icon">ðŸ”€</div>
                  <div class="delegation-type-title">Split Delegation</div>
                  <div class="delegation-type-description">Distribute votes across up to 4 delegates</div>
                </label>
              </div>

              <div id="singleDelegateSection">
                <div class="delegate-input-group">
                  <label class="delegate-input-label">Delegate Address or ENS</label>
                  <input
                    type="text"
                    id="singleDelegateAddress"
                    class="modal-input"
                    placeholder="0x... or vitalik.eth (leave empty for self)"
                  />
                </div>
              </div>

              <div id="splitDelegateSection" class="delegation-section-hidden">
                <div id="delegateInputs"></div>
                <button class="add-delegate-btn" onclick="addDelegateInput()" id="addDelegateBtn">+ Add Delegate</button>
                <div id="delegationTotalDisplay" class="delegation-total">
                  <div class="delegation-total-row">
                    <span class="delegation-total-label">Total Delegated:</span>
                    <span id="totalDelegatedPercent" class="delegation-total-value">0.00%</span>
                  </div>
                  <div id="selfDelegationInfo" class="delegation-total-row delegation-self-row">
                    <span class="delegation-self-label">Remaining (self):</span>
                    <span id="selfDelegatedPercent" class="delegation-self-value">100.00%</span>
                  </div>
                  <div id="delegationWarning" class="delegation-warning">
                    âš ï¸ Total exceeds 100%
                  </div>
                  <div class="delegation-hint">
                    If total is less than 100%, the remaining % will be self-delegated
                  </div>
                </div>
              </div>

              <div class="delegation-actions">
                <button class="delegation-button" onclick="submitDelegation()">Set Delegation</button>
                <button class="delegation-button" onclick="clearDelegation()">Clear & Self-Delegate</button>
                <button class="delegation-button" onclick="toggleDelegationForm()">Cancel</button>
              </div>
            </div>

            <div id="delegationActions" class="delegation-manage">
              <button class="delegation-button delegation-manage-btn" onclick="toggleDelegationForm()">
                Manage Delegation
              </button>
            </div>
          </div>
        </div>

        <!-- Vote Receipts Panel -->
        <div class="receipts-panel">
          <h3 class="dao-panel-title">Vote Receipts Collection</h3>
          <div id="receiptsGrid" class="receipts-grid">
            <!-- Receipt cards will be dynamically rendered here -->
          </div>
        </div>
      </div>

      <!-- Members List Content -->
      <div class="dao-members-content" id="daoMembersView">
        <div class="members-panel">
          <div class="members-header">
            <h3 class="dao-panel-title">DAO Members</h3>
            <div class="members-stats">
              <div class="members-stat">
                <span class="members-stat-label">Total Members:</span>
                <span class="members-stat-value" id="memberCount">0</span>
              </div>
              <div class="members-stat">
                <span class="members-stat-label">Badge Holders:</span>
                <span class="members-stat-value" id="badgeHolderCount">0</span>
              </div>
            </div>
          </div>
          <div class="members-list" id="membersList">
            <!-- Members will be dynamically rendered here -->
          </div>
        </div>
      </div>
    </section>

    <!-- Modal for NFT viewing -->
    <div id="nftModal" class="nft-modal" onclick="closeNFTModal()">
      <div class="nft-modal-content" onclick="event.stopPropagation()">
        <button class="nft-modal-close" onclick="closeNFTModal()">&times;</button>
        <div id="nftModalBody" class="nft-modal-body">
          <!-- NFT content will be dynamically rendered here -->
        </div>
      </div>
    </div>


<!-- Footer web ring -->
<footer class="site-footer">
  <a href="../">Swap</a> &middot; <a href="../domains/">Domains</a> &middot; <a href="../coin/">Coin</a> &middot; <a href="../predict/">Predict</a> &middot; <a href="../orderbook/">Orderbook</a> &middot; <a href="../lp/">LP</a> &middot; built by <a href="https://opensea.io/collection/zorgz" target="_blank" rel="noopener"><svg width="14" height="14" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin:0 2px;image-rendering:pixelated"><rect width="16" height="16" fill="#0a0a0a"/><rect x="3" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="5" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="10" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="12" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="4" y="4" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="5" width="10" height="1" fill="#e8e8e0"/><rect x="2" y="6" width="12" height="3" fill="#e8e8e0"/><rect x="3" y="9" width="10" height="1" fill="#e8e8e0"/><rect x="4" y="10" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="10" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="5" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="9" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="2" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="7" y="12" width="2" height="1" fill="#e8e8e0"/><rect x="11" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="1" y="13" width="2" height="1" fill="#e8e8e0"/><rect x="13" y="13" width="2" height="1" fill="#e8e8e0"/></svg></a><a href="#/dao/1/0x5E58BA0e06ED0F5558f83bE732a4b899a674053E">zOrg</a> &middot;
  <a href="https://x.com/z_fi_" target="_blank" rel="noopener" title="X"><svg width="14" height="14" viewBox="0 0 300 300.251" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;fill:currentColor"><path d="M178.57 127.15 290.27 0h-26.46l-97.03 110.38L89.34 0H0l117.13 166.93L0 300.25h26.46l102.4-116.59 81.8 116.59h89.34M36.01 19.54H76.66l187.13 262.13h-40.66"/></svg></a>
  <div style="margin-top:8px;letter-spacing:1px"><a href="https://github.com/z-fi/zFi" target="_blank" rel="noopener" style="text-decoration:none;color:inherit">zfi.wei</a></div>
  <div class="tagline" style="margin-top:4px;font-size:12px;letter-spacing:0.5px;font-style:italic">the most secure-by-default exchange that does everything onchain</div>
</footer>

    <script src="../ethers.min.js"></script>
    <script src="../walletconnect.min.js"></script>
    <!-- Web3 Integration Script -->
    <script>
      function isDark() { return document.documentElement.classList.contains('dark'); }
      function cssVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
      function toggleDark() {
        document.documentElement.classList.toggle('dark');
        localStorage.setItem('dark', document.documentElement.classList.contains('dark') ? '1' : '0');
        if (heroFire && heroFire.updateTheme) heroFire.updateTheme();
      }

      // DOM element cache (initialized on page load)
      const DOMCache = {
        get(id) {
          return this[id] || document.getElementById(id);
        },
        init() {
          this.daoGallery = document.getElementById('daoGallery');
          this.daoTiles = document.getElementById('daoTiles');
          this.allDaosGallery = document.getElementById('allDaosGallery');
          this.allDaosTiles = document.getElementById('allDaosTiles');
          this.daoDashboard = document.getElementById('daoDashboard');
          this.dashboardTitle = document.getElementById('dashboardTitle');
          this.daoEmblem = document.getElementById('daoEmblem');
          this.daoEtherscanLink = document.getElementById('daoEtherscanLink');
          this.daoAddressText = document.getElementById('daoAddressText');
          this.proposalsList = document.getElementById('proposalsList');
          this.chatroomMessages = document.getElementById('chatroomMessages');
          this.walletModal = document.getElementById('walletModal');
          this.nftModal = document.getElementById('nftModal');
          this.purchaseModal = document.getElementById('purchaseModal');
          this.ragequitModal = document.getElementById('ragequitModal');
          this.proposalDescription = document.getElementById('proposalDescription');
          this.proposalFields = document.getElementById('proposalFields');
        }
      };

      // Optimized DOM access - uses cache when available
      const getEl = (id) => DOMCache.get(id);

      // HTML escape function to prevent XSS attacks
      function fmtBal(v) { const n = parseFloat(v); return n === 0 ? '0' : n < 0.01 ? '<0.01' : n.toLocaleString(undefined, {maximumFractionDigits: 2}); }

      function escapeHtml(unsafe) {
        if (!unsafe) return '';
        return String(unsafe)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      }

      // Sanitize URLs to prevent XSS via data: URIs and javascript: protocols
      function sanitizeUrl(url) {
        if (!url || typeof url !== 'string') return '';
        const trimmed = url.trim();

        // Block dangerous protocols
        const dangerous = /^(javascript|data|vbscript|file|about):/i;
        if (dangerous.test(trimmed)) {
          return '';
        }

        // Only allow http:, https:, ipfs:, and relative URLs
        if (!/^(https?:|ipfs:|\/|\.\/|\.\.\/)/i.test(trimmed) && trimmed.length > 0) {
          return '';
        }

        return trimmed;
      }

      // Production-safe logger - set DEBUG to false for production
      const DEBUG = false;
      const logger = {
        log: (...args) => { if (DEBUG) console.log(...args); },
        warn: (...args) => { if (DEBUG) console.warn(...args); },
        error: (...args) => { if (DEBUG) console.error(...args); }
      };

      // Convert IPFS URLs to gateway URLs (browsers don't support ipfs:// natively)
      function toGatewayUrl(url) {
        if (!url || typeof url !== 'string') return url;

        // Check if URL contains any IPFS reference
        if (!url.includes('ipfs://') && !url.includes('ipfs/') && !url.includes('ipns/')) {
          return url;
        }

        // Check for IPNS first (ipfs://ipns/NAME or ipns/NAME)
        // IPNS names can be long (k51... keys) or domain names
        const ipnsMatch = url.match(/ipns\/([a-zA-Z0-9._-]+)/);
        if (ipnsMatch) {
          return 'https://ipfs.io/ipns/' + ipnsMatch[1];
        }

        // Extract IPFS CID - look for common CID formats
        // CIDv0: Qm followed by 44 base58 chars
        // CIDv1: bafy/bafk followed by base32 chars
        const cidMatch = url.match(/(Qm[1-9A-HJ-NP-Za-km-z]{44}|baf[yk][a-zA-Z2-7]{50,})/);
        if (cidMatch) {
          return 'https://ipfs.io/ipfs/' + cidMatch[1];
        }

        // Fallback: strip all ipfs:// prefixes and path segments, use whatever remains
        let path = url;
        // Remove any http(s) prefix first
        path = path.replace(/^https?:\/\/[^\/]+\//, '');
        // Remove all ipfs:// occurrences
        while (path.includes('ipfs://')) {
          path = path.replace('ipfs://', '');
        }
        // Remove ipfs/ path segments
        while (path.includes('ipfs/')) {
          path = path.replace('ipfs/', '');
        }
        // Clean up leading slashes
        path = path.replace(/^\/+/, '');

        if (path && path.length > 0) {
          return 'https://ipfs.io/ipfs/' + path;
        }

        return url;
      }

      // Build contractURI metadata JSON (ERC-7572 compatible)
      // Returns data URI with JSON for on-chain storage, or empty string if no description/image
      // Note: If empty, the on-chain renderer displays default DUNA charter
      function buildContractURI(name, symbol, description, imageUrl) {
        const hasDescription = description && description.trim();
        const hasImage = imageUrl && imageUrl.trim();

        // If neither description nor image, return empty to trigger renderer's DUNA default
        if (!hasDescription && !hasImage) {
          return '';
        }

        const metadata = {
          name: name || '',
          symbol: symbol || ''
        };

        // Add description if provided
        if (hasDescription) {
          metadata.description = description.trim();
        }

        // Add image if provided
        if (hasImage) {
          metadata.image = imageUrl.trim();
        }

        const json = JSON.stringify(metadata);
        return 'data:application/json;utf8,' + json;
      }

      // Auto-save form data to prevent loss
      function saveToLocalStorage() {
        const formData = {
          daoName: getEl('daoName')?.value || '',
          daoSymbol: getEl('daoSymbol')?.value || '',
          daoDescription: getEl('daoDescription')?.value || '',
          quorumBps: getEl('quorumBps')?.value || '50',
          timestamp: Date.now()
        };
        try {
          localStorage.setItem(CONSTANTS.STORAGE_KEY_SUMMON, JSON.stringify(formData));
        } catch (e) {
          if (e.name === 'QuotaExceededError') {
            logger.error('localStorage quota exceeded - draft not saved');
            // Silent failure acceptable for draft auto-save
          } else {
            logger.error('Failed to save draft:', e);
          }
        }
      }

      // Restore form data on page load
      document.addEventListener('DOMContentLoaded', () => {
        try {
          const saved = localStorage.getItem(CONSTANTS.STORAGE_KEY_SUMMON);
          if (saved) {
            const data = JSON.parse(saved);
            // Only restore if less than 24 hours old
            if (Date.now() - data.timestamp < CONSTANTS.DRAFT_RETENTION_MS) {
              if (getEl('daoName')) getEl('daoName').value = data.daoName || '';
              if (getEl('daoSymbol')) getEl('daoSymbol').value = data.daoSymbol || '';
              if (getEl('daoDescription')) getEl('daoDescription').value = data.daoDescription || '';
              if (getEl('quorumBps')) getEl('quorumBps').value = data.quorumBps || '50';
            }
          }
        } catch (e) {
          logger.warn('Could not restore form data');
        }
      });

      // Debounced form saving
      let saveTimeout;
      document.addEventListener('input', (e) => {
        if (e.target.closest('#summonForm')) {
          clearTimeout(saveTimeout);
          saveTimeout = setTimeout(saveToLocalStorage, 1000);
        }
      });

      // Enhanced error handling with user-friendly messages
      window.addEventListener('error', (e) => {
        logger.error('Application error:', e);
        // Could show a user-friendly error notification here
      });

      // Network status monitoring
      let isOnline = navigator.onLine;
      window.addEventListener('online', () => {
        isOnline = true;
      });
      window.addEventListener('offline', () => {
        isOnline = false;
        logger.warn('Network connection lost');
        alert('Network connection lost. Please check your internet connection.');
      });


      const SUMMONER_ADDRESS = '0x0000000000330B8df9E3bc5E553074DA58eE9138';
      const SUMMONER_ABI = [
        {
          "inputs": [
            {"internalType": "string", "name": "orgName", "type": "string"},
            {"internalType": "string", "name": "orgSymbol", "type": "string"},
            {"internalType": "string", "name": "orgURI", "type": "string"},
            {"internalType": "uint16", "name": "quorumBps", "type": "uint16"},
            {"internalType": "bool", "name": "ragequittable", "type": "bool"},
            {"internalType": "address", "name": "renderer", "type": "address"},
            {"internalType": "bytes32", "name": "salt", "type": "bytes32"},
            {"internalType": "address[]", "name": "initHolders", "type": "address[]"},
            {"internalType": "uint256[]", "name": "initShares", "type": "uint256[]"},
            {"components": [
              {"internalType": "address", "name": "target", "type": "address"},
              {"internalType": "uint256", "name": "value", "type": "uint256"},
              {"internalType": "bytes", "name": "data", "type": "bytes"}
            ], "internalType": "struct Call[]", "name": "initCalls", "type": "tuple[]"}
          ],
          "name": "summon",
          "outputs": [{"internalType": "contract Moloch", "name": "dao", "type": "address"}],
          "stateMutability": "payable",
          "type": "function"
        }
      ];

      const VIEW_HELPER_ADDRESS = '0x00000000006631040967E58e3430e4B77921a2db';
      const TRIBUTE_ADDRESS = '0x000000000066524fcf78Dc1E41E9D525d9ea73D0';

      const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';
      const MULTICALL3_ABI = [
        {
          "inputs": [{ "components": [
            { "name": "target", "type": "address" },
            { "name": "allowFailure", "type": "bool" },
            { "name": "callData", "type": "bytes" }
          ], "name": "calls", "type": "tuple[]" }],
          "name": "aggregate3",
          "outputs": [{ "components": [
            { "name": "success", "type": "bool" },
            { "name": "returnData", "type": "bytes" }
          ], "name": "returnData", "type": "tuple[]" }],
          "stateMutability": "view",
          "type": "function"
        }
      ];

      // ==================== NETWORK CONFIGURATION ====================
      const NETWORK = {
        chainId: 1n,
        chainIdHex: '0x1',
        name: 'Ethereum',
        rpcs: [
          'https://ethereum.publicnode.com',
          'https://1rpc.io/eth',
          'https://eth.drpc.org',
          'https://eth.llamarpc.com'
        ],
        explorer: 'https://etherscan.io',
        treasuryTokens: [
          ethers.ZeroAddress, // ETH
          '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC
          '0xdAC17F958D2ee523a2206206994597C13D831ec7', // USDT
          '0x6B175474E89094C44Da98b954EedeAC495271d0F', // DAI
          '0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0', // wstETH
          '0xae78736Cd615f374D3085123A210448E74Fc6393'  // rETH
        ],
        tokenMeta: {
          [ethers.ZeroAddress]: { symbol: 'ETH', decimals: 18 },
          '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48': { symbol: 'USDC', decimals: 6 },
          '0xdAC17F958D2ee523a2206206994597C13D831ec7': { symbol: 'USDT', decimals: 6 },
          '0x6B175474E89094C44Da98b954EedeAC495271d0F': { symbol: 'DAI', decimals: 18 },
          '0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0': { symbol: 'wstETH', decimals: 18 },
          '0xae78736Cd615f374D3085123A210448E74Fc6393': { symbol: 'rETH', decimals: 18 }
        }
      };

      function getNetwork() {
        return NETWORK;
      }

      function toggleSummoner() {
        const body = document.getElementById('summonerBody');
        const toggle = document.querySelector('.summoner-toggle');
        if (!body || !toggle) return;
        const open = body.style.display !== 'none';
        body.style.display = open ? 'none' : 'block';
        toggle.textContent = (open ? '\u25B6' : '\u25BC') + ' Summon New DAO';
        toggle.classList.toggle('open', !open);
      }

      function scrollToYourDAOs() {
        const daoGallery = document.getElementById('daoGallery');
        if (daoGallery) {
          daoGallery.classList.add('show');
          daoGallery.scrollIntoView({ behavior: 'smooth' });
        }
      }

      function scrollToAllDAOs() {
        const allDaosGallery = document.getElementById('allDaosGallery');
        if (!allDaosGallery) return;

        allDaosGallery.classList.add('show');
        allDaosGallery.scrollIntoView({ behavior: 'smooth' });

        // Focus the search input
        const searchInput = document.getElementById('daoSearchInput');
        if (searchInput) setTimeout(() => searchInput.focus(), 300);
      }

      async function searchDAO() {
        const input = document.getElementById('daoSearchInput');
        const tilesContainer = document.getElementById('allDaosTiles');
        if (!input || !tilesContainer) return;

        const query = input.value.trim();
        if (!query) return;

        if (ethers.isAddress(query)) {
          await searchDAOByAddress(query, tilesContainer);
        } else {
          await searchDAOByName(query, tilesContainer);
        }
      }

      async function searchDAOByAddress(query, tilesContainer) {
        const fireHandle = showFireLoading(tilesContainer);

        try {
          const treasuryTokens = getNetwork().treasuryTokens;
          const result = await withRpcFallback(async (activeProvider) => {
            const viewHelper = new ethers.Contract(VIEW_HELPER_ADDRESS, VIEW_HELPER_ABI, activeProvider);
            return await viewHelper.getDAOWithDAICO(
              query,
              0, 5, // proposals
              0, 200, // messages
              treasuryTokens,
              treasuryTokens // tribTokens
            );
          });

          fireHandle.stop();
          const dao = result.base;
          if (!dao || !dao.meta || !dao.meta.name) {
            tilesContainer.innerHTML = '<p class="badge-empty">No DAO found at this address</p>';
            return;
          }

          // Store as single-item allDAOs array for openDAO compatibility
          allDAOs = [dao];
          allDAOsLoaded = true;

          tilesContainer.innerHTML = '';
          const tile = document.createElement('div');
          tile.className = 'all-dao-tile dao-tile';
          tile.onclick = () => openDAO(0, 'all');
          tile.innerHTML = `
            <div class="dao-tile-emblem" id="emblem-search-0"></div>
            <div class="dao-tile-name">${escapeHtml(dao.meta.name)}</div>
            <div class="dao-tile-symbol">${escapeHtml(dao.meta.symbol)}</div>
            <div class="dao-tile-stats">
              <div class="dao-stat">
                <div class="dao-stat-label">Total Shares</div>
                <div class="dao-stat-value" title="${ethers.formatUnits(dao.supplies.sharesTotalSupply, 18)}">${fmtBal(ethers.formatUnits(dao.supplies.sharesTotalSupply, 18))}</div>
              </div>
              <div class="dao-stat">
                <div class="dao-stat-label">Total Loot</div>
                <div class="dao-stat-value" title="${ethers.formatUnits(dao.supplies.lootTotalSupply, 18)}">${fmtBal(ethers.formatUnits(dao.supplies.lootTotalSupply, 18))}</div>
              </div>
              <div class="dao-stat">
                <div class="dao-stat-label">Proposals</div>
                <div class="dao-stat-value">${dao.proposals.length}</div>
              </div>
              <div class="dao-stat">
                <div class="dao-stat-label">Members</div>
                <div class="dao-stat-value">${dao.members.length}</div>
              </div>
            </div>
          `;
          tilesContainer.appendChild(tile);
          renderTileEmblem(dao.dao, 'emblem-search-0');
          showStatus('', false);
        } catch (error) {
          fireHandle.stop();
          logger.error('Error searching DAO:', error);
          tilesContainer.innerHTML = '<p class="badge-empty">No DAO found at this address</p>';
          showStatus('', false);
        }
      }

      async function searchDAOByName(query, tilesContainer) {
        const fireHandle = showFireLoading(tilesContainer);

        try {
          if (!allDAOsCache) {
            allDAOsCache = await withRpcFallback(async (activeProvider) => {
              const viewHelper = new ethers.Contract(VIEW_HELPER_ADDRESS, VIEW_HELPER_ABI, activeProvider);
              return await viewHelper.getDAOsFullState(0, 500, 0, 0, 0, 0, []);
            });
          }

          fireHandle.stop();
          const lowerQuery = query.toLowerCase();
          const matches = allDAOsCache.filter(dao =>
            dao.meta.name.toLowerCase().includes(lowerQuery) ||
            dao.meta.symbol.toLowerCase().includes(lowerQuery)
          );

          if (matches.length === 0) {
            tilesContainer.innerHTML = `<p class="badge-empty">No DAOs found matching "${escapeHtml(query)}"</p>`;
            return;
          }

          // Store matches for openDAO compatibility
          allDAOs = matches;
          allDAOsLoaded = true;

          tilesContainer.innerHTML = '';
          matches.forEach((dao, index) => {
            const tile = document.createElement('div');
            tile.className = 'all-dao-tile dao-tile';
            tile.onclick = () => openDAO(index, 'all');
            tile.innerHTML = `
              <div class="dao-tile-emblem" id="emblem-search-${index}"></div>
              <div class="dao-tile-name">${escapeHtml(dao.meta.name)}</div>
              <div class="dao-tile-symbol">${escapeHtml(dao.meta.symbol)}</div>
              <div class="dao-tile-stats">
                <div class="dao-stat">
                  <div class="dao-stat-label">Total Shares</div>
                  <div class="dao-stat-value" title="${ethers.formatUnits(dao.supplies.sharesTotalSupply, 18)}">${fmtBal(ethers.formatUnits(dao.supplies.sharesTotalSupply, 18))}</div>
                </div>
                <div class="dao-stat">
                  <div class="dao-stat-label">Total Loot</div>
                  <div class="dao-stat-value" title="${ethers.formatUnits(dao.supplies.lootTotalSupply, 18)}">${fmtBal(ethers.formatUnits(dao.supplies.lootTotalSupply, 18))}</div>
                </div>
                <div class="dao-stat">
                  <div class="dao-stat-label">Members</div>
                  <div class="dao-stat-value">${dao.members.length}</div>
                </div>
              </div>
            `;
            tilesContainer.appendChild(tile);
            renderTileEmblem(dao.dao, `emblem-search-${index}`);
          });

          showStatus('', false);
        } catch (error) {
          fireHandle.stop();
          logger.error('Error searching DAOs by name:', error);
          tilesContainer.innerHTML = '<p class="badge-empty">Error searching DAOs. Please try again.</p>';
          showStatus('', false);
        }
      }

      // Get the block explorer URL
      function getExplorerUrl() {
        return getNetwork().explorer;
      }

      // Get the block explorer link for an address
      function getExplorerAddressUrl(address) {
        return `${getExplorerUrl()}/address/${address}`;
      }

      // Get the OpenSea URL for an NFT
      function getOpenSeaUrl(contractAddress, tokenId) {
        return `https://opensea.io/assets/ethereum/${contractAddress.toLowerCase()}/${tokenId}`;
      }

      // Convert treasury.balances array to a list of token objects with metadata
      // treasury: { balances: [{token: address, balance: uint256}, ...] }
      function parseTreasuryBalances(treasury) {
        const network = getNetwork();
        const tokenMeta = network.tokenMeta;
        const result = [];
        const seen = new Set();

        if (!treasury || !treasury.balances) return result;

        for (const tb of treasury.balances) {
          const tokenAddr = tb.token;
          const key = tokenAddr.toLowerCase();
          if (seen.has(key)) continue;
          seen.add(key);

          const meta = tokenMeta[tokenAddr] || tokenMeta[key] || { symbol: '???', decimals: 18 };

          result.push({
            address: tokenAddr,
            balance: tb.balance,
            symbol: meta.symbol,
            decimals: meta.decimals,
            icon: getTokenIcon(tokenAddr)
          });
        }

        return result;
      }

      let _tokenSymbolMap = null;

      function getTokenIcon(address) {
        const addr = address?.toLowerCase();
        if (!addr || addr === ethers.ZeroAddress.toLowerCase()) return TOKEN_ICONS.eth;

        if (!_tokenSymbolMap) {
          _tokenSymbolMap = {
            'eth': TOKEN_ICONS.eth,
            'usdc': TOKEN_ICONS.usdc,
            'usdt': TOKEN_ICONS.usdt,
            'dai': TOKEN_ICONS.dai,
            'wsteth': TOKEN_ICONS.wsteth,
            'reth': TOKEN_ICONS.reth
          };
        }
        const symbolMap = _tokenSymbolMap;

        const network = getNetwork();
        const meta = network.tokenMeta[address] || network.tokenMeta[addr];
        if (meta) {
          const iconKey = meta.symbol.toLowerCase();
          if (symbolMap[iconKey]) return symbolMap[iconKey];
        }

        return TOKEN_ICONS.defaultCoin || `<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><circle cx="16" cy="16" r="14" fill="none" stroke="#000" stroke-width="2"/><circle cx="16" cy="16" r="8" fill="none" stroke="#000" stroke-width="1.5" opacity="0.5"/></svg>`;
      }

      // Get all supported tokens including ETH for current network
      function getNetworkTokens() {
        const network = getNetwork();
        const result = [];

        for (const tokenAddr of network.treasuryTokens) {
          const meta = network.tokenMeta[tokenAddr];
          if (meta) {
            result.push({
              address: tokenAddr,
              symbol: meta.symbol,
              decimals: meta.decimals,
              icon: getTokenIcon(tokenAddr)
            });
          }
        }

        return result;
      }

      // Batch all dashboard view calls into a single Multicall3 RPC round-trip
      async function batchDashboardData(daoAddress, userAddress) {
        const molochIface = new ethers.Interface(MOLOCH_ABI);
        const tributeIface = new ethers.Interface(TRIBUTE_ABI);

        const tokens = getNetworkTokens();
        const allowanceTokens = userAddress ? [
          { symbol: 'ETH', address: ethers.ZeroAddress, decimals: 18, icon: TOKEN_ICONS.eth },
          { symbol: 'USDC', address: TOKEN_ADDRESSES.usdc, decimals: 6, icon: TOKEN_ICONS.usdc },
          { symbol: 'USDT', address: TOKEN_ADDRESSES.usdt, decimals: 6, icon: TOKEN_ICONS.usdt },
          { symbol: 'DAI', address: TOKEN_ADDRESSES.dai, decimals: 18, icon: TOKEN_ICONS.dai },
          { symbol: 'wstETH', address: TOKEN_ADDRESSES.wsteth, decimals: 18, icon: TOKEN_ICONS.wsteth },
          { symbol: 'rETH', address: TOKEN_ADDRESSES.reth, decimals: 18, icon: TOKEN_ICONS.reth },
          { symbol: 'Shares', address: currentDAO.dao.meta.sharesToken, decimals: 18, icon: TOKEN_ICONS.defaultCoin },
          { symbol: 'Loot', address: currentDAO.dao.meta.lootToken, decimals: 18, icon: TOKEN_ICONS.defaultCoin }
        ] : [];

        // Build call list
        const calls = [];
        const callMap = []; // tracks what each call index means

        // 1. config()
        calls.push({ target: daoAddress, allowFailure: true, callData: molochIface.encodeFunctionData('config') });
        callMap.push({ type: 'config' });

        // 2. sales(token) for each network token
        for (const token of tokens) {
          calls.push({ target: daoAddress, allowFailure: true, callData: molochIface.encodeFunctionData('sales', [token.address]) });
          callMap.push({ type: 'sales', token });
        }

        // 3. allowance(token, user) for each token (only if user connected)
        for (const token of allowanceTokens) {
          calls.push({ target: daoAddress, allowFailure: true, callData: molochIface.encodeFunctionData('allowance', [token.address, userAddress]) });
          callMap.push({ type: 'allowance', token });
        }

        // 4. getActiveDaoTributes(dao)
        calls.push({ target: TRIBUTE_ADDRESS, allowFailure: true, callData: tributeIface.encodeFunctionData('getActiveDaoTributes', [daoAddress]) });
        callMap.push({ type: 'tributes' });

        // 5. transfersLocked() on shares and loot tokens
        const transfersLockedIface = new ethers.Interface(['function transfersLocked() view returns (bool)']);
        const transfersLockedCalldata = transfersLockedIface.encodeFunctionData('transfersLocked');
        calls.push({ target: currentDAO.dao.meta.sharesToken, allowFailure: true, callData: transfersLockedCalldata });
        callMap.push({ type: 'sharesTransfersLocked' });
        calls.push({ target: currentDAO.dao.meta.lootToken, allowFailure: true, callData: transfersLockedCalldata });
        callMap.push({ type: 'lootTransfersLocked' });

        // 6. contractURI()
        calls.push({ target: daoAddress, allowFailure: true, callData: molochIface.encodeFunctionData('contractURI') });
        callMap.push({ type: 'contractURI' });

        // Execute single multicall
        const results = await withRpcFallback(async (activeProvider) => {
          const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, activeProvider);
          return await multicall.aggregate3(calls);
        });

        // Decode results
        const batch = { config: undefined, sales: [], allowances: [], tributes: undefined, sharesTransfersLocked: undefined, lootTransfersLocked: undefined, contractURI: undefined };

        for (let i = 0; i < results.length; i++) {
          const { success, returnData } = results[i];
          const entry = callMap[i];

          if (!success) {
            logger.warn(`Multicall: ${entry.type} call failed`);
            continue;
          }

          try {
            if (entry.type === 'config') {
              const decoded = molochIface.decodeFunctionResult('config', returnData);
              batch.config = decoded[0];
            } else if (entry.type === 'sales') {
              const decoded = molochIface.decodeFunctionResult('sales', returnData);
              batch.sales.push({
                token: entry.token,
                sale: { pricePerShare: decoded[0], cap: decoded[1], minting: decoded[2], active: decoded[3], isLoot: decoded[4] }
              });
            } else if (entry.type === 'allowance') {
              const decoded = molochIface.decodeFunctionResult('allowance', returnData);
              batch.allowances.push({ token: entry.token, allowance: decoded[0] });
            } else if (entry.type === 'tributes') {
              const decoded = tributeIface.decodeFunctionResult('getActiveDaoTributes', returnData);
              batch.tributes = decoded[0];
            } else if (entry.type === 'sharesTransfersLocked') {
              const decoded = transfersLockedIface.decodeFunctionResult('transfersLocked', returnData);
              batch.sharesTransfersLocked = decoded[0];
            } else if (entry.type === 'lootTransfersLocked') {
              const decoded = transfersLockedIface.decodeFunctionResult('transfersLocked', returnData);
              batch.lootTransfersLocked = decoded[0];
            } else if (entry.type === 'contractURI') {
              const decoded = molochIface.decodeFunctionResult('contractURI', returnData);
              batch.contractURI = decoded[0];
            }
          } catch (e) {
            logger.warn(`Multicall: failed to decode ${entry.type}:`, e.message);
          }
        }

        return batch;
      }

      // Get token address by symbol for current network
      function getTokenAddressBySymbol(symbol) {
        const network = getNetwork();
        const symbolLower = symbol.toLowerCase();

        for (const [addr, meta] of Object.entries(network.tokenMeta)) {
          if (meta.symbol.toLowerCase() === symbolLower) {
            return addr;
          }
        }
        return null;
      }

      // Get token metadata by address for current network
      function getTokenMetaByAddress(address) {
        const network = getNetwork();
        return network.tokenMeta[address] || network.tokenMeta[address.toLowerCase()] || null;
      }

      const VIEW_HELPER_ABI = [
        {
          "inputs": [
            {"internalType": "address", "name": "user", "type": "address"},
            {"internalType": "uint256", "name": "daoStart", "type": "uint256"},
            {"internalType": "uint256", "name": "daoCount", "type": "uint256"},
            {"internalType": "uint256", "name": "proposalStart", "type": "uint256"},
            {"internalType": "uint256", "name": "proposalCount", "type": "uint256"},
            {"internalType": "uint256", "name": "messageStart", "type": "uint256"},
            {"internalType": "uint256", "name": "messageCount", "type": "uint256"},
            {"internalType": "address[]", "name": "treasuryTokens", "type": "address[]"}
          ],
          "name": "getUserDAOsFullState",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {"internalType": "address", "name": "dao", "type": "address"},
                    {
                      "components": [
                        {"internalType": "string", "name": "name", "type": "string"},
                        {"internalType": "string", "name": "symbol", "type": "string"},
                        {"internalType": "string", "name": "contractURI", "type": "string"},
                        {"internalType": "address", "name": "sharesToken", "type": "address"},
                        {"internalType": "address", "name": "lootToken", "type": "address"},
                        {"internalType": "address", "name": "badgesToken", "type": "address"},
                        {"internalType": "address", "name": "renderer", "type": "address"}
                      ],
                      "internalType": "struct DAOMeta",
                      "name": "meta",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {"internalType": "uint96", "name": "proposalThreshold", "type": "uint96"},
                        {"internalType": "uint96", "name": "minYesVotesAbsolute", "type": "uint96"},
                        {"internalType": "uint96", "name": "quorumAbsolute", "type": "uint96"},
                        {"internalType": "uint64", "name": "proposalTTL", "type": "uint64"},
                        {"internalType": "uint64", "name": "timelockDelay", "type": "uint64"},
                        {"internalType": "uint16", "name": "quorumBps", "type": "uint16"},
                        {"internalType": "bool", "name": "ragequittable", "type": "bool"},
                        {"internalType": "uint256", "name": "autoFutarchyParam", "type": "uint256"},
                        {"internalType": "uint256", "name": "autoFutarchyCap", "type": "uint256"},
                        {"internalType": "address", "name": "rewardToken", "type": "address"}
                      ],
                      "internalType": "struct DAOGovConfig",
                      "name": "gov",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {"internalType": "uint256", "name": "sharesTotalSupply", "type": "uint256"},
                        {"internalType": "uint256", "name": "lootTotalSupply", "type": "uint256"},
                        {"internalType": "uint256", "name": "sharesHeldByDAO", "type": "uint256"},
                        {"internalType": "uint256", "name": "lootHeldByDAO", "type": "uint256"}
                      ],
                      "internalType": "struct DAOTokenSupplies",
                      "name": "supplies",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "components": [
                            {"internalType": "address", "name": "token", "type": "address"},
                            {"internalType": "uint256", "name": "balance", "type": "uint256"}
                          ],
                          "internalType": "struct TokenBalance[]",
                          "name": "balances",
                          "type": "tuple[]"
                        }
                      ],
                      "internalType": "struct DAOTreasury",
                      "name": "treasury",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {"internalType": "address", "name": "account", "type": "address"},
                        {"internalType": "uint256", "name": "shares", "type": "uint256"},
                        {"internalType": "uint256", "name": "loot", "type": "uint256"},
                        {"internalType": "uint16", "name": "seatId", "type": "uint16"},
                        {"internalType": "uint256", "name": "votingPower", "type": "uint256"},
                        {"internalType": "address[]", "name": "delegates", "type": "address[]"},
                        {"internalType": "uint32[]", "name": "delegatesBps", "type": "uint32[]"}
                      ],
                      "internalType": "struct MemberView[]",
                      "name": "members",
                      "type": "tuple[]"
                    },
                    {
                      "components": [
                        {"internalType": "uint256", "name": "id", "type": "uint256"},
                        {"internalType": "address", "name": "proposer", "type": "address"},
                        {"internalType": "uint8", "name": "state", "type": "uint8"},
                        {"internalType": "uint48", "name": "snapshotBlock", "type": "uint48"},
                        {"internalType": "uint64", "name": "createdAt", "type": "uint64"},
                        {"internalType": "uint64", "name": "queuedAt", "type": "uint64"},
                        {"internalType": "uint256", "name": "supplySnapshot", "type": "uint256"},
                        {"internalType": "uint96", "name": "forVotes", "type": "uint96"},
                        {"internalType": "uint96", "name": "againstVotes", "type": "uint96"},
                        {"internalType": "uint96", "name": "abstainVotes", "type": "uint96"},
                        {
                          "components": [
                            {"internalType": "bool", "name": "enabled", "type": "bool"},
                            {"internalType": "address", "name": "rewardToken", "type": "address"},
                            {"internalType": "uint256", "name": "pool", "type": "uint256"},
                            {"internalType": "bool", "name": "resolved", "type": "bool"},
                            {"internalType": "uint8", "name": "winner", "type": "uint8"},
                            {"internalType": "uint256", "name": "finalWinningSupply", "type": "uint256"},
                            {"internalType": "uint256", "name": "payoutPerUnit", "type": "uint256"}
                          ],
                          "internalType": "struct FutarchyView",
                          "name": "futarchy",
                          "type": "tuple"
                        },
                        {
                          "components": [
                            {"internalType": "address", "name": "voter", "type": "address"},
                            {"internalType": "uint8", "name": "support", "type": "uint8"},
                            {"internalType": "uint256", "name": "weight", "type": "uint256"}
                          ],
                          "internalType": "struct VoterView[]",
                          "name": "voters",
                          "type": "tuple[]"
                        }
                      ],
                      "internalType": "struct ProposalView[]",
                      "name": "proposals",
                      "type": "tuple[]"
                    },
                    {
                      "components": [
                        {"internalType": "uint256", "name": "index", "type": "uint256"},
                        {"internalType": "string", "name": "text", "type": "string"}
                      ],
                      "internalType": "struct MessageView[]",
                      "name": "messages",
                      "type": "tuple[]"
                    }
                  ],
                  "internalType": "struct DAOLens",
                  "name": "dao",
                  "type": "tuple"
                },
                {
                  "components": [
                    {"internalType": "address", "name": "account", "type": "address"},
                    {"internalType": "uint256", "name": "shares", "type": "uint256"},
                    {"internalType": "uint256", "name": "loot", "type": "uint256"},
                    {"internalType": "uint16", "name": "seatId", "type": "uint16"},
                    {"internalType": "uint256", "name": "votingPower", "type": "uint256"},
                    {"internalType": "address[]", "name": "delegates", "type": "address[]"},
                    {"internalType": "uint32[]", "name": "delegatesBps", "type": "uint32[]"}
                  ],
                  "internalType": "struct MemberView",
                  "name": "member",
                  "type": "tuple"
                }
              ],
              "internalType": "struct UserDAOLens[]",
              "name": "out",
              "type": "tuple[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "uint256", "name": "daoStart", "type": "uint256"},
            {"internalType": "uint256", "name": "daoCount", "type": "uint256"},
            {"internalType": "uint256", "name": "proposalStart", "type": "uint256"},
            {"internalType": "uint256", "name": "proposalCount", "type": "uint256"},
            {"internalType": "uint256", "name": "messageStart", "type": "uint256"},
            {"internalType": "uint256", "name": "messageCount", "type": "uint256"},
            {"internalType": "address[]", "name": "treasuryTokens", "type": "address[]"}
          ],
          "name": "getDAOsFullState",
          "outputs": [
            {
              "components": [
                {"internalType": "address", "name": "dao", "type": "address"},
                {
                  "components": [
                    {"internalType": "string", "name": "name", "type": "string"},
                    {"internalType": "string", "name": "symbol", "type": "string"},
                    {"internalType": "string", "name": "contractURI", "type": "string"},
                    {"internalType": "address", "name": "sharesToken", "type": "address"},
                    {"internalType": "address", "name": "lootToken", "type": "address"},
                    {"internalType": "address", "name": "badgesToken", "type": "address"},
                    {"internalType": "address", "name": "renderer", "type": "address"}
                  ],
                  "internalType": "struct DAOMeta",
                  "name": "meta",
                  "type": "tuple"
                },
                {
                  "components": [
                    {"internalType": "uint96", "name": "proposalThreshold", "type": "uint96"},
                    {"internalType": "uint96", "name": "minYesVotesAbsolute", "type": "uint96"},
                    {"internalType": "uint96", "name": "quorumAbsolute", "type": "uint96"},
                    {"internalType": "uint64", "name": "proposalTTL", "type": "uint64"},
                    {"internalType": "uint64", "name": "timelockDelay", "type": "uint64"},
                    {"internalType": "uint16", "name": "quorumBps", "type": "uint16"},
                    {"internalType": "bool", "name": "ragequittable", "type": "bool"},
                    {"internalType": "uint256", "name": "autoFutarchyParam", "type": "uint256"},
                    {"internalType": "uint256", "name": "autoFutarchyCap", "type": "uint256"},
                    {"internalType": "address", "name": "rewardToken", "type": "address"}
                  ],
                  "internalType": "struct DAOGovConfig",
                  "name": "gov",
                  "type": "tuple"
                },
                {
                  "components": [
                    {"internalType": "uint256", "name": "sharesTotalSupply", "type": "uint256"},
                    {"internalType": "uint256", "name": "lootTotalSupply", "type": "uint256"},
                    {"internalType": "uint256", "name": "sharesHeldByDAO", "type": "uint256"},
                    {"internalType": "uint256", "name": "lootHeldByDAO", "type": "uint256"}
                  ],
                  "internalType": "struct DAOTokenSupplies",
                  "name": "supplies",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "components": [
                        {"internalType": "address", "name": "token", "type": "address"},
                        {"internalType": "uint256", "name": "balance", "type": "uint256"}
                      ],
                      "internalType": "struct TokenBalance[]",
                      "name": "balances",
                      "type": "tuple[]"
                    }
                  ],
                  "internalType": "struct DAOTreasury",
                  "name": "treasury",
                  "type": "tuple"
                },
                {
                  "components": [
                    {"internalType": "address", "name": "account", "type": "address"},
                    {"internalType": "uint256", "name": "shares", "type": "uint256"},
                    {"internalType": "uint256", "name": "loot", "type": "uint256"},
                    {"internalType": "uint16", "name": "seatId", "type": "uint16"},
                    {"internalType": "uint256", "name": "votingPower", "type": "uint256"},
                    {"internalType": "address[]", "name": "delegates", "type": "address[]"},
                    {"internalType": "uint32[]", "name": "delegatesBps", "type": "uint32[]"}
                  ],
                  "internalType": "struct MemberView[]",
                  "name": "members",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {"internalType": "uint256", "name": "id", "type": "uint256"},
                    {"internalType": "address", "name": "proposer", "type": "address"},
                    {"internalType": "uint8", "name": "state", "type": "uint8"},
                    {"internalType": "uint48", "name": "snapshotBlock", "type": "uint48"},
                    {"internalType": "uint64", "name": "createdAt", "type": "uint64"},
                    {"internalType": "uint64", "name": "queuedAt", "type": "uint64"},
                    {"internalType": "uint256", "name": "supplySnapshot", "type": "uint256"},
                    {"internalType": "uint96", "name": "forVotes", "type": "uint96"},
                    {"internalType": "uint96", "name": "againstVotes", "type": "uint96"},
                    {"internalType": "uint96", "name": "abstainVotes", "type": "uint96"},
                    {
                      "components": [
                        {"internalType": "bool", "name": "enabled", "type": "bool"},
                        {"internalType": "address", "name": "rewardToken", "type": "address"},
                        {"internalType": "uint256", "name": "pool", "type": "uint256"},
                        {"internalType": "bool", "name": "resolved", "type": "bool"},
                        {"internalType": "uint8", "name": "winner", "type": "uint8"},
                        {"internalType": "uint256", "name": "finalWinningSupply", "type": "uint256"},
                        {"internalType": "uint256", "name": "payoutPerUnit", "type": "uint256"}
                      ],
                      "internalType": "struct FutarchyView",
                      "name": "futarchy",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {"internalType": "address", "name": "voter", "type": "address"},
                        {"internalType": "uint8", "name": "support", "type": "uint8"},
                        {"internalType": "uint256", "name": "weight", "type": "uint256"}
                      ],
                      "internalType": "struct VoterView[]",
                      "name": "voters",
                      "type": "tuple[]"
                    }
                  ],
                  "internalType": "struct ProposalView[]",
                  "name": "proposals",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {"internalType": "uint256", "name": "index", "type": "uint256"},
                    {"internalType": "string", "name": "text", "type": "string"}
                  ],
                  "internalType": "struct MessageView[]",
                  "name": "messages",
                  "type": "tuple[]"
                }
              ],
              "internalType": "struct DAOLens[]",
              "name": "out",
              "type": "tuple[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "address", "name": "dao", "type": "address"},
            {"internalType": "uint256", "name": "proposalStart", "type": "uint256"},
            {"internalType": "uint256", "name": "proposalCount", "type": "uint256"},
            {"internalType": "uint256", "name": "messageStart", "type": "uint256"},
            {"internalType": "uint256", "name": "messageCount", "type": "uint256"},
            {"internalType": "address[]", "name": "treasuryTokens", "type": "address[]"},
            {"internalType": "address[]", "name": "tribTokens", "type": "address[]"}
          ],
          "name": "getDAOWithDAICO",
          "outputs": [
            {
              "components": [
                {
                  "components": [
                    {"internalType": "address", "name": "dao", "type": "address"},
                    {
                      "components": [
                        {"internalType": "string", "name": "name", "type": "string"},
                        {"internalType": "string", "name": "symbol", "type": "string"},
                        {"internalType": "string", "name": "contractURI", "type": "string"},
                        {"internalType": "address", "name": "sharesToken", "type": "address"},
                        {"internalType": "address", "name": "lootToken", "type": "address"},
                        {"internalType": "address", "name": "badgesToken", "type": "address"},
                        {"internalType": "address", "name": "renderer", "type": "address"}
                      ],
                      "internalType": "struct DAOMeta",
                      "name": "meta",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {"internalType": "uint96", "name": "proposalThreshold", "type": "uint96"},
                        {"internalType": "uint96", "name": "minYesVotesAbsolute", "type": "uint96"},
                        {"internalType": "uint96", "name": "quorumAbsolute", "type": "uint96"},
                        {"internalType": "uint64", "name": "proposalTTL", "type": "uint64"},
                        {"internalType": "uint64", "name": "timelockDelay", "type": "uint64"},
                        {"internalType": "uint16", "name": "quorumBps", "type": "uint16"},
                        {"internalType": "bool", "name": "ragequittable", "type": "bool"},
                        {"internalType": "uint256", "name": "autoFutarchyParam", "type": "uint256"},
                        {"internalType": "uint256", "name": "autoFutarchyCap", "type": "uint256"},
                        {"internalType": "address", "name": "rewardToken", "type": "address"}
                      ],
                      "internalType": "struct DAOGovConfig",
                      "name": "gov",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {"internalType": "uint256", "name": "sharesTotalSupply", "type": "uint256"},
                        {"internalType": "uint256", "name": "lootTotalSupply", "type": "uint256"},
                        {"internalType": "uint256", "name": "sharesHeldByDAO", "type": "uint256"},
                        {"internalType": "uint256", "name": "lootHeldByDAO", "type": "uint256"}
                      ],
                      "internalType": "struct DAOTokenSupplies",
                      "name": "supplies",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {
                          "components": [
                            {"internalType": "address", "name": "token", "type": "address"},
                            {"internalType": "uint256", "name": "balance", "type": "uint256"}
                          ],
                          "internalType": "struct TokenBalance[]",
                          "name": "balances",
                          "type": "tuple[]"
                        }
                      ],
                      "internalType": "struct DAOTreasury",
                      "name": "treasury",
                      "type": "tuple"
                    },
                    {
                      "components": [
                        {"internalType": "address", "name": "account", "type": "address"},
                        {"internalType": "uint256", "name": "shares", "type": "uint256"},
                        {"internalType": "uint256", "name": "loot", "type": "uint256"},
                        {"internalType": "uint16", "name": "seatId", "type": "uint16"},
                        {"internalType": "uint256", "name": "votingPower", "type": "uint256"},
                        {"internalType": "address[]", "name": "delegates", "type": "address[]"},
                        {"internalType": "uint32[]", "name": "delegatesBps", "type": "uint32[]"}
                      ],
                      "internalType": "struct MemberView[]",
                      "name": "members",
                      "type": "tuple[]"
                    },
                    {
                      "components": [
                        {"internalType": "uint256", "name": "id", "type": "uint256"},
                        {"internalType": "address", "name": "proposer", "type": "address"},
                        {"internalType": "uint8", "name": "state", "type": "uint8"},
                        {"internalType": "uint48", "name": "snapshotBlock", "type": "uint48"},
                        {"internalType": "uint64", "name": "createdAt", "type": "uint64"},
                        {"internalType": "uint64", "name": "queuedAt", "type": "uint64"},
                        {"internalType": "uint256", "name": "supplySnapshot", "type": "uint256"},
                        {"internalType": "uint96", "name": "forVotes", "type": "uint96"},
                        {"internalType": "uint96", "name": "againstVotes", "type": "uint96"},
                        {"internalType": "uint96", "name": "abstainVotes", "type": "uint96"},
                        {
                          "components": [
                            {"internalType": "bool", "name": "enabled", "type": "bool"},
                            {"internalType": "address", "name": "rewardToken", "type": "address"},
                            {"internalType": "uint256", "name": "pool", "type": "uint256"},
                            {"internalType": "bool", "name": "resolved", "type": "bool"},
                            {"internalType": "uint8", "name": "winner", "type": "uint8"},
                            {"internalType": "uint256", "name": "finalWinningSupply", "type": "uint256"},
                            {"internalType": "uint256", "name": "payoutPerUnit", "type": "uint256"}
                          ],
                          "internalType": "struct FutarchyView",
                          "name": "futarchy",
                          "type": "tuple"
                        },
                        {
                          "components": [
                            {"internalType": "address", "name": "voter", "type": "address"},
                            {"internalType": "uint8", "name": "support", "type": "uint8"},
                            {"internalType": "uint256", "name": "weight", "type": "uint256"}
                          ],
                          "internalType": "struct VoterView[]",
                          "name": "voters",
                          "type": "tuple[]"
                        }
                      ],
                      "internalType": "struct ProposalView[]",
                      "name": "proposals",
                      "type": "tuple[]"
                    },
                    {
                      "components": [
                        {"internalType": "uint256", "name": "index", "type": "uint256"},
                        {"internalType": "string", "name": "text", "type": "string"}
                      ],
                      "internalType": "struct MessageView[]",
                      "name": "messages",
                      "type": "tuple[]"
                    }
                  ],
                  "internalType": "struct DAOLens",
                  "name": "dao",
                  "type": "tuple"
                },
                {
                  "components": [
                    {"internalType": "address", "name": "tribTkn", "type": "address"},
                    {"internalType": "uint256", "name": "tribAmt", "type": "uint256"},
                    {"internalType": "uint256", "name": "forAmt", "type": "uint256"},
                    {"internalType": "address", "name": "forTkn", "type": "address"},
                    {"internalType": "uint40", "name": "deadline", "type": "uint40"},
                    {"internalType": "uint256", "name": "remainingSupply", "type": "uint256"},
                    {"internalType": "uint256", "name": "totalSupply", "type": "uint256"},
                    {"internalType": "uint256", "name": "treasuryBalance", "type": "uint256"},
                    {"internalType": "uint256", "name": "allowance", "type": "uint256"},
                    {"internalType": "uint16", "name": "lpBps", "type": "uint16"},
                    {"internalType": "uint16", "name": "maxSlipBps", "type": "uint16"},
                    {"internalType": "uint256", "name": "feeOrHook", "type": "uint256"}
                  ],
                  "internalType": "struct SaleView[]",
                  "name": "sales",
                  "type": "tuple[]"
                },
                {
                  "components": [
                    {"internalType": "address", "name": "ops", "type": "address"},
                    {"internalType": "address", "name": "tribTkn", "type": "address"},
                    {"internalType": "uint128", "name": "ratePerSec", "type": "uint128"},
                    {"internalType": "uint64", "name": "lastClaim", "type": "uint64"},
                    {"internalType": "uint256", "name": "claimable", "type": "uint256"},
                    {"internalType": "uint256", "name": "pending", "type": "uint256"},
                    {"internalType": "uint256", "name": "treasuryBalance", "type": "uint256"},
                    {"internalType": "uint256", "name": "tapAllowance", "type": "uint256"}
                  ],
                  "internalType": "struct TapView",
                  "name": "tap",
                  "type": "tuple"
                }
              ],
              "internalType": "struct DAICOLens",
              "name": "out",
              "type": "tuple"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        }
      ];

      const MOLOCH_ABI = [
        {
          "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
          "name": "openProposal",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
          "name": "queue",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [{"internalType": "string", "name": "message", "type": "string"}],
          "name": "chat",
          "outputs": [],
          "stateMutability": "payable",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "uint8", "name": "op", "type": "uint8"},
            {"internalType": "address", "name": "to", "type": "address"},
            {"internalType": "uint256", "name": "value", "type": "uint256"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
            {"internalType": "bytes32", "name": "nonce", "type": "bytes32"}
          ],
          "name": "executeByVotes",
          "outputs": [
            {"internalType": "bool", "name": "ok", "type": "bool"},
            {"internalType": "bytes", "name": "retData", "type": "bytes"}
          ],
          "stateMutability": "payable",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "uint256", "name": "id", "type": "uint256"},
            {"internalType": "uint8", "name": "support", "type": "uint8"}
          ],
          "name": "castVote",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
          "name": "cancelVote",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "uint256", "name": "", "type": "uint256"},
            {"internalType": "address", "name": "", "type": "address"}
          ],
          "name": "hasVoted",
          "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "config",
          "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [{"internalType": "bytes[]", "name": "data", "type": "bytes[]"}],
          "name": "multicall",
          "outputs": [{"internalType": "bytes[]", "name": "results", "type": "bytes[]"}],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "address[]", "name": "tokens", "type": "address[]"},
            {"internalType": "uint256", "name": "sharesToBurn", "type": "uint256"},
            {"internalType": "uint256", "name": "lootToBurn", "type": "uint256"}
          ],
          "name": "ragequit",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "address", "name": "receiver", "type": "address"},
            {"internalType": "uint256", "name": "id", "type": "uint256"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"}
          ],
          "name": "transfer",
          "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "uint256", "name": "id", "type": "uint256"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"}
          ],
          "name": "cashOutFutarchy",
          "outputs": [{"internalType": "uint256", "name": "payout", "type": "uint256"}],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "address", "name": "owner", "type": "address"},
            {"internalType": "uint256", "name": "id", "type": "uint256"}
          ],
          "name": "balanceOf",
          "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "badges",
          "outputs": [{"internalType": "address", "name": "", "type": "address"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "shares",
          "outputs": [{"internalType": "address", "name": "", "type": "address"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "loot",
          "outputs": [{"internalType": "address", "name": "", "type": "address"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [{"internalType": "uint256", "name": "id", "type": "uint256"}],
          "name": "tokenURI",
          "outputs": [{"internalType": "string", "name": "", "type": "string"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "contractURI",
          "outputs": [{"internalType": "string", "name": "", "type": "string"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [{"internalType": "address", "name": "payToken", "type": "address"}],
          "name": "sales",
          "outputs": [
            {"internalType": "uint256", "name": "pricePerShare", "type": "uint256"},
            {"internalType": "uint256", "name": "cap", "type": "uint256"},
            {"internalType": "bool", "name": "minting", "type": "bool"},
            {"internalType": "bool", "name": "active", "type": "bool"},
            {"internalType": "bool", "name": "isLoot", "type": "bool"}
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "address", "name": "payToken", "type": "address"},
            {"internalType": "uint256", "name": "pricePerShare", "type": "uint256"},
            {"internalType": "uint256", "name": "cap", "type": "uint256"},
            {"internalType": "bool", "name": "minting", "type": "bool"},
            {"internalType": "bool", "name": "active", "type": "bool"},
            {"internalType": "bool", "name": "isLoot", "type": "bool"}
          ],
          "name": "setSale",
          "outputs": [],
          "stateMutability": "payable",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "address", "name": "payToken", "type": "address"},
            {"internalType": "uint256", "name": "shareAmount", "type": "uint256"},
            {"internalType": "uint256", "name": "maxPay", "type": "uint256"}
          ],
          "name": "buyShares",
          "outputs": [],
          "stateMutability": "payable",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "uint8", "name": "op", "type": "uint8"},
            {"internalType": "address", "name": "to", "type": "address"},
            {"internalType": "uint256", "name": "value", "type": "uint256"},
            {"internalType": "bytes", "name": "data", "type": "bytes"},
            {"internalType": "bytes32", "name": "nonce", "type": "bytes32"}
          ],
          "name": "spendPermit",
          "outputs": [
            {"internalType": "bool", "name": "ok", "type": "bool"},
            {"internalType": "bytes", "name": "retData", "type": "bytes"}
          ],
          "stateMutability": "payable",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "address", "name": "token", "type": "address"},
            {"internalType": "address", "name": "spender", "type": "address"}
          ],
          "name": "allowance",
          "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {"internalType": "address", "name": "token", "type": "address"},
            {"internalType": "uint256", "name": "amount", "type": "uint256"}
          ],
          "name": "spendAllowance",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "anonymous": false,
          "inputs": [
            {"indexed": true, "name": "from", "type": "address"},
            {"indexed": true, "name": "index", "type": "uint256"},
            {"indexed": false, "name": "text", "type": "string"}
          ],
          "name": "Message",
          "type": "event"
        }
      ];

      // ERC20 ABI for token interactions
      const ERC20_ABI = [
        {
          "inputs": [{"internalType": "address", "name": "owner", "type": "address"}, {"internalType": "address", "name": "spender", "type": "address"}],
          "name": "allowance",
          "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [{"internalType": "address", "name": "spender", "type": "address"}, {"internalType": "uint256", "name": "amount", "type": "uint256"}],
          "name": "approve",
          "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
          "name": "balanceOf",
          "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "decimals",
          "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "name",
          "outputs": [{"internalType": "string", "name": "", "type": "string"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [],
          "name": "symbol",
          "outputs": [{"internalType": "string", "name": "", "type": "string"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [{"internalType": "address", "name": "to", "type": "address"}, {"internalType": "uint256", "name": "amount", "type": "uint256"}],
          "name": "transfer",
          "outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
          "stateMutability": "nonpayable",
          "type": "function"
        }
      ];

      const TRIBUTE_ABI = [
        {
          "inputs": [
            {"name": "dao", "type": "address"},
            {"name": "tribTkn", "type": "address"},
            {"name": "tribAmt", "type": "uint256"},
            {"name": "forTkn", "type": "address"},
            {"name": "forAmt", "type": "uint256"}
          ],
          "name": "proposeTribute",
          "outputs": [],
          "stateMutability": "payable",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "dao", "type": "address"},
            {"name": "tribTkn", "type": "address"}
          ],
          "name": "cancelTribute",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "proposer", "type": "address"},
            {"name": "tribTkn", "type": "address"}
          ],
          "name": "claimTribute",
          "outputs": [],
          "stateMutability": "payable",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "dao", "type": "address"}
          ],
          "name": "getActiveDaoTributes",
          "outputs": [
            {
              "components": [
                {"name": "proposer", "type": "address"},
                {"name": "tribTkn", "type": "address"},
                {"name": "tribAmt", "type": "uint256"},
                {"name": "forTkn", "type": "address"},
                {"name": "forAmt", "type": "uint256"}
              ],
              "name": "",
              "type": "tuple[]"
            }
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "anonymous": false,
          "inputs": [
            {"indexed": true, "name": "proposer", "type": "address"},
            {"indexed": true, "name": "dao", "type": "address"},
            {"indexed": false, "name": "tribTkn", "type": "address"},
            {"indexed": false, "name": "tribAmt", "type": "uint256"},
            {"indexed": false, "name": "forTkn", "type": "address"},
            {"indexed": false, "name": "forAmt", "type": "uint256"}
          ],
          "name": "TributeProposed",
          "type": "event"
        },
        {
          "anonymous": false,
          "inputs": [
            {"indexed": true, "name": "proposer", "type": "address"},
            {"indexed": true, "name": "dao", "type": "address"},
            {"indexed": false, "name": "tribTkn", "type": "address"},
            {"indexed": false, "name": "tribAmt", "type": "uint256"},
            {"indexed": false, "name": "forTkn", "type": "address"},
            {"indexed": false, "name": "forAmt", "type": "uint256"}
          ],
          "name": "TributeClaimed",
          "type": "event"
        }
      ];

      // DAICO ABI for external OTC sale contract
      const DAICO_ABI = [
        {
          "inputs": [
            {"name": "dao", "type": "address"},
            {"name": "tribTkn", "type": "address"}
          ],
          "name": "sales",
          "outputs": [
            {"name": "tribAmt", "type": "uint256"},
            {"name": "forAmt", "type": "uint256"},
            {"name": "forTkn", "type": "address"},
            {"name": "deadline", "type": "uint40"}
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "dao", "type": "address"},
            {"name": "tribTkn", "type": "address"}
          ],
          "name": "lpConfigs",
          "outputs": [
            {"name": "lpBps", "type": "uint16"},
            {"name": "maxSlipBps", "type": "uint16"},
            {"name": "feeOrHook", "type": "uint256"}
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "dao", "type": "address"},
            {"name": "tribTkn", "type": "address"},
            {"name": "payAmt", "type": "uint256"}
          ],
          "name": "quoteBuy",
          "outputs": [{"name": "buyAmt", "type": "uint256"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "dao", "type": "address"},
            {"name": "tribTkn", "type": "address"},
            {"name": "buyAmt", "type": "uint256"}
          ],
          "name": "quotePayExactOut",
          "outputs": [{"name": "payAmt", "type": "uint256"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "dao", "type": "address"},
            {"name": "tribTkn", "type": "address"},
            {"name": "payAmt", "type": "uint256"},
            {"name": "minBuyAmt", "type": "uint256"}
          ],
          "name": "buy",
          "outputs": [],
          "stateMutability": "payable",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "dao", "type": "address"},
            {"name": "tribTkn", "type": "address"},
            {"name": "buyAmt", "type": "uint256"},
            {"name": "maxPayAmt", "type": "uint256"}
          ],
          "name": "buyExactOut",
          "outputs": [],
          "stateMutability": "payable",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "tribTkn", "type": "address"},
            {"name": "tribAmt", "type": "uint256"},
            {"name": "forTkn", "type": "address"},
            {"name": "forAmt", "type": "uint256"},
            {"name": "deadline", "type": "uint40"}
          ],
          "name": "setSale",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "tribTkn", "type": "address"},
            {"name": "lpBps", "type": "uint16"},
            {"name": "maxSlipBps", "type": "uint16"},
            {"name": "feeOrHook", "type": "uint256"}
          ],
          "name": "setLPConfig",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "tribTkn", "type": "address"},
            {"name": "tribAmt", "type": "uint256"},
            {"name": "forTkn", "type": "address"},
            {"name": "forAmt", "type": "uint256"},
            {"name": "deadline", "type": "uint40"},
            {"name": "lpBps", "type": "uint16"},
            {"name": "maxSlipBps", "type": "uint16"},
            {"name": "feeOrHook", "type": "uint256"}
          ],
          "name": "setSaleWithLP",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "tribTkn", "type": "address"},
            {"name": "tribAmt", "type": "uint256"},
            {"name": "forTkn", "type": "address"},
            {"name": "forAmt", "type": "uint256"},
            {"name": "deadline", "type": "uint40"},
            {"name": "ops", "type": "address"},
            {"name": "ratePerSec", "type": "uint128"}
          ],
          "name": "setSaleWithTap",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [
            {"name": "tribTkn", "type": "address"},
            {"name": "tribAmt", "type": "uint256"},
            {"name": "forTkn", "type": "address"},
            {"name": "forAmt", "type": "uint256"},
            {"name": "deadline", "type": "uint40"},
            {"name": "lpBps", "type": "uint16"},
            {"name": "maxSlipBps", "type": "uint16"},
            {"name": "feeOrHook", "type": "uint256"},
            {"name": "ops", "type": "address"},
            {"name": "ratePerSec", "type": "uint128"}
          ],
          "name": "setSaleWithLPAndTap",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [{"name": "dao", "type": "address"}],
          "name": "taps",
          "outputs": [
            {"name": "ops", "type": "address"},
            {"name": "tribTkn", "type": "address"},
            {"name": "ratePerSec", "type": "uint128"},
            {"name": "lastClaim", "type": "uint64"}
          ],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [{"name": "dao", "type": "address"}],
          "name": "pendingTap",
          "outputs": [{"name": "owed", "type": "uint256"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [{"name": "dao", "type": "address"}],
          "name": "claimableTap",
          "outputs": [{"name": "", "type": "uint256"}],
          "stateMutability": "view",
          "type": "function"
        },
        {
          "inputs": [{"name": "dao", "type": "address"}],
          "name": "claimTap",
          "outputs": [{"name": "claimed", "type": "uint256"}],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [{"name": "newOps", "type": "address"}],
          "name": "setTapOps",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        {
          "inputs": [{"name": "newRate", "type": "uint128"}],
          "name": "setTapRate",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        }
      ];

      // Constants for minimal proxy pattern (from Solidity reference)
      const CLONE_PREFIX = '0x602d5f8160095f39f35f5f365f5f37365f73';
      const CLONE_SUFFIX = '0x5af43d5f5f3e6029573d5ffd5b3d5ff3';

      // Implementation addresses per network (L2s have different addresses due to EVM differences)
      const IMPLEMENTATIONS = {
        moloch: '0x643A45B599D81be3f3A68F37EB3De55fF10673C1',
        shares: '0x71E9b38d301b5A58cb998C1295045FE276Acf600',
        badges: '0x47C175Ce83B6B931ccBedD5ce95e701984eD96d5',
        loot: '0x6f1f2aF76a3aDD953277e9F369242697C87bc6A5'
      };

      // DAICO contract address (external OTC sale peripheral)
      const DAICO_ADDRESS = '0x000000000033e92DB97B4B3beCD2c255126C60aC';

      // Token addresses - dynamically returns addresses for current network
      // This is a getter object that looks up addresses by symbol
      const TOKEN_ADDRESSES = new Proxy({}, {
        get(target, prop) {
          const symbol = prop.toLowerCase();
          const addr = getTokenAddressBySymbol(symbol);
          return addr || ethers.ZeroAddress;
        }
      });

      // Shared interfaces (created once, reused throughout)
      const INTERFACES = {
        setQuorumBps: new ethers.Interface(['function setQuorumBps(uint16)']),
        setRagequittable: new ethers.Interface(['function setRagequittable(bool)']),
        setSale: new ethers.Interface(['function setSale(address,uint256,uint256,bool,bool,bool)']),
        setProposalTTL: new ethers.Interface(['function setProposalTTL(uint64)']),
        setTimelockDelay: new ethers.Interface(['function setTimelockDelay(uint64)']),
        mintFromMoloch: new ethers.Interface(['function mintFromMoloch(address,uint256)']),
        setProposalThreshold: new ethers.Interface(['function setProposalThreshold(uint96)']),
        setTransfersLocked: new ethers.Interface(['function setTransfersLocked(bool,bool)']),
        setAutoFutarchy: new ethers.Interface(['function setAutoFutarchy(uint256,uint256)']),
        setRenderer: new ethers.Interface(['function setRenderer(address)']),
        setPermit: new ethers.Interface(['function setPermit(uint8,address,uint256,bytes,bytes32,address,uint256)']),
        bumpConfig: new ethers.Interface(['function bumpConfig()']),
        setAllowance: new ethers.Interface(['function setAllowance(address,address,uint256)']),
        // DAICO interfaces
        daicoSetSale: new ethers.Interface(['function setSale(address tribTkn, uint256 tribAmt, address forTkn, uint256 forAmt, uint40 deadline)']),
        daicoSetLPConfig: new ethers.Interface(['function setLPConfig(address tribTkn, uint16 lpBps, uint16 maxSlipBps, uint256 feeOrHook)']),
        daicoSetSaleWithLP: new ethers.Interface(['function setSaleWithLP(address tribTkn, uint256 tribAmt, address forTkn, uint256 forAmt, uint40 deadline, uint16 lpBps, uint16 maxSlipBps, uint256 feeOrHook)']),
        daicoSetSaleWithTap: new ethers.Interface(['function setSaleWithTap(address tribTkn, uint256 tribAmt, address forTkn, uint256 forAmt, uint40 deadline, address ops, uint128 ratePerSec)']),
        daicoSetSaleWithLPAndTap: new ethers.Interface(['function setSaleWithLPAndTap(address tribTkn, uint256 tribAmt, address forTkn, uint256 forAmt, uint40 deadline, uint16 lpBps, uint16 maxSlipBps, uint256 feeOrHook, address ops, uint128 ratePerSec)']),
        daicoSales: new ethers.Interface(['function sales(address dao, address tribTkn) view returns (uint256 tribAmt, uint256 forAmt, address forTkn, uint40 deadline)']),
        daicoLpConfigs: new ethers.Interface(['function lpConfigs(address dao, address tribTkn) view returns (uint16 lpBps, uint16 maxSlipBps, uint256 feeOrHook)']),
        daicoTaps: new ethers.Interface(['function taps(address dao) view returns (address ops, address tribTkn, uint128 ratePerSec, uint64 lastClaim)']),
        daicoPendingTap: new ethers.Interface(['function pendingTap(address dao) view returns (uint256 owed)']),
        daicoClaimableTap: new ethers.Interface(['function claimableTap(address dao) view returns (uint256)']),
        daicoClaimTap: new ethers.Interface(['function claimTap(address dao) returns (uint256 claimed)']),
        daicoSetTapOps: new ethers.Interface(['function setTapOps(address newOps)']),
        daicoSetTapRate: new ethers.Interface(['function setTapRate(uint128 newRate)']),
        daicoQuoteBuy: new ethers.Interface(['function quoteBuy(address dao, address tribTkn, uint256 payAmt) view returns (uint256)']),
        daicoBuy: new ethers.Interface(['function buy(address dao, address tribTkn, uint256 payAmt, uint256 minBuyAmt) payable']),
        daicoBuyExactOut: new ethers.Interface(['function buyExactOut(address dao, address tribTkn, uint256 buyAmt, uint256 maxPayAmt) payable']),
        // ERC20 approve for DAICO approvals
        erc20Approve: new ethers.Interface(['function approve(address spender, uint256 amount)'])
      };

      // Helper to create minimal proxy init code
      function minimalProxyInitCode(implementation) {
        // Normalize the address to lowercase without 0x prefix
        const impl = implementation.toLowerCase().replace(/^0x/, '');
        // Ensure it's 40 characters (20 bytes)
        if (impl.length !== 40) {
          throw new Error('Invalid implementation address length');
        }
        return ethers.concat([
          CLONE_PREFIX,
          '0x' + impl,
          CLONE_SUFFIX
        ]);
      }

      // Generic CREATE2 address prediction
      function computeCreate2Address(deployer, salt, implementation) {
        const initCode = minimalProxyInitCode(implementation);
        const initCodeHash = ethers.keccak256(initCode);

        const encoded = ethers.solidityPacked(
          ['bytes1', 'address', 'bytes32', 'bytes32'],
          ['0xff', deployer, salt, initCodeHash]
        );
        const hash = ethers.keccak256(encoded);
        // Extract the last 20 bytes (40 hex chars) and checksum it
        const rawAddress = '0x' + hash.slice(-40);
        // Return checksummed address
        return ethers.getAddress(rawAddress);
      }

      // Predict all Majeur addresses
      function predictMajeurAddresses(initHolders, initShares, userSalt) {
        // Step 1: Recreate Summoner's salt
        const abiCoder = new ethers.AbiCoder();
        const summonerSalt = ethers.keccak256(
          abiCoder.encode(
            ['address[]', 'uint256[]', 'bytes32'],
            [initHolders, initShares, userSalt]
          )
        );

        // Step 2: Predict Moloch DAO clone
        const dao = computeCreate2Address(SUMMONER_ADDRESS, summonerSalt, IMPLEMENTATIONS.moloch);

        // Step 3: Child salt for badges/shares/loot
        // bytes32(bytes20(address(dao))) = dao address right-padded to 32 bytes
        // In Solidity, bytes types are left-aligned (right-padded with zeros)
        const daoNoPrefix = dao.toLowerCase().replace(/^0x/, '');
        if (daoNoPrefix.length !== 40) {
          throw new Error('Invalid DAO address length');
        }
        const childSalt = '0x' + daoNoPrefix + '000000000000000000000000'; // 12 zero bytes suffix

        // Step 4: Predict child clones
        const badges = computeCreate2Address(dao, childSalt, IMPLEMENTATIONS.badges);
        const shares = computeCreate2Address(dao, childSalt, IMPLEMENTATIONS.shares);
        const loot = computeCreate2Address(dao, childSalt, IMPLEMENTATIONS.loot);

        return { dao, badges, shares, loot };
      }


      // Constants - extracting magic numbers for maintainability
      const WEINS_ADDRESS = "0x0000000000696760E15f265e828DB644A0c242EB";
      const WEINS_ABI = ["function reverseResolve(address) view returns (string)"];

      const CONSTANTS = {
        // Time
        DRAFT_RETENTION_MS: 24 * 60 * 60 * 1000, // 24 hours in milliseconds
        REFRESH_COOLDOWN_MS: 5000, // 5 seconds
        TOAST_DURATION_MS: 3000,
        TOAST_DURATION_LONG_MS: 6000,

        // Token & Blockchain
        TOKEN_DECIMALS: 18,
        MIN_DISPLAY_BALANCE: 0.0001,
        BIPS_DIVISOR: 10000, // Basis points to percentage (1 bps = 0.01%)

        // UI Thresholds
        MAX_MEMBERS_DISPLAY: 100,
        MAX_PROPOSALS_DISPLAY: 50,
        ANIMATION_DELAY_MS: 50,

        // Storage
        STORAGE_KEY_SUMMON: 'molochSummonDraft',

        // Fetch Limits
        DAO_FETCH_LIMIT: 50,
        PROPOSAL_FETCH_LIMIT: 10,
        MESSAGE_FETCH_LIMIT: 10
      };

      // Read-only provider for access without wallet
      // Cache RPC provider instances to avoid repeated construction overhead
      const rpcProviderCache = new Map();
      function getRpcProvider(rpc) {
        if (!rpcProviderCache.has(rpc)) {
          rpcProviderCache.set(rpc, new ethers.JsonRpcProvider(rpc));
        }
        return rpcProviderCache.get(rpc);
      }

      // Execute a function with RPC fallback
      // Tries connected provider first (unless WalletConnect), then each public RPC until one succeeds
      async function withRpcFallback(fn) {
        const network = getNetwork();

        // Try connected wallet provider first (if not WalletConnect - its RPCs are unreliable)
        if (provider && !walletConnectProvider) {
          try {
            return await fn(provider);
          } catch (e) {
            logger.warn('Connected provider failed, trying public RPCs:', e.message);
          }
        }

        // Try each public RPC until one works
        for (const rpc of network.rpcs) {
          try {
            const rpcProvider = getRpcProvider(rpc);
            return await fn(rpcProvider);
          } catch (e) {
            logger.warn(`RPC ${rpc} failed:`, e.message);
            // Continue to next RPC
          }
        }

        throw new Error('All RPC endpoints failed - check network connection');
      }

      // Get transaction overrides for WalletConnect (skips unreliable local gas estimation)
      function getWalletConnectTxOverrides(baseOptions = {}) {
        if (walletConnectProvider) {
          return { ...baseOptions, gasLimit: 1_000_000n };
        }
        return baseOptions;
      }

      let readOnlyProvider = null;
      let provider = null;
      let signer = null;
      let connectedWallet = null;
      let connectedAddress = null;
      let connectedWalletProvider = null; // Raw wallet provider for network switching
      let walletConnectProvider = null; // WalletConnect provider instance
      let userDAOs = [];
      let allDAOs = [];
      let allDAOsLoaded = false; // Track if All DAOs gallery has been loaded
      let allDAOsCache = null; // Cached list of all DAOs for name/symbol search
      let heroFire = null; // Animation handle for hero fire
      let currentDAO = null;
      let currentDAICO = null; // Cached DAICO data (sales, tap) for current DAO
      let currentDaoTributes = [];
      let tributeRefreshTimestamp = 0;

      // Connection state management
      let isConnecting = false;
      let eip6963Providers = new Map();

      // Transaction state management (prevent double-submission race conditions)
      let isSendingMessage = false;
      let isVoting = false;
      let isCancellingVote = false;
      let isCreatingProposal = false;
      let isExecutingProposal = false;

      // Name lookup cache (prevents repeated network calls for same addresses)
      const nameCache = new Map(); // address => { name: string, timestamp: number }
      const NAME_CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

      // Cached name lookup: tries .wei first, then ENS
      async function lookupENS(address) {
        if (!address) return null;

        const key = address.toLowerCase();
        const cached = nameCache.get(key);
        const now = Date.now();

        // Return cached value if still valid
        if (cached && (now - cached.timestamp) < NAME_CACHE_TTL) {
          return cached.name;
        }

        let resolvedName = null;

        // Run .wei and ENS lookups in parallel, prefer .wei
        const [weiResult, ensResult] = await Promise.allSettled([
          withRpcFallback(async (rpc) => {
            const ns = new ethers.Contract(WEINS_ADDRESS, WEINS_ABI, rpc);
            return await ns.reverseResolve(address);
          }),
          provider ? provider.lookupAddress(address) : Promise.resolve(null)
        ]);

        if (weiResult.status === 'fulfilled' && weiResult.value) {
          resolvedName = weiResult.value.toLowerCase();
        } else if (ensResult.status === 'fulfilled' && ensResult.value) {
          resolvedName = ensResult.value;
        }

        // Cache the result (even if null)
        nameCache.set(key, { name: resolvedName, timestamp: now });
        return resolvedName;
      }

      // Event listener cleanup
      let walletEventHandlers = null;

      // Utility function to check if error is user rejection
      function isUserRejection(error) {
        if (!error) return false;

        // Check error codes
        if (error.code === 4001 || error.code === -32603 || error.code === 'ACTION_REJECTED') {
          return true;
        }

        // Check error message (case insensitive)
        const message = (error.message || '').toLowerCase();
        if (message.includes('user rejected') ||
            message.includes('user denied') ||
            message.includes('transaction cancelled') ||
            message.includes('cancelled by user') ||
            message.includes('user closed') ||
            message.includes('qr code modal closed')) {
          return true;
        }

        // Check nested error object
        if (error.error) {
          return isUserRejection(error.error);
        }

        // Check reason field
        if (error.reason) {
          const reason = error.reason.toLowerCase();
          if (reason.includes('user rejected') || reason.includes('user denied')) {
            return true;
          }
        }

        return false;
      }

      // Reliable multi-provider detection
      function findProvider(checkFn) {
        if (window.ethereum?.providers?.length) {
          for (const p of window.ethereum.providers) {
            if (checkFn(p)) return p;
          }
        }
        if (window.ethereum && checkFn(window.ethereum)) return window.ethereum;
        return null;
      }

      // Wallet detection configuration
      const WALLET_CONFIG = {
        metamask: { name: 'MetaMask', icon: 'ðŸ¦Š', detect: () => findProvider(p => p.isMetaMask), getProvider: () => findProvider(p => p.isMetaMask) },
        coinbase: { name: 'Coinbase', icon: 'ðŸ”µ', detect: () => findProvider(p => p.isCoinbaseWallet), getProvider: () => findProvider(p => p.isCoinbaseWallet) },
        rabby: { name: 'Rabby', icon: 'ðŸ°', detect: () => findProvider(p => p.isRabby), getProvider: () => findProvider(p => p.isRabby) },
        rainbow: { name: 'Rainbow', icon: 'ðŸŒˆ', detect: () => findProvider(p => p.isRainbow), getProvider: () => findProvider(p => p.isRainbow) },
        walletconnect: { name: 'WalletConnect', icon: 'ðŸ“±' }
      };

      // EIP-6963: Multi-injector wallet detection
      function initEIP6963() {
        if (typeof window === 'undefined') return;

        window.addEventListener('eip6963:announceProvider', (event) => {
          const { info, provider } = event.detail;
          eip6963Providers.set(info.uuid, { info, provider });
        });

        window.dispatchEvent(new Event('eip6963:requestProvider'));
      }

      function detectWallets() {
        const detected = [];
        const seenNames = new Set();

        // First, detect legacy injected wallets (skip walletconnect - handled separately below)
        for (const [key, wallet] of Object.entries(WALLET_CONFIG)) {
          if (key === 'walletconnect') continue;
          if (wallet.detect()) {
            detected.push({ key, ...wallet });
            seenNames.add(wallet.name.toLowerCase());
          }
        }

        // Then, add EIP-6963 detected wallets that weren't already found
        for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
          const nameLower = info.name.toLowerCase();
          if (!seenNames.has(nameLower)) {
            // Sanitize wallet metadata to prevent XSS from malicious wallet extensions
            const safeName = escapeHtml(info.name);
            const safeIconUrl = sanitizeUrl(info.icon);
            const safeIcon = safeIconUrl ? `<img src="${escapeHtml(safeIconUrl)}" style="width: 1.2rem; height: 1.2rem;" alt="${safeName}"/>` : 'ðŸ”Œ';

            detected.push({
              key: `eip6963_${uuid}`,
              name: safeName,
              icon: safeIcon,
              detect: () => true,
              getProvider: () => provider,
              isEIP6963: true
            });
            seenNames.add(nameLower);
          }
        }

        // Always add WalletConnect as an option (for mobile QR scanning)
        const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
        if (wcModule?.EthereumProvider) {
          detected.push({
            key: 'walletconnect',
            name: 'WalletConnect',
            icon: 'ðŸ“±',
            isWalletConnect: true
          });
        }

        return detected;
      }

      // LocalStorage helpers
      function saveWalletPreference(walletKey) {
        try {
          localStorage.setItem('preferredWallet', walletKey);
        } catch (e) {
          logger.warn('Failed to save wallet preference:', e);
        }
      }

      function getWalletPreference() {
        try {
          return localStorage.getItem('preferredWallet');
        } catch (e) {
          logger.warn('Failed to get wallet preference:', e);
          return null;
        }
      }

      function clearWalletPreference() {
        try {
          localStorage.removeItem('preferredWallet');
        } catch (e) {
          logger.warn('Failed to clear wallet preference:', e);
        }
      }

      function showWalletModal() {
        const modalOverlay = getEl('walletModal');
        const walletOptions = document.getElementById('walletOptions');

        // If already connected, show disconnect option
        if (connectedWallet && connectedAddress) {
          // Get wallet info - support both legacy and EIP-6963 wallets
          let wallet;
          if (connectedWallet.startsWith('eip6963_')) {
            const uuid = connectedWallet.replace('eip6963_', '');
            const eip6963Wallet = eip6963Providers.get(uuid);
            if (eip6963Wallet) {
              // Sanitize wallet metadata to prevent XSS from malicious wallet extensions
              const safeName = escapeHtml(eip6963Wallet.info.name);
              const safeIconUrl = sanitizeUrl(eip6963Wallet.info.icon);
              const safeIcon = safeIconUrl ? `<img src="${escapeHtml(safeIconUrl)}" style="width: 1.2rem; height: 1.2rem;" alt="${safeName}"/>` : 'ðŸ”Œ';

              wallet = {
                name: safeName,
                icon: safeIcon
              };
            }
          } else {
            wallet = WALLET_CONFIG[connectedWallet];
          }

          if (wallet) {
            walletOptions.innerHTML = `
              <div class="wallet-connected-info">
                <div style="display: flex; align-items: center; margin-bottom: 0.75rem;">
                  <div class="wallet-icon" style="margin-right: 1rem;">${wallet.icon}</div>
                  <div>
                    <div class="wallet-name">${wallet.name}</div>
                    <div class="wallet-status installed">Connected</div>
                  </div>
                </div>
                <div class="wallet-connected-addr">
                  ${connectedAddress}
                </div>
              </div>
              <div class="wallet-option wallet-disconnect" onclick="disconnectWallet()">
                <div class="wallet-name" style="margin: 0;">Disconnect Wallet</div>
              </div>
            `;
          }
        } else {
          // Show wallet selection
          const wallets = detectWallets();

          if (wallets.length === 0) {
            walletOptions.innerHTML = `
              <div class="wallet-option" onclick="window.open('https://metamask.io/download/', '_blank')">
                <div class="wallet-icon">ðŸ¦Š</div>
                <div class="wallet-info">
                  <div class="wallet-name">Install MetaMask</div>
                  <div class="wallet-status">No wallet detected</div>
                </div>
              </div>
              <div class="wallet-option" onclick="window.open('https://www.coinbase.com/wallet/downloads', '_blank')">
                <div class="wallet-icon">ðŸ”µ</div>
                <div class="wallet-info">
                  <div class="wallet-name">Install Coinbase Wallet</div>
                  <div class="wallet-status">Browser extension</div>
                </div>
              </div>
              <div class="wallet-option" onclick="window.open('https://rainbow.me/download', '_blank')">
                <div class="wallet-icon">ðŸŒˆ</div>
                <div class="wallet-info">
                  <div class="wallet-name">Install Rainbow</div>
                  <div class="wallet-status">Browser extension</div>
                </div>
              </div>
            `;
          } else {
            walletOptions.innerHTML = wallets.map(wallet => `
              <div class="wallet-option" onclick="connectWithWallet('${wallet.key}')">
                <div class="wallet-icon">${wallet.icon}</div>
                <div class="wallet-info">
                  <div class="wallet-name">${wallet.name}</div>
                  <div class="wallet-status installed">${wallet.isWalletConnect ? 'QR Code' : 'Detected'}</div>
                </div>
              </div>
            `).join('');
          }
        }

        modalOverlay.classList.add('active');
        document.body.classList.add('modal-open');
      }

      function closeWalletModal() {
        getEl('walletModal').classList.remove('active');
        document.body.classList.remove('modal-open');
      }

      // Close modal when clicking outside
      document.addEventListener('DOMContentLoaded', () => {
        const modalOverlay = getEl('walletModal');
        modalOverlay.addEventListener('click', (e) => {
          if (e.target === modalOverlay) {
            closeWalletModal();
          }
        });
      });

      async function connectWithWallet(walletKey) {
        if (isConnecting) return;
        isConnecting = true;

        try {
          closeWalletModal();
          let wallet;
          let walletProvider;

          if (walletKey === 'walletconnect') {
            wallet = WALLET_CONFIG.walletconnect;
            const wcModule = (typeof globalThis !== 'undefined' ? globalThis : window)['@walletconnect/ethereum-provider'];
            const WCProvider = wcModule?.EthereumProvider;
            if (!WCProvider?.init) {
              showStatus('WalletConnect provider not available. Please refresh the page.', true);
              return;
            }

            if (walletConnectProvider) {
              try { await walletConnectProvider.disconnect?.(); } catch (e) {}
              walletConnectProvider = null;
            }

            walletConnectProvider = await WCProvider.init({
              projectId: '1e8390ef1c1d8a185e035912a1409749',
              chains: [1],
              showQrModal: true,
              rpcMap: { 1: 'https://1rpc.io/eth' },
              metadata: {
                name: 'MAJÂ·DAO',
                description: 'Summon and manage DAOs',
                url: window.location.origin,
                icons: ['https://daico.wtf/icon.png']
              }
            });

            await walletConnectProvider.enable();
            walletProvider = walletConnectProvider;
          } else if (walletKey.startsWith('eip6963_')) {
            const uuid = walletKey.replace('eip6963_', '');
            const eip6963Wallet = eip6963Providers.get(uuid);
            if (eip6963Wallet) {
              wallet = {
                name: eip6963Wallet.info.name,
                icon: (() => { const u = sanitizeUrl(eip6963Wallet.info.icon); return u ? `<img src="${escapeHtml(u)}" style="width: 1.2rem; height: 1.2rem;"/>` : 'ðŸ”Œ'; })(),
                getProvider: () => eip6963Wallet.provider
              };
            }
            if (!wallet) { logger.error('Unknown wallet:', walletKey); return; }
            walletProvider = wallet.getProvider();
            if (!walletProvider) { showStatus(`${wallet.name} not found`, true); return; }
            await walletProvider.request({ method: 'eth_requestAccounts' });
          } else {
            wallet = WALLET_CONFIG[walletKey];
            if (!wallet) { logger.error('Unknown wallet:', walletKey); return; }
            walletProvider = wallet.getProvider();
            if (!walletProvider) { showStatus(`${wallet.name} not found`, true); return; }
            await walletProvider.request({ method: 'eth_requestAccounts' });
          }

          // Enforce Ethereum mainnet (chain 1)
          const chainIdHex = await walletProvider.request({ method: 'eth_chainId' });
          if (BigInt(chainIdHex) !== 1n) {
            try {
              await walletProvider.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: '0x1' }]
              });
              const newChainId = await walletProvider.request({ method: 'eth_chainId' });
              if (BigInt(newChainId) !== 1n) throw new Error('Chain switch failed');
            } catch (switchErr) {
              showStatus('Please switch to Ethereum Mainnet', true);
              if (walletKey === 'walletconnect') {
                try { walletConnectProvider?.disconnect(); } catch (e) {}
                walletConnectProvider = null;
              }
              return;
            }
          }

          // ethers v6 setup
          provider = new ethers.BrowserProvider(walletProvider);
          signer = await provider.getSigner();
          const address = await signer.getAddress();

          // Store connected wallet info
          connectedWallet = walletKey;
          connectedAddress = address;
          connectedWalletProvider = walletProvider;
          saveWalletPreference(walletKey);

          // Update UI
          const walletBtn = getEl('walletBtn');
          if (walletBtn) {
            walletBtn.textContent = address.slice(0, 6) + '...' + address.slice(-4);
            walletBtn.classList.add('connected');
            lookupENS(address).then(name => {
              if (name && connectedAddress === address) walletBtn.textContent = name;
            }).catch(() => {});
          }
          updateWcBanner();
          const summonBtn = getEl('summonBtn');
          if (summonBtn) {
            summonBtn.disabled = false;
            summonBtn.textContent = 'SUMMON DAO';
          }

          // Initialize first member with connected wallet
          const foundingMembersList = getEl('foundingMembersList');
          if (foundingMembersList && foundingMembersList.children.length === 0) {
            const memberRow = createMemberRow(address, '1', true);
            foundingMembersList.appendChild(memberRow);
            updateLootInputs();
          }

          // Setup event listeners (simple: reload on account/chain change)
          if (connectedWalletProvider && walletEventHandlers) {
            try {
              connectedWalletProvider.removeListener('accountsChanged', walletEventHandlers.accountsChanged);
              connectedWalletProvider.removeListener('chainChanged', walletEventHandlers.chainChanged);
            } catch (e) {}
          }
          walletEventHandlers = {
            accountsChanged: () => window.location.reload(),
            chainChanged: () => window.location.reload()
          };
          walletProvider.on('accountsChanged', walletEventHandlers.accountsChanged);
          walletProvider.on('chainChanged', walletEventHandlers.chainChanged);

          // Fetch user's DAOs
          showStatus('Fetching your DAOs...', false);
          await fetchUserDAOs();

          const deepLink = parseDAODeepLink();
          if (userDAOs.length > 0) {
            hideHeroFire();
            renderDAOGallery();
          }

          if (deepLink) {
            if (currentDAO && currentDAO.dao.dao.toLowerCase() === deepLink.address.toLowerCase()) {
              // DAO already loaded read-only â€” just refresh wallet-dependent parts
              await renderAllowances();
              renderDaoStats();
            } else {
              showStatus('Opening linked DAO...', false);
              const opened = await openDAOByAddress(deepLink.address);
              if (opened) {
                requestAnimationFrame(() => {
                  setTimeout(() => {
                    const dashboard = document.getElementById('daoDashboard');
                    if (dashboard) dashboard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                  }, 100);
                });
              }
            }
          } else {
            showStatus(`Connected to ${wallet?.name || 'wallet'}`, false);
            if (userDAOs.length > 0) {
              setTimeout(() => {
                const daoGallery = document.getElementById('daoGallery');
                if (daoGallery) daoGallery.scrollIntoView({ behavior: 'smooth' });
              }, 100);
            } else {
              setTimeout(() => {
                const summoner = document.getElementById('summoner');
                if (summoner) summoner.scrollIntoView({ behavior: 'smooth' });
              }, 100);
            }
          }
        } catch (error) {
          if (isUserRejection(error)) {
            showStatus('', false);
            return;
          }
          logger.error(error);
          const walletName = wallet?.name || 'wallet';
          let errorMessage = `Failed to connect ${walletName}`;
          if (error.code === -32002) {
            errorMessage = `Please check ${walletName} - a connection request is pending`;
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.message) {
            const msg = error.message.split('\n')[0];
            if (msg.length < 100) errorMessage = msg;
          }
          showStatus(errorMessage, true);
        } finally {
          isConnecting = false;
        }
      }

      async function connectWallet() {
        showWalletModal();
      }

      function updateWcBanner() {
        const existing = document.getElementById('wcBanner');
        if (existing) existing.remove();
        if (connectedWallet === 'walletconnect' && connectedAddress) {
          const banner = document.createElement('div');
          banner.id = 'wcBanner';
          banner.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#1a1a2e;color:#fff;padding:10px 16px;display:flex;justify-content:space-between;align-items:center;z-index:9000;font-size:13px;';
          banner.innerHTML = '<span>ðŸ“± Connected via WalletConnect</span><button onclick="disconnectWallet()" style="background:#fff;color:#000;border:none;padding:6px 12px;border-radius:0;cursor:pointer;font-size:12px;">Disconnect</button>';
          document.body.prepend(banner);
          document.body.style.paddingTop = '44px';
        } else {
          document.body.style.paddingTop = '';
        }
      }

      function disconnectWallet() {
        // Clean up event listeners
        if (connectedWalletProvider && walletEventHandlers) {
          try {
            connectedWalletProvider.removeListener('accountsChanged', walletEventHandlers.accountsChanged);
            connectedWalletProvider.removeListener('chainChanged', walletEventHandlers.chainChanged);
          } catch (e) {}
        }
        walletEventHandlers = null;

        // Disconnect WalletConnect session if active
        if (walletConnectProvider) {
          try { walletConnectProvider.disconnect(); } catch (e) {}
          walletConnectProvider = null;
        }

        // Clear state
        provider = null;
        signer = null;
        connectedWallet = null;
        connectedAddress = null;
        connectedWalletProvider = null;
        isConnecting = false;
        userDAOs = [];
        currentDAO = null;
        currentDAICO = null;

        clearWalletPreference();

        // Reset UI
        const walletBtn = getEl('walletBtn');
        if (walletBtn) {
          walletBtn.textContent = 'connect';
          walletBtn.classList.remove('connected');
        }
        updateWcBanner();

        const summonBtn = getEl('summonBtn');
        if (summonBtn) {
          summonBtn.disabled = true;
          summonBtn.textContent = 'CONNECT WALLET TO SUMMON';
        }

        // Hide DAO galleries and dashboard
        const daoGallery = getEl('daoGallery');
        if (daoGallery) daoGallery.classList.remove('show');
        const allDaosGallery = getEl('allDaosGallery');
        if (allDaosGallery) allDaosGallery.classList.remove('show');
        const daoDashboard = getEl('daoDashboard');
        if (daoDashboard) daoDashboard.classList.remove('show');

        // Show hero fire again
        const fireEl = document.getElementById('fireHero');
        if (fireEl) fireEl.classList.remove('hide');
        if (heroFire) { heroFire.start(); }

        closeWalletModal();
        showStatus('Wallet disconnected', false);
      }

      // Ragequit modal functions
      // Store custom tokens for ragequit (cleared on modal open)
      let ragequitCustomTokens = [];

      async function openRagequitModal() {
        if (!currentDAO) {
          showStatus('No DAO selected', true);
          return;
        }

        const modal = getEl('ragequitModal');
        const member = currentDAO.member;

        // Check if user is a member
        if (!member) {
          showStatus('You are not a member of this DAO', true);
          return;
        }

        // Display user's shares and loot
        const shares = ethers.formatUnits(member.shares, 18);
        const loot = ethers.formatUnits(member.loot, 18);
        document.getElementById('ragequitUserShares').textContent = parseFloat(shares).toFixed(4);
        document.getElementById('ragequitUserLoot').textContent = parseFloat(loot).toFixed(4);

        // Clear inputs
        getEl('ragequitSharesInput').value = '';
        getEl('ragequitLootInput').value = '';
        document.getElementById('ragequitCustomTokenInput').value = '';

        // Clear custom tokens list
        ragequitCustomTokens = [];

        // Generate token list with checkboxes
        const tokenList = getEl('ragequitTokenList');
        tokenList.innerHTML = '';

        const treasury = currentDAO.dao.treasury;
        const tokens = parseTreasuryBalances(treasury);

        // Add custom sale tokens if any (skip tokens already in treasury)
        if (customSaleTokens.length > 0) {
          const existingAddrs = new Set(tokens.map(t => t.address.toLowerCase()));
          for (const customToken of customSaleTokens) {
            if (existingAddrs.has(customToken.address.toLowerCase())) continue;
            try {
              const tokenContract = new ethers.Contract(customToken.address, ERC20_ABI, provider);
              const balance = await tokenContract.balanceOf(currentDAO.dao.dao);
              tokens.push({
                symbol: customToken.symbol,
                address: customToken.address,
                balance: balance,
                decimals: customToken.decimals,
                icon: TOKEN_ICONS.defaultCoin,
                isCustomSale: true
              });
            } catch (error) {
              logger.error(`Error fetching balance for custom sale token ${customToken.symbol}:`, error);
            }
          }
        }

        tokens.forEach(token => {
          const formattedBalance = parseFloat(ethers.formatUnits(token.balance, token.decimals)).toFixed(4);

          const tokenDiv = document.createElement('div');
          tokenDiv.style.cssText = 'display: flex; align-items: center; padding: 0.7rem; background: var(--surface); border: 2px solid var(--border-muted); cursor: pointer; transition: all 0.2s ease; ';

          // Add sale badge for custom sale tokens
          const saleBadge = token.isCustomSale
            ? ' <span style="font-size: 0.65rem; color: var(--fg); background: var(--surface); padding: 0.15rem 0.35rem; letter-spacing: 0.05em; margin-left: 0.35rem;">SALE</span>'
            : '';

          tokenDiv.innerHTML = `
            <input type="checkbox" id="token_${escapeHtml(token.symbol)}" value="${token.address}"
                   style="margin-right: 1rem; width: 20px; height: 20px; cursor: pointer; accent-color: var(--fg);" checked>
            <div class="token-icon" style="width: 28px; height: 28px; margin-right: 1rem; flex-shrink: 0;">${token.icon}</div>
            <div style="flex: 1;">
              <div style="font-size: 0.8rem; color: var(--fg); margin-bottom: 0.2rem; line-height: 1.3;">${escapeHtml(token.symbol)}${saleBadge}</div>
              <div style="font-size: 0.75rem; color: var(--fg-dim); line-height: 1.3;">Balance: ${formattedBalance}</div>
            </div>
          `;

          tokenList.appendChild(tokenDiv);

          const checkbox = tokenDiv.querySelector('input[type="checkbox"]');

          // Function to update visual state
          const updateVisualState = () => {
            if (checkbox.checked) {
              tokenDiv.style.background = cssVar('--surface-hover');
              tokenDiv.style.borderColor = cssVar('--fg');
              tokenDiv.style.borderWidth = '2px';
            } else {
              tokenDiv.style.background = cssVar('--surface');
              tokenDiv.style.borderColor = cssVar('--border-muted');
              tokenDiv.style.borderWidth = '1px';
            }
          };

          // Hover effects
          tokenDiv.onmouseover = () => {
            if (checkbox.checked) {
              tokenDiv.style.borderColor = cssVar('--fg');
              tokenDiv.style.background = cssVar('--surface');
            } else {
              tokenDiv.style.borderColor = cssVar('--border-muted');
              tokenDiv.style.background = cssVar('--surface-hover');
            }
          };

          tokenDiv.onmouseout = () => {
            updateVisualState();
          };

          // Make the whole div clickable to toggle checkbox
          tokenDiv.onclick = (e) => {
            if (e.target.tagName !== 'INPUT') {
              checkbox.checked = !checkbox.checked;
            }
            updateVisualState();
          };

          // Listen for checkbox changes
          checkbox.onchange = () => {
            updateVisualState();
          };
        });

        modal.classList.add('active');
        document.body.classList.add('modal-open');
      }

      function closeRagequitModal() {
        getEl('ragequitModal').classList.remove('active');
        document.body.classList.remove('modal-open');
      }

      // Add custom token to ragequit list
      async function addCustomRagequitToken() {
        const input = document.getElementById('ragequitCustomTokenInput');
        const tokenAddress = input.value.trim();

        if (!tokenAddress || !ethers.isAddress(tokenAddress)) {
          showStatus('Invalid token address', true);
          return;
        }

        // Normalize address
        const normalizedAddress = ethers.getAddress(tokenAddress);

        // Check if already added (standard or custom)
        const tokenList = getEl('ragequitTokenList');
        const existingCheckbox = tokenList.querySelector(`input[value="${normalizedAddress}"]`);
        if (existingCheckbox) {
          showStatus('Token already in list', true);
          return;
        }

        // Check if it's a forbidden address
        const normalizedLower = normalizedAddress.toLowerCase();
        if (normalizedLower === currentDAO.dao.meta.sharesToken?.toLowerCase() ||
            normalizedLower === currentDAO.dao.meta.lootToken?.toLowerCase() ||
            normalizedLower === currentDAO.dao.dao?.toLowerCase() ||
            normalizedLower === '0x00000000000000000000000000000000000003ef') {
          showStatus('Cannot ragequit with shares, loot, or DAO tokens', true);
          return;
        }

        try {
          showStatus('Fetching token info...', false);

          const tokenContract = new ethers.Contract(normalizedAddress, ERC20_ABI, provider);

          // Fetch token info
          const [symbol, decimals, balance] = await Promise.all([
            tokenContract.symbol().catch(() => 'UNKNOWN'),
            tokenContract.decimals().catch(() => 18),
            tokenContract.balanceOf(currentDAO.dao.dao).catch(() => 0n)
          ]);

          const formattedBalance = parseFloat(ethers.formatUnits(balance, decimals)).toFixed(4);

          // Create token div
          const tokenDiv = document.createElement('div');
          tokenDiv.style.cssText = 'display: flex; align-items: center; padding: 0.7rem; background: transparent; border: 1px solid var(--border-muted); cursor: pointer; transition: all 0.3s ease; ';
          tokenDiv.onmouseover = () => tokenDiv.style.borderColor = cssVar('--fg-dim');
          tokenDiv.onmouseout = () => tokenDiv.style.borderColor = cssVar('--border-muted');

          // Custom token icon (generic coin)
          const customIcon = `<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
            <circle cx="16" cy="16" r="14" fill="none" stroke="currentColor" stroke-width="2"/>
            <path d="M16 8v16M8 16h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
          </svg>`;

          tokenDiv.innerHTML = `
            <input type="checkbox" id="token_custom_${normalizedAddress}" value="${normalizedAddress}"
                   style="margin-right: 1rem; width: 20px; height: 20px; cursor: pointer;" checked>
            <div class="token-icon" style="width: 28px; height: 28px; margin-right: 1rem; flex-shrink: 0;">${customIcon}</div>
            <div style="flex: 1; min-width: 0;">
              <div style="font-size: 0.8rem; color: var(--fg); margin-bottom: 0.2rem; line-height: 1.3;">${symbol} <span style="font-size: 0.65rem; opacity: 0.6;">(Custom)</span></div>
              <div style="font-size: 0.75rem; color: var(--fg-dim); line-height: 1.3;">Balance: ${formattedBalance}</div>
              <div style="font-size: 0.65rem; color: var(--fg-dim); margin-top: 0.15rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${normalizedAddress}</div>
            </div>
            <button onclick="removeCustomRagequitToken('${normalizedAddress}')"
                    style="padding: 0.35rem 0.6rem; background: var(--status-error); border: 1px solid var(--red); color: var(--red); font-size: 0.65rem; cursor: pointer; white-space: nowrap; flex-shrink: 0; margin-left: 0.5rem;"
                    onmouseover="this.style.background='var(--status-error)'"
                    onmouseout="this.style.background='var(--status-error)'">
              Remove
            </button>
          `;

          tokenDiv.onclick = (e) => {
            if (e.target.type !== 'checkbox' && e.target.tagName !== 'BUTTON') {
              const checkbox = tokenDiv.querySelector('input[type="checkbox"]');
              checkbox.checked = !checkbox.checked;
            }
          };

          tokenList.appendChild(tokenDiv);

          // Store custom token info
          ragequitCustomTokens.push({ address: normalizedAddress, symbol, decimals });

          // Clear input
          input.value = '';
          showStatus(`Added ${symbol} to ragequit list`, false);

        } catch (error) {
          logger.error('Error fetching custom token:', error);
          showStatus('Failed to fetch token info', true);
        }
      }

      // Remove custom token from ragequit list
      function removeCustomRagequitToken(address) {
        const tokenList = getEl('ragequitTokenList');
        const tokenDiv = tokenList.querySelector(`input[value="${address}"]`)?.closest('div[style*="display: flex"]');
        if (tokenDiv) {
          tokenDiv.remove();
        }
        ragequitCustomTokens = ragequitCustomTokens.filter(t => t.address !== address);
        showStatus('Token removed', false);
      }

      // Set max shares in ragequit modal
      function setRagequitMaxShares() {
        const sharesText = document.getElementById('ragequitUserShares')?.textContent;
        if (sharesText && sharesText !== '0') {
          const input = getEl('ragequitSharesInput');
          input.value = sharesText;

          // Visual feedback
          input.style.borderColor = '#000';
          setTimeout(() => {
            input.style.borderColor = cssVar('--border-muted');
          }, 500);
        }
      }

      // Set max loot in ragequit modal
      function setRagequitMaxLoot() {
        const lootText = document.getElementById('ragequitUserLoot')?.textContent;
        if (lootText && lootText !== '0') {
          const input = getEl('ragequitLootInput');
          input.value = lootText;

          // Visual feedback
          input.style.borderColor = '#000';
          setTimeout(() => {
            input.style.borderColor = cssVar('--border-muted');
          }, 500);
        }
      }

      async function executeRagequit() {
        try {
          if (!signer || !currentDAO) {
            showStatus('No wallet connected or DAO selected', true);
            return;
          }

          // Get input values
          const sharesInput = getEl('ragequitSharesInput').value.trim();
          const lootInput = getEl('ragequitLootInput').value.trim();

          if (!sharesInput && !lootInput) {
            showStatus('Please enter shares or loot to burn', true);
            return;
          }

          const sharesToBurn = sharesInput ? ethers.parseUnits(sharesInput, 18) : 0n;
          const lootToBurn = lootInput ? ethers.parseUnits(lootInput, 18) : 0n;

          if (sharesToBurn === 0n && lootToBurn === 0n) {
            showStatus('Must burn at least some shares or loot', true);
            return;
          }

          // Get selected tokens (includes both standard and custom tokens)
          const checkboxes = document.querySelectorAll('#ragequitTokenList input[type="checkbox"]:checked');
          if (checkboxes.length === 0) {
            showStatus('Please select at least one token to claim', true);
            return;
          }

          const tokenAddresses = Array.from(checkboxes).map(cb => cb.value);

          // CRITICAL: Sort addresses in strictly ascending order (required by contract)
          // Contract checks: if (i != 0 && tk <= prev) revert NotOk();
          // This means each address must be > previous address (no equals, no descending)
          tokenAddresses.sort((a, b) => {
            const aBig = BigInt(a);
            const bBig = BigInt(b);
            return aBig < bBig ? -1 : aBig > bBig ? 1 : 0;
          });

          // Execute ragequit
          const daoContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, signer);

          showStatus('Executing ragequit...', false);
          const tx = await daoContract.ragequit(tokenAddresses, sharesToBurn, lootToBurn, getWalletConnectTxOverrides());

          showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);
          await tx.wait();

          showStatus(`âœ¨ Ragequit executed successfully! <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View transaction</a>`, false);
          closeRagequitModal();

          // Refresh DAO data
          await fetchUserDAOs();

          // Refresh current DAO view if still a member
          if (currentDAO) {
            const daoIndex = userDAOs.findIndex(udao =>
              udao.dao.dao.toLowerCase() === currentDAO.dao.dao.toLowerCase()
            );
            if (daoIndex !== -1) {
              await openDAO(daoIndex, 'user');
            } else {
              // User is no longer a member, go back to gallery
              backToGallery();
            }
          }

        } catch (error) {
          logger.error('Ragequit failed:', error);

          if (isUserRejection(error)) {
            showStatus('Ragequit cancelled', false);
            return;
          }

          let errorMessage = 'Ragequit failed';

          if (error.message?.includes('NotOk')) {
            errorMessage = 'Ragequit not allowed - DAO may not allow ragequitting';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message) {
            const msg = error.message.split('\n')[0];
            if (msg.length < 100) {
              errorMessage = msg;
            }
          }

          showStatus(errorMessage, true);
        }
      }

      // Transfer Receipt Modal Functions
      let currentTransferReceipt = null;

      function openTransferReceiptModal(receipt) {
        if (!currentDAO || !connectedAddress) {
          showStatus('No wallet connected or DAO selected', true);
          return;
        }

        currentTransferReceipt = receipt;

        // Helper function to truncate long IDs
        const truncateId = (id) => {
          const str = id.toString();
          if (str.length <= 20) return str;
          return `${str.slice(0, 10)}...${str.slice(-8)}`;
        };

        // Convert receipt ID from hex to decimal uint256
        const receiptIdDecimal = BigInt(receipt.receiptId).toString();

        // Display receipt info - convert hex to uint256 decimal
        const receiptIdEl = document.getElementById('transferReceiptId');
        receiptIdEl.setAttribute('data-full-id', receiptIdDecimal);
        receiptIdEl.setAttribute('data-hex-id', receipt.receiptId); // Keep hex for contract call
        receiptIdEl.textContent = truncateId(receiptIdDecimal);
        receiptIdEl.onclick = () => toggleFullId(receiptIdEl);

        const proposalIdEl = document.getElementById('transferProposalId');
        const proposalIdStr = receipt.proposalId.toString();
        proposalIdEl.setAttribute('data-full-id', proposalIdStr);
        proposalIdEl.textContent = proposalIdStr.length > 15 ? truncateId(proposalIdStr) : `#${proposalIdStr}`;
        proposalIdEl.onclick = () => toggleFullId(proposalIdEl);

        document.getElementById('transferAvailableAmount').textContent = ethers.formatUnits(receipt.balance, 18);

        // Clear inputs
        document.getElementById('transferRecipient').value = '';
        getEl('transferAmount').value = '';

        // Show modal
        getEl('transferReceiptModal').classList.add('active');
        document.body.classList.add('modal-open');
      }

      function toggleFullId(element) {
        const fullId = element.getAttribute('data-full-id');
        const currentText = element.textContent;
        const isProposal = element.id === 'transferProposalId';

        if (currentText.includes('...')) {
          // Show full ID
          element.textContent = isProposal && fullId.length <= 15 ? `#${fullId}` : fullId;
          element.style.wordBreak = 'break-all';
        } else {
          // Show truncated
          const truncated = fullId.length <= 20 ? fullId : `${fullId.slice(0, 10)}...${fullId.slice(-8)}`;
          element.textContent = truncated;
          element.style.wordBreak = 'normal';
        }
      }

      function closeTransferReceiptModal() {
        getEl('transferReceiptModal').classList.remove('active');
        document.body.classList.remove('modal-open');
        currentTransferReceipt = null;
      }

      function setTransferMaxAmount() {
        const availableAmountEl = document.getElementById('transferAvailableAmount');
        if (availableAmountEl) {
          const input = getEl('transferAmount');
          input.value = availableAmountEl.textContent;

          // Visual feedback
          input.style.borderColor = '#000';
          setTimeout(() => {
            input.style.borderColor = cssVar('--border-muted');
          }, 500);
        }
      }

      function copyReceiptId() {
        const receiptIdEl = document.getElementById('transferReceiptId');
        const fullReceiptId = receiptIdEl.getAttribute('data-full-id');

        navigator.clipboard.writeText(fullReceiptId).then(() => {
          const btn = document.getElementById('copyReceiptBtn');
          const originalText = btn.textContent;
          btn.textContent = 'Copied!';
          btn.style.background = cssVar('--status-success');
          btn.style.borderColor = cssVar('--green');
          btn.style.color = cssVar('--green');
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = cssVar('--surface-hover');
            btn.style.borderColor = cssVar('--border-muted');
            btn.style.color = '#000';
          }, 2000);
        }).catch(err => {
          logger.error('Failed to copy:', err);
          showStatus('Failed to copy to clipboard', true);
        });
      }

      async function executeReceiptTransfer() {
        try {
          if (!signer || !currentDAO || !currentTransferReceipt) {
            showStatus('No wallet connected or DAO selected', true);
            return;
          }

          const recipientInput = document.getElementById('transferRecipient').value.trim();
          const amountInput = getEl('transferAmount').value.trim();

          if (!recipientInput) {
            showStatus('Please enter a recipient address or ENS', true);
            return;
          }

          if (!amountInput || isNaN(parseFloat(amountInput)) || parseFloat(amountInput) <= 0) {
            showStatus('Please enter a valid amount', true);
            return;
          }

          const amount = ethers.parseUnits(amountInput, 18);

          // Check if amount exceeds balance
          if (amount > currentTransferReceipt.balance) {
            showStatus('Amount exceeds available balance', true);
            return;
          }

          // Resolve ENS or validate address
          let recipientAddress;
          try {
            if (recipientInput.endsWith('.eth')) {
              showStatus('Resolving ENS name...', false);
              recipientAddress = await provider.resolveName(recipientInput);
              if (!recipientAddress) {
                showStatus('ENS name not found', true);
                return;
              }
            } else {
              if (!ethers.isAddress(recipientInput)) {
                showStatus('Invalid address', true);
                return;
              }
              recipientAddress = ethers.getAddress(recipientInput);
            }
          } catch (error) {
            logger.error('Error resolving address:', error);
            showStatus('Invalid address or ENS name', true);
            return;
          }

          // Execute transfer using ERC6909 transfer function
          const daoContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, signer);

          // Use hex receipt ID for contract call (ethers accepts hex strings)
          const receiptIdHex = currentTransferReceipt.receiptId;

          showStatus('Transferring receipt...', false);
          const tx = await daoContract.transfer(recipientAddress, receiptIdHex, amount, getWalletConnectTxOverrides());

          showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);
          await tx.wait();

          showStatus(`âœ¨ Receipt transferred successfully! <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View transaction</a>`, false);

          closeTransferReceiptModal();

          // Refresh membership to update receipt balances
          if (currentDAO.member) {
            await renderVoteReceipts();
          }

        } catch (error) {
          logger.error('Transfer failed:', error);

          if (isUserRejection(error)) {
            showStatus('Transaction cancelled by user', false);
            return;
          }

          let errorMessage = 'Transfer failed';

          if (error.message?.includes('NotOk')) {
            errorMessage = 'Transfer not allowed';
          } else if (error.message?.includes('insufficient')) {
            errorMessage = 'Insufficient balance';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message) {
            const msg = error.message.split('\n')[0];
            if (msg.length < 100) {
              errorMessage = msg;
            }
          }

          showStatus(errorMessage, true);
        }
      }

      // DEPOSIT MODAL FUNCTIONS
      let depositAssets = [];
      let selectedDepositAssetIndex = null;

      async function openDepositModal() {
        if (!signer || !currentDAO) {
          showStatus('Please connect wallet and select a DAO first', true);
          return;
        }

        const modal = document.getElementById('depositModal');
        modal.classList.add('active');
        document.body.classList.add('modal-open');

        // Set DAO address
        document.getElementById('depositDaoAddress').textContent = currentDAO.dao.dao;

        // Populate asset dropdown
        const dropdown = getEl('depositAssetDropdown');
        dropdown.innerHTML = '';

        depositAssets = [];

        // Add standard assets with icons (network-specific)
        const standardAssets = getNetworkTokens();

        for (const asset of standardAssets) {
          depositAssets.push(asset);
          const option = document.createElement('div');
          const index = depositAssets.length - 1;
          option.onclick = () => selectDepositAsset(index);
          option.style.cssText = 'padding: 0.7rem; display: flex; align-items: center; gap: 0.5rem; cursor: pointer; transition: background 0.2s;';
          option.onmouseover = () => option.style.background = cssVar('--surface-hover');
          option.onmouseout = () => option.style.background = 'transparent';
          option.innerHTML = `
            <div style="width: 24px; height: 24px; flex-shrink: 0;">${asset.icon}</div>
            <span style="color: #000; font-size: 0.9rem;">${escapeHtml(asset.symbol)}</span>
          `;
          dropdown.appendChild(option);
        }

        // Add custom sale tokens (skip tokens already listed)
        if (customSaleTokens.length > 0) {
          const existingAddrs = new Set(depositAssets.map(a => a.address.toLowerCase()));
          for (const customToken of customSaleTokens) {
            if (existingAddrs.has(customToken.address.toLowerCase())) continue;
            depositAssets.push({
              symbol: customToken.symbol,
              address: customToken.address,
              decimals: customToken.decimals,
              icon: TOKEN_ICONS.defaultCoin
            });
            const option = document.createElement('div');
            const index = depositAssets.length - 1;
            option.onclick = () => selectDepositAsset(index);
            option.style.cssText = 'padding: 0.7rem; display: flex; align-items: center; gap: 0.5rem; cursor: pointer; transition: background 0.2s;';
            option.onmouseover = () => option.style.background = cssVar('--surface-hover');
            option.onmouseout = () => option.style.background = 'transparent';
            option.innerHTML = `
              <div style="width: 24px; height: 24px; flex-shrink: 0;">${TOKEN_ICONS.defaultCoin}</div>
              <span style="color: #000; font-size: 0.9rem;">${escapeHtml(customToken.symbol)} <span style="font-size: 0.75rem; opacity: 0.6;">(SALE)</span></span>
            `;
            dropdown.appendChild(option);
          }
        }

        // Reset form
        selectedDepositAssetIndex = null;
        document.getElementById('depositAssetDisplay').innerHTML = '<span>Choose an asset...</span>';
        getEl('depositAmount').value = '';
        getEl('depositUserBalance').textContent = '0';
      }

      function toggleDepositAssetDropdown() {
        const dropdown = getEl('depositAssetDropdown');
        dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
      }

      async function selectDepositAsset(index) {
        selectedDepositAssetIndex = index;
        const asset = depositAssets[index];

        // Update display
        const display = document.getElementById('depositAssetDisplay');
        display.innerHTML = `
          <div style="width: 24px; height: 24px; flex-shrink: 0;">${asset.icon}</div>
          <span>${asset.symbol}</span>
        `;

        // Close dropdown
        getEl('depositAssetDropdown').style.display = 'none';

        // Update balance
        await updateDepositBalance();
      }

      function closeDepositModal() {
        document.getElementById('depositModal').classList.remove('active');
        document.body.classList.remove('modal-open');
      }

      async function updateDepositBalance() {
        if (selectedDepositAssetIndex === null) {
          getEl('depositUserBalance').textContent = '0';
          return;
        }

        const asset = depositAssets[selectedDepositAssetIndex];

        try {
          const addr = await signer.getAddress();
          let balance;
          if (asset.address === ethers.ZeroAddress) {
            balance = await provider.getBalance(addr);
          } else {
            const tokenContract = new ethers.Contract(asset.address, ERC20_ABI, provider);
            balance = await tokenContract.balanceOf(addr);
          }

          const formatted = parseFloat(ethers.formatUnits(balance, asset.decimals)).toFixed(4);
          getEl('depositUserBalance').textContent = `${formatted} ${asset.symbol}`;
          getEl('depositUserBalance').dataset.rawBalance = balance.toString();
          getEl('depositUserBalance').dataset.decimals = asset.decimals;
        } catch (error) {
          logger.error('Error fetching balance:', error);
          getEl('depositUserBalance').textContent = '0';
        }
      }

      function setDepositMax() {
        const balanceEl = getEl('depositUserBalance');
        const rawBalance = balanceEl.dataset.rawBalance;
        const decimals = balanceEl.dataset.decimals;

        if (!rawBalance || !decimals) {
          showStatus('Please select an asset first', true);
          return;
        }

        try {
          const formatted = ethers.formatUnits(rawBalance, decimals);
          getEl('depositAmount').value = formatted;

          // Visual feedback
          const input = getEl('depositAmount');
          input.style.borderColor = '#000';
          setTimeout(() => {
            input.style.borderColor = cssVar('--border-muted');
          }, 500);
        } catch (error) {
          logger.error('Error setting max:', error);
          showStatus('Failed to set max amount', true);
        }
      }

      async function executeDeposit() {
        try {
          if (!signer || !currentDAO) {
            showStatus('No wallet connected or DAO selected', true);
            return;
          }

          if (selectedDepositAssetIndex === null) {
            showStatus('Please select an asset', true);
            return;
          }

          const asset = depositAssets[selectedDepositAssetIndex];
          const amountInput = getEl('depositAmount').value.trim();

          if (!amountInput || isNaN(parseFloat(amountInput)) || parseFloat(amountInput) <= 0) {
            showStatus('Please enter a valid amount', true);
            return;
          }

          const amount = ethers.parseUnits(amountInput, asset.decimals);

          // Check balance
          const balanceEl = getEl('depositUserBalance');
          const rawBalance = BigInt(balanceEl.dataset.rawBalance || '0');

          if (amount > rawBalance) {
            showStatus('Amount exceeds your balance', true);
            return;
          }

          const daoAddress = currentDAO.dao.dao;

          if (asset.address === ethers.ZeroAddress) {
            // ETH deposit - simple transfer
            showStatus('Depositing ETH...', false);
            const tx = await signer.sendTransaction(getWalletConnectTxOverrides({
              to: daoAddress,
              value: amount
            }));

            showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);
            await tx.wait();

            showStatus(`âœ¨ Deposited ${amountInput} ETH successfully! <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View transaction</a>`, false);
          } else {
            // ERC20 deposit - transfer to DAO
            const tokenContract = new ethers.Contract(asset.address, ERC20_ABI, signer);

            showStatus(`Depositing ${asset.symbol}...`, false);
            const tx = await tokenContract.transfer(daoAddress, amount, getWalletConnectTxOverrides());

            showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);
            await tx.wait();

            showStatus(`âœ¨ Deposited ${amountInput} ${asset.symbol} successfully! <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View transaction</a>`, false);
          }

          closeDepositModal();

          // Refresh treasury display
          setTimeout(async () => {
            await renderTreasury();
          }, 2000);

        } catch (error) {
          logger.error('Deposit failed:', error);

          if (isUserRejection(error)) {
            showStatus('Transaction cancelled by user', false);
            return;
          }

          let errorMessage = 'Deposit failed';

          if (error.message?.includes('insufficient')) {
            errorMessage = 'Insufficient balance or gas';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message) {
            const msg = error.message.split('\n')[0];
            if (msg.length < 100) {
              errorMessage = msg;
            }
          }

          showStatus(errorMessage, true);
        }
      }

      // Tribute Modal Functions
      let tributeAssets = [];
      let selectedTributeAssetIndex = null;
      let requestAssets = [];
      let selectedRequestAssetIndex = null;

      async function openTributeModal() {
        if (!signer || !currentDAO) {
          showStatus('Please connect wallet and select a DAO first', true);
          return;
        }

        const modal = getEl('tributeModal');
        modal.classList.add('active');
        document.body.classList.add('modal-open');

        // Populate tribute asset dropdown (what user offers)
        const tributeDropdown = getEl('tributeAssetDropdown');
        tributeDropdown.innerHTML = '';
        tributeAssets = [];

        // Add standard assets (network-specific)
        const standardAssets = getNetworkTokens();

        for (const asset of standardAssets) {
          tributeAssets.push(asset);
          const option = document.createElement('div');
          const index = tributeAssets.length - 1;
          option.onclick = () => selectTributeAsset(index);
          option.style.cssText = 'padding: 0.7rem; display: flex; align-items: center; gap: 0.5rem; cursor: pointer; transition: background 0.2s;';
          option.onmouseover = () => option.style.background = cssVar('--surface-hover');
          option.onmouseout = () => option.style.background = 'transparent';
          option.innerHTML = `
            <div style="width: 24px; height: 24px; flex-shrink: 0;">${asset.icon}</div>
            <span style="color: #000; font-size: 0.9rem;">${escapeHtml(asset.symbol)}</span>
          `;
          tributeDropdown.appendChild(option);
        }

        // Populate request asset dropdown (what user wants from DAO treasury)
        const requestDropdown = getEl('requestAssetDropdown');
        requestDropdown.innerHTML = '';
        requestAssets = [];

        // Prioritize Shares and Loot at the top
        const daoMeta = currentDAO.dao.meta;
        const priorityAssets = [
          { symbol: 'Shares', address: daoMeta.sharesToken, decimals: 18, icon: TOKEN_ICONS.defaultCoin, isGovernanceToken: true },
          { symbol: 'Loot', address: daoMeta.lootToken, decimals: 18, icon: TOKEN_ICONS.defaultCoin, isGovernanceToken: true }
        ];

        for (const asset of priorityAssets) {
          requestAssets.push(asset);
          const option = document.createElement('div');
          const index = requestAssets.length - 1;
          option.onclick = () => selectRequestAsset(index);
          option.style.cssText = 'padding: 0.7rem; display: flex; align-items: center; gap: 0.5rem; cursor: pointer; transition: background 0.2s; border-bottom: 1px solid var(--border-muted);';
          option.onmouseover = () => option.style.background = cssVar('--surface-hover');
          option.onmouseout = () => option.style.background = 'transparent';
          option.innerHTML = `
            <div style="width: 24px; height: 24px; flex-shrink: 0;">${asset.icon}</div>
            <span style="color: #000; font-size: 0.9rem;">${asset.symbol}</span>
            <span style="font-size: 0.7rem; color: var(--fg-muted); margin-left: auto;">GOVERNANCE</span>
          `;
          requestDropdown.appendChild(option);
        }

        // Add standard treasury assets
        for (const asset of standardAssets) {
          requestAssets.push(asset);
          const option = document.createElement('div');
          const index = requestAssets.length - 1;
          option.onclick = () => selectRequestAsset(index);
          option.style.cssText = 'padding: 0.7rem; display: flex; align-items: center; gap: 0.5rem; cursor: pointer; transition: background 0.2s;';
          option.onmouseover = () => option.style.background = cssVar('--surface-hover');
          option.onmouseout = () => option.style.background = 'transparent';
          option.innerHTML = `
            <div style="width: 24px; height: 24px; flex-shrink: 0;">${asset.icon}</div>
            <span style="color: #000; font-size: 0.9rem;">${escapeHtml(asset.symbol)}</span>
          `;
          requestDropdown.appendChild(option);
        }

        // Reset form
        selectedTributeAssetIndex = null;
        selectedRequestAssetIndex = null;
        getEl('tributeAssetDisplay').innerHTML = '<span>Choose asset to offer...</span>';
        getEl('requestAssetDisplay').innerHTML = '<span>Choose asset to request...</span>';
        document.getElementById('tributeAmount').value = '';
        document.getElementById('requestAmount').value = '';
        getEl('tributeUserBalance').textContent = '0';
      }

      function toggleTributeAssetDropdown() {
        const dropdown = getEl('tributeAssetDropdown');
        dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
      }

      function toggleRequestAssetDropdown() {
        const dropdown = getEl('requestAssetDropdown');
        dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
      }

      async function selectTributeAsset(index) {
        selectedTributeAssetIndex = index;
        const asset = tributeAssets[index];

        const display = getEl('tributeAssetDisplay');
        display.innerHTML = `
          <div style="width: 24px; height: 24px; flex-shrink: 0;">${asset.icon}</div>
          <span>${asset.symbol}</span>
        `;

        getEl('tributeAssetDropdown').style.display = 'none';

        // Update balance
        await updateTributeBalance();
      }

      async function selectRequestAsset(index) {
        selectedRequestAssetIndex = index;
        const asset = requestAssets[index];

        const display = getEl('requestAssetDisplay');
        display.innerHTML = `
          <div style="width: 24px; height: 24px; flex-shrink: 0;">${asset.icon}</div>
          <span>${asset.symbol}</span>
        `;

        getEl('requestAssetDropdown').style.display = 'none';
      }

      async function updateTributeBalance() {
        if (selectedTributeAssetIndex === null) {
          getEl('tributeUserBalance').textContent = '0';
          return;
        }

        const asset = tributeAssets[selectedTributeAssetIndex];

        try {
          const addr = await signer.getAddress();
          let balance;
          if (asset.address === ethers.ZeroAddress) {
            balance = await provider.getBalance(addr);
          } else {
            const tokenContract = new ethers.Contract(asset.address, ERC20_ABI, provider);
            balance = await tokenContract.balanceOf(addr);
          }

          const formatted = parseFloat(ethers.formatUnits(balance, asset.decimals)).toFixed(4);
          getEl('tributeUserBalance').textContent = `${formatted} ${asset.symbol}`;
        } catch (error) {
          logger.error('Error fetching balance:', error);
          getEl('tributeUserBalance').textContent = '0';
        }
      }

      function closeTributeModal() {
        getEl('tributeModal').classList.remove('active');
        document.body.classList.remove('modal-open');
      }

      async function executeTribute() {
        try {
          if (!signer || !currentDAO) {
            showStatus('No wallet connected or DAO selected', true);
            return;
          }

          if (selectedTributeAssetIndex === null) {
            showStatus('Please select an asset to offer', true);
            return;
          }

          if (selectedRequestAssetIndex === null) {
            showStatus('Please select an asset to request', true);
            return;
          }

          const tribAsset = tributeAssets[selectedTributeAssetIndex];
          const reqAsset = requestAssets[selectedRequestAssetIndex];

          const tribAmountInput = document.getElementById('tributeAmount').value.trim();
          const reqAmountInput = document.getElementById('requestAmount').value.trim();

          if (!tribAmountInput || isNaN(parseFloat(tribAmountInput)) || parseFloat(tribAmountInput) <= 0) {
            showStatus('Please enter a valid tribute amount', true);
            return;
          }

          if (!reqAmountInput || isNaN(parseFloat(reqAmountInput)) || parseFloat(reqAmountInput) <= 0) {
            showStatus('Please enter a valid request amount', true);
            return;
          }

          const tribAmt = ethers.parseUnits(tribAmountInput, tribAsset.decimals);
          const forAmt = ethers.parseUnits(reqAmountInput, reqAsset.decimals);

          const tributeContract = new ethers.Contract(TRIBUTE_ADDRESS, TRIBUTE_ABI, signer);
          const daoAddress = currentDAO.dao.dao;

          showStatus('Creating tribute offer...', false);

          let tx;
          if (tribAsset.address === ethers.ZeroAddress) {
            // ETH tribute
            tx = await tributeContract.proposeTribute(
              daoAddress,
              ethers.ZeroAddress,
              0,
              reqAsset.address,
              forAmt,
              getWalletConnectTxOverrides({ value: tribAmt })
            );
          } else {
            // ERC20 tribute - check allowance and approve if needed
            const tokenContract = new ethers.Contract(tribAsset.address, ERC20_ABI, signer);
            const userAddress = await signer.getAddress();
            const allowance = await tokenContract.allowance(userAddress, TRIBUTE_ADDRESS);

            if (allowance < tribAmt) {
              showStatus('Approving token transfer...', false);
              const approveTx = await tokenContract.approve(TRIBUTE_ADDRESS, tribAmt, getWalletConnectTxOverrides());
              showStatus(`Approval submitted. <a href="${getNetwork().explorer}/tx/${approveTx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);
              await approveTx.wait();
              showStatus('Approval confirmed. Creating tribute...', false);
            }

            tx = await tributeContract.proposeTribute(
              daoAddress,
              tribAsset.address,
              tribAmt,
              reqAsset.address,
              forAmt,
              getWalletConnectTxOverrides()
            );
          }

          showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);
          await tx.wait();

          showStatus(`âœ¨ Tribute offer created successfully! <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View transaction</a>`, false);

          closeTributeModal();
          await renderTributes();

        } catch (error) {
          logger.error('Error creating tribute:', error);

          let errorMessage = 'Failed to create tribute';
          if (error.code === 'ACTION_REJECTED') {
            errorMessage = 'Transaction rejected by user';
          } else if (error.message?.includes('insufficient funds')) {
            errorMessage = 'Insufficient balance or gas';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          }

          showStatus(errorMessage, true);
        }
      }

      // Clear tribute helper UI
      function clearTributeHelper() {
        const helper = document.getElementById('tributeHelper');
        if (helper) helper.remove();
      }

      // Accept tribute - populate proposal form with batchCalls to claim tribute
      async function acceptTributeProposal(index) {
        if (!signer || !currentDAO) {
          showStatus('Please connect wallet', true);
          return;
        }

        // Check membership - only members can sponsor proposals
        const memberShares = BigInt(currentDAO.member?.shares || 0);
        const memberLoot = BigInt(currentDAO.member?.loot || 0);
        if (!currentDAO.member || (memberShares === 0n && memberLoot === 0n)) {
          showStatus('Only DAO members can sponsor tribute claims', true);
          return;
        }

        const tribute = currentDaoTributes[index];
        if (!tribute) return;

        try {
          showStatus('Preparing tribute claim proposal...', false);

          // Get token info
          let tribSymbol = 'ETH';
          let tribDecimals = 18;
          let forSymbol = 'ETH';
          let forDecimals = 18;

          if (tribute.tribTkn !== ethers.ZeroAddress) {
            tribSymbol = await getTokenSymbol(tribute.tribTkn);
            tribDecimals = await getTokenDecimals(tribute.tribTkn);
          }

          if (tribute.forTkn !== ethers.ZeroAddress) {
            forSymbol = await getTokenSymbol(tribute.forTkn);
            forDecimals = await getTokenDecimals(tribute.forTkn);
          }

          const tribBalance = parseFloat(ethers.formatUnits(tribute.tribAmt, tribDecimals)).toFixed(4);
          const forBalance = parseFloat(ethers.formatUnits(tribute.forAmt, forDecimals)).toFixed(4);

          const daoAddress = currentDAO.dao.dao;

          // Build the multicall based on what is being requested
          const calls = [];
          const isSharesOrLoot = tribute.forTkn.toLowerCase() === currentDAO.dao.meta.sharesToken.toLowerCase() ||
                                  tribute.forTkn.toLowerCase() === currentDAO.dao.meta.lootToken.toLowerCase();

          if (isSharesOrLoot) {
            // Case 1: Requesting Shares or Loot - need to mint first
            // Step 1: Mint the tokens to the DAO itself (so it can then send to Tribute contract)
            const mintInterface = new ethers.Interface(['function mintFromMoloch(address,uint256)']);
            const mintCalldata = mintInterface.encodeFunctionData('mintFromMoloch', [daoAddress, tribute.forAmt]);
            calls.push([tribute.forTkn, 0n, mintCalldata]);

            // Step 2: Approve Tribute contract to spend the tokens
            const approveInterface = new ethers.Interface(['function approve(address,uint256)']);
            const approveCalldata = approveInterface.encodeFunctionData('approve', [TRIBUTE_ADDRESS, tribute.forAmt]);
            calls.push([tribute.forTkn, 0n, approveCalldata]);

            // Step 3: Claim the tribute
            const tributeInterface = new ethers.Interface(TRIBUTE_ABI);
            const claimCalldata = tributeInterface.encodeFunctionData('claimTribute', [tribute.proposer, tribute.tribTkn]);
            calls.push([TRIBUTE_ADDRESS, 0n, claimCalldata]);
          } else if (tribute.forTkn !== ethers.ZeroAddress) {
            // Case 2: Requesting regular ERC20 - just approve and claim
            // Step 1: Approve Tribute contract
            const approveInterface = new ethers.Interface(['function approve(address,uint256)']);
            const approveCalldata = approveInterface.encodeFunctionData('approve', [TRIBUTE_ADDRESS, tribute.forAmt]);
            calls.push([tribute.forTkn, 0n, approveCalldata]);

            // Step 2: Claim the tribute
            const tributeInterface = new ethers.Interface(TRIBUTE_ABI);
            const claimCalldata = tributeInterface.encodeFunctionData('claimTribute', [tribute.proposer, tribute.tribTkn]);
            calls.push([TRIBUTE_ADDRESS, 0n, claimCalldata]);
          } else {
            // Case 3: Requesting ETH - send ETH with claim call
            const tributeInterface = new ethers.Interface(TRIBUTE_ABI);
            const claimCalldata = tributeInterface.encodeFunctionData('claimTribute', [tribute.proposer, tribute.tribTkn]);
            calls.push([TRIBUTE_ADDRESS, tribute.forAmt, claimCalldata]);
          }

          // Encode batchCalls for proposal execution (self-call from DAO)
          const batchCallsInterface = new ethers.Interface(['function batchCalls((address,uint256,bytes)[])']);
          const batchCallsCalldata = batchCallsInterface.encodeFunctionData('batchCalls', [calls]);

          // Create description
          const description = `Accept tribute: Receive ${tribBalance} ${tribSymbol} from ${tribute.proposer.slice(0, 6)}...${tribute.proposer.slice(-4)} in exchange for ${forBalance} ${forSymbol}`;

          // Clear any existing helpers
          clearTransferHelper();
          clearMintHelper();
          clearFutarchyHelper();
          clearRendererHelper();
          clearQuorumHelper();
          clearTTLHelper();
          clearTimelockDelayHelper();
          clearThresholdHelper();
          clearRagequitHelper();
          clearTransferabilityHelper();
          clearEmergencyPermitHelper();
          clearSaleHelper();
          clearAllowanceHelper();
          clearTributeHelper();

          // Scroll to proposal form
          const proposalForm = document.querySelector('.proposal-form');
          if (proposalForm) {
            proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }

          // Add tribute helper UI
          let helperDiv = document.createElement('div');
          helperDiv.id = 'tributeHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));

          helperDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
              <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
                TRIBUTE CLAIM
              </div>
              <button onclick="clearTributeHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
            </div>
            <div style="font-size: 0.8rem; color: var(--fg); margin-bottom: 0.5rem;">
              <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem;">
                <span>DAO Receives:</span>
                <span style="color: #000;">${escapeHtml(tribBalance)} ${escapeHtml(tribSymbol)}</span>
              </div>
              <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem;">
                <span>DAO Sends:</span>
                <span style="color: #ff9d7b;">${escapeHtml(forBalance)} ${escapeHtml(forSymbol)}</span>
              </div>
              <div style="display: flex; justify-content: space-between;">
                <span>To:</span>
                <span style="font-family: monospace; font-size: 0.75rem;">${tribute.proposer.slice(0, 10)}...${tribute.proposer.slice(-8)}</span>
              </div>
            </div>
            <div style="font-size: 0.7rem; color: var(--fg-dim); margin-top: 0.5rem;">
              Review the proposal below and submit to create a vote.
            </div>
          `;

          // Populate proposal form fields
          // Target is the DAO itself (self-call with batchCalls)
          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = batchCallsCalldata;

          // Use locked description with machine-readable tag
          const lockedDesc = `${description}\n\n<<<TRIBUTE_CLAIM tribToken=${tribute.tribTkn} tribAmount=${tribute.tribAmt.toString()} forToken=${tribute.forTkn} forAmount=${tribute.forAmt.toString()} proposer=${tribute.proposer} TRIBUTE_CLAIM>>>`;
          setLockedProposalDescription(lockedDesc, description);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated. Review and submit below.', false);

        } catch (error) {
          logger.error('Error preparing tribute claim proposal:', error);

          let errorMessage = 'Failed to prepare proposal';
          if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          }

          showStatus(errorMessage, true);
        }
      }

      // Cancel a tribute offer
      async function cancelTributeOffer(index) {
        if (!signer || !currentDAO) {
          showStatus('Please connect wallet', true);
          return;
        }

        const tribute = currentDaoTributes[index];
        if (!tribute) return;

        try {
          const userAddress = await signer.getAddress();
          if (tribute.proposer.toLowerCase() !== userAddress.toLowerCase()) {
            showStatus('You can only cancel your own tributes', true);
            return;
          }

          showStatus('Canceling tribute...', false);

          const tributeContract = new ethers.Contract(TRIBUTE_ADDRESS, TRIBUTE_ABI, signer);
          const tx = await tributeContract.cancelTribute(currentDAO.dao.dao, tribute.tribTkn, getWalletConnectTxOverrides());

          showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);
          await tx.wait();

          showStatus(`âœ¨ Tribute cancelled and refunded! <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View transaction</a>`, false);

          // Refresh tributes display
          await renderTributes();

        } catch (error) {
          logger.error('Error canceling tribute:', error);

          let errorMessage = 'Failed to cancel tribute';
          if (error.code === 'ACTION_REJECTED') {
            errorMessage = 'Transaction rejected by user';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          }

          showStatus(errorMessage, true);
        }
      }

      // Close modals when clicking outside
      document.addEventListener('DOMContentLoaded', () => {
        // Initialize token icons in summoning form
        initializeSalePaymentTokenIcons();

        const ragequitModal = getEl('ragequitModal');
        if (ragequitModal) {
          ragequitModal.addEventListener('click', (e) => {
            if (e.target === ragequitModal) {
              closeRagequitModal();
            }
          });
        }

        const transferReceiptModal = getEl('transferReceiptModal');
        if (transferReceiptModal) {
          transferReceiptModal.addEventListener('click', (e) => {
            if (e.target === transferReceiptModal) {
              closeTransferReceiptModal();
            }
          });
        }

        const purchaseModal = getEl('purchaseModal');
        if (purchaseModal) {
          purchaseModal.addEventListener('click', (e) => {
            if (e.target === purchaseModal) {
              closePurchaseModal();
            }
          });
        }

        const depositModal = document.getElementById('depositModal');
        if (depositModal) {
          depositModal.addEventListener('click', (e) => {
            if (e.target === depositModal) {
              closeDepositModal();
            }
          });
        }

        const tributeModal = getEl('tributeModal');
        if (tributeModal) {
          tributeModal.addEventListener('click', (e) => {
            if (e.target === tributeModal) {
              closeTributeModal();
            }
          });
        }

        // Close custom dropdowns when clicking outside
        document.addEventListener('click', (e) => {
          // Close deposit asset dropdown
          const depositAssetDisplay = document.getElementById('depositAssetDisplay');
          const depositAssetDropdown = getEl('depositAssetDropdown');
          if (depositAssetDropdown && !depositAssetDisplay?.contains(e.target) && !depositAssetDropdown.contains(e.target)) {
            depositAssetDropdown.style.display = 'none';
          }

          // Close sale payment token dropdown
          const salePaymentTokenDisplay = document.getElementById('salePaymentTokenDisplay');
          const salePaymentTokenDropdown = getEl('salePaymentTokenDropdown');
          if (salePaymentTokenDropdown && !salePaymentTokenDisplay?.contains(e.target) && !salePaymentTokenDropdown.contains(e.target)) {
            salePaymentTokenDropdown.style.display = 'none';
          }

          // Close proposal pay token dropdown
          const proposalPayTokenDisplay = document.getElementById('proposalPayTokenDisplay');
          const proposalPayTokenDropdown = getEl('proposalPayTokenDropdown');
          if (proposalPayTokenDropdown && !proposalPayTokenDisplay?.contains(e.target) && !proposalPayTokenDropdown.contains(e.target)) {
            proposalPayTokenDropdown.style.display = 'none';
          }

          // Close tribute asset dropdown
          const tributeAssetDisplay = getEl('tributeAssetDisplay');
          const tributeAssetDropdown = getEl('tributeAssetDropdown');
          if (tributeAssetDropdown && !tributeAssetDisplay?.contains(e.target) && !tributeAssetDropdown.contains(e.target)) {
            tributeAssetDropdown.style.display = 'none';
          }

          // Close request asset dropdown
          const requestAssetDisplay = getEl('requestAssetDisplay');
          const requestAssetDropdown = getEl('requestAssetDropdown');
          if (requestAssetDropdown && !requestAssetDisplay?.contains(e.target) && !requestAssetDropdown.contains(e.target)) {
            requestAssetDropdown.style.display = 'none';
          }
        });
      });

      // Fetch user's DAOs from View Helper
      async function fetchUserDAOs() {
        if (!connectedAddress) return [];

        const treasuryTokens = getNetwork().treasuryTokens;
        const userAddr = connectedAddress; // Capture in case it changes

        try {
          // Use RPC fallback for reliability (especially important for WalletConnect)
          const result = await withRpcFallback(async (activeProvider) => {
            const viewHelper = new ethers.Contract(VIEW_HELPER_ADDRESS, VIEW_HELPER_ABI, activeProvider);

            // Default params: start at DAO 0, fetch up to 10 DAOs, recent 20 proposals, messages
            return await viewHelper.getUserDAOsFullState(
              userAddr,
              0,  // daoStart
              10, // daoCount
              0,  // proposalStart
              20, // proposalCount (increased for better visibility)
              0,  // messageStart
              200, // messageCount (fetch many to ensure we see recent ones)
              treasuryTokens
            );
          });

          userDAOs = result;

          return userDAOs;
        } catch (error) {
          logger.error('Error fetching user DAOs:', error);
          return [];
        }
      }

      // Fetch DAICO data (sales, tap) for a specific DAO using batched view helper
      // This replaces many individual RPC calls with a single efficient call
      async function fetchDAICOData(daoAddress) {
        if (!daoAddress) return null;

        const treasuryTokens = getNetwork().treasuryTokens;
        const tribTokens = getNetwork().treasuryTokens; // Same tokens for tribute

        try {
          const result = await withRpcFallback(async (activeProvider) => {
            const viewHelper = new ethers.Contract(VIEW_HELPER_ADDRESS, VIEW_HELPER_ABI, activeProvider);

            // Single batched call that gets DAO state + DAICO sales + tap info
            return await viewHelper.getDAOWithDAICO(
              daoAddress,
              0,  // proposalStart (we already have proposals from initial load)
              0,  // proposalCount (skip proposals, already loaded)
              0,  // messageStart
              0,  // messageCount (skip messages, already loaded)
              treasuryTokens,
              tribTokens
            );
          });

          return result;
        } catch (error) {
          logger.error('Error fetching DAICO data:', error);
          return null;
        }
      }

      // Compute proposal ID (matches Solidity _intentHashId logic)
      //
      // MUST match exactly:
      //   Solidity: keccak256(abi.encode(address(this), op, to, value, keccak256(data), nonce, config))
      //   Types:    [address,            uint8, address, uint256, bytes32,         bytes32, uint256]
      //
      // Parameter requirements:
      //   - daoAddress: string (DAO contract address)
      //   - op: number 0-1 (0=call, 1=delegatecall)
      //   - to: string (target address)
      //   - value: BigInt (Wei amount, NOT ETH string!)
      //   - data: string (hex calldata, can be "0x" for empty)
      //   - nonce: string (hex bytes32, e.g., "0x0000...")
      //   - config: BigInt (from DAO's config() function)
      function computeProposalId(daoAddress, op, to, value, data, nonce, config) {
        const abiCoder = new ethers.AbiCoder();

        // Hash the calldata (Solidity: keccak256(data))
        const dataHash = ethers.keccak256(data);

        // Encode all parameters in the same order as Solidity
        const encoded = abiCoder.encode(
          ['address', 'uint8', 'address', 'uint256', 'bytes32', 'bytes32', 'uint256'],
          [daoAddress, op, to, value, dataHash, nonce, config]
        );

        // Return as BigInt for consistency
        return BigInt(ethers.keccak256(encoded));
      }

      // Encode proposal as tagged message (raw JSON for transparency)
      //
      // ARCHITECTURE NOTE: Moloch.sol stores only proposal IDs (hashes), not call data.
      // Chat messages serve as the "source of truth" for proposal parameters:
      //   - Proposal ID = hash(dao, op, to, value, keccak256(data), nonce, config)
      //   - Chat message contains all parameters needed for execution
      //   - UI can verify integrity by re-hashing and comparing to proposal ID
      //   - When executing, parameters are extracted from the tagged message
      //
      // This design saves gas (no redundant storage) while keeping everything on-chain.
      function encodeProposalMessage(op, to, value, data, nonce, description) {
        // Sanitize description to prevent delimiter collision
        const safeDescription = description
          .replace(/<<<PROPOSAL_DATA/g, '< <<PROPOSAL_DATA')
          .replace(/PROPOSAL_DATA>>>/g, 'PROPOSAL_DATA>> >');

        const proposalData = {
          type: 'PROPOSAL',
          op: op,
          to: to,
          value: value.toString(),
          data: data,
          nonce: nonce,
          description: safeDescription
        };

        // Use unique delimiters that won't appear in hex data or descriptions
        // Raw JSON (not base64) for transparency - anyone can read proposals in chat
        return `<<<PROPOSAL_DATA\n${JSON.stringify(proposalData, null, 2)}\nPROPOSAL_DATA>>>`;
      }

      // Decode proposal from tagged message
      function decodeProposalMessage(messageText) {
        // Match multiline content between delimiters
        const match = messageText.match(/<<<PROPOSAL_DATA\n([\s\S]*?)\nPROPOSAL_DATA>>>/);
        if (!match) return null;

        try {
          const decoded = JSON.parse(match[1]);
          if (decoded.type === 'PROPOSAL') {
            // Validate nonce is a proper bytes32 hex string (0x + 64 hex chars)
            if (typeof decoded.nonce !== 'string' || !/^0x[0-9a-fA-F]{64}$/.test(decoded.nonce)) {
              logger.error('Invalid proposal nonce format:', decoded.nonce);
              return null;
            }
            return decoded;
          }
        } catch (e) {
          logger.error('Failed to decode proposal message:', e);
        }

        return null;
      }

      // Render DAO gallery
      function renderDAOGallery() {
        const daoTiles = DOMCache.daoTiles;
        const daoGallery = DOMCache.daoGallery;

        if (!daoTiles) return;

        daoTiles.innerHTML = '';

        if (userDAOs.length === 0) {
          showFireLoading(daoTiles);
          daoGallery.classList.add('show');
          return;
        }

        userDAOs.forEach((userDAOLens, index) => {
          const dao = userDAOLens.dao;
          const member = userDAOLens.member;

          const tile = document.createElement('div');
          tile.className = 'dao-tile';
          tile.onclick = () => openDAO(index);

          const sharesBN = member.shares;
          const lootBN = member.loot;

          const sharesRaw = ethers.formatUnits(sharesBN, 18);
          const lootRaw = ethers.formatUnits(lootBN, 18);

          tile.innerHTML = `
            <div class="dao-tile-emblem" id="emblem-user-${index}"></div>
            <div class="dao-tile-name">${escapeHtml(dao.meta.name)}</div>
            <div class="dao-tile-symbol">${escapeHtml(dao.meta.symbol)}</div>
            <div class="dao-tile-stats">
              <div class="dao-stat">
                <div class="dao-stat-label">Your Shares</div>
                <div class="dao-stat-value" title="${sharesRaw}">${fmtBal(sharesRaw)}</div>
              </div>
              <div class="dao-stat">
                <div class="dao-stat-label">Your Loot</div>
                <div class="dao-stat-value" title="${lootRaw}">${fmtBal(lootRaw)}</div>
              </div>
              <div class="dao-stat">
                <div class="dao-stat-label">Proposals</div>
                <div class="dao-stat-value">${dao.proposals.length}</div>
              </div>
              <div class="dao-stat">
                <div class="dao-stat-label">Messages</div>
                <div class="dao-stat-value">${dao.messages.length}</div>
              </div>
            </div>
          `;

          daoTiles.appendChild(tile);

          // Render emblem asynchronously
          renderTileEmblem(dao.dao, `emblem-user-${index}`);
        });

        daoGallery.classList.add('show');
      }

      // Token SVG icons
      const TOKEN_ICONS = {
        eth: `<svg viewBox="0 0 32 32" version="1.1" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <style type="text/css">
            .st1{fill:#80D8FF;}
            .st4{fill:#55FB9B;}
            .st6{fill:#C1AEE1;}
            .st8{fill:#FF8A80;}
            .st10{fill:#FFF176;}
            .st16{fill:#42A5F5;}
            .st17{fill:#37474F;}
          </style>
          <g>
            <polygon class="st1" points="7.62,18.83 16.01,30.5 16.01,24.1"/>
            <polygon class="st16" points="16.01,30.5 24.38,18.78 16.01,24.1"/>
            <polygon class="st10" points="16.01,1.5 7.62,16.23 16.01,12.3"/>
            <polygon class="st8" points="24.38,16.18 16.01,1.5 16.01,12.3"/>
            <polygon class="st6" points="16.01,21.5 24.38,16.18 16.01,12.3"/>
            <polygon class="st4" points="16.01,12.3 7.62,16.23 16.01,21.5"/>
            <path class="st17" d="M16.01,22c-0.09,0-0.18-0.03-0.27-0.08l-8.39-5.27c-0.23-0.14-0.3-0.44-0.17-0.67l8.39-14.73c0.18-0.31,0.69-0.31,0.87,0l8.36,14.68c0.13,0.23,0.06,0.53-0.17,0.67l-8.36,5.32C16.2,21.97,16.11,22,16.01,22z M8.3,16.06l7.71,4.85l7.69-4.89L16.01,2.51L8.3,16.06z"/>
            <path class="st17" d="M16.01,31c-0.28,0-0.5-0.22-0.5-0.5v-6.4c0-0.28,0.22-0.5,0.5-0.5s0.5,0.22,0.5,0.5v6.4C16.51,30.78,16.29,31,16.01,31z"/>
            <path class="st17" d="M16.01,31c-0.16,0-0.31-0.08-0.41-0.21L7.22,19.12c-0.14-0.19-0.12-0.46,0.04-0.63c0.16-0.17,0.43-0.21,0.63-0.08l8.12,5.11l8.1-5.15c0.2-0.13,0.47-0.1,0.63,0.08c0.16,0.17,0.18,0.44,0.04,0.63l-8.36,11.72C16.33,30.92,16.16,30.98,16.01,31z M9.52,20.61l6.49,9.03l6.47-9.06l-6.2,3.94c-0.16,0.1-0.37,0.1-0.53,0L9.52,20.61z"/>
            <path class="st17" d="M16.01,22c-0.09,0-0.18-0.03-0.27-0.08l-8.39-5.27c-0.15-0.1-0.24-0.27-0.23-0.45s0.12-0.34,0.29-0.42l8.39-3.93c0.13-0.06,0.29-0.06,0.42,0l8.36,3.88c0.17,0.08,0.28,0.24,0.29,0.42c0.01,0.18-0.08,0.36-0.23,0.45l-8.36,5.32C16.2,21.97,16.11,22,16.01,22z M8.67,16.29l7.34,4.62l7.33-4.66l-7.32-3.4L8.67,16.29z"/>
            <path class="st17" d="M16.01,22c-0.28,0-0.5-0.22-0.5-0.5v-20c0-0.28,0.22-0.5,0.5-0.5s0.5,0.22,0.5,0.5v20C16.51,21.78,16.29,22,16.01,22z"/>
            <path class="st17" d="M16.01,22c-0.09,0-0.18-0.03-0.27-0.08l-8.39-5.27c-0.23-0.14-0.3-0.44-0.17-0.67l8.39-14.73c0.18-0.31,0.69-0.31,0.87,0l8.36,14.68c0.13,0.23,0.06,0.53-0.17,0.67l-8.36,5.32C16.2,21.97,16.11,22,16.01,22z M8.3,16.06l7.71,4.85l7.69-4.89L16.01,2.51L8.3,16.06z"/>
          </g>
        </svg>`,
        usdc: `<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
          <g fill="none">
            <circle fill="#3E73C4" cx="16" cy="16" r="16"/>
            <g fill="#FFF">
              <path d="M20.022 18.124c0-2.124-1.28-2.852-3.84-3.156-1.828-.243-2.193-.728-2.193-1.578 0-.85.61-1.396 1.828-1.396 1.097 0 1.707.364 2.011 1.275a.458.458 0 00.427.303h.975a.416.416 0 00.427-.425v-.06a3.04 3.04 0 00-2.743-2.489V9.142c0-.243-.183-.425-.487-.486h-.915c-.243 0-.426.182-.487.486v1.396c-1.829.242-2.986 1.456-2.986 2.974 0 2.002 1.218 2.791 3.778 3.095 1.707.303 2.255.668 2.255 1.639 0 .97-.853 1.638-2.011 1.638-1.585 0-2.133-.667-2.316-1.578-.06-.242-.244-.364-.427-.364h-1.036a.416.416 0 00-.426.425v.06c.243 1.518 1.219 2.61 3.23 2.914v1.457c0 .242.183.425.487.485h.915c.243 0 .426-.182.487-.485V21.34c1.829-.303 3.047-1.578 3.047-3.217z"/>
              <path d="M12.892 24.497c-4.754-1.7-7.192-6.98-5.424-11.653.914-2.55 2.925-4.491 5.424-5.402.244-.121.365-.303.365-.607v-.85c0-.242-.121-.424-.365-.485-.061 0-.183 0-.244.06a10.895 10.895 0 00-7.13 13.717c1.096 3.4 3.717 6.01 7.13 7.102.244.121.488 0 .548-.243.061-.06.061-.122.061-.243v-.85c0-.182-.182-.424-.365-.546zm6.46-18.936c-.244-.122-.488 0-.548.242-.061.061-.061.122-.061.243v.85c0 .243.182.485.365.607 4.754 1.7 7.192 6.98 5.424 11.653-.914 2.55-2.925 4.491-5.424 5.402-.244.121-.365.303-.365.607v.85c0 .242.121.424.365.485.061 0 .183 0 .244-.06a10.895 10.895 0 007.13-13.717c-1.096-3.46-3.778-6.07-7.13-7.162z"/>
            </g>
          </g>
        </svg>`,
        usdt: `<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
          <g fill="none" fill-rule="evenodd">
            <circle cx="16" cy="16" r="16" fill="#26A17B"/>
            <path fill="#FFF" d="M17.922 17.383v-.002c-.11.008-.677.042-1.942.042-1.01 0-1.721-.03-1.971-.042v.003c-3.888-.171-6.79-.848-6.79-1.658 0-.809 2.902-1.486 6.79-1.66v2.644c.254.018.982.061 1.988.061 1.207 0 1.812-.05 1.925-.06v-2.643c3.88.173 6.775.85 6.775 1.658 0 .81-2.895 1.485-6.775 1.657m0-3.59v-2.366h5.414V7.819H8.595v3.608h5.414v2.365c-4.4.202-7.709 1.074-7.709 2.118 0 1.044 3.309 1.915 7.709 2.118v7.582h3.913v-7.584c4.393-.202 7.694-1.073 7.694-2.116 0-1.043-3.301-1.914-7.694-2.117"/>
          </g>
        </svg>`,
        dai: `<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
          <g fill="none" fill-rule="evenodd">
            <circle fill="#F4B731" fill-rule="nonzero" cx="16" cy="16" r="16"/>
            <path d="M9.277 8h6.552c3.985 0 7.006 2.116 8.13 5.194H26v1.861h-1.611c.031.294.047.594.047.898v.046c0 .342-.02.68-.06 1.01H26v1.86h-2.08C22.767 21.905 19.77 24 15.83 24H9.277v-5.131H7v-1.86h2.277v-1.954H7v-1.86h2.277V8zm1.831 10.869v3.462h4.72c2.914 0 5.078-1.387 6.085-3.462H11.108zm11.366-1.86H11.108v-1.954h11.37c.041.307.063.622.063.944v.045c0 .329-.023.65-.067.964zM15.83 9.665c2.926 0 5.097 1.424 6.098 3.528h-10.82V9.666h4.72z" fill="#FFF"/>
          </g>
        </svg>`,
        wsteth: `<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
          <g fill="none">
            <circle fill="#00A3FF" cx="16" cy="16" r="16"/>
            <path d="M9.437 14.864l-.181.275c-2.048 3.097-1.603 7.253 1.034 9.824 1.561 1.521 3.622 2.353 5.683 2.353 0 0 0 0-6.536-12.452z" fill="#FFF"/>
            <path opacity=".6" d="M15.997 18.611l-6.56-3.747c6.56 12.452 6.56 12.452 6.56 12.452 0-2.683 0-5.623 0-8.705z" fill="#FFF"/>
            <path opacity=".6" d="M22.563 14.864l.181.275c2.048 3.097 1.603 7.253-1.034 9.824-1.561 1.521-3.622 2.353-5.683 2.353 0 0 0 0 6.536-12.452z" fill="#FFF"/>
            <path opacity=".2" d="M16.003 18.611l6.56-3.747c-6.56 12.452-6.56 12.452-6.56 12.452 0-2.683 0-5.623 0-8.705z" fill="#FFF"/>
            <path opacity=".2" d="M16.004 10.239v6.459l5.654-3.23-5.654-3.229z" fill="#FFF"/>
            <path opacity=".6" d="M16.005 10.239l-5.655 3.229 5.655 3.23v-6.46z" fill="#FFF"/>
            <path d="M16.005 4.805l-5.655 8.668 5.655-3.233V4.805z" fill="#FFF"/>
            <path opacity=".6" d="M16.004 10.238l5.658 3.23-5.658-8.674v5.444z" fill="#FFF"/>
          </g>
        </svg>`,
        reth: `<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="bgGradient" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" style="stop-color:#FFAA6B;stop-opacity:1"/>
              <stop offset="100%" style="stop-color:#FF8A5B;stop-opacity:1"/>
            </linearGradient>
          </defs>
          <circle cx="100" cy="100" r="95" fill="#FFC93D"/>
          <circle cx="100" cy="100" r="88" fill="#FF6B6B"/>
          <circle cx="100" cy="100" r="82" fill="url(#bgGradient)"/>
          <g transform="translate(100, 100) rotate(45)">
            <path d="M -8 -25 C -8 -30, -5 -35, 0 -35 C 5 -35, 8 -30, 8 -25 L 8 -5 L 18 5 L 18 15 L 8 10 L 8 20 L 0 25 L -8 20 L -8 10 L -18 15 L -18 5 L -8 -5 Z" fill="white"/>
            <circle cx="0" cy="-20" r="4" fill="#FF8A5B"/>
            <path d="M -6 20 L -9 35 L -3 30 L 0 38 L 3 30 L 9 35 L 6 20 Z" fill="white"/>
          </g>
        </svg>`,
        // Default coin icon for custom tokens
        defaultCoin: `<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
          <circle cx="16" cy="16" r="15" fill="none" stroke="#000" stroke-width="2"/>
          <circle cx="16" cy="16" r="10" fill="none" stroke="#000" stroke-width="1.5" opacity="0.4"/>
          <circle cx="16" cy="16" r="6" fill="none" stroke="#000" stroke-width="1.5" opacity="0.6"/>
          <circle cx="16" cy="16" r="2" fill="#000"/>
        </svg>`
      };

      // Render DAO stats in header
      function renderDaoStats() {
        const statsBar = document.getElementById('daoStatsBar');
        if (!statsBar || !currentDAO) return;

        const dao = currentDAO.dao;

        // Format totals
        const totalProposals = dao.proposals.length;
        // Members array structure: [0]=address, [1]=shares, [2]=loot, [3]=seatId
        const totalBadgeMembers = dao.members.filter(m => m[3] && m[3] > 0).length;
        const totalShares = parseFloat(ethers.formatEther(dao.supplies.sharesTotalSupply)).toFixed(1);
        const totalLoot = parseFloat(ethers.formatEther(dao.supplies.lootTotalSupply)).toFixed(1);

        statsBar.innerHTML = `
          <div class="dao-stat-item">
            <div class="dao-stat-label">Proposals</div>
            <div class="dao-stat-value">${totalProposals}</div>
          </div>
          <div class="dao-stat-item">
            <div class="dao-stat-label">Badge Members</div>
            <div class="dao-stat-value">${totalBadgeMembers}</div>
          </div>
          <div class="dao-stat-item">
            <div class="dao-stat-label">Total Shares</div>
            <div class="dao-stat-value">${totalShares}</div>
          </div>
          <div class="dao-stat-item">
            <div class="dao-stat-label">Total Loot</div>
            <div class="dao-stat-value">${totalLoot}</div>
          </div>
        `;
      }

      // Render governance info
      // Format seconds into human-readable time
      function formatDuration(seconds) {
        const secs = Number(seconds);
        if (secs === 0) return 'Disabled';

        const days = Math.floor(secs / 86400);
        const hours = Math.floor((secs % 86400) / 3600);
        const minutes = Math.floor((secs % 3600) / 60);

        if (days > 0) {
          return hours > 0 ? `${days}d ${hours}h` : `${days} day${days !== 1 ? 's' : ''}`;
        } else if (hours > 0) {
          return minutes > 0 ? `${hours}h ${minutes}m` : `${hours} hour${hours !== 1 ? 's' : ''}`;
        } else if (minutes > 0) {
          return `${minutes} minute${minutes !== 1 ? 's' : ''}`;
        } else {
          return `${secs} second${secs !== 1 ? 's' : ''}`;
        }
      }

      // Update proposal TTL info in the proposal form
      function updateProposalTTLInfo() {
        const ttlInfoDiv = document.getElementById('proposalTTLInfo');
        const ttlInfoText = document.getElementById('proposalTTLInfoText');

        if (!ttlInfoDiv || !ttlInfoText || !currentDAO) {
          if (ttlInfoDiv) ttlInfoDiv.style.display = 'none';
          return;
        }

        const ttlSeconds = Number(currentDAO.dao.gov.proposalTTL || 0);

        if (ttlSeconds === 0) {
          ttlInfoDiv.style.display = 'none';
          return;
        }

        const ttlFormatted = formatDuration(ttlSeconds);
        const now = new Date();
        const expiryDate = new Date(now.getTime() + ttlSeconds * 1000);

        const dateOptions = { month: 'short', day: 'numeric', year: 'numeric' };
        const timeOptions = { hour: 'numeric', minute: '2-digit', hour12: true };
        const expiryDateStr = expiryDate.toLocaleDateString('en-US', dateOptions);
        const expiryTimeStr = expiryDate.toLocaleTimeString('en-US', timeOptions);

        ttlInfoText.innerHTML = `Proposal will expire in <strong>${ttlFormatted}</strong> (${expiryDateStr} at ${expiryTimeStr})`;
        ttlInfoDiv.style.display = 'block';
      }

      async function renderGovernanceInfo(prefetchedTransferLocks) {
        const governanceInfo = document.getElementById('governanceInfo');
        if (!governanceInfo || !currentDAO) return;

        const gov = currentDAO.dao.gov;
        const supplies = currentDAO.dao.supplies;

        // Calculate quorum percentage
        const quorumBps = Number(gov.quorumBps);
        const quorumPercent = (quorumBps / 100).toFixed(2);

        // Format ragequittable
        const ragequittable = gov.ragequittable ? 'Enabled' : 'Disabled';

        // Format proposal TTL
        const proposalTTL = formatDuration(gov.proposalTTL || 0);

        // Format proposal threshold
        const proposalThreshold = BigInt(gov.proposalThreshold || 0);
        const proposalThresholdFormatted = proposalThreshold > 0n
          ? parseFloat(ethers.formatUnits(proposalThreshold, 18)).toFixed(2) + ' shares'
          : 'Disabled';

        // Format timelock delay
        const timelockDelay = formatDuration(gov.timelockDelay || 0);

        // Update proposal form TTL info
        updateProposalTTLInfo();

        // Decode futarchy settings
        let futarchyText = 'Disabled';
        const futarchyParam = BigInt(gov.autoFutarchyParam || 0);
        const futarchyCap = BigInt(gov.autoFutarchyCap || 0);

        if (futarchyParam > 0n && futarchyCap > 0n) {
          const paramBps = Number(futarchyParam);
          const paramPercent = (paramBps / 100).toFixed(2);
          const capFormatted = parseFloat(ethers.formatEther(futarchyCap)).toFixed(1);
          futarchyText = `${paramPercent}% of supply, ${capFormatted} LOOT cap`;
        }

        // Fetch transfer lock status for shares and loot
        let transferabilityText = 'Loading...';
        try {
          let sharesLocked, lootLocked;
          if (prefetchedTransferLocks && prefetchedTransferLocks.sharesTransfersLocked !== undefined) {
            sharesLocked = prefetchedTransferLocks.sharesTransfersLocked;
            lootLocked = prefetchedTransferLocks.lootTransfersLocked;
          } else {
            const tokenABI = ['function transfersLocked() view returns (bool)'];
            [sharesLocked, lootLocked] = await withRpcFallback(async (activeProvider) => {
              const sharesContract = new ethers.Contract(currentDAO.dao.meta.sharesToken, tokenABI, activeProvider);
              const lootContract = new ethers.Contract(currentDAO.dao.meta.lootToken, tokenABI, activeProvider);
              return await Promise.all([
                sharesContract.transfersLocked(),
                lootContract.transfersLocked()
              ]);
            });
          }

          // Store for use in proposal helper
          currentDAO._transferLocks = { sharesLocked, lootLocked };

          if (!sharesLocked && !lootLocked) {
            transferabilityText = 'Shares & Loot transferable';
          } else if (sharesLocked && lootLocked) {
            transferabilityText = 'Shares & Loot locked';
          } else if (sharesLocked) {
            transferabilityText = 'Shares locked, Loot transferable';
          } else {
            transferabilityText = 'Shares transferable, Loot locked';
          }
        } catch (error) {
          logger.warn('Error fetching transferability:', error.message);
          transferabilityText = 'Unknown';
        }

        governanceInfo.innerHTML = `
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.5rem;">
            <div>
              <div style="font-size: 0.7rem; color: var(--fg-dim); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.35rem;">
                Quorum
                <a href="#" onclick="event.preventDefault(); prepareQuorumProposal(); switchDaoView('dao');"
                   title="Create proposal to change quorum"
                   style="color: #000; opacity: 0.5; line-height: 1;">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                  </svg>
                </a>
              </div>
              <div style="font-size: 0.95rem; color: #000;">${quorumPercent}%</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: var(--fg-dim); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.35rem;">
                Ragequit
                <a href="#" onclick="event.preventDefault(); prepareRagequitProposal(); switchDaoView('dao');"
                   title="Create proposal to toggle ragequit"
                   style="color: #000; opacity: 0.5; line-height: 1;">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                  </svg>
                </a>
              </div>
              <div style="font-size: 0.95rem; color: #000;">${ragequittable}</div>
            </div>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.5rem;">
            <div>
              <div style="font-size: 0.7rem; color: var(--fg-dim); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.35rem;">
                Proposal TTL
                <a href="#" onclick="event.preventDefault(); prepareTTLProposal(); switchDaoView('dao');"
                   title="Create proposal to change proposal TTL"
                   style="color: #000; opacity: 0.5; line-height: 1;">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                  </svg>
                </a>
              </div>
              <div style="font-size: 0.95rem; color: #000;">${proposalTTL}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: var(--fg-dim); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.35rem;">
                Proposal Threshold
                <a href="#" onclick="event.preventDefault(); prepareThresholdProposal(); switchDaoView('dao');"
                   title="Create proposal to change proposal threshold"
                   style="color: #000; opacity: 0.5; line-height: 1;">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                  </svg>
                </a>
              </div>
              <div style="font-size: 0.95rem; color: #000;">${proposalThresholdFormatted}</div>
            </div>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.5rem;">
            <div>
              <div style="font-size: 0.7rem; color: var(--fg-dim); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.35rem;">
                Timelock Delay
                <a href="#" onclick="event.preventDefault(); prepareTimelockDelayProposal(); switchDaoView('dao');"
                   title="Create proposal to change timelock delay"
                   style="color: #000; opacity: 0.5; line-height: 1;">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                  </svg>
                </a>
              </div>
              <div style="font-size: 0.95rem; color: #000;">${timelockDelay}</div>
            </div>
            <div>
              <div style="font-size: 0.7rem; color: var(--fg-dim); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.35rem;">
                Transferability
                <a href="#" onclick="event.preventDefault(); prepareTransferabilityProposal(); switchDaoView('dao');"
                   title="Create proposal to toggle transferability"
                   style="color: #000; opacity: 0.5; line-height: 1;">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="16"></line>
                    <line x1="8" y1="12" x2="16" y2="12"></line>
                  </svg>
                </a>
              </div>
              <div style="font-size: 0.95rem; color: #000;">${transferabilityText}</div>
            </div>
          </div>
          <div>
            <div style="font-size: 0.7rem; color: var(--fg-dim); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.35rem;">
              Auto-Futarchy
              <a href="#" onclick="event.preventDefault(); prepareFutarchyProposal(); switchDaoView('dao');"
                 title="Create proposal to configure auto-futarchy"
                 style="color: #000; opacity: 0.5; line-height: 1;">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"></circle>
                  <line x1="12" y1="8" x2="12" y2="16"></line>
                  <line x1="8" y1="12" x2="16" y2="12"></line>
                </svg>
              </a>
            </div>
            <div style="font-size: 0.95rem; color: #000;">${futarchyText}</div>
          </div>
          <div style="margin-top: 0.75rem;">
            <div style="font-size: 0.7rem; color: var(--fg-dim); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.35rem;">
              Renderer
              <a href="#" onclick="event.preventDefault(); prepareRendererProposal(); switchDaoView('dao');"
                 title="Create proposal to change renderer"
                 style="color: #000; opacity: 0.5; line-height: 1;">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"></circle>
                  <line x1="12" y1="8" x2="12" y2="16"></line>
                  <line x1="8" y1="12" x2="16" y2="12"></line>
                </svg>
              </a>
            </div>
            <div style="font-size: 0.85rem; color: #000;">
              <a href="${getNetwork().explorer}/address/${currentDAO.dao.meta.renderer}"
                 target="_blank"
                 rel="noopener noreferrer"
                 style="color: #000; text-decoration: none; display: inline-flex; align-items: center; gap: 0.25rem;"
                 onmouseover="this.style.textDecoration='underline';"
                 onmouseout="this.style.textDecoration='none';">
                ${currentDAO.dao.meta.renderer.slice(0, 6)}...${currentDAO.dao.meta.renderer.slice(-4)}
                <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                  <polyline points="15 3 21 3 21 9"></polyline>
                  <line x1="10" y1="14" x2="21" y2="3"></line>
                </svg>
              </a>
            </div>
          </div>
          <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border-muted);">
            <div style="font-size: 0.7rem; color: #c0392b; text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem; display: flex; align-items: center; gap: 0.35rem;">
              Emergency Permits
              <a href="#" onclick="event.preventDefault(); prepareEmergencyPermitProposal(); switchDaoView('dao');"
                 title="Grant or revoke emergency config bump permits"
                 style="color: #c0392b; opacity: 0.5; line-height: 1;">
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"></circle>
                  <line x1="12" y1="8" x2="12" y2="16"></line>
                  <line x1="8" y1="12" x2="16" y2="12"></line>
                </svg>
              </a>
            </div>
            <div style="font-size: 0.85rem; color: var(--fg-dim);">
              Config bump permits (see member collectibles)
            </div>
          </div>
        `;
      }

      // Render active sales info
      async function renderSalesInfo(prefetchedSales) {
        const salesInfo = document.getElementById('salesInfo');
        const salesSection = document.getElementById('salesSection');
        if (!salesInfo || !salesSection || !currentDAO) return;

        try {
          // Check sales for all supported tokens (network-specific)
          const tokens = getNetworkTokens();

          // Parse chat messages for SALE tags to find custom token sales
          // SALE tags can appear in two places:
          // 1. Directly in the message text
          // 2. Inside PROPOSAL_DATA JSON in the description field
          const customTokens = [];
          if (currentDAO.dao.messages && currentDAO.dao.messages.length > 0) {
            for (const message of currentDAO.dao.messages) {
              if (!message.text) continue;

              // Try to extract SALE tag from raw message first
              let textToSearch = message.text;

              // Also check if this is a proposal message - extract description
              const propData = decodeProposalMessage(message.text);
              if (propData && propData.description) {
                textToSearch += '\n' + propData.description;
              }

              const saleMatch = textToSearch.match(/<<<SALE\s+token="([^"]+)"\s+price="([^"]+)"\s+decimals="(\d+)"\s+symbol="([^"]+)"\s+SALE>>>/);
              if (saleMatch) {
                const [, tokenAddress, price, decimals, symbol] = saleMatch;

                // Normalize address for comparison
                const normalizedAddress = tokenAddress.toLowerCase();

                // Check if we already have this token
                if (!tokens.find(t => t.address.toLowerCase() === normalizedAddress) &&
                    !customTokens.find(t => t.address.toLowerCase() === normalizedAddress)) {

                  customTokens.push({
                    symbol,
                    address: tokenAddress,
                    decimals: parseInt(decimals),
                    isCustom: true
                  });

                  // Cache for other functions that might need it
                  if (!customTokenCache[normalizedAddress]) {
                    customTokenCache[normalizedAddress] = {
                      symbol,
                      decimals: parseInt(decimals),
                      name: symbol
                    };
                  }
                }
              }
            }
          }

          // Combine standard and custom tokens
          const allTokens = [...tokens, ...customTokens];

          // Use prefetched sales for standard tokens, fetch custom tokens individually
          let salesResults;
          if (prefetchedSales && prefetchedSales.length > 0) {
            // Start with prefetched results for standard network tokens
            salesResults = [...prefetchedSales];

            // Fetch custom tokens individually (not in the initial batch)
            if (customTokens.length > 0) {
              const customResults = await withRpcFallback(async (activeProvider) => {
                const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, activeProvider);
                return await Promise.all(customTokens.map(token =>
                  molochContract.sales(token.address)
                    .then(sale => ({ token, sale }))
                    .catch(err => {
                      logger.warn(`Error fetching sale for ${token.symbol}:`, err.message);
                      return { token, sale: { active: false } };
                    })
                ));
              });
              salesResults.push(...customResults);
            }
          } else {
            // Fallback: fetch all sales individually
            salesResults = await withRpcFallback(async (activeProvider) => {
              const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, activeProvider);
              const salePromises = allTokens.map(token =>
                molochContract.sales(token.address)
                  .then(sale => ({ token, sale }))
                  .catch(err => {
                    logger.warn(`Error fetching sale for ${token.symbol}:`, err.message);
                    return { token, sale: { active: false } }; // Return inactive on error
                  })
              );
              return await Promise.all(salePromises);
            });
          }

          const activeSales = [];
          for (const result of salesResults) {
            const { token, sale } = result;
            if (sale.active) {
              activeSales.push({
                token: token,
                pricePerShare: sale.pricePerShare,
                cap: sale.cap,
                minting: sale.minting,
                isLoot: sale.isLoot
              });
            }
          }

          // Extract active custom sale tokens for use in treasury and ragequit
          customSaleTokens = activeSales
            .filter(sale => sale.token.isCustom)
            .map(sale => ({
              symbol: sale.token.symbol,
              address: sale.token.address,
              decimals: sale.token.decimals
            }));

          // Fetch DAICO data using batched view helper (single RPC call for all sales + tap)
          const daoAddress = currentDAO.dao.dao;
          if (!currentDAICO) {
            currentDAICO = await fetchDAICOData(daoAddress);
          }

          // Process DAICO sales from batched response
          const activeDaicoSales = [];
          let tapInfo = null;
          let claimableTap = 0n;

          if (currentDAICO) {
            const now = Math.floor(Date.now() / 1000);
            const sharesAddress = currentDAO.dao.meta.sharesToken?.toLowerCase();
            const lootAddress = currentDAO.dao.meta.lootToken?.toLowerCase();

            // Process sales from view helper response
            for (const sale of currentDAICO.sales) {
              // Check if sale is active: tribAmt > 0, forAmt > 0, not expired
              const isExpired = sale.deadline > 0 && Number(sale.deadline) < now;
              if (sale.tribAmt > 0n && sale.forAmt > 0n && sale.forTkn !== ethers.ZeroAddress && !isExpired) {
                const forTknLower = sale.forTkn.toLowerCase();
                const isLoot = forTknLower === lootAddress;

                // Find token info for the tribute token
                const token = allTokens.find(t => t.address.toLowerCase() === sale.tribTkn.toLowerCase()) || {
                  symbol: sale.tribTkn === ethers.ZeroAddress ? 'ETH' : 'Token',
                  address: sale.tribTkn,
                  decimals: 18
                };

                // LP config is already included in SaleView
                let lpConfig = null;
                if (sale.lpBps > 0) {
                  lpConfig = {
                    lpBps: Number(sale.lpBps),
                    maxSlipBps: Number(sale.maxSlipBps),
                    feeOrHook: sale.feeOrHook
                  };
                }

                activeDaicoSales.push({
                  token: token,
                  tribAmt: sale.tribAmt,
                  forTkn: sale.forTkn,
                  forAmt: sale.forAmt,
                  deadline: sale.deadline,
                  isLoot: isLoot,
                  available: sale.allowance, // Already fetched by view helper
                  remainingSupply: sale.remainingSupply,
                  totalSupply: sale.totalSupply,
                  treasuryBalance: sale.treasuryBalance,
                  lpConfig: lpConfig,
                  isDaico: true
                });
              }
            }

            // Process tap info from view helper response
            const tap = currentDAICO.tap;
            if (tap && tap.ops !== ethers.ZeroAddress && tap.ratePerSec > 0n) {
              tapInfo = {
                ops: tap.ops,
                tribTkn: tap.tribTkn,
                ratePerSec: tap.ratePerSec,
                lastClaim: Number(tap.lastClaim)
              };
              claimableTap = tap.claimable;
            }
          }

          // Check if there's anything to display (sales or tap)
          const hasTap = tapInfo && tapInfo.ops !== ethers.ZeroAddress && tapInfo.ratePerSec > 0n;
          if (activeSales.length === 0 && activeDaicoSales.length === 0 && !hasTap) {
            salesSection.style.display = 'none';
            return;
          }

          salesSection.style.display = 'block';

          let salesHTML = '';

          // Render internal sales first
          for (const sale of activeSales) {
            const tokenType = sale.isLoot ? 'LOOT' : 'SHARES';
            const tokenSymbol = sale.isLoot ? `${currentDAO.dao.meta.symbol}-LOOT` : currentDAO.dao.meta.symbol;
            // pricePerShare is a simple integer ratio (token-wei per share-wei)
            const priceRatio = sale.pricePerShare.toString();
            const priceFormatted = `${priceRatio}:1`;
            const capText = sale.cap > 0n ? `${parseFloat(ethers.formatEther(sale.cap)).toFixed(2)} remaining` : 'Unlimited';
            const sourceText = sale.minting ? 'Minting new' : 'From treasury';

            // Detect 1:1 ratio for governance staking/upgrade (18 decimals, price = 1)
            const is1to1Upgrade = sale.token.decimals === 18 && sale.pricePerShare === 1n;
            const displayTitle = is1to1Upgrade ? `${tokenType} GOVERNANCE STAKING/UPGRADE` : `${tokenType} SALE`;

            // Fetch DAO balance for custom tokens
            let daoBalance = '';
            if (sale.token.isCustom) {
              try {
                const tokenContract = new ethers.Contract(sale.token.address, ERC20_ABI, provider);
                const balance = await tokenContract.balanceOf(currentDAO.dao.dao);
                const balanceFormatted = parseFloat(ethers.formatUnits(balance, sale.token.decimals)).toFixed(2);
                daoBalance = `<div style="font-size: 0.75rem; color: var(--fg-dim); margin-top: 0.25rem;">DAO Balance: ${balanceFormatted} ${sale.token.symbol}</div>`;
              } catch (err) {
                logger.error(`Error fetching DAO balance for ${sale.token.symbol}:`, err);
              }
            }

            // Token contract link
            const tokenContractLink = sale.token.address === ethers.ZeroAddress
              ? ''
              : `<div style="margin-top: 0.5rem; font-size: 0.7rem;">
                   <a href="${getNetwork().explorer}/token/${sale.token.address}"
                      target="_blank"
                      rel="noopener noreferrer"
                      style="color: var(--fg-muted); text-decoration: none; display: inline-flex; align-items: center; gap: 0.25rem;"
                      onmouseover="this.style.color='#000'; this.style.textDecoration='underline';"
                      onmouseout="this.style.color='#999'; this.style.textDecoration='none';">
                     <span>ðŸ”</span> View ${sale.token.symbol} on Explorer
                     <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                       <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                       <polyline points="15 3 21 3 21 9"></polyline>
                       <line x1="10" y1="14" x2="21" y2="3"></line>
                     </svg>
                   </a>
                 </div>`;

            salesHTML += `
              <div style="padding: 0.75rem; background: var(--surface); border: 1px solid var(--border-muted); margin-bottom: 0.75rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                  <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">${displayTitle}</div>
                  <div style="font-size: 0.75rem; color: var(--fg-dim);">${sourceText}</div>
                </div>
                ${is1to1Upgrade ? '<div style="font-size: 0.75rem; color: var(--fg-muted); margin-bottom: 0.5rem; font-style: italic;">1:1 token upgrade â€¢ Ragequit to reclaim</div>' : ''}
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.5rem;">
                  <div>
                    <div style="font-size: 0.7rem; color: var(--fg-dim);">Price</div>
                    <div style="font-size: 0.9rem; color: #000;">${priceFormatted} ${sale.token.symbol}</div>
                  </div>
                  <div>
                    <div style="font-size: 0.7rem; color: var(--fg-dim);">Available</div>
                    <div style="font-size: 0.9rem; color: #000;">${capText}</div>
                  </div>
                </div>
                ${daoBalance}
                ${tokenContractLink}
                <button onclick="openPurchaseModal('${sale.token.address}', '${sale.token.symbol}', ${sale.token.decimals}, ${sale.isLoot})"
                        onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)';"
                        onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)';"
                        style="width: 100%; padding: 0.75rem; background: #f9f9f9; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.7rem; letter-spacing: 0.12em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600; min-height: 44px; margin-top: 0.75rem;">
                  ${is1to1Upgrade ? 'Stake/Upgrade' : `Purchase ${tokenSymbol}`}
                </button>
              </div>
            `;
          }

          // Render DAICO sales
          for (const sale of activeDaicoSales) {
            const tokenType = sale.isLoot ? 'LOOT' : 'SHARES';
            const tokenSymbol = sale.isLoot ? `${currentDAO.dao.meta.symbol}-LOOT` : currentDAO.dao.meta.symbol;

            // Format the ratio: tribAmt of payment token -> forAmt of shares/loot
            // Example: 1 ETH for 1000 shares = "0.001 ETH per token" or "1 ETH : 1000 tokens"
            const tribAmtFormatted = parseFloat(ethers.formatUnits(sale.tribAmt, sale.token.decimals));
            const forAmtFormatted = parseFloat(ethers.formatEther(sale.forAmt));
            const pricePerToken = tribAmtFormatted / forAmtFormatted;

            // Format price nicely
            let priceFormatted;
            if (pricePerToken >= 0.01) {
              priceFormatted = `${pricePerToken.toFixed(4)} ${sale.token.symbol}`;
            } else if (pricePerToken >= 0.000001) {
              priceFormatted = `${pricePerToken.toFixed(8)} ${sale.token.symbol}`;
            } else {
              // Very small prices - show as ratio
              priceFormatted = `${tribAmtFormatted} ${sale.token.symbol} : ${forAmtFormatted}`;
            }

            // Available supply based on allowance
            const availableFormatted = parseFloat(ethers.formatEther(sale.available));
            const capText = availableFormatted > 0 ? `${availableFormatted.toFixed(2)} available` : 'Check allowance';

            // LP config display
            let lpConfigHTML = '';
            if (sale.lpConfig && sale.lpConfig.lpBps > 0) {
              const lpPct = (sale.lpConfig.lpBps / 100).toFixed(1);
              const buyerPct = (100 - sale.lpConfig.lpBps / 100).toFixed(1);
              lpConfigHTML = `
                <div style="margin-bottom: 0.5rem; padding: 0.4rem; background: #f0f4ff; font-size: 0.7rem; color: #4466aa;">
                  <span style="font-weight: 600;">LP Enabled:</span> ${lpPct}% to ZAMM liquidity â€¢ Buyers receive ${buyerPct}% of quoted rate
                </div>
              `;
            }

            salesHTML += `
              <div style="padding: 0.75rem; background: var(--status-success); border: 1px solid var(--green); margin-bottom: 0.75rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                  <div style="font-size: 0.85rem; color: var(--green); letter-spacing: 0.1em;">${tokenType} DAICO SALE</div>
                  <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <a href="#" onclick="event.preventDefault(); prepareSaleProposal('${sale.token.address}', '${sale.token.symbol}', ${sale.token.decimals}, ${sale.isLoot}, '${sale.tribAmt}', '${sale.forAmt}', '${sale.forTkn}', ${sale.deadline || 0}); switchDaoView('dao');"
                       title="Configure or cancel sale via proposal"
                       style="color: var(--green); opacity: 0.6; line-height: 1;">
                      <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                      </svg>
                    </a>
                    <div style="font-size: 0.7rem; color: var(--green); background: var(--status-success); padding: 0.2rem 0.5rem; ">External OTC</div>
                  </div>
                </div>
                <div style="font-size: 0.75rem; color: var(--fg); margin-bottom: 0.5rem;">
                  Pay ${sale.token.symbol} â†’ Receive ${tokenSymbol}
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.5rem;">
                  <div>
                    <div style="font-size: 0.7rem; color: var(--fg-dim);">Price per token</div>
                    <div style="font-size: 0.9rem; color: #000;">${priceFormatted}</div>
                  </div>
                  <div>
                    <div style="font-size: 0.7rem; color: var(--fg-dim);">Available</div>
                    <div style="font-size: 0.9rem; color: #000;">${capText}</div>
                  </div>
                </div>
                <div style="font-size: 0.7rem; color: var(--fg-dim); margin-bottom: 0.5rem;">
                  Ratio: ${tribAmtFormatted} ${sale.token.symbol} = ${forAmtFormatted} ${tokenSymbol}
                </div>
                ${(() => {
                  // Deadline display with countdown
                  const deadlineNum = Number(sale.deadline);
                  if (!deadlineNum || deadlineNum === 0) {
                    return '<div style="font-size: 0.7rem; color: var(--green); margin-bottom: 0.5rem;">â³ No deadline</div>';
                  }
                  const now = Math.floor(Date.now() / 1000);
                  const secsLeft = deadlineNum - now;
                  if (secsLeft <= 0) {
                    return '<div style="font-size: 0.7rem; color: #e74c3c; margin-bottom: 0.5rem;">â° Ended</div>';
                  }
                  const deadlineDate = new Date(deadlineNum * 1000);
                  const dateStr = deadlineDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                  const timeStr = deadlineDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                  const days = Math.floor(secsLeft / 86400);
                  const hours = Math.floor((secsLeft % 86400) / 3600);
                  const mins = Math.floor((secsLeft % 3600) / 60);
                  let countdown = days > 0 ? days + 'd ' + hours + 'h' : hours > 0 ? hours + 'h ' + mins + 'm' : mins + 'm';
                  return '<div style="font-size: 0.7rem; color: var(--green); margin-bottom: 0.5rem;">â³ Ends ' + dateStr + ' ' + timeStr + ' (' + countdown + ' left)</div>';
                })()}
                ${lpConfigHTML}
                <button onclick="openDaicoPurchaseModal('${sale.token.address}', '${sale.token.symbol}', ${sale.token.decimals}, ${sale.isLoot}, '${sale.tribAmt}', '${sale.forAmt}')"
                        onmouseover="this.style.background='var(--status-success)'; this.style.borderColor='var(--green)';"
                        onmouseout="this.style.background='var(--status-success)'; this.style.borderColor='var(--border-muted)';"
                        style="width: 100%; padding: 0.75rem; background: var(--status-success); border: 1px solid var(--green); color: #000; font-size: 0.7rem; letter-spacing: 0.12em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600; min-height: 44px; margin-top: 0.75rem;">
                  Purchase ${tokenSymbol} via DAICO
                </button>
              </div>
            `;
          }

          // Render Tap info if active
          if (tapInfo && tapInfo.ops !== ethers.ZeroAddress) {
            // Find the tap's payment token info
            const tapToken = allTokens.find(t => t.address.toLowerCase() === tapInfo.tribTkn.toLowerCase()) || { symbol: 'Unknown', decimals: 18 };
            const ratePerMonth = parseFloat(ethers.formatUnits(tapInfo.ratePerSec * 2629746n, tapToken.decimals));
            const claimableFormatted = parseFloat(ethers.formatUnits(claimableTap, tapToken.decimals));
            const opsShort = tapInfo.ops.slice(0, 8) + '...' + tapInfo.ops.slice(-6);

            salesHTML += `
              <div style="padding: 0.75rem; background: #fffaf0; border: 1px solid #e0c8a0; margin-bottom: 0.75rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                  <div style="font-size: 0.85rem; color: #b8860b; letter-spacing: 0.1em;">TAP FUNDING</div>
                  <div style="font-size: 0.7rem; color: #b8860b; background: #fffaf0; padding: 0.2rem 0.5rem; ">Continuous</div>
                </div>
                <div style="font-size: 0.75rem; color: var(--fg); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.35rem;">
                  <span style="color: #b8860b;">Ops:</span>
                  <a href="${getNetwork().explorer}/address/${tapInfo.ops}" target="_blank" rel="noopener" style="color: var(--fg); text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${opsShort}</a>
                  <a href="#" onclick="event.preventDefault(); prepareTapOpsProposal('${tapInfo.ops}'); switchDaoView('dao');"
                     title="Create proposal to change tap ops address"
                     style="color: #b8860b; opacity: 0.6; line-height: 1; margin-left: 0.25rem;">
                    <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <circle cx="12" cy="12" r="10"></circle>
                      <line x1="12" y1="8" x2="12" y2="16"></line>
                      <line x1="8" y1="12" x2="16" y2="12"></line>
                    </svg>
                  </a>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.5rem;">
                  <div>
                    <div style="font-size: 0.7rem; color: var(--fg-dim); display: flex; align-items: center; gap: 0.35rem;">
                      Rate
                      <a href="#" onclick="event.preventDefault(); prepareTapRateProposal('${tapToken.address}', '${tapToken.symbol}', ${tapToken.decimals}, '${tapInfo.ratePerSec}'); switchDaoView('dao');"
                         title="Create proposal to change tap rate"
                         style="color: #b8860b; opacity: 0.6; line-height: 1;">
                        <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                          <circle cx="12" cy="12" r="10"></circle>
                          <line x1="12" y1="8" x2="12" y2="16"></line>
                          <line x1="8" y1="12" x2="16" y2="12"></line>
                        </svg>
                      </a>
                    </div>
                    <div style="font-size: 0.9rem; color: #000;">${ratePerMonth.toLocaleString()} ${tapToken.symbol}/mo</div>
                  </div>
                  <div>
                    <div style="font-size: 0.7rem; color: var(--fg-dim);">Claimable</div>
                    <div style="font-size: 0.9rem; color: ${claimableFormatted > 0 ? '#2d8a2d' : '#000'};">${claimableFormatted.toLocaleString()} ${tapToken.symbol}</div>
                  </div>
                </div>
                ${claimableFormatted > 0 ? `
                <button onclick="claimDaicoTap('${daoAddress}')"
                        onmouseover="this.style.background='#e0c8a0'; this.style.borderColor='#b8860b';"
                        onmouseout="this.style.background='#fdf5e8'; this.style.borderColor='#d4b888';"
                        style="width: 100%; padding: 0.75rem; background: #fffaf0; border: 1px solid #d4b888; color: #000; font-size: 0.7rem; letter-spacing: 0.12em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600; min-height: 44px; margin-top: 0.5rem;">
                  Claim Tap
                </button>
                ` : '<div style="font-size: 0.7rem; color: #b8860b; text-align: center; padding: 0.5rem 0;">Nothing to claim yet</div>'}
              </div>
            `;
          }

          salesInfo.innerHTML = salesHTML;
        } catch (error) {
          logger.error('Error rendering sales:', error);
          salesSection.style.display = 'none';
        }
      }

      // Render treasury
      async function renderTreasury() {
        const treasuryAssets = document.getElementById('treasuryAssets');
        if (!treasuryAssets || !currentDAO) return;

        treasuryAssets.innerHTML = '';

        const treasury = currentDAO.dao.treasury;
        const assets = parseTreasuryBalances(treasury);

        // Add custom sale tokens if any (skip tokens already in treasury)
        if (customSaleTokens.length > 0) {
          const existingAddrs = new Set(assets.map(a => a.address.toLowerCase()));
          const newTokens = customSaleTokens.filter(t => !existingAddrs.has(t.address.toLowerCase()));
          const balanceResults = await Promise.all(newTokens.map(async (customToken) => {
            try {
              const tokenContract = new ethers.Contract(customToken.address, ERC20_ABI, provider);
              const balance = await tokenContract.balanceOf(currentDAO.dao.dao);
              return {
                symbol: customToken.symbol,
                balance: balance,
                decimals: customToken.decimals,
                icon: TOKEN_ICONS.defaultCoin,
                address: customToken.address,
                isCustomSale: true
              };
            } catch (error) {
              logger.error(`Error fetching balance for custom sale token ${customToken.symbol}:`, error);
              return null;
            }
          }));
          assets.push(...balanceResults.filter(r => r !== null));
        }

        assets.forEach(asset => {
          const assetDiv = document.createElement('div');
          assetDiv.className = 'treasury-asset';
          assetDiv.style.cursor = 'pointer';
          assetDiv.title = `Click to create ${asset.symbol} transfer proposal`;

          const formattedBalance = parseFloat(ethers.formatUnits(asset.balance, asset.decimals)).toFixed(4);

          // Add sale badge for custom sale tokens
          const saleBadge = asset.isCustomSale
            ? '<div style="font-size: 0.6rem; color: #000; background: #f9f9f9; padding: 0.15rem 0.35rem; margin-top: 0.25rem; letter-spacing: 0.05em;">SALE</div>'
            : '';

          assetDiv.innerHTML = `
            <div class="treasury-asset-icon">${asset.icon}</div>
            <div class="treasury-asset-symbol">${asset.symbol}${saleBadge}</div>
            <div class="treasury-asset-balance">${formattedBalance}</div>
          `;

          assetDiv.onclick = () => prepareTransferProposal(asset);

          treasuryAssets.appendChild(assetDiv);
        });

        // Add "+ Custom" option for custom tokens
        const customAssetDiv = document.createElement('div');
        customAssetDiv.className = 'treasury-asset';
        customAssetDiv.style.cursor = 'pointer';
        customAssetDiv.style.borderStyle = 'dashed';
        customAssetDiv.style.minHeight = '0';
        customAssetDiv.title = 'Click to send or configure sale for a custom ERC20 token';

        const coinIcon = `<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
          <circle cx="16" cy="16" r="14" fill="none" stroke="#000" stroke-width="2" stroke-dasharray="2,2"/>
          <path d="M16 8v16M8 16h16" stroke="#000" stroke-width="2" stroke-linecap="round"/>
        </svg>`;

        customAssetDiv.innerHTML = `
          <div class="treasury-asset-icon">${coinIcon}</div>
          <div class="treasury-asset-symbol" style="font-size: 0.75rem;">+ Custom</div>
          <div class="treasury-asset-balance" style="font-size: 0.7rem; opacity: 0.6;">ERC20</div>
        `;

        customAssetDiv.onclick = () => prepareCustomTokenProposal();

        treasuryAssets.appendChild(customAssetDiv);

        // Show/hide ragequit button based on ragequittable setting
        const ragequitBtn = document.getElementById('ragequitBtn');
        if (ragequitBtn) {
          ragequitBtn.style.display = currentDAO.dao.gov.ragequittable ? 'block' : 'none';
        }
      }

      // Render tributes
      async function renderTributes(prefetchedTributes) {
        const tributeOffers = document.getElementById('tributeOffers');
        if (!tributeOffers || !currentDAO) return;

        try {
          if (prefetchedTributes !== undefined) {
            currentDaoTributes = prefetchedTributes;
          } else {
            currentDaoTributes = await withRpcFallback(async (rpcProvider) => {
              const tributeContract = new ethers.Contract(TRIBUTE_ADDRESS, TRIBUTE_ABI, rpcProvider);
              return await tributeContract.getActiveDaoTributes(currentDAO.dao.dao);
            });
          }

          tributeOffers.innerHTML = '';

          if (currentDaoTributes.length === 0) {
            tributeOffers.innerHTML = `
              <div style="grid-column: 1 / -1; padding: 1rem; text-align: center; color: var(--fg-dim); font-size: 0.85rem;">
                No active tributes
              </div>
            `;
            return;
          }

          for (let i = 0; i < currentDaoTributes.length; i++) {
            const tribute = currentDaoTributes[i];

            // Get token info for tribute (check local metadata first, then RPC)
            let tribSymbol = 'ETH';
            let tribDecimals = 18;
            let tribIcon = TOKEN_ICONS.eth;

            if (tribute.tribTkn !== ethers.ZeroAddress) {
              const tribMeta = getTokenMetaByAddress(tribute.tribTkn);
              tribSymbol = tribMeta ? tribMeta.symbol : await getTokenSymbol(tribute.tribTkn);
              tribDecimals = tribMeta ? tribMeta.decimals : await getTokenDecimals(tribute.tribTkn);
              tribIcon = getTokenIcon(tribute.tribTkn);
            }

            // Get token info for request (check local metadata first, then RPC)
            let forSymbol = 'ETH';
            let forDecimals = 18;

            if (tribute.forTkn !== ethers.ZeroAddress) {
              const forMeta = getTokenMetaByAddress(tribute.forTkn);
              forSymbol = forMeta ? forMeta.symbol : await getTokenSymbol(tribute.forTkn);
              forDecimals = forMeta ? forMeta.decimals : await getTokenDecimals(tribute.forTkn);
            }

            const tribBalance = parseFloat(ethers.formatUnits(tribute.tribAmt, tribDecimals)).toFixed(4);
            const forBalance = parseFloat(ethers.formatUnits(tribute.forAmt, forDecimals)).toFixed(4);

            const card = document.createElement('div');
            card.className = 'tribute-card';

            // Check if this is the user's own tribute and if they're a member
            const userAddress = signer ? await signer.getAddress() : null;
            const isOwnTribute = userAddress && tribute.proposer.toLowerCase() === userAddress.toLowerCase();
            const isMember = currentDAO.member && (BigInt(currentDAO.member.shares || 0) > 0n || BigInt(currentDAO.member.loot || 0) > 0n);

            // Build buttons - members can sponsor, proposers can cancel (both if applicable)
            let buttonsHtml = '';
            if (isMember) {
              buttonsHtml += `
                <button class="tribute-accept-button" onclick="acceptTributeProposal(${i})">
                  Sponsor Claim
                </button>
              `;
            }
            if (isOwnTribute) {
              buttonsHtml += `
                <button class="tribute-accept-button" style="background: #fff0f0; border-color: #e8c0c0;" onclick="cancelTributeOffer(${i})">
                  Cancel
                </button>
              `;
            }

            card.innerHTML = `
              <div class="tribute-icon">${tribIcon}</div>
              <div class="tribute-proposer" title="${tribute.proposer}">${tribute.proposer.slice(0, 6)}...${tribute.proposer.slice(-4)}</div>
              <div class="tribute-amount">${tribBalance} ${tribSymbol}</div>
              <div class="tribute-request">Wants: ${forBalance} ${forSymbol}</div>
              <div class="tribute-buttons">${buttonsHtml}</div>
            `;

            tributeOffers.appendChild(card);

            // Resolve ENS name asynchronously and update display
            lookupENS(tribute.proposer).then(ensName => {
              const proposerEl = card.querySelector('.tribute-proposer');
              if (ensName && proposerEl) {
                proposerEl.textContent = ensName;
              }
            }).catch(() => {
              // Silently fail - address is already displayed
            });
          }
        } catch (error) {
          logger.error('Error rendering tributes:', error);
          tributeOffers.innerHTML = `
            <div style="grid-column: 1 / -1; padding: 1rem; text-align: center; color: #e74c3c; font-size: 0.85rem;">
              Error loading tributes
            </div>
          `;
        }
      }

      // Helper to get token symbol
      async function getTokenSymbol(tokenAddress) {
        try {
          return await withRpcFallback(async (rpcProvider) => {
            const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, rpcProvider);
            return await tokenContract.symbol();
          });
        } catch (error) {
          return tokenAddress.slice(0, 6);
        }
      }

      // Helper to get token decimals
      async function getTokenDecimals(tokenAddress) {
        try {
          return await withRpcFallback(async (rpcProvider) => {
            const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, rpcProvider);
            return await tokenContract.decimals();
          });
        } catch (error) {
          return 18;
        }
      }

      // Prepare transfer proposal from treasury asset
      async function prepareTransferProposal(asset) {
        // Clear any existing helpers and locked description first
        clearTransferHelper();
        clearMintHelper();
        clearFutarchyHelper();
        clearRendererHelper();
        clearQuorumHelper();
        clearTTLHelper();
        clearTimelockDelayHelper();
        clearThresholdHelper();
        clearRagequitHelper();
        clearTransferabilityHelper();
        clearEmergencyPermitHelper();
        clearSaleHelper();
        clearAllowanceHelper();
        clearTributeHelper();
        clearLockedDescription();

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add transfer helper UI
        let helperDiv = document.createElement('div');
        helperDiv.id = 'transferHelper';
        helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
        proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));

        // Store asset info for later use
        helperDiv.dataset.assetSymbol = asset.symbol;
        helperDiv.dataset.assetAddress = asset.address;
        helperDiv.dataset.assetDecimals = asset.decimals;

        // Show transfer helper with Send/Sale toggle (Sale only for DAI and custom 18-decimal tokens)
        const isDaiOrCustom = asset.address?.toLowerCase() === TOKEN_ADDRESSES.dai.toLowerCase() || asset.isCustomSale === true;
        const showSaleToggle = asset.decimals === 18 && isDaiOrCustom;
        const saleButtonHTML = showSaleToggle ? `
                <button id="saleToggle" onclick="toggleProposalMode('sale')"
                        style="padding: 0.35rem 0.75rem; background: transparent; border: none; color: var(--fg-dim); font-size: 0.7rem; letter-spacing: 0.1em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease;">
                  Sale
                </button>` : '';

        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
                ${asset.symbol}
              </div>
              <div style="display: flex; background: transparent; overflow: hidden;">
                <button id="sendToggle" onclick="toggleProposalMode('send')"
                        style="padding: 0.35rem 0.75rem; background: var(--surface-hover); border: none; color: var(--fg); font-size: 0.7rem; letter-spacing: 0.1em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease;">
                  Send
                </button>${saleButtonHTML}
              </div>
            </div>
            <button onclick="clearTransferHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div id="proposalFields"></div>
        `;

        // Show send mode by default
        toggleProposalMode('send');
      }

      function toggleProposalMode(mode) {
        const helperDiv = getEl('transferHelper');
        if (!helperDiv) return;

        const sendToggle = document.getElementById('sendToggle');
        const saleToggle = document.getElementById('saleToggle');
        const fieldsDiv = document.getElementById('proposalFields');

        const symbol = helperDiv.dataset.assetSymbol;
        const address = helperDiv.dataset.assetAddress;
        const decimals = parseInt(helperDiv.dataset.assetDecimals);

        // Validate decimals
        if (isNaN(decimals)) {
          showStatus('Invalid token configuration', true);
          return;
        }

        // Sale mode only available for 18-decimal tokens
        if (mode === 'sale' && decimals !== 18) {
          showStatus('Token sales require 18-decimal tokens for proper share pricing', true);
          return;
        }

        // Update toggle button states
        if (mode === 'send') {
          if (sendToggle) {
            sendToggle.style.background = cssVar('--border-muted');
            sendToggle.style.color = '#000';
          }
          if (saleToggle) {
            saleToggle.style.background = 'transparent';
            saleToggle.style.color = '#999';
          }

          // Show send fields
          fieldsDiv.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
              <div>
                <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Recipient Address or ENS</label>
                <input type="text" id="treasurySendRecipient" placeholder="vitalik.eth or 0x..."
                       style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 16px;" />
              </div>
              <div>
                <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Amount (${symbol})</label>
                <input type="text" id="treasurySendAmount" placeholder="0.0"
                       style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 16px;" />
              </div>
            </div>
            <button type="button" onclick="populateTransferProposalFromHelper()"
                    onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                    onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                    style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
              Populate Proposal Form
            </button>
          `;
          setTimeout(() => {
            const recipientInput = document.getElementById('treasurySendRecipient');
            if (recipientInput) recipientInput.focus();
          }, 100);

        } else if (mode === 'sale') {
          if (sendToggle) {
            sendToggle.style.background = 'transparent';
            sendToggle.style.color = '#999';
          }
          if (saleToggle) {
            saleToggle.style.background = cssVar('--border-muted');
            saleToggle.style.color = '#000';
          }

          // Show sale configuration fields
          fieldsDiv.innerHTML = `
            <div style="margin-bottom: 0.75rem;">
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Token Type</label>
              <select id="modalSaleTokenType"
                      style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 16px; min-height: 44px;">
                <option value="shares">Shares (Voting)</option>
                <option value="loot">Loot (Non-Voting)</option>
              </select>
            </div>
            <div style="margin-bottom: 0.75rem;">
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">
                Price per Token (${symbol}) <span style="color: #e74c3c;">*</span>
                <span title="For 1:1 upgrades, use 1.0" style="cursor: help; margin-left: 0.25rem;">â„¹ï¸</span>
              </label>
              <input type="text" id="modalSalePrice" placeholder="1.0" inputmode="decimal"
                     style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 16px;" />
            </div>
            <div style="margin-bottom: 0.75rem;">
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Sale Cap (0 = unlimited)</label>
              <input type="text" id="modalSaleCap" placeholder="0" inputmode="decimal"
                     style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 16px;" />
            </div>
            <div style="margin-bottom: 0.75rem;">
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Status</label>
              <select id="modalSaleStatus"
                      style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 16px; min-height: 44px;">
                <option value="active">Active</option>
                <option value="inactive">Inactive</option>
              </select>
            </div>
            <div style="margin-bottom: 0.75rem;">
              <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.85rem; color: var(--fg); cursor: pointer; min-height: 44px;">
                <input type="checkbox" id="modalSaleMinting" checked
                       style="width: 1.25rem; height: 1.25rem; cursor: pointer; accent-color: #000;" />
                <span>Mint new tokens (unchecked = sell from treasury)</span>
              </label>
            </div>
            <div id="customTokenSaleHint" style="display: none; margin-bottom: 0.75rem; padding: 0.75rem; background: #f9f9f9; border-left: 3px solid #000; font-size: 0.85rem; color: #000; line-height: 1.5;">
              <strong style="color: #000;">Sale Preview:</strong> <span id="customTokenSaleHintText"></span>
            </div>
            <button type="button" onclick="populateSaleProposalFromToggle('${symbol}', '${address}', ${decimals})"
                    onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                    onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                    style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
              Populate Proposal Form
            </button>
          `;
          setTimeout(() => {
            const priceInput = getEl('modalSalePrice');
            if (priceInput) priceInput.focus();

            // Set up event listeners for custom token sale hints
            const capInput = getEl('modalSaleCap');
            const typeInput = getEl('modalSaleTokenType');

            if (priceInput && capInput) {
              const updateHint = () => updateCustomTokenSaleHint(symbol);

              // Remove old listeners before adding new ones to prevent memory leaks
              priceInput.removeEventListener('input', updateHint);
              capInput.removeEventListener('input', updateHint);
              typeInput.removeEventListener('change', updateHint);

              // Add fresh listeners
              priceInput.addEventListener('input', updateHint);
              capInput.addEventListener('input', updateHint);
              typeInput.addEventListener('change', updateHint);
              updateHint(); // Initial update
            }
          }, 100);
        }
      }

      // Update custom token sale hint
      function updateCustomTokenSaleHint(tokenSymbol) {
        const priceInput = getEl('modalSalePrice')?.value?.trim();
        const capInput = getEl('modalSaleCap')?.value?.trim();
        const tokenType = getEl('modalSaleTokenType')?.value || 'shares';

        const hint = document.getElementById('customTokenSaleHint');
        const hintText = document.getElementById('customTokenSaleHintText');

        if (!hint || !hintText) return;

        const price = parseFloat(priceInput);
        const cap = parseFloat(capInput);

        const tokenTypeText = tokenType === 'loot' ? 'Loot' : 'Share';

        // Show hint even without price - guide the user
        if (!priceInput || isNaN(price) || price <= 0) {
          hintText.innerHTML = `<span style="opacity: 0.6;">Enter price to see sale preview (e.g., "1 ${tokenSymbol} for 1 ${tokenTypeText}")</span>`;
          hint.style.display = 'block';
          return;
        }

        // Detect 1:1 upgrade path
        const is1to1 = price === 1;

        // Build the hint text - more natural word order: "1 DAI for 1 Share"
        let text = `<strong>${price} ${tokenSymbol}</strong> for <strong>1 ${tokenTypeText}</strong>`;

        if (cap && !isNaN(cap) && cap > 0) {
          text += ` up to <strong>${cap.toLocaleString()} ${tokenTypeText}${cap !== 1 ? 's' : ''}</strong>`;
        } else {
          text += ` <span style="opacity: 0.7;">(unlimited)</span>`;
        }

        // Add 1:1 upgrade path hint or cost example
        if (is1to1) {
          text += ` <span style="color: #000; font-weight: 600; margin-left: 0.5rem;">â€¢ 1:1 Upgrade Path</span>`;
        } else {
          // Add cost example
          const exampleAmount = 100;
          const exampleCost = exampleAmount * price;
          text += `<br><span style="opacity: 0.6; font-size: 0.85em;">Example: ${exampleCost.toLocaleString()} ${tokenSymbol} buys ${exampleAmount} ${tokenTypeText}s</span>`;
        }

        hintText.innerHTML = text;
        hint.style.display = 'block';
      }

      function clearTransferHelper() {
        const helperDiv = getEl('transferHelper');
        if (helperDiv) helperDiv.remove();
      }

      // Prepare custom token proposal (Send or Sale)
      async function prepareCustomTokenProposal() {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        // Clear any existing helpers first
        clearTransferHelper();
        clearMintHelper();
        clearFutarchyHelper();
        clearQuorumHelper();
        clearTTLHelper();
        clearTimelockDelayHelper();
        clearThresholdHelper();
        clearRagequitHelper();
        clearTransferabilityHelper();
        clearEmergencyPermitHelper();
        clearSaleHelper();

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add custom token helper UI
        let helperDiv = document.createElement('div');
        helperDiv.id = 'transferHelper';
        helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
        proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));

        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">CUSTOM TOKEN</div>
            <button onclick="clearTransferHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f9f9f9; border-left: 3px solid #ccc; font-size: 0.8rem; color: var(--fg); line-height: 1.5;">
            <strong>Step 1:</strong> Enter token address and click "Fetch" to load token info<br>
            <strong>Step 2:</strong> Choose "Send" or "Sale" action after token is loaded
          </div>
          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">
              Token Address
              <span title="Enter a custom ERC20 token address. Use for token upgrades, custom sales, or transfers." style="cursor: help; margin-left: 0.25rem;">â„¹ï¸</span>
            </label>
            <div style="display: flex; gap: 0.5rem;">
              <input type="text" id="proposalCustomTokenAddress" placeholder="0x..." autocomplete="off"
                     onkeydown="if(event.key==='Enter'){event.preventDefault();fetchAndShowCustomToken();}"
                     style="flex: 1; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 16px;" />
              <button type="button" onclick="fetchAndShowCustomToken()"
                      style="padding: 0.6rem 1rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.1em; cursor: pointer; white-space: nowrap; min-height: 44px;">
                Fetch Token Info
              </button>
            </div>
            <div id="proposalCustomTokenInfoDisplay" style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--fg);"></div>
          </div>
          <div id="customTokenActions" style="display: none;"></div>
        `;

        setTimeout(() => {
          const addressInput = document.getElementById('proposalCustomTokenAddress');
          if (addressInput) addressInput.focus();
        }, 100);
      }

      // Fetch custom token info and show Send/Sale options
      async function fetchAndShowCustomToken() {
        try {
          const inputEl = document.getElementById('proposalCustomTokenAddress');
          const infoDiv = document.getElementById('proposalCustomTokenInfoDisplay');
          const actionsDiv = document.getElementById('customTokenActions');

          if (!infoDiv || !actionsDiv) {
            return;
          }

          if (!inputEl) {
            infoDiv.innerHTML = '<span style="color: #e74c3c;">Input field not found - try reopening the form</span>';
            actionsDiv.style.display = 'none';
            return;
          }

          const tokenAddress = inputEl.value?.trim();

          if (!tokenAddress || tokenAddress.length === 0) {
            infoDiv.innerHTML = '<span style="color: #e74c3c;">Please enter a token address</span>';
            actionsDiv.style.display = 'none';
            return;
          }

          // Validate Ethereum address format
          if (!ethers.isAddress(tokenAddress)) {
            infoDiv.innerHTML = '<span style="color: #e74c3c;">Invalid Ethereum address format</span>';
            actionsDiv.style.display = 'none';
            return;
          }

          // Normalize to checksummed address
          const checksummedAddress = ethers.getAddress(tokenAddress);

          if (!currentDAO || !currentDAO.dao || !currentDAO.dao.dao) {
            infoDiv.innerHTML = '<span style="color: #e74c3c;">Please select a DAO first</span>';
            actionsDiv.style.display = 'none';
            return;
          }

          if (!provider) {
            infoDiv.innerHTML = '<span style="color: #e74c3c;">Wallet not connected</span>';
            actionsDiv.style.display = 'none';
            showStatus('Please connect your wallet first', true);
            return;
          }

          infoDiv.innerHTML = 'Fetching token info...';
          actionsDiv.style.display = 'none';

          const tokenContract = new ethers.Contract(checksummedAddress, ERC20_ABI, provider);

          // Fetch token info with individual error handling for better diagnostics
          let name, symbol, decimals, daoBalance;

          try {
            name = await tokenContract.name();
          } catch (e) {
            logger.warn('Failed to fetch token name:', e);
            name = 'Unknown';
          }

          try {
            symbol = await tokenContract.symbol();
          } catch (e) {
            logger.warn('Failed to fetch token symbol:', e);
            symbol = 'UNKNOWN';
          }

          try {
            decimals = await tokenContract.decimals();
          } catch (e) {
            logger.warn('Failed to fetch token decimals:', e);
            decimals = 18;
          }

          try {
            daoBalance = await tokenContract.balanceOf(currentDAO.dao.dao);
          } catch (e) {
            logger.warn('Failed to fetch DAO balance:', e);
            daoBalance = 0n;
          }

          // Cache the result
          customTokenCache[checksummedAddress.toLowerCase()] = { name, symbol, decimals: Number(decimals) };

          const balanceFormatted = parseFloat(ethers.formatUnits(daoBalance, decimals)).toFixed(2);

          infoDiv.innerHTML = `
            <div style="padding: 0.5rem; background: #f9f9f9; border-left: 3px solid #000; ">
              <div><strong>${name}</strong> (${symbol})</div>
              <div style="font-size: 0.7rem; opacity: 0.8; margin-top: 0.25rem;">${decimals} decimals â€¢ DAO Balance: ${balanceFormatted}</div>
              <div style="font-size: 0.65rem; opacity: 0.6; margin-top: 0.25rem; font-family: monospace;">${checksummedAddress}</div>
            </div>
          `;

          // Store token info in the helper div for later use
          const helperDiv = getEl('transferHelper');
          if (helperDiv) {
            helperDiv.dataset.assetSymbol = symbol;
            helperDiv.dataset.assetAddress = checksummedAddress;
            helperDiv.dataset.assetDecimals = decimals;
          }

          // Show Send/Sale toggle with clear instructions (Sale only for 18-decimal tokens)
          actionsDiv.style.display = 'block';
          const showSaleToggle = Number(decimals) === 18;
          const saleButtonHTML = showSaleToggle ? `
                <button id="saleToggle" onclick="toggleProposalMode('sale')"
                        style="flex: 1; padding: 0.5rem 0.75rem; background: transparent; border: none; color: var(--fg-dim); font-size: 0.7rem; letter-spacing: 0.1em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; min-height: 44px;">
                  Sale
                </button>` : '';
          const decimalWarning = !showSaleToggle ? `
              <div style="margin-top: 0.5rem; padding: 0.5rem; background: #fff8e0; border-left: 3px solid #ddc040; font-size: 0.7rem; color: #b8860b;">
                âš ï¸ Token sales require 18-decimal tokens. This ${decimals}-decimal token can only be sent.
              </div>` : '';

          actionsDiv.innerHTML = `
            <div style="padding: 0.75rem; background: var(--surface); border: 1px solid var(--border-muted); margin-bottom: 0.75rem;">
              <div style="font-size: 0.75rem; color: var(--fg); margin-bottom: 0.5rem;">âœ“ Token loaded! Choose an action:</div>
              <div style="display: flex; background: transparent; overflow: hidden;">
                <button id="sendToggle" onclick="toggleProposalMode('send')"
                        style="flex: 1; padding: 0.5rem 0.75rem; background: var(--surface-hover); border: none; color: var(--fg); font-size: 0.7rem; letter-spacing: 0.1em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; min-height: 44px;">
                  Send
                </button>${saleButtonHTML}
              </div>${decimalWarning}
            </div>
            <div id="proposalFields"></div>
          `;

          // Show send mode by default
          toggleProposalMode('send');

        } catch (error) {
          logger.error('Error fetching custom token:', error);
          const infoDiv = document.getElementById('proposalCustomTokenInfoDisplay');
          const actionsDiv = document.getElementById('customTokenActions');

          let errorMsg = 'Failed to fetch token info';
          if (error.message) {
            if (error.message.includes('network') || error.message.includes('connection')) {
              errorMsg = 'Network error - check your connection';
            } else if (error.message.includes('invalid') || error.message.includes('not a contract')) {
              errorMsg = 'Invalid token address - not an ERC20 contract';
            } else {
              errorMsg = `Error: ${error.message.slice(0, 100)}`;
            }
          }

          if (infoDiv) {
            infoDiv.innerHTML = `<span style="color: #e74c3c;">${errorMsg}</span>`;
          }
          if (actionsDiv) {
            actionsDiv.style.display = 'none';
          }
        }
      }

      // Wrapper function to read params from helper div dataset
      async function populateTransferProposalFromHelper() {
        const helperDiv = getEl('transferHelper');
        if (!helperDiv) {
          showStatus('Transfer helper not found', true);
          return;
        }
        const symbol = helperDiv.dataset.assetSymbol;
        const address = helperDiv.dataset.assetAddress;
        const decimals = parseInt(helperDiv.dataset.assetDecimals);
        await populateTransferProposal(symbol, address, decimals);
      }

      async function populateTransferProposal(symbol, address, decimals) {
        try {
          const recipientEl = document.getElementById('treasurySendRecipient');
          const amountEl = document.getElementById('treasurySendAmount');

          if (!recipientEl || !amountEl) {
            showStatus('Input fields not found', true);
            return;
          }

          const recipientInput = recipientEl.value.trim();
          let amountInput = amountEl.value.trim();

          if (!recipientInput) {
            showStatus('Please enter recipient address or ENS', true);
            return;
          }

          // Remove commas from amount for parsing
          amountInput = amountInput.replace(/,/g, '');

          if (!amountInput || isNaN(amountInput) || parseFloat(amountInput) <= 0) {
            showStatus('Please enter valid amount', true);
            return;
          }

          showStatus('Resolving address...', false);

          // Resolve ENS if needed
          let recipientAddress = recipientInput;
          if (recipientInput.endsWith('.eth') || !recipientInput.startsWith('0x')) {
            if (!provider) {
              showStatus('Provider not available for ENS resolution', true);
              return;
            }
            try {
              const resolved = await provider.resolveName(recipientInput);
              if (!resolved) {
                showStatus('Could not resolve ENS name', true);
                return;
              }
              recipientAddress = resolved;
              showStatus(`Resolved to ${recipientAddress.slice(0, 6)}...${recipientAddress.slice(-4)}`, false);
            } catch (error) {
              showStatus('ENS resolution failed', true);
              return;
            }
          }

          // Validate address
          if (!ethers.isAddress(recipientAddress)) {
            showStatus('Invalid address', true);
            return;
          }

          const amount = amountInput;
          const amountWei = ethers.parseUnits(amount, decimals);

          // Populate form
          let description;
          let lockedDesc;
          if (symbol === 'ETH') {
            // For ETH: target is recipient, value is amount, no calldata
            getEl('proposalTo').value = recipientAddress;
            getEl('proposalValue').value = amount;
            getEl('proposalData').value = '0x';
            description = `Transfer ${amount} ETH to ${recipientInput}`;
            lockedDesc = `${description}\n\n<<<TRANSFER token=ETH amount=${amountWei.toString()} recipient=${recipientAddress} TRANSFER>>>`;
          } else {
            // For ERC20: target is token contract, encode transfer calldata
            // transfer(address recipient, uint256 amount)
            const abiCoder = new ethers.AbiCoder();
            const transferCalldata = '0xa9059cbb' + abiCoder.encode(
              ['address', 'uint256'],
              [recipientAddress, amountWei]
            ).slice(2);

            getEl('proposalTo').value = address;
            getEl('proposalValue').value = '0';
            getEl('proposalData').value = transferCalldata;
            description = `Transfer ${amount} ${symbol} to ${recipientInput}`;
            lockedDesc = `${description}\n\n<<<TRANSFER token=${address} symbol=${symbol} amount=${amountWei.toString()} recipient=${recipientAddress} TRANSFER>>>`;
          }

          // Set locked description
          setLockedProposalDescription(lockedDesc, description);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearTransferHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating transfer proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Prepare mint proposal for shares or loot
      async function prepareMintProposal(tokenType) {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const dao = currentDAO.dao;
        const tokenAddress = tokenType === 'shares' ? dao.meta.sharesToken : dao.meta.lootToken;
        const tokenSymbol = tokenType === 'shares' ? dao.meta.symbol : `${dao.meta.symbol}-LOOT`;

        if (!tokenAddress) {
          showStatus(`${tokenType} token address not found`, true);
          return;
        }

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add mint helper UI if not already present
        let helperDiv = document.getElementById('mintHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'mintHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        // Show mint helper
        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
              MINT ${tokenType.toUpperCase()}
            </div>
            <button onclick="clearMintHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Recipient Address or ENS</label>
              <input type="text" id="mintRecipient" placeholder="vitalik.eth or 0x..."
                     style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;" />
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Amount (${tokenSymbol})</label>
              <input type="text" id="mintAmount" placeholder="0.0"
                     style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;" />
            </div>
          </div>
          <button onclick="populateMintProposal('${tokenType}', '${tokenSymbol}', '${tokenAddress}')"
                  onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                  onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Focus on recipient input
        setTimeout(() => {
          const recipientInput = document.getElementById('mintRecipient');
          if (recipientInput) recipientInput.focus();
        }, 100);
      }

      function clearMintHelper() {
        const helperDiv = document.getElementById('mintHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateMintProposal(tokenType, tokenSymbol, tokenAddress) {
        try {
          const recipientInput = document.getElementById('mintRecipient').value.trim();
          const amountInput = document.getElementById('mintAmount').value.trim();

          if (!recipientInput) {
            showStatus('Please enter recipient address or ENS', true);
            return;
          }

          if (!amountInput || isNaN(amountInput) || parseFloat(amountInput) <= 0) {
            showStatus('Please enter valid amount', true);
            return;
          }

          showStatus('Resolving address...', false);

          // Resolve ENS if needed
          let recipientAddress = recipientInput;
          if (recipientInput.endsWith('.eth') || !recipientInput.startsWith('0x')) {
            if (!provider) {
              showStatus('Provider not available for ENS resolution', true);
              return;
            }
            try {
              const resolved = await provider.resolveName(recipientInput);
              if (!resolved) {
                showStatus('Could not resolve ENS name', true);
                return;
              }
              recipientAddress = resolved;
              showStatus(`Resolved to ${recipientAddress.slice(0, 6)}...${recipientAddress.slice(-4)}`, false);
            } catch (error) {
              showStatus('ENS resolution failed', true);
              return;
            }
          }

          // Validate address
          if (!ethers.isAddress(recipientAddress)) {
            showStatus('Invalid address', true);
            return;
          }

          const amount = amountInput;
          const amountWei = ethers.parseUnits(amount, 18); // Shares and loot are always 18 decimals

          // Encode mintFromMoloch(address recipient, uint256 amount)
          const mintCalldata = INTERFACES.mintFromMoloch.encodeFunctionData('mintFromMoloch', [recipientAddress, amountWei]);

          getEl('proposalTo').value = tokenAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = mintCalldata;

          const description = `Mint ${amount} ${tokenSymbol} to ${recipientInput}`;
          setLockedProposalDescription(description);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearMintHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating mint proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Prepare futarchy proposal for DAO self-configuration
      async function prepareFutarchyProposal() {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const dao = currentDAO.dao;
        const daoAddress = dao.dao;

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add futarchy helper UI if not already present
        let helperDiv = document.getElementById('futarchyHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'futarchyHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        // Get current futarchy settings
        const currentParam = BigInt(dao.gov.autoFutarchyParam || 0);
        const currentCap = BigInt(dao.gov.autoFutarchyCap || 0);
        let currentPreset = 'off';

        if (currentParam > 0n && currentCap > 0n) {
          if (currentParam === 5n && currentCap === ethers.parseEther('2')) {
            currentPreset = 'low';
          } else if (currentParam === 10n && currentCap === ethers.parseEther('5')) {
            currentPreset = 'standard';
          } else if (currentParam === 50n && currentCap === ethers.parseEther('10')) {
            currentPreset = 'high';
          } else {
            currentPreset = 'custom';
          }
        }

        // Show futarchy helper
        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
              CONFIGURE AUTO-FUTARCHY
            </div>
            <button onclick="clearFutarchyHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Preset</label>
            <select id="futarchyPreset"
                    style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;">
              <option value="off" ${currentPreset === 'off' ? 'selected' : ''}>Off (Disable auto-futarchy)</option>
              <option value="low" ${currentPreset === 'low' ? 'selected' : ''}>Low: 0.05% supply, 2 LOOT cap</option>
              <option value="standard" ${currentPreset === 'standard' ? 'selected' : ''}>Standard: 0.1% supply, 5 LOOT cap</option>
              <option value="high" ${currentPreset === 'high' ? 'selected' : ''}>High: 0.5% supply, 10 LOOT cap</option>
            </select>
            <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--fg-dim);">
              Auto-futarchy mints LOOT rewards to winning voters (% of total supply, capped per proposal)
            </div>
          </div>
          <button onclick="populateFutarchyProposal('${daoAddress}')"
                  onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                  onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Focus on preset dropdown
        setTimeout(() => {
          const presetSelect = document.getElementById('futarchyPreset');
          if (presetSelect) presetSelect.focus();
        }, 100);
      }

      function clearFutarchyHelper() {
        const helperDiv = document.getElementById('futarchyHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateFutarchyProposal(daoAddress) {
        try {
          const preset = document.getElementById('futarchyPreset').value;

          let param = 0n;
          let cap = 0n;
          let description = '';

          if (preset === 'off') {
            param = 0n;
            cap = 0n;
            description = 'Disable auto-futarchy (turn off voter rewards)';
          } else if (preset === 'low') {
            param = 5n;  // 5 bps (0.05%)
            cap = ethers.parseEther('2');  // 2 LOOT
            description = 'Enable auto-futarchy: Low (0.05% supply, 2 LOOT cap)';
          } else if (preset === 'standard') {
            param = 10n;  // 10 bps (0.1%)
            cap = ethers.parseEther('5');  // 5 LOOT
            description = 'Enable auto-futarchy: Standard (0.1% supply, 5 LOOT cap)';
          } else if (preset === 'high') {
            param = 50n;  // 50 bps (0.5%)
            cap = ethers.parseEther('10');  // 10 LOOT
            description = 'Enable auto-futarchy: High (0.5% supply, 10 LOOT cap)';
          }

          // Encode setAutoFutarchy(uint256 param, uint256 cap)
          const futarchyCalldata = INTERFACES.setAutoFutarchy.encodeFunctionData('setAutoFutarchy', [param, cap]);

          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = futarchyCalldata;

          setLockedProposalDescription(description);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearFutarchyHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating futarchy proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Renderer proposal helper
      async function prepareRendererProposal() {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const dao = currentDAO.dao;
        const daoAddress = dao.dao;
        const currentRenderer = dao.meta.renderer;

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add renderer helper UI if not already present
        let helperDiv = document.getElementById('rendererHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'rendererHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        // Show renderer helper
        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
              CHANGE RENDERER
            </div>
            <button onclick="clearRendererHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Current Renderer</label>
            <div style="font-size: 0.85rem; color: var(--fg-dim); margin-bottom: 0.75rem; font-family: 'Courier New', monospace;">
              <a href="${getNetwork().explorer}/address/${currentRenderer}" target="_blank" rel="noopener noreferrer" style="color: #000; text-decoration: none;">${currentRenderer}</a>
            </div>
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">New Renderer Address</label>
            <input type="text" id="rendererAddress" placeholder="0x..."
                   style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-family: 'Courier New', monospace; font-size: 0.85rem;" />
            <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--fg-dim);">
              The renderer contract generates NFT metadata for receipts and badges
            </div>
          </div>
          <button onclick="populateRendererProposal('${daoAddress}')"
                  onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                  onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Focus on input
        setTimeout(() => {
          const input = document.getElementById('rendererAddress');
          if (input) {
            input.focus();
          }
        }, 100);
      }

      function clearRendererHelper() {
        const helperDiv = document.getElementById('rendererHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateRendererProposal(daoAddress) {
        try {
          const rendererInput = document.getElementById('rendererAddress').value.trim();

          if (!rendererInput || !ethers.isAddress(rendererInput)) {
            showStatus('Please enter a valid Ethereum address', true);
            return;
          }

          // Encode setRenderer(address)
          const rendererCalldata = INTERFACES.setRenderer.encodeFunctionData('setRenderer', [rendererInput]);

          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = rendererCalldata;

          setLockedProposalDescription(`Change renderer to ${rendererInput}`);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearRendererHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating renderer proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Quorum proposal helper
      async function prepareQuorumProposal() {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const dao = currentDAO.dao;
        const daoAddress = dao.dao;
        const currentQuorum = (Number(dao.gov.quorumBps) / 100).toFixed(2);

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add quorum helper UI if not already present
        let helperDiv = document.getElementById('quorumHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'quorumHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        // Calculate current quorum in votes
        const currentTotalSupply = BigInt(currentDAO.dao.supplies.sharesTotalSupply || 0);
        const currentQuorumBps = Number(currentDAO.dao.gov.quorumBps);
        const currentRequiredVotes = (BigInt(currentQuorumBps) * currentTotalSupply) / 10000n;
        const currentRequiredVotesFormatted = parseFloat(ethers.formatEther(currentRequiredVotes)).toFixed(2);
        const totalSupplyFormatted = parseFloat(ethers.formatEther(currentTotalSupply)).toFixed(2);

        // Check if current quorum rounds to 0
        const hasZeroQuorum = currentQuorumBps > 0 && currentTotalSupply > 0n && currentRequiredVotes === 0n;

        // Show quorum helper
        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
              CHANGE QUORUM
            </div>
            <button onclick="clearQuorumHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f9f9f9; ">
            <div style="font-size: 0.85rem; color: var(--fg); margin-bottom: 0.5rem;">
              Current Quorum: <strong>${currentQuorum}%</strong>
            </div>
            <div style="font-size: 0.85rem; color: var(--fg);">
              Current estimated quorum: <strong>${currentRequiredVotesFormatted} votes</strong> / ${totalSupplyFormatted} shares
            </div>
            ${hasZeroQuorum ? `
              <div style="margin-top: 0.5rem; padding: 0.5rem; background: #fff0f0; border: 1px solid #e74c3c; font-size: 0.8rem; color: #e74c3c;">
                <strong>âš ï¸ Warning:</strong> Current quorumBps results in 0-vote quorum due to rounding. Consider increasing quorumBps or setting an absolute quorum.
              </div>
            ` : ''}
          </div>
          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">New Quorum Percentage</label>
            <input type="text" id="quorumPercentage" placeholder="${currentQuorum}" value="${currentQuorum}"
                   oninput="updateProposalQuorumPreview()"
                   style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;" />
            <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--fg-dim);">
              Quorum is the minimum % of shares required to pass proposals
            </div>
            <div id="proposalQuorumPreview" style="margin-top: 0.5rem; display: none;"></div>
          </div>
          <button onclick="populateQuorumProposal('${daoAddress}')"
                  onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                  onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Focus on input
        setTimeout(() => {
          const input = getEl('quorumPercentage');
          if (input) {
            input.select();
            input.focus();
          }
        }, 100);
      }

      function updateProposalQuorumPreview() {
        if (!currentDAO) return;

        const previewDiv = document.getElementById('proposalQuorumPreview');
        const percentInput = getEl('quorumPercentage');
        if (!previewDiv || !percentInput) return;

        const newPercent = parseFloat(percentInput.value);
        if (isNaN(newPercent) || newPercent < 0 || newPercent > 100) {
          previewDiv.style.display = 'none';
          return;
        }

        const newQuorumBps = Math.floor(newPercent * 100);
        const currentTotalSupply = BigInt(currentDAO.dao.supplies.sharesTotalSupply || 0);
        const newRequiredVotes = (BigInt(newQuorumBps) * currentTotalSupply) / 10000n;
        const newRequiredVotesFormatted = parseFloat(ethers.formatEther(newRequiredVotes)).toFixed(2);

        const hasZeroQuorum = newQuorumBps > 0 && currentTotalSupply > 0n && newRequiredVotes === 0n;

        if (hasZeroQuorum) {
          previewDiv.innerHTML = `
            <div style="padding: 0.5rem; background: #fff0f0; border: 1px solid #e74c3c; font-size: 0.8rem; color: #e74c3c;">
              <strong>âš ï¸ Warning:</strong> New quorum (${newPercent}%) will result in <strong>0 required votes</strong>. Consider a higher percentage.
            </div>
          `;
          previewDiv.style.display = 'block';
        } else {
          previewDiv.innerHTML = `
            <div style="padding: 0.5rem; background: var(--surface); border: 1px solid var(--border-muted); font-size: 0.8rem; color: #000;">
              New estimated quorum: <strong>${newRequiredVotesFormatted} votes</strong>
            </div>
          `;
          previewDiv.style.display = 'block';
        }
      }

      function clearQuorumHelper() {
        const helperDiv = document.getElementById('quorumHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateQuorumProposal(daoAddress) {
        try {
          const percentInput = getEl('quorumPercentage').value.trim();

          if (!percentInput || isNaN(percentInput) || parseFloat(percentInput) < 0 || parseFloat(percentInput) > 100) {
            showStatus('Please enter a valid percentage (0-100)', true);
            return;
          }

          const quorumBps = Math.floor(parseFloat(percentInput) * 100);

          // Warn if this would result in 0 required votes
          if (currentDAO) {
            const currentTotalSupply = BigInt(currentDAO.dao.supplies.sharesTotalSupply || 0);
            const newRequiredVotes = (BigInt(quorumBps) * currentTotalSupply) / 10000n;

            if (quorumBps > 0 && currentTotalSupply > 0n && newRequiredVotes === 0n) {
              const continueAnyway = confirm(
                'âš ï¸ WARNING: This quorum percentage with current supply results in 0 required votes.\n\n' +
                'This effectively disables dynamic quorum for proposals.\n\n' +
                'Consider:\n' +
                'â€¢ Using a higher percentage\n' +
                'â€¢ Setting an absolute quorum instead\n\n' +
                'Do you want to create this proposal anyway?'
              );
              if (!continueAnyway) {
                return;
              }
            }
          }

          // Encode setQuorumBps(uint16 bps)
          const calldata = INTERFACES.setQuorumBps.encodeFunctionData('setQuorumBps', [quorumBps]);

          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          setLockedProposalDescription(`Change quorum to ${percentInput}%`);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearQuorumHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating quorum proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // TTL proposal helper
      async function prepareTTLProposal() {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const dao = currentDAO.dao;
        const daoAddress = dao.dao;
        const currentTTL = Number(dao.gov.proposalTTL || 0);

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add TTL helper UI if not already present
        let helperDiv = document.getElementById('ttlHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'ttlHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        // Convert current TTL to most appropriate unit
        let defaultValue, defaultUnit;
        if (currentTTL % 86400 === 0 && currentTTL > 0) {
          defaultValue = currentTTL / 86400;
          defaultUnit = '86400';
        } else if (currentTTL % 3600 === 0 && currentTTL > 0) {
          defaultValue = currentTTL / 3600;
          defaultUnit = '3600';
        } else if (currentTTL % 60 === 0 && currentTTL > 0) {
          defaultValue = currentTTL / 60;
          defaultUnit = '60';
        } else {
          defaultValue = currentTTL;
          defaultUnit = '1';
        }

        // Show TTL helper
        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
              CHANGE PROPOSAL TTL
            </div>
            <button onclick="clearTTLHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">New Proposal TTL</label>
            <div style="display: flex; gap: 0.5rem;">
              <input type="number" id="ttlValue" placeholder="${defaultValue}" value="${defaultValue}"
                     style="flex: 1; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;" />
              <select id="ttlUnit" style="padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;">
                <option value="86400" ${defaultUnit === '86400' ? 'selected' : ''}>Days</option>
                <option value="3600" ${defaultUnit === '3600' ? 'selected' : ''}>Hours</option>
                <option value="60" ${defaultUnit === '60' ? 'selected' : ''}>Minutes</option>
                <option value="1" ${defaultUnit === '1' ? 'selected' : ''}>Seconds</option>
              </select>
            </div>
            <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--fg-dim);">
              Current: ${formatDuration(currentTTL)}. TTL determines how long proposals remain active before expiring.
            </div>
          </div>
          <button onclick="populateTTLProposal('${daoAddress}')"
                  onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                  onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Focus on input
        setTimeout(() => {
          const input = document.getElementById('ttlValue');
          if (input) {
            input.select();
            input.focus();
          }
        }, 100);
      }

      function clearTTLHelper() {
        const helperDiv = document.getElementById('ttlHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateTTLProposal(daoAddress) {
        try {
          const valueInput = document.getElementById('ttlValue').value.trim();
          const unitMultiplier = parseInt(document.getElementById('ttlUnit').value);

          if (!valueInput || isNaN(valueInput) || parseFloat(valueInput) < 0) {
            showStatus('Please enter a valid positive number', true);
            return;
          }

          const ttlSeconds = Math.floor(parseFloat(valueInput) * unitMultiplier);

          // Encode setProposalTTL(uint64)
          const calldata = INTERFACES.setProposalTTL.encodeFunctionData('setProposalTTL', [ttlSeconds]);

          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          setLockedProposalDescription(`Change proposal TTL to ${formatDuration(ttlSeconds)}`);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearTTLHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating TTL proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Timelock Delay proposal helper
      async function prepareTimelockDelayProposal() {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const dao = currentDAO.dao;
        const daoAddress = dao.dao;
        const currentDelay = Number(dao.gov.timelockDelay || 0);

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add timelock delay helper UI if not already present
        let helperDiv = document.getElementById('timelockDelayHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'timelockDelayHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        // Convert current delay to most appropriate unit
        let defaultValue, defaultUnit;
        if (currentDelay % 86400 === 0 && currentDelay > 0) {
          defaultValue = currentDelay / 86400;
          defaultUnit = '86400';
        } else if (currentDelay % 3600 === 0 && currentDelay > 0) {
          defaultValue = currentDelay / 3600;
          defaultUnit = '3600';
        } else if (currentDelay % 60 === 0 && currentDelay > 0) {
          defaultValue = currentDelay / 60;
          defaultUnit = '60';
        } else {
          defaultValue = currentDelay;
          defaultUnit = '1';
        }

        // Show timelock delay helper
        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
              CHANGE TIMELOCK DELAY
            </div>
            <button onclick="clearTimelockDelayHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">New Timelock Delay</label>
            <div style="display: flex; gap: 0.5rem;">
              <input type="number" id="proposalTimelockDelayValue" placeholder="${defaultValue}" value="${defaultValue}"
                     style="flex: 1; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;" />
              <select id="proposalTimelockDelayUnit" style="padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;">
                <option value="86400" ${defaultUnit === '86400' ? 'selected' : ''}>Days</option>
                <option value="3600" ${defaultUnit === '3600' ? 'selected' : ''}>Hours</option>
                <option value="60" ${defaultUnit === '60' ? 'selected' : ''}>Minutes</option>
                <option value="1" ${defaultUnit === '1' ? 'selected' : ''}>Seconds</option>
              </select>
            </div>
            <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--fg-dim);">
              Current: ${formatDuration(currentDelay)}. Timelock delay determines how long to wait after a proposal passes before it can be executed.
            </div>
          </div>
          <button onclick="populateTimelockDelayProposal('${daoAddress}')"
                  onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                  onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Focus on input
        setTimeout(() => {
          const input = document.getElementById('proposalTimelockDelayValue');
          if (input) {
            input.select();
            input.focus();
          }
        }, 100);
      }

      function clearTimelockDelayHelper() {
        const helperDiv = document.getElementById('timelockDelayHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateTimelockDelayProposal(daoAddress) {
        try {
          const valueInput = document.getElementById('proposalTimelockDelayValue').value.trim();
          const unitMultiplier = parseInt(document.getElementById('proposalTimelockDelayUnit').value);

          if (!valueInput || isNaN(valueInput) || parseFloat(valueInput) < 0) {
            showStatus('Please enter a valid positive number', true);
            return;
          }

          const delaySeconds = Math.floor(parseFloat(valueInput) * unitMultiplier);

          // Encode setTimelockDelay(uint64)
          const calldata = INTERFACES.setTimelockDelay.encodeFunctionData('setTimelockDelay', [delaySeconds]);

          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          setLockedProposalDescription(`Change timelock delay to ${formatDuration(delaySeconds)}`);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearTimelockDelayHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating timelock delay proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Proposal Threshold helper
      async function prepareThresholdProposal() {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const dao = currentDAO.dao;
        const daoAddress = dao.dao;
        const currentThreshold = BigInt(dao.gov.proposalThreshold || 0);
        const currentThresholdFormatted = parseFloat(ethers.formatUnits(currentThreshold, 18)).toFixed(2);

        // Get current total share supply (not including shares held by DAO)
        const totalShares = BigInt(dao.supplies.sharesTotalSupply || 0);
        const sharesHeldByDAO = BigInt(dao.supplies.sharesHeldByDAO || 0);
        const circulatingShares = totalShares - sharesHeldByDAO;

        // Check for active DAICO sales that sell voting shares
        let daicoSharesAvailable = 0n;
        try {
          const daicoContract = new ethers.Contract(DAICO_ADDRESS, DAICO_ABI, provider);
          const sharesAddress = dao.meta.sharesToken;

          // Query DAICO for sales with common payment tokens
          const paymentTokens = [
            ethers.ZeroAddress, // ETH
            TOKEN_ADDRESSES.usdc,
            TOKEN_ADDRESSES.usdt,
            TOKEN_ADDRESSES.dai,
            TOKEN_ADDRESSES.wsteth,
            TOKEN_ADDRESSES.reth
          ];

          const now = Math.floor(Date.now() / 1000);
          for (const payToken of paymentTokens) {
            try {
              const sale = await daicoContract.sales(daoAddress, payToken);
              // Check if sale is active (not expired)
              const isExpired = sale.deadline > 0 && Number(sale.deadline) < now;
              if (sale.tribAmt > 0n && sale.forAmt > 0n && sale.forTkn.toLowerCase() === sharesAddress.toLowerCase() && !isExpired) {
                // This is a DAICO sale selling voting shares - get available allowance
                const sharesContract = new ethers.Contract(sharesAddress, ERC20_ABI, provider);
                const allowance = await sharesContract.allowance(daoAddress, DAICO_ADDRESS);
                daicoSharesAvailable += allowance;
              }
            } catch (e) {
              // Sale doesn't exist for this token, continue
            }
          }
        } catch (e) {
          logger.error('Error checking DAICO sales:', e);
        }

        const maxPotentialShares = circulatingShares + daicoSharesAvailable;
        const maxThreshold = parseFloat(ethers.formatUnits(maxPotentialShares, 18)).toFixed(2);
        const hasDaicoShares = daicoSharesAvailable > 0n;
        const daicoSharesFormatted = parseFloat(ethers.formatUnits(daicoSharesAvailable, 18)).toFixed(2);
        const circulatingFormatted = parseFloat(ethers.formatUnits(circulatingShares, 18)).toFixed(2);

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add threshold helper UI if not already present
        let helperDiv = document.getElementById('thresholdHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'thresholdHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        // Build max allowed description
        const maxDesc = hasDaicoShares
          ? `<strong>${maxThreshold}</strong> shares (${circulatingFormatted} circulating + ${daicoSharesFormatted} DAICO sale)`
          : `<strong>${maxThreshold}</strong> shares (total circulating supply)`;

        // Show threshold helper
        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
              CHANGE PROPOSAL THRESHOLD
            </div>
            <button onclick="clearThresholdHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">New Proposal Threshold (shares)</label>
            <input type="number" id="thresholdValue" placeholder="${currentThresholdFormatted}" value="${currentThresholdFormatted}" step="0.01" min="0" max="${maxThreshold}"
                   style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;" />
            <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--fg-dim);">
              Current: <strong>${currentThresholdFormatted}</strong> shares. Max allowed: ${maxDesc}.
            </div>
            <div style="margin-top: 0.35rem; font-size: 0.7rem; color: #aaa;">
              ðŸ’¡ Minimum shares required to create proposals. Cannot exceed potential share supply.
            </div>
          </div>
          <button onclick="populateThresholdProposal('${daoAddress}', '${maxThreshold}')"
                  onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                  onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Focus on input
        setTimeout(() => {
          const input = document.getElementById('thresholdValue');
          if (input) {
            input.select();
            input.focus();
          }
        }, 100);
      }

      function clearThresholdHelper() {
        const helperDiv = document.getElementById('thresholdHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateThresholdProposal(daoAddress, maxThresholdStr) {
        try {
          const thresholdInput = document.getElementById('thresholdValue').value.trim();
          const maxThreshold = parseFloat(maxThresholdStr);

          if (!thresholdInput || isNaN(thresholdInput) || parseFloat(thresholdInput) < 0) {
            showStatus('Please enter a valid positive number', true);
            return;
          }

          const thresholdValue = parseFloat(thresholdInput);

          // Validate against max potential supply (circulating + DAICO shares)
          if (thresholdValue > maxThreshold) {
            showStatus(`Threshold cannot exceed max potential share supply (${maxThreshold} shares)`, true);
            return;
          }

          // Convert to wei (uint96)
          const thresholdWei = ethers.parseUnits(thresholdValue.toString(), 18);

          // Encode setProposalThreshold(uint96)
          const calldata = INTERFACES.setProposalThreshold.encodeFunctionData('setProposalThreshold', [thresholdWei]);

          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          setLockedProposalDescription(`Change proposal threshold to ${thresholdValue} shares`);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearThresholdHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating threshold proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Ragequit proposal helper
      async function prepareRagequitProposal() {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const dao = currentDAO.dao;
        const daoAddress = dao.dao;
        const currentRagequit = dao.gov.ragequittable;

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add ragequit helper UI if not already present
        let helperDiv = document.getElementById('ragequitHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'ragequitHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        const newStatus = !currentRagequit;
        const actionText = newStatus ? 'Enable' : 'Disable';

        // Show ragequit helper
        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
              TOGGLE RAGEQUIT
            </div>
            <button onclick="clearRagequitHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f9f9f9; ">
            <div style="font-size: 0.85rem; color: var(--fg); margin-bottom: 0.5rem;">
              Current Status: <strong>${currentRagequit ? 'Enabled' : 'Disabled'}</strong>
            </div>
            <div style="font-size: 0.85rem; color: var(--fg);">
              This proposal will: <strong>${actionText} Ragequit</strong>
            </div>
            <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--fg-dim);">
              Ragequit allows members to exit the DAO and claim their proportional share of treasury
            </div>
          </div>
          <button onclick="populateRagequitProposal('${daoAddress}', ${newStatus})"
                  onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                  onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;
      }

      function clearRagequitHelper() {
        const helperDiv = document.getElementById('ragequitHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateRagequitProposal(daoAddress, newStatus) {
        try {
          // Encode setRagequittable(bool)
          const calldata = INTERFACES.setRagequittable.encodeFunctionData('setRagequittable', [newStatus]);

          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          setLockedProposalDescription(`${newStatus ? 'Enable' : 'Disable'} ragequit`);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearRagequitHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating ragequit proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Transferability proposal helper
      async function prepareTransferabilityProposal() {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const dao = currentDAO.dao;
        const daoAddress = dao.dao;

        // Get current lock status
        if (!currentDAO._transferLocks) {
          showStatus('Transfer lock status not loaded yet, please wait...', true);
          return;
        }

        const { sharesLocked, lootLocked } = currentDAO._transferLocks;

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add transferability helper UI if not already present
        let helperDiv = document.getElementById('transferabilityHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'transferabilityHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        // Show transferability helper with toggle options
        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
              CONFIGURE TRANSFERABILITY
            </div>
            <button onclick="clearTransferabilityHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f9f9f9; ">
            <div style="font-size: 0.85rem; color: var(--fg); margin-bottom: 0.5rem;">
              Current Status:
            </div>
            <div style="font-size: 0.85rem; color: var(--fg); margin-left: 1rem;">
              <div>Shares: <strong>${sharesLocked ? 'Locked (non-transferable)' : 'Unlocked (transferable)'}</strong></div>
              <div>Loot: <strong>${lootLocked ? 'Locked (non-transferable)' : 'Unlocked (transferable)'}</strong></div>
            </div>
            <div style="margin-top: 0.75rem; font-size: 0.75rem; color: var(--fg-dim);">
              Select which tokens to update (unchecked items will keep their current state):
            </div>
          </div>
          <div style="margin-bottom: 0.75rem; display: flex; flex-direction: column; gap: 0.5rem;">
            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.75rem; background: var(--surface); border: 1px solid var(--border-muted); transition: all 0.2s ease;"
                   onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)';"
                   onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)';">
              <input type="checkbox" id="transferabilityUpdateShares" checked style="cursor: pointer; width: 18px; height: 18px; accent-color: #000;">
              <span style="color: #000; font-size: 0.9rem; font-weight: 600;">Update Shares</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.75rem; background: ${!sharesLocked ? 'var(--surface-hover)' : 'var(--surface)'}; border: 1px solid ${!sharesLocked ? 'var(--fg-muted)' : 'var(--border-muted)'}; margin-left: 1.5rem; transition: all 0.2s ease;" id="sharesToggleLabel"
                   onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)';"
                   onmouseout="const checked = getEl('transferabilitySharesUnlocked').checked; this.style.background = checked ? 'var(--surface-hover)' : 'var(--surface)'; this.style.borderColor = checked ? 'var(--fg-muted)' : 'var(--border-muted)';"
                   onclick="setTimeout(() => { const checked = getEl('transferabilitySharesUnlocked').checked; this.style.background = checked ? 'var(--surface-hover)' : 'var(--surface)'; this.style.borderColor = checked ? 'var(--fg-muted)' : 'var(--border-muted)'; }, 10);">
              <input type="checkbox" id="transferabilitySharesUnlocked" ${!sharesLocked ? 'checked' : ''} style="cursor: pointer; width: 18px; height: 18px; accent-color: #000;">
              <span style="color: #000; font-size: 0.85rem;">Make Shares Transferable</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.75rem; background: var(--surface); border: 1px solid var(--border-muted); transition: all 0.2s ease;"
                   onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)';"
                   onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)';">
              <input type="checkbox" id="transferabilityUpdateLoot" checked style="cursor: pointer; width: 18px; height: 18px; accent-color: #000;">
              <span style="color: #000; font-size: 0.9rem; font-weight: 600;">Update Loot</span>
            </label>
            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer; padding: 0.75rem; background: ${!lootLocked ? 'var(--surface-hover)' : 'var(--surface)'}; border: 1px solid ${!lootLocked ? 'var(--fg-muted)' : 'var(--border-muted)'}; margin-left: 1.5rem; transition: all 0.2s ease;" id="lootToggleLabel"
                   onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)';"
                   onmouseout="const checked = getEl('transferabilityLootUnlocked').checked; this.style.background = checked ? 'var(--surface-hover)' : 'var(--surface)'; this.style.borderColor = checked ? 'var(--fg-muted)' : 'var(--border-muted)';"
                   onclick="setTimeout(() => { const checked = getEl('transferabilityLootUnlocked').checked; this.style.background = checked ? 'var(--surface-hover)' : 'var(--surface)'; this.style.borderColor = checked ? 'var(--fg-muted)' : 'var(--border-muted)'; }, 10);">
              <input type="checkbox" id="transferabilityLootUnlocked" ${!lootLocked ? 'checked' : ''} style="cursor: pointer; width: 18px; height: 18px; accent-color: #000;">
              <span style="color: #000; font-size: 0.85rem;">Make Loot Transferable</span>
            </label>
          </div>
          <button onclick="populateTransferabilityProposal('${daoAddress}')"
                  onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                  onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;
      }

      function clearTransferabilityHelper() {
        const helperDiv = document.getElementById('transferabilityHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateTransferabilityProposal(daoAddress) {
        try {
          if (!currentDAO || !currentDAO._transferLocks) {
            showStatus('Transfer lock status not available', true);
            return;
          }

          const { sharesLocked, lootLocked } = currentDAO._transferLocks;

          // Get user selections
          const updateShares = document.getElementById('transferabilityUpdateShares').checked;
          const updateLoot = document.getElementById('transferabilityUpdateLoot').checked;
          const sharesUnlocked = getEl('transferabilitySharesUnlocked').checked;
          const lootUnlocked = getEl('transferabilityLootUnlocked').checked;

          if (!updateShares && !updateLoot) {
            showStatus('Please select at least one token type to update', true);
            return;
          }

          // Determine final locked states
          // For shares: if updating, use inverse of checkbox; if not updating, keep current
          const finalSharesLocked = updateShares ? !sharesUnlocked : sharesLocked;
          const finalLootLocked = updateLoot ? !lootUnlocked : lootLocked;

          // Encode setTransfersLocked(bool sharesLocked, bool lootLocked)
          const calldata = INTERFACES.setTransfersLocked.encodeFunctionData('setTransfersLocked', [
            finalSharesLocked,
            finalLootLocked
          ]);

          // Build description
          let description = 'Update transferability: ';
          const changes = [];
          if (updateShares) {
            changes.push(`Shares ${sharesUnlocked ? 'unlocked' : 'locked'}`);
          }
          if (updateLoot) {
            changes.push(`Loot ${lootUnlocked ? 'unlocked' : 'locked'}`);
          }
          description += changes.join(', ');

          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          // Use locked description with machine-readable tag
          const lockedDesc = `${description}\n\n<<<TRANSFERABILITY sharesLocked=${finalSharesLocked} lootLocked=${finalLootLocked} TRANSFERABILITY>>>`;
          setLockedProposalDescription(lockedDesc, description);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearTransferabilityHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            getEl('proposalDescriptionLocked').scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 300);

        } catch (error) {
          logger.error('Error populating transferability proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Emergency Permit (Config Bump) proposal helper
      async function prepareEmergencyPermitProposal() {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const dao = currentDAO.dao;
        const daoAddress = dao.dao;

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add emergency permit helper UI if not already present
        let helperDiv = document.getElementById('emergencyPermitHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'emergencyPermitHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: #fff5f5; border: 1px solid #f5d5d5; ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        // Calculate the emergency permit ID
        const bumpConfigCalldata = INTERFACES.bumpConfig.encodeFunctionData('bumpConfig', []);
        const emergencyNonce = ethers.id("EMERGENCY_CONFIG_BUMP"); // Consistent nonce for this permit type
        const config = await (new ethers.Contract(daoAddress, MOLOCH_ABI, provider)).config();
        const permitId = computeProposalId(daoAddress, 0, daoAddress, 0, bumpConfigCalldata, emergencyNonce, config);

        // Check current permit balance for connected user
        let currentBalance = 0;
        let currentHolderAddress = '';
        if (signer) {
          const userAddress = await signer.getAddress();
          currentHolderAddress = userAddress;
          try {
            const molochContract = new ethers.Contract(daoAddress, MOLOCH_ABI, provider);
            currentBalance = Number(await molochContract.balanceOf(userAddress, permitId));
          } catch (e) {
            logger.error('Error fetching permit balance:', e);
          }
        }

        // Show emergency permit helper
        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #c0392b; letter-spacing: 0.1em;">
              EMERGENCY PERMIT (CONFIG BUMP)
            </div>
            <button onclick="clearEmergencyPermitHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #fff0f0; ">
            <div style="font-size: 0.85rem; color: var(--fg); margin-bottom: 0.5rem;">
              <strong>âš ï¸ Emergency Power:</strong> Config Bump
            </div>
            <div style="font-size: 0.8rem; color: var(--fg); line-height: 1.4;">
              This permit allows instant execution of <code>bumpConfig()</code>, which increments the config counter and <strong>invalidates all pending proposals and permits</strong>. Use this as a last resort to reset governance state in emergencies.
            </div>
            ${currentBalance > 0 ? `
              <div style="margin-top: 0.5rem; font-size: 0.85rem; color: #c0392b;">
                You currently hold: <strong>${currentBalance}</strong> use${currentBalance !== 1 ? 's' : ''}
              </div>
            ` : ''}
          </div>
          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Recipient Address</label>
            <input type="text" id="emergencyPermitRecipient" placeholder="${currentHolderAddress || '0x...'}" value="${currentHolderAddress}"
                   style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid #f5d5d5; color: #000; font-family: 'Courier New', monospace; font-size: 0.85rem;" />
          </div>
          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Number of Uses</label>
            <input type="number" id="emergencyPermitCount" placeholder="1" value="${currentBalance > 0 ? currentBalance : 1}" min="0" step="1"
                   style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid #f5d5d5; color: #000; font-size: 0.95rem;" />
            <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--fg-dim);">
              Set to <strong>0</strong> to revoke all permits, or increase to add more uses. Each use allows one config bump.
            </div>
          </div>
          <button onclick="populateEmergencyPermitProposal('${daoAddress}', '${permitId.toString()}', '${bumpConfigCalldata}', '${emergencyNonce}')"
                  onmouseover="this.style.background='#f5d5d5'; this.style.borderColor='#c0392b'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px #f5d5d5';"
                  onmouseout="this.style.background='#fff0f0'; this.style.borderColor='#e8c0c0'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: #fff0f0; border: 1px solid #e8c0c0; color: #000; font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Focus on count input
        setTimeout(() => {
          const input = document.getElementById('emergencyPermitCount');
          if (input) {
            input.select();
            input.focus();
          }
        }, 100);
      }

      function clearEmergencyPermitHelper() {
        const helperDiv = document.getElementById('emergencyPermitHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateEmergencyPermitProposal(daoAddress, permitId, bumpConfigCalldata, emergencyNonce) {
        try {
          const recipientInput = document.getElementById('emergencyPermitRecipient').value.trim();
          const countInput = document.getElementById('emergencyPermitCount').value.trim();

          if (!recipientInput) {
            showStatus('Please enter a recipient address', true);
            return;
          }

          // Resolve ENS if needed
          const recipientAddress = await resolveENS(recipientInput);
          if (!ethers.isAddress(recipientAddress)) {
            showStatus('Please enter a valid Ethereum address or ENS name', true);
            return;
          }

          if (countInput === '' || isNaN(countInput) || parseInt(countInput) < 0) {
            showStatus('Please enter a valid number of uses (0 or more)', true);
            return;
          }

          const count = parseInt(countInput);

          // Encode setPermit(uint8 op, address to, uint256 value, bytes data, bytes32 nonce, address spender, uint256 count)
          const calldata = INTERFACES.setPermit.encodeFunctionData('setPermit', [
            0, // op = call
            daoAddress, // to = self (for bumpConfig)
            0, // value = 0
            bumpConfigCalldata, // data = bumpConfig() calldata
            emergencyNonce, // nonce = consistent emergency nonce
            recipientAddress, // spender = recipient
            count // count = number of uses
          ]);

          const action = count === 0 ? 'Revoke' : (count === 1 ? 'Grant' : `Grant ${count}`);
          const description = `${action} emergency config bump permit${count !== 1 ? 's' : ''} to ${recipientAddress.slice(0, 6)}...${recipientAddress.slice(-4)}`;

          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          // Use locked description with machine-readable tag
          const lockedDesc = `${description}\n\n<<<EMERGENCY_PERMIT recipient=${recipientAddress} count=${count} permitId=${permitId} EMERGENCY_PERMIT>>>`;
          setLockedProposalDescription(lockedDesc, description);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearEmergencyPermitHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            getEl('proposalDescriptionLocked').scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 300);

        } catch (error) {
          logger.error('Error populating emergency permit proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Purchase modal functions
      async function openPurchaseModal(payToken, tokenSymbol, tokenDecimals, isLoot) {
        if (!signer) {
          showStatus('Please connect wallet first', true);
          return;
        }

        const modal = getEl('purchaseModal');
        const content = document.getElementById('purchaseModalContent');

        const tokenType = isLoot ? 'LOOT' : 'SHARES';
        const daoSymbol = currentDAO.dao.meta.symbol;
        const targetSymbol = isLoot ? `${daoSymbol}-LOOT` : daoSymbol;

        // Show loading state
        content.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: var(--fg-dim);">
            Loading balance...
          </div>
        `;
        modal.classList.add('active');
        document.body.classList.add('modal-open');

        try {
          // Fetch user balance and sale info
          const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, provider);
          const sale = await molochContract.sales(payToken);

          let userBalance = 0n;
          if (payToken === ethers.ZeroAddress) {
            userBalance = await provider.getBalance(connectedAddress);
          } else {
            const tokenContract = new ethers.Contract(payToken, ERC20_ABI, provider);
            userBalance = await tokenContract.balanceOf(connectedAddress);
          }

          const balanceFormatted = parseFloat(ethers.formatUnits(userBalance, tokenDecimals)).toFixed(6);

          // Calculate max affordable shares based on user balance
          // pricePerShare is payToken wei per share wei
          let maxAffordable = '0';
          if (userBalance > 0n && sale.pricePerShare > 0n) {
            const maxShares = userBalance / sale.pricePerShare;
            maxAffordable = ethers.formatEther(maxShares);
          }

          content.innerHTML = `
            <div style="margin-bottom: 1rem;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                <label style="font-size: 0.85rem; color: var(--fg);">Amount to Purchase (${targetSymbol})</label>
                <button onclick="setMaxPurchaseAmount('${maxAffordable}')"
                        onmouseover="this.style.background='var(--surface-hover)'; this.style.color='var(--fg)';"
                        onmouseout="this.style.background='var(--surface-hover)'; this.style.color='var(--fg-dim)';"
                        style="padding: 0.35rem 0.65rem; background: var(--surface); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.7rem; letter-spacing: 0.1em; cursor: pointer; text-transform: uppercase; font-weight: 600; transition: all 0.2s ease; min-height: 32px;">
                  MAX
                </button>
              </div>
              <input type="number" id="purchaseAmount" placeholder="0.0" step="any" min="0" inputmode="decimal"
                     style="width: 100%; padding: 0.875rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 16px; " />
            </div>
            <div style="margin-bottom: 1rem; padding: 0.875rem; background: var(--surface); border: 1px solid var(--border-muted); ">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.35rem;">
                <span style="font-size: 0.75rem; color: var(--fg-dim);">Your Balance:</span>
                <span style="font-size: 0.85rem; color: #000; font-weight: 600;">${balanceFormatted} ${tokenSymbol}</span>
              </div>
              <div style="font-size: 0.75rem; color: var(--fg-dim); margin-top: 0.25rem;">
                Payment will be in <strong>${tokenSymbol}</strong>
              </div>
            </div>
            <button onclick="executePurchase('${payToken}', ${tokenDecimals}, ${isLoot})"
                    onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)';"
                    onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)';"
                    style="width: 100%; padding: 1rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.8rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; font-weight: 600; transition: all 0.2s ease; min-height: 48px;">
              Confirm Purchase
            </button>
          `;
        } catch (error) {
          logger.error('Error loading purchase modal:', error);
          content.innerHTML = `
            <div style="text-align: center; padding: 2rem; color: var(--fg-dim);">
              Error loading balance. Please try again.
            </div>
          `;
        }
      }

      function setMaxPurchaseAmount(maxAmount) {
        const input = getEl('purchaseAmount');
        if (input) {
          // Format to remove trailing zeros
          const formatted = parseFloat(maxAmount).toString();
          input.value = formatted;
          input.focus();
        }
      }

      function closePurchaseModal() {
        getEl('purchaseModal').classList.remove('active');
        document.body.classList.remove('modal-open');
      }

      async function executePurchase(payToken, tokenDecimals, isLoot) {
        try {
          const amountInput = getEl('purchaseAmount').value.trim();
          if (!amountInput || isNaN(parseFloat(amountInput)) || parseFloat(amountInput) <= 0) {
            showStatus('Please enter a valid amount', true);
            return;
          }

          const shareAmount = ethers.parseEther(amountInput);
          const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, signer);
          const sale = await molochContract.sales(payToken);

          if (!sale.active) {
            showStatus('Sale is no longer active', true);
            return;
          }

          // Calculate cost
          // pricePerShare is payToken wei per share wei (no extra scaling)
          // For 18-dec tokens: pricePerShare=1 means 1:1 (1e18 tokens buys 1e18 shares)
          const cost = shareAmount * sale.pricePerShare;
          const maxPay = (cost * 105n) / 100n; // 5% slippage

          // ERC20 token: check allowance and approve if needed
          if (payToken !== ethers.ZeroAddress) {
            showStatus('Checking token allowance...', false);

            const tokenContract = new ethers.Contract(payToken, ERC20_ABI, signer);

            // Check user balance
            const userBalance = await tokenContract.balanceOf(connectedAddress);
            if (userBalance < cost) {
              showStatus(`Insufficient balance. Need ${ethers.formatUnits(cost, tokenDecimals)} tokens`, true);
              return;
            }

            // Check allowance
            const currentAllowance = await tokenContract.allowance(connectedAddress, currentDAO.dao.dao);

            if (currentAllowance < cost) {
              showStatus('Approving token spend... Please confirm in wallet', false);

              // Request approval for exact amount needed (or can use MaxUint256 for unlimited)
              const approveTx = await tokenContract.approve(currentDAO.dao.dao, cost, getWalletConnectTxOverrides());

              showStatus(`Approval transaction submitted. <a href="${getNetwork().explorer}/tx/${approveTx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);

              await approveTx.wait();

              showStatus('Approval confirmed! Proceeding with purchase...', false);
            }
          }

          showStatus('Confirming purchase... Please sign the transaction', false);

          let tx;
          if (payToken === ethers.ZeroAddress) {
            tx = await molochContract.buyShares(payToken, shareAmount, maxPay, getWalletConnectTxOverrides({ value: maxPay }));
          } else {
            tx = await molochContract.buyShares(payToken, shareAmount, maxPay, getWalletConnectTxOverrides());
          }

          const tokenType = isLoot ? 'LOOT' : 'SHARES';
          showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);

          await tx.wait();

          showStatus(`âœ¨ Purchase successful! You received ${amountInput} ${tokenType}. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View transaction</a>`, false);

          closePurchaseModal();
          await refreshCurrentDAO();
          await renderSalesInfo();
        } catch (error) {
          logger.error('Purchase failed:', error);

          if (isUserRejection(error)) {
            showStatus('Transaction cancelled by user', false);
            return;
          }

          let errorMessage = 'Purchase failed';
          if (error.message?.includes('insufficient funds')) {
            errorMessage = 'Insufficient funds for transaction';
          } else if (error.message?.includes('ERC20: insufficient allowance')) {
            errorMessage = 'Insufficient token allowance. Please try again';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message) {
            errorMessage = error.message.slice(0, 100);
          }

          showStatus(errorMessage, true);
        }
      }

      // DAICO Purchase Modal - for external OTC sales
      async function openDaicoPurchaseModal(tribToken, tokenSymbol, tokenDecimals, isLoot, tribAmt, forAmt) {
        if (!signer) {
          showStatus('Please connect wallet first', true);
          return;
        }

        const modal = getEl('purchaseModal');
        const content = document.getElementById('purchaseModalContent');

        const tokenType = isLoot ? 'LOOT' : 'SHARES';
        const daoSymbol = currentDAO.dao.meta.symbol;
        const targetSymbol = isLoot ? `${daoSymbol}-LOOT` : daoSymbol;

        // Show loading state
        content.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: var(--fg-dim);">
            Loading DAICO sale info...
          </div>
        `;
        modal.classList.add('active');
        document.body.classList.add('modal-open');

        try {
          // Fetch user balance
          let userBalance = 0n;
          if (tribToken === ethers.ZeroAddress) {
            userBalance = await provider.getBalance(connectedAddress);
          } else {
            const tokenContract = new ethers.Contract(tribToken, ERC20_ABI, provider);
            userBalance = await tokenContract.balanceOf(connectedAddress);
          }

          const balanceFormatted = parseFloat(ethers.formatUnits(userBalance, tokenDecimals)).toFixed(6);

          // Calculate the ratio and max affordable
          const tribAmtBn = BigInt(tribAmt);
          const forAmtBn = BigInt(forAmt);

          // Max tokens user can buy = (userBalance * forAmt) / tribAmt
          let maxAffordable = '0';
          if (userBalance > 0n && tribAmtBn > 0n) {
            const maxTokens = (userBalance * forAmtBn) / tribAmtBn;
            maxAffordable = ethers.formatEther(maxTokens);
          }

          // Format ratio for display
          const tribAmtFormatted = parseFloat(ethers.formatUnits(tribAmtBn, tokenDecimals)).toFixed(6);
          const forAmtFormatted = parseFloat(ethers.formatEther(forAmtBn)).toFixed(4);

          // Build DAICO sale page link
          const chainId = getNetwork().chainId;
          const daicoSaleUrl = `https://daicowtf.eth.limo/#/sale/${chainId}/${currentDAO.dao.dao}`;

          content.innerHTML = `
            <div style="margin-bottom: 1rem; padding: 0.75rem; background: var(--status-success); border-left: 3px solid var(--green); font-size: 0.85rem; color: #000;">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <strong style="color: var(--green);">DAICO Sale</strong><br>
                  Ratio: ${tribAmtFormatted} ${tokenSymbol} = ${forAmtFormatted} ${targetSymbol}
                </div>
                <a href="${daicoSaleUrl}" target="_blank" rel="noopener noreferrer"
                   style="display: flex; align-items: center; gap: 0.35rem; padding: 0.4rem 0.6rem; background: var(--status-success); border: 1px solid var(--green); color: var(--green); text-decoration: none; font-size: 0.7rem; letter-spacing: 0.05em; transition: all 0.2s ease;"
                   onmouseover="this.style.background='var(--status-success)'; this.style.borderColor='var(--green)';"
                   onmouseout="this.style.background='var(--status-success)'; this.style.borderColor='var(--border-muted)';">
                  View on DAICO
                  <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                    <polyline points="15 3 21 3 21 9"></polyline>
                    <line x1="10" y1="14" x2="21" y2="3"></line>
                  </svg>
                </a>
              </div>
            </div>
            <div style="margin-bottom: 1rem;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                <label style="font-size: 0.85rem; color: var(--fg);">Amount to Purchase (${targetSymbol})</label>
                <button onclick="setMaxPurchaseAmount('${maxAffordable}')"
                        onmouseover="this.style.background='var(--status-success)'; this.style.color='var(--green)';"
                        onmouseout="this.style.background='var(--status-success)'; this.style.color='#999';"
                        style="padding: 0.35rem 0.65rem; background: var(--status-success); border: 1px solid var(--green); color: var(--fg); font-size: 0.7rem; letter-spacing: 0.1em; cursor: pointer; text-transform: uppercase; font-weight: 600; transition: all 0.2s ease; min-height: 32px;">
                  MAX
                </button>
              </div>
              <input type="number" id="purchaseAmount" placeholder="0.0" step="any" min="0" inputmode="decimal"
                     oninput="updateDaicoCostPreview('${tribToken}', ${tokenDecimals}, '${tribAmt}', '${forAmt}', '${tokenSymbol}')"
                     style="width: 100%; padding: 0.875rem; background: transparent; border: 1px solid var(--green); color: #000; font-size: 16px; " />
            </div>
            <div id="daicoCostPreview" style="margin-bottom: 1rem; padding: 0.875rem; background: var(--status-success); border: 1px solid var(--green); ">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.35rem;">
                <span style="font-size: 0.75rem; color: var(--fg-dim);">Your Balance:</span>
                <span style="font-size: 0.85rem; color: #000; font-weight: 600;">${balanceFormatted} ${tokenSymbol}</span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span style="font-size: 0.75rem; color: var(--fg-dim);">Estimated Cost:</span>
                <span id="daicoCostAmount" style="font-size: 0.85rem; color: var(--green); font-weight: 600;">-- ${tokenSymbol}</span>
              </div>
            </div>
            <button onclick="executeDaicoPurchase('${tribToken}', ${tokenDecimals}, ${isLoot}, '${tribAmt}', '${forAmt}')"
                    onmouseover="this.style.background='var(--status-success)'; this.style.borderColor='var(--green)';"
                    onmouseout="this.style.background='var(--status-success)'; this.style.borderColor='var(--border-muted)';"
                    style="width: 100%; padding: 1rem; background: var(--status-success); border: 1px solid var(--green); color: #000; font-size: 0.8rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; font-weight: 600; transition: all 0.2s ease; min-height: 48px;">
              Purchase via DAICO
            </button>
          `;
        } catch (error) {
          logger.error('Error loading DAICO purchase modal:', error);
          content.innerHTML = `
            <div style="text-align: center; padding: 2rem; color: var(--fg-dim);">
              Error loading sale info. Please try again.
            </div>
          `;
        }
      }

      // Update cost preview for DAICO purchase
      function updateDaicoCostPreview(tribToken, tokenDecimals, tribAmt, forAmt, tokenSymbol) {
        const amountInput = getEl('purchaseAmount').value.trim();
        const costEl = document.getElementById('daicoCostAmount');

        if (!costEl) return;

        if (!amountInput || isNaN(parseFloat(amountInput)) || parseFloat(amountInput) <= 0) {
          costEl.textContent = `-- ${tokenSymbol}`;
          return;
        }

        try {
          const buyAmount = ethers.parseEther(amountInput);
          const tribAmtBn = BigInt(tribAmt);
          const forAmtBn = BigInt(forAmt);

          // Cost = ceil((buyAmount * tribAmt) / forAmt)
          const num = buyAmount * tribAmtBn;
          const cost = (num + forAmtBn - 1n) / forAmtBn;

          const costFormatted = parseFloat(ethers.formatUnits(cost, tokenDecimals)).toFixed(6);
          costEl.textContent = `${costFormatted} ${tokenSymbol}`;
        } catch (e) {
          costEl.textContent = `-- ${tokenSymbol}`;
        }
      }

      // Execute DAICO purchase
      async function executeDaicoPurchase(tribToken, tokenDecimals, isLoot, tribAmt, forAmt) {
        try {
          const amountInput = getEl('purchaseAmount').value.trim();
          if (!amountInput || isNaN(parseFloat(amountInput)) || parseFloat(amountInput) <= 0) {
            showStatus('Please enter a valid amount', true);
            return;
          }

          const buyAmount = ethers.parseEther(amountInput);
          const tribAmtBn = BigInt(tribAmt);
          const forAmtBn = BigInt(forAmt);

          // Calculate cost with ceiling division
          // cost = ceil((buyAmount * tribAmt) / forAmt)
          const num = buyAmount * tribAmtBn;
          const cost = (num + forAmtBn - 1n) / forAmtBn;

          // Add slippage for maxPay (5%)
          const maxPay = (cost * 105n) / 100n;

          const daicoContract = new ethers.Contract(DAICO_ADDRESS, DAICO_ABI, signer);
          const daoAddress = currentDAO.dao.dao;

          // For ERC20 payments, check allowance and approve if needed
          if (tribToken !== ethers.ZeroAddress) {
            showStatus('Checking token allowance...', false);

            const tokenContract = new ethers.Contract(tribToken, ERC20_ABI, signer);

            // Check user balance
            const userBalance = await tokenContract.balanceOf(connectedAddress);
            if (userBalance < cost) {
              showStatus(`Insufficient balance. Need ${ethers.formatUnits(cost, tokenDecimals)} tokens`, true);
              return;
            }

            // Check allowance to DAICO contract
            const currentAllowance = await tokenContract.allowance(connectedAddress, DAICO_ADDRESS);

            if (currentAllowance < maxPay) {
              showStatus('Approving token spend... Please confirm in wallet', false);

              // Request approval for the DAICO contract
              const approveTx = await tokenContract.approve(DAICO_ADDRESS, maxPay, getWalletConnectTxOverrides());

              showStatus(`Approval transaction submitted. <a href="${getNetwork().explorer}/tx/${approveTx.hash}" target="_blank" rel="noopener" style="color: var(--green); text-decoration: underline;">View on Explorer</a>`, false);

              await approveTx.wait();

              showStatus('Approval confirmed! Proceeding with purchase...', false);
            }
          }

          showStatus('Confirming DAICO purchase... Please sign the transaction', false);

          let tx;
          // Use buyExactOut for exact output amount
          if (tribToken === ethers.ZeroAddress) {
            // ETH payment - send maxPay as value, contract will refund excess
            tx = await daicoContract.buyExactOut(daoAddress, tribToken, buyAmount, maxPay, getWalletConnectTxOverrides({ value: maxPay }));
          } else {
            // ERC20 payment
            tx = await daicoContract.buyExactOut(daoAddress, tribToken, buyAmount, maxPay, getWalletConnectTxOverrides());
          }

          const tokenType = isLoot ? 'LOOT' : 'SHARES';
          showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: var(--green); text-decoration: underline;">View on Explorer</a>`, false);

          await tx.wait();

          showStatus(`âœ¨ DAICO purchase successful! You received ${amountInput} ${tokenType}. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: var(--green); text-decoration: underline;">View transaction</a>`, false);

          closePurchaseModal();
          await refreshCurrentDAO();
          await renderSalesInfo();
        } catch (error) {
          logger.error('DAICO purchase failed:', error);

          if (isUserRejection(error)) {
            showStatus('Transaction cancelled by user', false);
            return;
          }

          let errorMessage = 'DAICO purchase failed';
          if (error.message?.includes('insufficient funds')) {
            errorMessage = 'Insufficient funds for transaction';
          } else if (error.message?.includes('NoSale')) {
            errorMessage = 'Sale is no longer active';
          } else if (error.message?.includes('InvalidParams')) {
            errorMessage = 'Invalid parameters - check amount and slippage';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message) {
            errorMessage = error.message.slice(0, 100);
          }

          showStatus(errorMessage, true);
        }
      }

      // Claim DAICO tap funds
      async function claimDaicoTap(daoAddress) {
        try {
          if (!signer) {
            showStatus('Please connect wallet first', true);
            return;
          }

          showStatus('Claiming tap funds...', false);

          const daicoContract = new ethers.Contract(DAICO_ADDRESS, DAICO_ABI, signer);

          const tx = await daicoContract.claimTap(daoAddress, getWalletConnectTxOverrides());

          showStatus(`Tap claim submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #b8860b; text-decoration: underline;">View on Explorer</a>`, false);

          const receipt = await tx.wait();

          showStatus(`Tap claimed successfully! <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #b8860b; text-decoration: underline;">View transaction</a>`, false);

          // Refresh sales info to update claimable amount
          await renderSalesInfo();
        } catch (error) {
          logger.error('Tap claim failed:', error);

          if (isUserRejection(error)) {
            showStatus('Transaction cancelled by user', false);
            return;
          }

          let errorMessage = 'Tap claim failed';
          if (error.message?.includes('NoTap')) {
            errorMessage = 'No tap configured for this DAO';
          } else if (error.message?.includes('NothingToClaim')) {
            errorMessage = 'Nothing to claim yet';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          }

          showStatus(errorMessage, true);
        }
      }

      // TAP Rate proposal helper - for changing the tap rate via governance
      async function prepareTapRateProposal(tribTknAddress, tribTknSymbol, tribTknDecimals, currentRatePerSec) {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const daoAddress = currentDAO.dao.dao;

        // Calculate current rate per month for display
        const SECONDS_PER_MONTH = 2629746n;
        const currentRateBn = BigInt(currentRatePerSec);
        const currentRatePerMonth = parseFloat(ethers.formatUnits(currentRateBn * SECONDS_PER_MONTH, tribTknDecimals));

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add tap rate helper UI if not already present
        let helperDiv = document.getElementById('tapRateHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'tapRateHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: #fffaf0; border: 1px solid #e0c8a0; ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #b8860b; letter-spacing: 0.1em;">
              CHANGE TAP RATE
            </div>
            <button onclick="clearTapRateHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #fffaf0; ">
            <div style="font-size: 0.85rem; color: var(--fg); margin-bottom: 0.35rem;">
              Current Rate: <strong>${currentRatePerMonth.toLocaleString()} ${tribTknSymbol}/month</strong>
            </div>
            <div style="font-size: 0.75rem; color: var(--fg-dim);">
              Token: ${tribTknSymbol} (${tribTknDecimals} decimals)
            </div>
          </div>
          <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: #fffaf0; font-size: 0.75rem; color: #b8860b;">
            <strong>Note:</strong> Per DAICO design, rate changes are non-retroactive. Any unclaimed tap at the old rate is forfeited when the rate changes.
          </div>
          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">New Rate (${tribTknSymbol} per month)</label>
            <input type="text" id="tapRateInput" placeholder="${currentRatePerMonth.toLocaleString()}" value="${currentRatePerMonth.toFixed(2)}"
                   oninput="updateTapRatePreview(${tribTknDecimals}, '${tribTknSymbol}')"
                   style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid #e0c8a0; color: #000; font-size: 0.95rem;" />
            <div style="margin-top: 0.35rem; font-size: 0.7rem; color: var(--fg-dim);">
              Enter 0 to freeze/pause the tap
            </div>
            <div id="tapRatePreview" style="margin-top: 0.5rem; display: none;"></div>
          </div>
          <button onclick="populateTapRateProposal('${daoAddress}', ${tribTknDecimals}, '${tribTknSymbol}')"
                  onmouseover="this.style.background='#e0c8a0'; this.style.borderColor='#b8860b'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px #e0c8a0';"
                  onmouseout="this.style.background='#fdf5e8'; this.style.borderColor='#d4b888'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: #fffaf0; border: 1px solid #d4b888; color: #000; font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Focus on input
        setTimeout(() => {
          const input = getEl('tapRateInput');
          if (input) {
            input.select();
            input.focus();
          }
        }, 100);
      }

      function updateTapRatePreview(decimals, symbol) {
        const previewDiv = document.getElementById('tapRatePreview');
        const rateInput = getEl('tapRateInput');
        if (!previewDiv || !rateInput) return;

        const newRatePerMonth = parseFloat(rateInput.value.replace(/,/g, ''));
        if (isNaN(newRatePerMonth) || newRatePerMonth < 0) {
          previewDiv.style.display = 'none';
          return;
        }

        // Calculate rate per second
        const SECONDS_PER_MONTH = 2629746;
        const ratePerSec = newRatePerMonth / SECONDS_PER_MONTH;

        // Calculate daily/yearly amounts
        const ratePerDay = newRatePerMonth / 30.44; // avg days per month
        const ratePerYear = newRatePerMonth * 12;

        previewDiv.style.display = 'block';
        previewDiv.innerHTML = `
          <div style="padding: 0.5rem; background: #fffaf0; font-size: 0.75rem; color: var(--fg);">
            <div>â‰ˆ ${ratePerDay.toFixed(4)} ${symbol}/day</div>
            <div>â‰ˆ ${ratePerYear.toLocaleString()} ${symbol}/year</div>
            ${newRatePerMonth === 0 ? '<div style="color: #b8860b; margin-top: 0.35rem;">âš ï¸ Setting rate to 0 will freeze the tap</div>' : ''}
          </div>
        `;
      }

      function clearTapRateHelper() {
        const helperDiv = document.getElementById('tapRateHelper');
        if (helperDiv) helperDiv.remove();
      }

      // DAICO Sale configuration proposal helper - for adjusting or cancelling a sale via governance
      async function prepareSaleProposal(tribTknAddress, tribTknSymbol, tribTknDecimals, isLoot, currentTribAmt, currentForAmt, forTkn, deadline) {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const daoAddress = currentDAO.dao.dao;
        const tokenType = isLoot ? 'LOOT' : 'SHARES';
        const tokenSymbol = isLoot ? `${currentDAO.dao.meta.symbol}-LOOT` : currentDAO.dao.meta.symbol;

        // Calculate current price per token
        const tribAmtFormatted = parseFloat(ethers.formatUnits(currentTribAmt, tribTknDecimals));
        const forAmtFormatted = parseFloat(ethers.formatEther(currentForAmt));
        const currentPricePerToken = tribAmtFormatted / forAmtFormatted;

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Remove any existing helpers first
        clearSaleHelper();
        clearTapRateHelper();
        clearTapOpsHelper();

        // Add sale helper UI
        let helperDiv = document.createElement('div');
        helperDiv.id = 'saleHelper';
        helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--status-success); border: 1px solid var(--green); ';
        proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));

        // Format deadline
        const deadlineDate = deadline && deadline > 0 ? new Date(Number(deadline) * 1000).toLocaleString() : 'No deadline';

        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: var(--green); letter-spacing: 0.1em;">
              CONFIGURE ${tokenType} SALE
            </div>
            <button onclick="clearSaleHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: var(--status-success); ">
            <div style="font-size: 0.85rem; color: var(--fg); margin-bottom: 0.35rem;">
              Current: <strong>${tribAmtFormatted} ${tribTknSymbol} â†’ ${forAmtFormatted} ${tokenSymbol}</strong>
            </div>
            <div style="font-size: 0.75rem; color: var(--fg-dim);">
              Price: ${currentPricePerToken.toFixed(6)} ${tribTknSymbol} per ${tokenSymbol} â€¢ Deadline: ${deadlineDate}
            </div>
          </div>

          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Action</label>
            <select id="saleActionSelect" onchange="updateSaleActionUI(${tribTknDecimals}, '${tribTknSymbol}', '${tokenSymbol}', ${tribAmtFormatted}, ${forAmtFormatted})"
                    style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--green); color: #000; font-size: 0.95rem;">
              <option value="cancel">Cancel Sale (disable purchasing)</option>
              <option value="adjust">Adjust Sale Terms</option>
            </select>
          </div>

          <div id="saleAdjustFields" style="display: none;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
              <div>
                <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Tribute Amount (${tribTknSymbol})</label>
                <input type="text" id="saleTribAmtInput" placeholder="${tribAmtFormatted}" value="${tribAmtFormatted}"
                       oninput="updateSalePreview(${tribTknDecimals}, '${tribTknSymbol}', '${tokenSymbol}')"
                       style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--green); color: #000; font-size: 0.95rem;" />
              </div>
              <div>
                <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">For Amount (${tokenSymbol})</label>
                <input type="text" id="saleForAmtInput" placeholder="${forAmtFormatted}" value="${forAmtFormatted}"
                       oninput="updateSalePreview(${tribTknDecimals}, '${tribTknSymbol}', '${tokenSymbol}')"
                       style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--green); color: #000; font-size: 0.95rem;" />
              </div>
            </div>
            <div style="margin-bottom: 0.75rem;">
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Deadline (optional)</label>
              <input type="datetime-local" id="saleDeadlineInput"
                     style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--green); color: #000; font-size: 0.95rem;" />
              <div style="margin-top: 0.35rem; font-size: 0.7rem; color: var(--fg-dim);">
                Leave empty for no deadline
              </div>
            </div>
            <div id="salePreview" style="margin-bottom: 0.75rem; display: none;"></div>
          </div>

          <div id="saleCancelWarning" style="margin-bottom: 0.75rem; padding: 0.5rem; background: #fff0f0; border: 1px solid #e74c3c; font-size: 0.75rem; color: #e74c3c;">
            <strong>Warning:</strong> Cancelling the sale will prevent any further purchases. The DAO can create a new sale later via another proposal.
          </div>

          <button onclick="populateSaleConfigProposal('${tribTknAddress}', '${tribTknSymbol}', ${tribTknDecimals}, '${forTkn}', ${isLoot}, '${tokenSymbol}')"
                  onmouseover="this.style.background='var(--status-success)'; this.style.borderColor='var(--green)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px var(--border-muted)';"
                  onmouseout="this.style.background='var(--status-success)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--status-success); border: 1px solid var(--green); color: #000; font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Focus on select
        setTimeout(() => {
          const select = getEl('saleActionSelect');
          if (select) select.focus();
        }, 100);
      }

      function updateSaleActionUI(tribDecimals, tribSymbol, forSymbol, currentTribAmt, currentForAmt) {
        const action = getEl('saleActionSelect').value;
        const adjustFields = document.getElementById('saleAdjustFields');
        const cancelWarning = document.getElementById('saleCancelWarning');

        if (action === 'cancel') {
          adjustFields.style.display = 'none';
          cancelWarning.style.display = 'block';
        } else {
          adjustFields.style.display = 'block';
          cancelWarning.style.display = 'none';
          updateSalePreview(tribDecimals, tribSymbol, forSymbol);
        }
      }

      function updateSalePreview(tribDecimals, tribSymbol, forSymbol) {
        const previewDiv = document.getElementById('salePreview');
        const tribInput = document.getElementById('saleTribAmtInput');
        const forInput = document.getElementById('saleForAmtInput');
        if (!previewDiv || !tribInput || !forInput) return;

        const newTribAmt = parseFloat(tribInput.value.replace(/,/g, ''));
        const newForAmt = parseFloat(forInput.value.replace(/,/g, ''));

        if (isNaN(newTribAmt) || isNaN(newForAmt) || newTribAmt <= 0 || newForAmt <= 0) {
          previewDiv.style.display = 'none';
          return;
        }

        const newPricePerToken = newTribAmt / newForAmt;

        previewDiv.style.display = 'block';
        previewDiv.innerHTML = `
          <div style="padding: 0.5rem; background: var(--status-success); font-size: 0.75rem; color: var(--fg);">
            <div>New ratio: ${newTribAmt} ${tribSymbol} = ${newForAmt} ${forSymbol}</div>
            <div>Price per token: ${newPricePerToken.toFixed(6)} ${tribSymbol}</div>
          </div>
        `;
      }

      function clearSaleHelper() {
        const helperDiv = getEl('saleHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateSaleConfigProposal(tribTknAddress, tribTknSymbol, tribTknDecimals, forTkn, isLoot, tokenSymbol) {
        try {
          const action = getEl('saleActionSelect').value;
          let tribAmt, forAmt, deadline;

          if (action === 'cancel') {
            // Cancel sale by setting amounts to 0
            tribAmt = 0n;
            forAmt = 0n;
            deadline = 0;
          } else {
            // Adjust sale terms
            const tribInput = document.getElementById('saleTribAmtInput').value.trim().replace(/,/g, '');
            const forInput = document.getElementById('saleForAmtInput').value.trim().replace(/,/g, '');
            const deadlineInput = document.getElementById('saleDeadlineInput').value;

            if (!tribInput || isNaN(parseFloat(tribInput)) || parseFloat(tribInput) <= 0) {
              showStatus('Please enter a valid tribute amount', true);
              return;
            }
            if (!forInput || isNaN(parseFloat(forInput)) || parseFloat(forInput) <= 0) {
              showStatus('Please enter a valid token amount', true);
              return;
            }

            tribAmt = ethers.parseUnits(tribInput, tribTknDecimals);
            forAmt = ethers.parseEther(forInput); // Shares/Loot are 18 decimals
            deadline = deadlineInput ? Math.floor(new Date(deadlineInput).getTime() / 1000) : 0;
          }

          // Use address(0) for ETH tribute token
          const tribTknParam = tribTknAddress === ethers.ZeroAddress ? ethers.ZeroAddress : tribTknAddress;

          // Encode setSale(address tribTkn, uint256 tribAmt, address forTkn, uint256 forAmt, uint40 deadline)
          const setSaleIface = new ethers.Interface(['function setSale(address tribTkn, uint256 tribAmt, address forTkn, uint256 forAmt, uint40 deadline)']);
          const calldata = setSaleIface.encodeFunctionData('setSale', [tribTknParam, tribAmt, forTkn, forAmt, deadline]);

          // Target is DAICO contract (DAO calls DAICO.setSale)
          getEl('proposalTo').value = DAICO_ADDRESS;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          let description;
          let metadata;
          if (action === 'cancel') {
            description = `Cancel ${tokenSymbol} DAICO sale (${tribTknSymbol} payments)`;
            metadata = `<<<DAICO_SALE action="cancel" tribToken="${tribTknParam}" tribSymbol="${tribTknSymbol}" forToken="${forTkn}" forSymbol="${tokenSymbol}" DAICO_SALE>>>`;
          } else {
            const tribAmtFormatted = parseFloat(ethers.formatUnits(tribAmt, tribTknDecimals));
            const forAmtFormatted = parseFloat(ethers.formatEther(forAmt));
            description = `Adjust ${tokenSymbol} sale: ${tribAmtFormatted} ${tribTknSymbol} = ${forAmtFormatted} ${tokenSymbol}`;
            metadata = `<<<DAICO_SALE action="adjust" tribToken="${tribTknParam}" tribDecimals="${tribTknDecimals}" tribSymbol="${tribTknSymbol}" tribAmt="${tribAmt.toString()}" forToken="${forTkn}" forSymbol="${tokenSymbol}" forAmt="${forAmt.toString()}" deadline="${deadline}" DAICO_SALE>>>`;
          }

          const fullDescription = `${description}\n\n${metadata}`;
          setLockedProposalDescription(fullDescription, description);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearSaleHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating sale proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Create new DAICO sale proposal helper - for DAOs that want to set up a new sale
      async function prepareNewDaicoSaleProposal() {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        // Switch to DAO view and scroll to proposal form
        switchDaoView('dao');

        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          setTimeout(() => {
            proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 100);
        }

        // Remove any existing helpers first
        clearSaleHelper();
        clearTapRateHelper();
        clearTapOpsHelper();
        clearNewSaleHelper();

        // Add new sale helper UI
        let helperDiv = document.createElement('div');
        helperDiv.id = 'newSaleHelper';
        helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--status-success); border: 1px solid var(--green); ';

        setTimeout(() => {
          const proposalFormEl = document.querySelector('.proposal-form');
          if (proposalFormEl) {
            proposalFormEl.insertBefore(helperDiv, proposalFormEl.querySelector('.proposal-form-group'));
          }
        }, 150);

        const sharesAddr = currentDAO.dao.shares;
        const lootAddr = currentDAO.dao.loot;
        const daoSymbol = currentDAO.dao.meta.symbol;

        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: var(--green); letter-spacing: 0.1em;">
              CREATE DAICO SALE
            </div>
            <button onclick="clearNewSaleHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: var(--status-success); font-size: 0.75rem; color: var(--fg);">
            Set up a DAICO sale to sell ${daoSymbol} shares or loot for ETH or ERC20 tokens. The DAICO contract will mint tokens to buyers.
          </div>

          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Token to Sell</label>
            <select id="newSaleTokenType"
                    style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--green); color: #000; font-size: 0.95rem;">
              <option value="shares">${daoSymbol} (Shares)</option>
              <option value="loot">${daoSymbol}-LOOT (Loot)</option>
            </select>
          </div>

          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Payment Token</label>
            <select id="newSalePaymentToken" onchange="updateNewSalePaymentUI()"
                    style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--green); color: #000; font-size: 0.95rem;">
              <option value="eth" data-decimals="18">ETH</option>
              <option value="usdc" data-decimals="6">USDC</option>
              <option value="usdt" data-decimals="6">USDT</option>
              <option value="dai" data-decimals="18">DAI</option>
              <option value="custom" data-decimals="18">Custom ERC20</option>
            </select>
          </div>

          <div id="newSaleCustomTokenFields" style="display: none; margin-bottom: 0.75rem;">
            <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 0.5rem;">
              <div>
                <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Token Address</label>
                <input type="text" id="newSaleCustomTokenAddr" placeholder="0x..."
                       style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--green); color: #000; font-size: 0.95rem;" />
              </div>
              <div>
                <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Decimals</label>
                <input type="number" id="newSaleCustomTokenDecimals" placeholder="18" value="18"
                       style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--green); color: #000; font-size: 0.95rem;" />
              </div>
            </div>
          </div>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Price Amount</label>
              <input type="text" id="newSaleTribAmt" placeholder="1" value="1"
                     oninput="updateNewSalePreview()"
                     style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--green); color: #000; font-size: 0.95rem;" />
              <div style="margin-top: 0.2rem; font-size: 0.65rem; color: var(--fg-dim);">Amount of payment token</div>
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Token Amount</label>
              <input type="text" id="newSaleForAmt" placeholder="1000" value="1000"
                     oninput="updateNewSalePreview()"
                     style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--green); color: #000; font-size: 0.95rem;" />
              <div style="margin-top: 0.2rem; font-size: 0.65rem; color: var(--fg-dim);">Amount of shares/loot</div>
            </div>
          </div>

          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Deadline (optional)</label>
            <input type="datetime-local" id="newSaleDeadline"
                   style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--green); color: #000; font-size: 0.95rem;" />
            <div style="margin-top: 0.2rem; font-size: 0.65rem; color: var(--fg-dim);">Leave empty for no deadline</div>
          </div>

          <div id="newSalePreview" style="margin-bottom: 0.75rem; padding: 0.5rem; background: var(--status-success); font-size: 0.75rem; color: var(--fg);">
            <div>Ratio: 1 <span id="newSalePaymentSymbol">ETH</span> = 1000 ${daoSymbol}</div>
            <div>Price per token: 0.001 <span id="newSalePaymentSymbol2">ETH</span></div>
          </div>

          <div style="margin-bottom: 0.75rem; padding: 0.5rem; background: #fffaf0; border: 1px solid #e0c8a0; font-size: 0.75rem; color: #b8860b;">
            <strong>Important:</strong> After this proposal passes, you must also grant DAICO minting permission for your shares/loot token via a separate setAuth proposal.
          </div>

          <button onclick="populateNewDaicoSaleProposal('${sharesAddr}', '${lootAddr}', '${daoSymbol}')"
                  onmouseover="this.style.background='var(--status-success)'; this.style.borderColor='var(--green)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px var(--border-muted)';"
                  onmouseout="this.style.background='var(--status-success)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--status-success); border: 1px solid var(--green); color: #000; font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Initialize preview
        setTimeout(() => updateNewSalePreview(), 200);
      }

      function updateNewSalePaymentUI() {
        const paymentSelect = document.getElementById('newSalePaymentToken');
        const customFields = document.getElementById('newSaleCustomTokenFields');
        const selectedOption = paymentSelect.options[paymentSelect.selectedIndex];

        if (paymentSelect.value === 'custom') {
          customFields.style.display = 'block';
        } else {
          customFields.style.display = 'none';
        }

        updateNewSalePreview();
      }

      function updateNewSalePreview() {
        const paymentSelect = document.getElementById('newSalePaymentToken');
        const tribAmtInput = document.getElementById('newSaleTribAmt');
        const forAmtInput = document.getElementById('newSaleForAmt');
        const previewDiv = document.getElementById('newSalePreview');
        const paymentSymbol1 = document.getElementById('newSalePaymentSymbol');
        const paymentSymbol2 = document.getElementById('newSalePaymentSymbol2');

        if (!paymentSelect || !tribAmtInput || !forAmtInput || !previewDiv) return;

        let paymentSymbol = paymentSelect.value.toUpperCase();
        if (paymentSymbol === 'CUSTOM') paymentSymbol = 'TOKEN';

        if (paymentSymbol1) paymentSymbol1.textContent = paymentSymbol;
        if (paymentSymbol2) paymentSymbol2.textContent = paymentSymbol;

        const tribAmt = parseFloat(tribAmtInput.value) || 0;
        const forAmt = parseFloat(forAmtInput.value) || 0;

        if (tribAmt > 0 && forAmt > 0) {
          const pricePerToken = tribAmt / forAmt;
          const tokenType = document.getElementById('newSaleTokenType')?.value === 'loot' ? 'LOOT' : 'SHARES';
          previewDiv.innerHTML = `
            <div>Ratio: ${tribAmt} ${paymentSymbol} = ${forAmt} ${tokenType}</div>
            <div>Price per token: ${pricePerToken.toFixed(6)} ${paymentSymbol}</div>
          `;
        }
      }

      function clearNewSaleHelper() {
        const helperDiv = document.getElementById('newSaleHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateNewDaicoSaleProposal(sharesAddr, lootAddr, daoSymbol) {
        try {
          const tokenType = document.getElementById('newSaleTokenType').value;
          const paymentToken = document.getElementById('newSalePaymentToken').value;
          const tribAmtInput = document.getElementById('newSaleTribAmt').value.trim();
          const forAmtInput = document.getElementById('newSaleForAmt').value.trim();
          const deadlineInput = document.getElementById('newSaleDeadline').value;

          // Validate inputs
          if (!tribAmtInput || isNaN(parseFloat(tribAmtInput)) || parseFloat(tribAmtInput) <= 0) {
            showStatus('Please enter a valid price amount', true);
            return;
          }
          if (!forAmtInput || isNaN(parseFloat(forAmtInput)) || parseFloat(forAmtInput) <= 0) {
            showStatus('Please enter a valid token amount', true);
            return;
          }

          // Get payment token address and decimals
          let tribTknAddr, tribTknDecimals, tribTknSymbol;
          switch (paymentToken) {
            case 'eth':
              tribTknAddr = ethers.ZeroAddress;
              tribTknDecimals = 18;
              tribTknSymbol = 'ETH';
              break;
            case 'usdc':
              tribTknAddr = TOKEN_ADDRESSES.usdc;
              tribTknDecimals = 6;
              tribTknSymbol = 'USDC';
              break;
            case 'usdt':
              tribTknAddr = TOKEN_ADDRESSES.usdt;
              tribTknDecimals = 6;
              tribTknSymbol = 'USDT';
              break;
            case 'dai':
              tribTknAddr = TOKEN_ADDRESSES.dai;
              tribTknDecimals = 18;
              tribTknSymbol = 'DAI';
              break;
            case 'custom':
              tribTknAddr = document.getElementById('newSaleCustomTokenAddr').value.trim();
              tribTknDecimals = parseInt(document.getElementById('newSaleCustomTokenDecimals').value) || 18;
              tribTknSymbol = 'TOKEN';
              if (!ethers.isAddress(tribTknAddr)) {
                showStatus('Please enter a valid custom token address', true);
                return;
              }
              break;
          }

          // Get forTkn (shares or loot)
          const forTkn = tokenType === 'loot' ? lootAddr : sharesAddr;
          const forTknSymbol = tokenType === 'loot' ? `${daoSymbol}-LOOT` : daoSymbol;

          // Parse amounts
          const tribAmt = ethers.parseUnits(tribAmtInput, tribTknDecimals);
          const forAmt = ethers.parseEther(forAmtInput); // Shares/Loot are 18 decimals
          const deadline = deadlineInput ? Math.floor(new Date(deadlineInput).getTime() / 1000) : 0;

          // Encode setSale(address tribTkn, uint256 tribAmt, address forTkn, uint256 forAmt, uint40 deadline)
          const setSaleIface = new ethers.Interface(['function setSale(address tribTkn, uint256 tribAmt, address forTkn, uint256 forAmt, uint40 deadline)']);
          const calldata = setSaleIface.encodeFunctionData('setSale', [tribTknAddr, tribAmt, forTkn, forAmt, deadline]);

          // Target is DAICO contract
          getEl('proposalTo').value = DAICO_ADDRESS;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          const description = `Create DAICO sale: ${tribAmtInput} ${tribTknSymbol} = ${forAmtInput} ${forTknSymbol}`;

          // Machine-readable metadata for sale description (allows DAO to set sale-specific description)
          const metadata = `<<<DAICO_SALE action="create" tribToken="${tribTknAddr}" tribDecimals="${tribTknDecimals}" tribSymbol="${tribTknSymbol}" tribAmt="${tribAmt.toString()}" forToken="${forTkn}" forSymbol="${forTknSymbol}" forAmt="${forAmt.toString()}" deadline="${deadline}" DAICO_SALE>>>`;
          const fullDescription = `${description}\n\n${metadata}`;

          setLockedProposalDescription(fullDescription, description);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated! Remember to also grant DAICO minting permission.', false);
          clearNewSaleHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating new sale proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Internal Moloch sale proposal helper - for 1:1 token upgrades or DAI continuous fundraise
      async function prepareInternalSaleProposal() {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        // Switch to DAO view and scroll to proposal form
        switchDaoView('dao');

        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          setTimeout(() => {
            proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 100);
        }

        // Remove any existing helpers first
        clearSaleHelper();
        clearNewSaleHelper();
        clearTapRateHelper();
        clearTapOpsHelper();
        clearInternalSaleHelper();

        // Add internal sale helper UI
        let helperDiv = document.createElement('div');
        helperDiv.id = 'internalSaleHelper';
        helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';

        setTimeout(() => {
          const proposalFormEl = document.querySelector('.proposal-form');
          if (proposalFormEl) {
            proposalFormEl.insertBefore(helperDiv, proposalFormEl.querySelector('.proposal-form-group'));
          }
        }, 150);

        const daoSymbol = currentDAO.dao.meta.symbol;

        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
              INTERNAL SALE
            </div>
            <button onclick="clearInternalSaleHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>

          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Sale Type</label>
            <select id="internalSaleType" onchange="updateInternalSaleUI()"
                    style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;">
              <option value="upgrade">Token Upgrade (1:1 migration)</option>
              <option value="dai">DAI Continuous Fundraise (1:1)</option>
              <option value="custom">Custom Sale</option>
            </select>
          </div>

          <div id="internalSaleDescription" style="margin-bottom: 0.75rem; padding: 0.6rem; background: #f9f9f9; font-size: 0.8rem; color: var(--fg-dim); line-height: 1.5;">
            <strong style="color: #000;">Token Upgrade:</strong> Allow holders of an existing ERC20 token to stake/upgrade to ${daoSymbol} shares at 1:1 ratio. Users can ragequit to reclaim their original tokens.
          </div>

          <div id="upgradeTokenFields" style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Token Address (18-decimal ERC20)</label>
            <div style="display: flex; gap: 0.5rem;">
              <input type="text" id="internalSaleTokenAddr" placeholder="0x..."
                     style="flex: 1; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;" />
              <button onclick="validateInternalSaleToken()" type="button"
                      style="padding: 0.6rem 1rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.7rem; letter-spacing: 0.1em; cursor: pointer; white-space: nowrap; min-height: 44px;">
                Check
              </button>
            </div>
            <div id="internalSaleTokenInfo" style="margin-top: 0.35rem; font-size: 0.75rem; color: var(--fg-dim);"></div>
          </div>

          <div id="daiFields" style="display: none; margin-bottom: 0.75rem;">
            <div style="padding: 0.6rem; background: #fffaf0; border: 1px solid #e0c8a0; font-size: 0.75rem; color: #b8860b;">
              DAI address will be used automatically: ${TOKEN_ADDRESSES.dai}
            </div>
          </div>

          <div id="customSaleFields" style="display: none;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
              <div>
                <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Price per Token</label>
                <input type="number" id="internalSalePrice" placeholder="1.0" step="any" min="0" value="1"
                       style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;" />
              </div>
              <div>
                <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Cap (0 = unlimited)</label>
                <input type="number" id="internalSaleCap" placeholder="0" step="any" min="0" value="0"
                       style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;" />
              </div>
            </div>
          </div>

          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Token to Issue</label>
              <select id="internalSaleTokenType"
                      style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;">
                <option value="shares">${daoSymbol} (Shares)</option>
                <option value="loot">${daoSymbol}-LOOT (Loot)</option>
              </select>
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Status</label>
              <select id="internalSaleStatus"
                      style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;">
                <option value="active">Active</option>
                <option value="inactive">Inactive (cancel sale)</option>
              </select>
            </div>
          </div>

          <div id="internalSalePreview" style="margin-bottom: 0.75rem; padding: 0.5rem; background: #f9f9f9; font-size: 0.75rem; color: var(--fg);">
            <div>1 TOKEN = 1 ${daoSymbol} (shares)</div>
            <div style="font-size: 0.7rem; color: var(--fg-dim);">Users can ragequit to reclaim their tokens</div>
          </div>

          <button onclick="populateInternalSaleProposal('${currentDAO.dao.dao}')"
                  onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                  onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Initialize UI
        setTimeout(() => updateInternalSaleUI(), 200);
      }

      function updateInternalSaleUI() {
        const saleType = document.getElementById('internalSaleType')?.value;
        const descriptionDiv = document.getElementById('internalSaleDescription');
        const upgradeFields = document.getElementById('upgradeTokenFields');
        const daiFields = document.getElementById('daiFields');
        const customFields = document.getElementById('customSaleFields');
        const previewDiv = document.getElementById('internalSalePreview');
        const tokenType = document.getElementById('internalSaleTokenType')?.value || 'shares';
        const daoSymbol = currentDAO?.dao?.meta?.symbol || 'TOKEN';
        const tokenSymbol = tokenType === 'loot' ? `${daoSymbol}-LOOT` : daoSymbol;

        if (!descriptionDiv) return;

        switch (saleType) {
          case 'upgrade':
            descriptionDiv.innerHTML = `<strong style="color: #000;">Token Upgrade:</strong> Allow holders of an existing ERC20 token to stake/upgrade to ${tokenSymbol} at 1:1 ratio. Users can ragequit to reclaim their original tokens.`;
            upgradeFields.style.display = 'block';
            daiFields.style.display = 'none';
            customFields.style.display = 'none';
            previewDiv.innerHTML = `
              <div>1 TOKEN = 1 ${tokenSymbol}</div>
              <div style="font-size: 0.7rem; color: var(--fg-dim);">Users can ragequit to reclaim their tokens</div>
            `;
            break;
          case 'dai':
            descriptionDiv.innerHTML = `<strong style="color: #000;">DAI Continuous Fundraise:</strong> Accept DAI at 1:1 ratio for ${tokenSymbol}. Ideal for continuous capital formation. DAI goes to treasury and can be ragequit.`;
            upgradeFields.style.display = 'none';
            daiFields.style.display = 'block';
            customFields.style.display = 'none';
            previewDiv.innerHTML = `
              <div>1 DAI = 1 ${tokenSymbol}</div>
              <div style="font-size: 0.7rem; color: var(--fg-dim);">Continuous fundraise - DAI redeemable via ragequit</div>
            `;
            break;
          case 'custom':
            descriptionDiv.innerHTML = `<strong style="color: #000;">Custom Sale:</strong> Configure a custom sale with any price and cap. For non-1:1 ratios or limited sales.`;
            upgradeFields.style.display = 'block';
            daiFields.style.display = 'none';
            customFields.style.display = 'block';
            previewDiv.innerHTML = `
              <div>Custom ratio - configure price and cap below</div>
            `;
            break;
        }
      }

      async function validateInternalSaleToken() {
        const tokenAddr = document.getElementById('internalSaleTokenAddr')?.value?.trim();
        const infoDiv = document.getElementById('internalSaleTokenInfo');
        if (!infoDiv) return;

        if (!tokenAddr || !ethers.isAddress(tokenAddr)) {
          infoDiv.innerHTML = '<span style="color: #e74c3c;">Invalid address</span>';
          return;
        }

        try {
          infoDiv.innerHTML = '<span style="color: var(--fg-dim);">Checking...</span>';
          const tokenContract = new ethers.Contract(tokenAddr, ERC20_ABI, provider);
          const [symbol, decimals] = await Promise.all([
            tokenContract.symbol(),
            tokenContract.decimals()
          ]);

          if (decimals !== 18n) {
            infoDiv.innerHTML = `<span style="color: #e74c3c;">${symbol} has ${decimals} decimals (must be 18)</span>`;
          } else {
            infoDiv.innerHTML = `<span style="color: var(--green);">âœ“ ${symbol} (18 decimals)</span>`;
            // Update preview
            const previewDiv = document.getElementById('internalSalePreview');
            const tokenType = document.getElementById('internalSaleTokenType')?.value || 'shares';
            const daoSymbol = currentDAO?.dao?.meta?.symbol || 'TOKEN';
            const tokenSymbol = tokenType === 'loot' ? `${daoSymbol}-LOOT` : daoSymbol;
            if (previewDiv && document.getElementById('internalSaleType')?.value !== 'custom') {
              previewDiv.innerHTML = `
                <div>1 ${symbol} = 1 ${tokenSymbol}</div>
                <div style="font-size: 0.7rem; color: var(--fg-dim);">Users can ragequit to reclaim their ${symbol}</div>
              `;
            }
          }
        } catch (e) {
          infoDiv.innerHTML = '<span style="color: #e74c3c;">Could not read token info</span>';
        }
      }

      function clearInternalSaleHelper() {
        const helperDiv = document.getElementById('internalSaleHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateInternalSaleProposal(daoAddress) {
        try {
          const saleType = document.getElementById('internalSaleType').value;
          const tokenType = document.getElementById('internalSaleTokenType').value;
          const status = document.getElementById('internalSaleStatus').value;
          const isLoot = tokenType === 'loot';
          const daoSymbol = currentDAO.dao.meta.symbol;
          const tokenSymbol = isLoot ? `${daoSymbol}-LOOT` : daoSymbol;

          let payTokenAddr, price, cap;

          if (saleType === 'dai') {
            payTokenAddr = TOKEN_ADDRESSES.dai;
            price = '1';
            cap = '0';
          } else if (saleType === 'upgrade') {
            payTokenAddr = document.getElementById('internalSaleTokenAddr')?.value?.trim();
            if (!payTokenAddr || !ethers.isAddress(payTokenAddr)) {
              showStatus('Please enter a valid token address', true);
              return;
            }
            price = '1';
            cap = '0';
          } else {
            // Custom
            payTokenAddr = document.getElementById('internalSaleTokenAddr')?.value?.trim();
            if (!payTokenAddr || !ethers.isAddress(payTokenAddr)) {
              showStatus('Please enter a valid token address', true);
              return;
            }
            price = document.getElementById('internalSalePrice')?.value?.trim() || '1';
            cap = document.getElementById('internalSaleCap')?.value?.trim() || '0';
          }

          const active = status === 'active';

          // Encode setSale(address payToken, uint256 pricePerShare, uint256 cap, bool minting, bool active, bool isLoot)
          // Internal Moloch sale always uses minting=true
          const priceWei = ethers.parseEther(price);
          const capWei = ethers.parseEther(cap);

          const calldata = INTERFACES.setSale.encodeFunctionData('setSale', [payTokenAddr, priceWei, capWei, true, active, isLoot]);

          // Target is the DAO itself (Moloch.setSale)
          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          let description;
          if (!active) {
            description = `Cancel internal sale for ${tokenSymbol}`;
          } else if (saleType === 'dai') {
            description = `Enable DAI continuous fundraise: 1 DAI = 1 ${tokenSymbol}`;
          } else if (saleType === 'upgrade') {
            description = `Enable token upgrade: 1:1 migration to ${tokenSymbol}`;
          } else {
            description = `Configure custom sale for ${tokenSymbol}`;
          }

          setLockedProposalDescription(description);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearInternalSaleHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating internal sale proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // TAP Ops proposal helper - for changing the tap beneficiary via governance
      async function prepareTapOpsProposal(currentOps) {
        if (!currentDAO || !currentDAO.dao) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const daoAddress = currentDAO.dao.dao;
        const currentOpsShort = currentOps.slice(0, 10) + '...' + currentOps.slice(-8);

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add tap ops helper UI if not already present
        let helperDiv = document.getElementById('tapOpsHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'tapOpsHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: #fffaf0; border: 1px solid #e0c8a0; ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #b8860b; letter-spacing: 0.1em;">
              CHANGE TAP OPS
            </div>
            <button onclick="clearTapOpsHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #fffaf0; ">
            <div style="font-size: 0.85rem; color: var(--fg); margin-bottom: 0.35rem;">
              Current Ops: <a href="${getNetwork().explorer}/address/${currentOps}" target="_blank" rel="noopener" style="color: #b8860b; text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${currentOpsShort}</a>
            </div>
            <div style="font-size: 0.75rem; color: var(--fg-dim);">
              The ops address receives claimed tap funds
            </div>
          </div>
          <div style="margin-bottom: 0.5rem; padding: 0.5rem; background: #fffaf0; font-size: 0.75rem; color: #b8860b;">
            <strong>Note:</strong> Setting ops to address(0) will disable tap claiming until a new ops is set.
          </div>
          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">New Ops Address</label>
            <input type="text" id="tapOpsInput" placeholder="0x..."
                   oninput="updateTapOpsPreview()"
                   style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid #e0c8a0; color: #000; font-size: 0.95rem;" />
            <div style="margin-top: 0.35rem; font-size: 0.7rem; color: var(--fg-dim);">
              Enter the new beneficiary address (EOA, multisig, or contract)
            </div>
            <div id="tapOpsPreview" style="margin-top: 0.5rem; display: none;"></div>
          </div>
          <button onclick="populateTapOpsProposal('${daoAddress}', '${currentOps}')"
                  onmouseover="this.style.background='#e0c8a0'; this.style.borderColor='#b8860b'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px #e0c8a0';"
                  onmouseout="this.style.background='#fdf5e8'; this.style.borderColor='#d4b888'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: #fffaf0; border: 1px solid #d4b888; color: #000; font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Focus on input
        setTimeout(() => {
          const input = getEl('tapOpsInput');
          if (input) input.focus();
        }, 100);
      }

      function updateTapOpsPreview() {
        const previewDiv = document.getElementById('tapOpsPreview');
        const opsInput = getEl('tapOpsInput');
        if (!previewDiv || !opsInput) return;

        const newOps = opsInput.value.trim();

        if (!newOps) {
          previewDiv.style.display = 'none';
          return;
        }

        previewDiv.style.display = 'block';

        // Check if it's a valid address
        if (!ethers.isAddress(newOps)) {
          previewDiv.innerHTML = `
            <div style="padding: 0.5rem; background: #fff0f0; border: 1px solid #e74c3c; font-size: 0.75rem; color: #e74c3c;">
              âš ï¸ Invalid address format
            </div>
          `;
          return;
        }

        // Check for zero address
        if (newOps === ethers.ZeroAddress) {
          previewDiv.innerHTML = `
            <div style="padding: 0.5rem; background: #fffaf0; border: 1px solid #e0c8a0; font-size: 0.75rem; color: #b8860b;">
              âš ï¸ Setting ops to zero address will disable tap claiming
            </div>
          `;
          return;
        }

        previewDiv.innerHTML = `
          <div style="padding: 0.5rem; background: var(--status-success); border: 1px solid var(--green); font-size: 0.75rem; color: var(--fg);">
            âœ“ Valid address: <a href="${getNetwork().explorer}/address/${newOps}" target="_blank" rel="noopener" style="color: var(--green); text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${newOps.slice(0, 10)}...${newOps.slice(-8)}</a>
          </div>
        `;
      }

      function clearTapOpsHelper() {
        const helperDiv = document.getElementById('tapOpsHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function populateTapOpsProposal(daoAddress, currentOps) {
        try {
          const opsInput = getEl('tapOpsInput').value.trim();

          if (!opsInput) {
            showStatus('Please enter a new ops address', true);
            return;
          }

          // Resolve ENS if needed
          let newOps = opsInput;
          if (opsInput.endsWith('.eth')) {
            try {
              showStatus('Resolving ENS name...', false);
              newOps = await provider.resolveName(opsInput);
              if (!newOps) {
                showStatus('Could not resolve ENS name', true);
                return;
              }
            } catch (e) {
              showStatus('Failed to resolve ENS name', true);
              return;
            }
          }

          if (!ethers.isAddress(newOps)) {
            showStatus('Please enter a valid Ethereum address or ENS name', true);
            return;
          }

          // Check if same as current
          if (newOps.toLowerCase() === currentOps.toLowerCase()) {
            showStatus('New ops address is the same as current ops', true);
            return;
          }

          // Encode setTapOps(address newOps) - called by DAO on DAICO contract
          const setTapOpsIface = new ethers.Interface(['function setTapOps(address newOps)']);
          const calldata = setTapOpsIface.encodeFunctionData('setTapOps', [newOps]);

          // Target is DAICO contract (DAO calls DAICO.setTapOps)
          getEl('proposalTo').value = DAICO_ADDRESS;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          const newOpsShort = newOps.slice(0, 10) + '...' + newOps.slice(-6);
          const description = newOps === ethers.ZeroAddress
            ? `Disable tap claiming (set ops to zero address)`
            : `Change tap ops to ${newOpsShort}`;

          // Machine-readable metadata for tap ops change
          const metadata = `<<<DAICO_TAP action="setOps" newOps="${newOps}" previousOps="${currentOps}" DAICO_TAP>>>`;
          const fullDescription = `${description}\n\n${metadata}`;

          setLockedProposalDescription(fullDescription, description);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearTapOpsHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating tap ops proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      async function populateTapRateProposal(daoAddress, decimals, symbol) {
        try {
          const rateInput = getEl('tapRateInput').value.trim().replace(/,/g, '');

          if (!rateInput || isNaN(parseFloat(rateInput)) || parseFloat(rateInput) < 0) {
            showStatus('Please enter a valid rate (0 or positive number)', true);
            return;
          }

          const newRatePerMonth = parseFloat(rateInput);

          // Convert monthly rate to rate per second (smallest units)
          // ratePerSec = (ratePerMonth * 10^decimals) / SECONDS_PER_MONTH
          const SECONDS_PER_MONTH = 2629746n;
          const ratePerMonthWei = ethers.parseUnits(newRatePerMonth.toString(), decimals);
          const ratePerSec = ratePerMonthWei / SECONDS_PER_MONTH;

          // Encode setTapRate(uint128 newRate) - called by DAO on DAICO contract
          const setTapRateIface = new ethers.Interface(['function setTapRate(uint128 newRate)']);
          const calldata = setTapRateIface.encodeFunctionData('setTapRate', [ratePerSec]);

          // Target is DAICO contract (DAO calls DAICO.setTapRate)
          getEl('proposalTo').value = DAICO_ADDRESS;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          const description = newRatePerMonth === 0
            ? `Freeze tap (set rate to 0)`
            : `Change tap rate to ${newRatePerMonth.toLocaleString()} ${symbol}/month`;

          // Machine-readable metadata for tap rate change
          const metadata = `<<<DAICO_TAP action="setRate" ratePerSec="${ratePerSec.toString()}" ratePerMonth="${newRatePerMonth}" symbol="${symbol}" decimals="${decimals}" DAICO_TAP>>>`;
          const fullDescription = `${description}\n\n${metadata}`;

          setLockedProposalDescription(fullDescription, description);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearTapRateHelper();

          // Scroll to show the populated form
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);

        } catch (error) {
          logger.error('Error populating tap rate proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Populate sale proposal from Send/Sale toggle
      async function populateSaleProposalFromToggle(symbol, address, decimals) {
        try {
          // Get elements from within the transferHelper div to avoid conflicts
          const helperDiv = getEl('transferHelper');
          if (!helperDiv) {
            showStatus('Helper not found - please try again', true);
            return;
          }

          const tokenTypeEl = helperDiv.querySelector('#modalSaleTokenType');
          const priceEl = helperDiv.querySelector('#modalSalePrice');
          const capEl = helperDiv.querySelector('#modalSaleCap');
          const mintingEl = helperDiv.querySelector('#modalSaleMinting');
          const statusEl = helperDiv.querySelector('#modalSaleStatus');

          if (!priceEl) {
            showStatus('Form elements not found - please try again', true);
            return;
          }

          const tokenType = tokenTypeEl?.value;
          const priceInput = priceEl?.value?.trim();
          const capInput = capEl?.value?.trim();
          const minting = mintingEl?.checked;
          const status = statusEl?.value;

          if (!priceInput || isNaN(priceInput) || parseFloat(priceInput) <= 0) {
            showStatus('âš ï¸ Please enter a valid price per token (required field)', true);
            // Highlight the price field
            if (priceEl) {
              priceEl.style.border = '2px solid #e74c3c';
              priceEl.focus();
              setTimeout(() => {
                priceEl.style.border = '1px solid var(--border-muted)';
              }, 2000);
            }
            return;
          }

          // Price is in "token-wei per share-wei" (simple integer ratio)
          // For 1:1 with 18-decimal tokens: user enters "1", price = 1 (not 1e18!)
          // This is because contract does: cost = shareAmount * price (no scaling)
          const pricePerShare = BigInt(Math.round(parseFloat(priceInput)));
          if (pricePerShare === 0n) {
            showStatus('Price must be at least 1 (fractional prices < 1 not supported)', true);
            return;
          }

          const cap = capInput && parseFloat(capInput) > 0 ? ethers.parseEther(capInput) : 0n;
          const isLoot = tokenType === 'loot';
          const active = status === 'active';

          // Get DAO address
          if (!currentDAO || !currentDAO.dao || !currentDAO.dao.dao) {
            showStatus('DAO not loaded', true);
            return;
          }
          const daoAddress = currentDAO.dao.dao;

          // Encode setSale call
          const calldata = INTERFACES.setSale.encodeFunctionData('setSale', [
            address, pricePerShare, cap, minting, active, isLoot
          ]);

          // Populate proposal form
          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = calldata;

          const tokenTypeText = isLoot ? 'LOOT' : 'SHARES';
          const sourceText = minting ? 'minting new tokens' : 'selling from treasury';
          const capText = cap > 0n ? `${ethers.formatEther(cap)} tokens` : 'unlimited';
          const statusText = active ? 'ACTIVE' : 'INACTIVE';

          let description = `Configure ${symbol} sale: ${priceInput} ${symbol} per ${tokenTypeText} token, ${capText} cap, ${sourceText}, status: ${statusText}`;

          // Always add SALE tag for tracking in UI (treasury, sales section, etc.)
          description += `\n\n<<<SALE token="${address}" price="${pricePerShare}" decimals="${decimals}" symbol="${symbol}" SALE>>>`;

          // Set locked description (user can add notes but can't edit the core description)
          setLockedProposalDescription(description);

          // Update UI hints and translations
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated with sale configuration', false);
          clearTransferHelper();

          // Scroll to description
          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 100);
        } catch (error) {
          logger.error('Error populating sale proposal:', error);
          showStatus('Failed to populate sale proposal: ' + error.message, true);
        }
      }

      // Update proposal form sale hint
      function updateProposalSaleHint() {
        const priceInput = getEl('proposalSalePrice')?.value?.trim();
        const capInput = getEl('proposalSaleCap')?.value?.trim();
        const tokenType = getEl('proposalSaleTokenType')?.value === 'true' ? 'loot' : 'shares';
        const paymentToken = getEl('salePayToken')?.value;

        const hint = document.getElementById('proposalSaleHint');
        const hintText = document.getElementById('proposalSaleHintText');

        if (!hint || !hintText) return;

        const price = parseFloat(priceInput);
        const cap = parseFloat(capInput);

        let payToken;
        if (paymentToken === 'custom') {
          payToken = 'TOKEN';
        } else {
          const tokenNames = {
            [TOKEN_ADDRESSES.dai]: 'DAI'
          };
          payToken = tokenNames[paymentToken] || 'TOKEN';
        }
        const tokenTypeText = tokenType === 'loot' ? 'Loot' : 'Share';

        // Show hint even without price - guide the user
        if (!priceInput || isNaN(price) || price <= 0) {
          hintText.innerHTML = `<span style="opacity: 0.6;">Enter price to see sale preview (e.g., "1 ${payToken} for 1 ${tokenTypeText}")</span>`;
          hint.style.display = 'block';
          return;
        }

        // Detect 1:1 upgrade path
        const is1to1 = price === 1;

        // Build the hint text - more natural word order: "1 DAI for 1 Share"
        let text = `<strong>${price} ${payToken}</strong> for <strong>1 ${tokenTypeText}</strong>`;

        if (cap && !isNaN(cap) && cap > 0) {
          text += ` up to <strong>${cap.toLocaleString()} ${tokenTypeText}${cap !== 1 ? 's' : ''}</strong>`;
        } else {
          text += ` <span style="opacity: 0.7;">(unlimited)</span>`;
        }

        // Add 1:1 upgrade path hint or cost example
        if (is1to1) {
          text += ` <span style="color: #000; font-weight: 600; margin-left: 0.5rem;">â€¢ 1:1 Upgrade Path</span>`;
        } else {
          // Add cost example
          const exampleAmount = 100;
          const exampleCost = exampleAmount * price;
          text += `<br><span style="opacity: 0.6; font-size: 0.85em;">Example: ${exampleCost.toLocaleString()} ${payToken} buys ${exampleAmount} ${tokenTypeText}s</span>`;
        }

        hintText.innerHTML = text;
        hint.style.display = 'block';
      }

      function clearDaicoSaleHelper() {
        const helperDiv = document.getElementById('daicoSaleHelper');
        if (helperDiv) helperDiv.remove();
      }

      // Populate DAICO sale proposal with batch calls
      async function populateDaicoSaleProposal() {
        try {
          const tribTokenSelect = getEl('daicoProposalTribToken');
          const forTokenSelect = document.getElementById('daicoProposalForToken');
          const tribAmtInput = document.getElementById('daicoProposalTribAmt').value.trim();
          const forAmtInput = document.getElementById('daicoProposalForAmt').value.trim();
          const supplyInput = document.getElementById('daicoProposalSupply').value.trim();

          // Validate inputs
          if (!tribAmtInput || isNaN(parseFloat(tribAmtInput)) || parseFloat(tribAmtInput) <= 0) {
            showStatus('Please enter a valid tribute amount', true);
            return;
          }
          if (!forAmtInput || isNaN(parseFloat(forAmtInput)) || parseFloat(forAmtInput) <= 0) {
            showStatus('Please enter a valid "for" amount', true);
            return;
          }
          if (!supplyInput || isNaN(parseFloat(supplyInput)) || parseFloat(supplyInput) <= 0) {
            showStatus('Please enter a valid sale supply', true);
            return;
          }

          // Check LP configuration
          const enableLP = document.getElementById('daicoProposalEnableLP')?.checked;
          const lpBpsInput = document.getElementById('daicoProposalLpBps')?.value?.trim();
          const feeOrHookInput = document.getElementById('daicoProposalFeeOrHook')?.value?.trim() || '30';

          // Check Tap configuration
          const enableTap = document.getElementById('daicoProposalEnableTap')?.checked;
          const tapOpsInput = document.getElementById('daicoProposalTapOps')?.value?.trim();
          const tapRateInput = document.getElementById('daicoProposalTapRate')?.value?.trim();
          const tapBudgetInput = document.getElementById('daicoProposalTapBudget')?.value?.trim();

          // Validate LP if enabled
          if (enableLP) {
            if (!lpBpsInput || parseInt(lpBpsInput) < 1 || parseInt(lpBpsInput) > 99) {
              showStatus('LP percentage must be between 1 and 99', true);
              return;
            }
          }

          // Validate Tap if enabled
          if (enableTap) {
            if (!tapOpsInput || !ethers.isAddress(tapOpsInput)) {
              showStatus('Please enter a valid Ops address for the tap', true);
              return;
            }
            if (!tapRateInput || isNaN(parseFloat(tapRateInput)) || parseFloat(tapRateInput) <= 0) {
              showStatus('Please enter a valid tap rate', true);
              return;
            }
            if (!tapBudgetInput || isNaN(parseFloat(tapBudgetInput)) || parseFloat(tapBudgetInput) <= 0) {
              showStatus('Please enter a valid tap budget', true);
              return;
            }
          }

          const tribToken = tribTokenSelect.value;
          const tribDecimals = parseInt(tribTokenSelect.getAttribute('data-decimals') || '18');
          const tribSymbol = tribTokenSelect.getAttribute('data-symbol') || 'ETH';
          const forToken = forTokenSelect.value;
          const forTokenName = forTokenSelect.options[forTokenSelect.selectedIndex].text;

          const daoAddress = currentDAO.dao.dao;

          // Parse amounts with correct decimals
          const tribAmt = ethers.parseUnits(tribAmtInput, tribDecimals);
          const forAmt = ethers.parseEther(forAmtInput);
          const saleSupply = ethers.parseEther(supplyInput);

          // LP parameters (convert percentage to basis points: 50% = 5000 bps)
          const lpBps = enableLP ? parseInt(lpBpsInput) * 100 : 0;
          const maxSlipBps = 100; // 1% default slippage
          const feeOrHook = parseInt(feeOrHookInput) || 30;

          // Tap parameters (convert rate from per-month to per-second)
          // Solidity expects smallest units per second; 1 month â‰ˆ 30.44 days â‰ˆ 2629746 seconds
          const SECONDS_PER_MONTH = 2629746n;
          let tapOps = ethers.ZeroAddress;
          let tapRatePerSec = 0n;
          let tapBudget = 0n;

          if (enableTap) {
            tapOps = tapOpsInput;
            const ratePerMonth = ethers.parseUnits(tapRateInput, tribDecimals);
            tapRatePerSec = ratePerMonth / SECONDS_PER_MONTH;
            tapBudget = ethers.parseUnits(tapBudgetInput, tribDecimals);

            // Ensure rate is at least 1 wei/sec if specified
            if (tapRatePerSec === 0n && ratePerMonth > 0n) {
              tapRatePerSec = 1n;
            }
          }

          // Determine if selling shares (vs loot)
          const isLoot = forToken === currentDAO.dao.meta.lootToken;

          // GOVERNANCE SAFETY CHECK: Prevent DAICO shares sales that could exceed proposal threshold
          if (!isLoot && currentDAO?.dao?.gov) {
            const proposalThreshold = BigInt(currentDAO.dao.gov.proposalThreshold || 0);
            if (proposalThreshold > 0n && saleSupply > proposalThreshold) {
              const continueAnyway = confirm(
                `âš ï¸ GOVERNANCE RISK: DAICO sale supply (${ethers.formatEther(saleSupply)} shares) exceeds proposal threshold (${ethers.formatEther(proposalThreshold)} shares).\n\n` +
                `A single buyer could accumulate enough voting shares to pass proposals unilaterally.\n\n` +
                `Consider:\n` +
                `â€¢ Selling LOOT (non-voting) instead\n` +
                `â€¢ Reducing supply to â‰¤ ${ethers.formatEther(proposalThreshold)}\n\n` +
                `Continue anyway?`
              );
              if (!continueAnyway) return;
            }
          }

          // Create batch proposal with calls using batchCalls pattern
          const calls = [];
          let numActions = 3; // Base: mint, approve, setSale (or combined)

          // Step 1: Mint the sale supply to the DAO itself
          const mintCalldata = INTERFACES.mintFromMoloch.encodeFunctionData('mintFromMoloch', [daoAddress, saleSupply]);
          calls.push([forToken, 0n, mintCalldata]);

          // Step 2: Approve DAICO contract to spend the minted tokens
          const approveCalldata = INTERFACES.erc20Approve.encodeFunctionData('approve', [DAICO_ADDRESS, saleSupply]);
          calls.push([forToken, 0n, approveCalldata]);

          // Step 3: If tap is enabled, set allowance for DAICO to spend from DAO treasury
          if (enableTap && tapBudget > 0n) {
            const setAllowanceCalldata = INTERFACES.setAllowance.encodeFunctionData('setAllowance', [DAICO_ADDRESS, tribToken, tapBudget]);
            calls.push([daoAddress, 0n, setAllowanceCalldata]);
            numActions++;
          }

          // Step 4: Configure the sale on DAICO contract (choose appropriate function)
          // deadline = 0 means no expiration
          let setSaleCalldata;
          let saleMethod;

          if (enableLP && enableTap) {
            // setSaleWithLPAndTap(tribTkn, tribAmt, forTkn, forAmt, deadline, lpBps, maxSlipBps, feeOrHook, ops, ratePerSec)
            setSaleCalldata = INTERFACES.daicoSetSaleWithLPAndTap.encodeFunctionData('setSaleWithLPAndTap', [
              tribToken, tribAmt, forToken, forAmt, 0, lpBps, maxSlipBps, feeOrHook, tapOps, tapRatePerSec
            ]);
            saleMethod = 'setSaleWithLPAndTap';
          } else if (enableLP) {
            // setSaleWithLP(tribTkn, tribAmt, forTkn, forAmt, deadline, lpBps, maxSlipBps, feeOrHook)
            setSaleCalldata = INTERFACES.daicoSetSaleWithLP.encodeFunctionData('setSaleWithLP', [
              tribToken, tribAmt, forToken, forAmt, 0, lpBps, maxSlipBps, feeOrHook
            ]);
            saleMethod = 'setSaleWithLP';
          } else if (enableTap) {
            // setSaleWithTap(tribTkn, tribAmt, forTkn, forAmt, deadline, ops, ratePerSec)
            setSaleCalldata = INTERFACES.daicoSetSaleWithTap.encodeFunctionData('setSaleWithTap', [
              tribToken, tribAmt, forToken, forAmt, 0, tapOps, tapRatePerSec
            ]);
            saleMethod = 'setSaleWithTap';
          } else {
            // setSale(tribTkn, tribAmt, forTkn, forAmt, deadline)
            setSaleCalldata = INTERFACES.daicoSetSale.encodeFunctionData('setSale', [tribToken, tribAmt, forToken, forAmt, 0]);
            saleMethod = 'setSale';
          }
          calls.push([DAICO_ADDRESS, 0n, setSaleCalldata]);

          // Encode batchCalls for proposal execution (self-call from DAO)
          const batchCallsInterface = new ethers.Interface(['function batchCalls((address,uint256,bytes)[])']);
          const batchCallsCalldata = batchCallsInterface.encodeFunctionData('batchCalls', [calls]);

          // Populate proposal form - target is DAO itself for batchCalls
          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = batchCallsCalldata;

          // Build description
          const pricePerToken = parseFloat(tribAmtInput) / parseFloat(forAmtInput);
          let description = `Setup DAICO Sale: ${supplyInput} ${forTokenName} available for purchase`;
          description += `\n\nSale Terms: ${tribAmtInput} ${tribSymbol} = ${forAmtInput} ${forTokenName} (${pricePerToken.toFixed(6)} ${tribSymbol}/token)`;

          if (enableLP) {
            const lpPct = parseInt(lpBpsInput);
            description += `\n\nLP Configuration: ${lpPct}% of tribute goes to ZAMM liquidity (buyers receive ${100 - lpPct}% of quoted rate)`;
          }

          if (enableTap) {
            const ratePerMonth = parseFloat(tapRateInput);
            description += `\n\nTap: ${ratePerMonth.toLocaleString()} ${tribSymbol}/month to ${tapOpsInput.slice(0, 10)}... (budget: ${parseFloat(tapBudgetInput).toLocaleString()} ${tribSymbol})`;
          }

          description += `\n\nThis proposal executes ${numActions} actions in a single batch:`;
          let actionNum = 1;
          description += `\n${actionNum++}. Mint ${supplyInput} ${forTokenName} to DAO`;
          description += `\n${actionNum++}. Approve DAICO contract to transfer tokens`;
          if (enableTap && tapBudget > 0n) {
            description += `\n${actionNum++}. Grant DAICO tap allowance (${ethers.formatUnits(tapBudget, tribDecimals)} ${tribSymbol})`;
          }
          description += `\n${actionNum++}. Configure sale via ${saleMethod} on DAICO (${DAICO_ADDRESS.slice(0, 10)}...)`;

          // Machine-readable metadata for proposal parsing
          let metadata = `<<<DAICO_SALE tribToken="${tribToken}" tribAmt="${tribAmt}" forToken="${forToken}" forAmt="${forAmt}" supply="${saleSupply}"`;
          if (enableLP) metadata += ` lpBps="${lpBps}" feeOrHook="${feeOrHook}"`;
          if (enableTap) metadata += ` tapOps="${tapOps}" tapRatePerSec="${tapRatePerSec}" tapBudget="${tapBudget}"`;
          metadata += ` DAICO_SALE>>>`;
          description += `\n\n${metadata}`;

          // Set locked description (user can add notes but can't edit the core description)
          setLockedProposalDescription(description);

          // Update UI hints
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated with DAICO sale batch proposal!', false);
          clearDaicoSaleHelper();

          // Scroll to description
          setTimeout(() => {
            getEl('proposalDescriptionLocked').scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 100);
        } catch (error) {
          logger.error('Error populating DAICO sale proposal:', error);
          showStatus('Failed to populate proposal: ' + error.message, true);
        }
      }

      // Allowance helper functions
      function clearAllowanceHelper() {
        const helperDiv = document.getElementById('allowanceHelper');
        if (helperDiv) helperDiv.remove();
      }

      async function prepareAllowanceProposal() {
        // Clear any existing helpers first
        clearTransferHelper();
        clearMintHelper();
        clearFutarchyHelper();
        clearQuorumHelper();
        clearTTLHelper();
        clearTimelockDelayHelper();
        clearThresholdHelper();
        clearRagequitHelper();
        clearTransferabilityHelper();
        clearEmergencyPermitHelper();
        clearSaleHelper();
        clearAllowanceHelper();

        if (!currentDAO) {
          showStatus('Please select a DAO first', true);
          return;
        }

        const daoAddress = currentDAO.dao.dao;

        // Scroll to proposal form
        const proposalForm = document.querySelector('.proposal-form');
        if (proposalForm) {
          proposalForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // Add allowance helper UI if not already present
        let helperDiv = document.getElementById('allowanceHelper');
        if (!helperDiv) {
          helperDiv = document.createElement('div');
          helperDiv.id = 'allowanceHelper';
          helperDiv.style.cssText = 'margin-bottom: 1rem; padding: 1rem; background: var(--surface); border: 1px solid var(--border-muted); ';
          proposalForm.insertBefore(helperDiv, proposalForm.querySelector('.proposal-form-group'));
        }

        // Build token options for supported treasury assets
        const tokenOptions = `
          <option value="${ethers.ZeroAddress}" data-decimals="18">ETH</option>
          <option value="${TOKEN_ADDRESSES.usdc}" data-decimals="6">USDC</option>
          <option value="${TOKEN_ADDRESSES.usdt}" data-decimals="6">USDT</option>
          <option value="${TOKEN_ADDRESSES.dai}" data-decimals="18">DAI</option>
          <option value="${TOKEN_ADDRESSES.wsteth}" data-decimals="18">wstETH</option>
          <option value="${TOKEN_ADDRESSES.reth}" data-decimals="18">rETH</option>
          <option value="${currentDAO.dao.meta.sharesToken}" data-decimals="18">Shares</option>
          <option value="${currentDAO.dao.meta.lootToken}" data-decimals="18">Loot</option>
        `;

        helperDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <div style="font-size: 0.85rem; color: #000; letter-spacing: 0.1em;">
              SET SPENDING ALLOWANCE
            </div>
            <button onclick="clearAllowanceHelper()" style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 1.2rem; padding: 0; line-height: 1;">&times;</button>
          </div>
          <div style="margin-bottom: 0.75rem; padding: 0.65rem; background: #f9f9f9; border-left: 3px solid #ccc; font-size: 0.8rem; color: var(--fg-dim); line-height: 1.4;">
            Grant a spender address the ability to withdraw assets from the DAO treasury up to a specified amount without proposal votes.
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Spender Address</label>
              <input type="text" id="allowanceSpender" placeholder="0x..."
                     style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;" />
            </div>
            <div>
              <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Token</label>
              <select id="allowanceToken" style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;">
                ${tokenOptions}
              </select>
            </div>
          </div>
          <div style="margin-bottom: 0.75rem;">
            <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem;">Amount (0 to revoke)</label>
            <input type="number" id="allowanceAmount" placeholder="0.0" step="any" min="0"
                   style="width: 100%; padding: 0.6rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.95rem;" />
            <small style="display: block; margin-top: 0.25rem; font-size: 0.7rem; color: var(--fg-dim);">Enter 0 to revoke an existing allowance</small>
          </div>
          <button onclick="populateAllowanceProposal('${daoAddress}')"
                  onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)'; this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.1)';"
                  onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'; this.style.transform='translateY(0)'; this.style.boxShadow='none';"
                  style="width: 100%; padding: 0.75rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600;">
            Populate Proposal Form
          </button>
        `;

        // Focus spender input
        setTimeout(() => {
          const spenderInput = document.getElementById('allowanceSpender');
          if (spenderInput) spenderInput.focus();
        }, 100);
      }

      function populateAllowanceProposal(daoAddress) {
        const spender = document.getElementById('allowanceSpender')?.value?.trim();
        const tokenSelect = document.getElementById('allowanceToken');
        const amountInput = document.getElementById('allowanceAmount')?.value;

        if (!spender || !ethers.isAddress(spender)) {
          showStatus('Please enter a valid spender address', true);
          return;
        }

        if (!tokenSelect) {
          showStatus('Token selection not found', true);
          return;
        }

        const token = tokenSelect.value;
        const decimals = parseInt(tokenSelect.selectedOptions[0]?.dataset.decimals || '18');
        const tokenSymbol = tokenSelect.selectedOptions[0]?.text || 'TOKEN';

        let amount;
        try {
          const amountValue = parseFloat(amountInput) || 0;
          amount = ethers.parseUnits(amountValue.toString(), decimals);
        } catch (e) {
          showStatus('Invalid amount format', true);
          return;
        }

        // Encode setAllowance(address spender, address token, uint256 amount)
        const calldata = INTERFACES.setAllowance.encodeFunctionData('setAllowance', [spender, token, amount]);

        getEl('proposalTo').value = daoAddress;
        getEl('proposalValue').value = '0';
        getEl('proposalData').value = calldata;

        const amountFormatted = parseFloat(amountInput) || 0;
        const action = amountFormatted === 0 ? 'Revoke' : 'Set';
        const description = `${action} ${tokenSymbol} spending allowance for ${spender.slice(0, 6)}...${spender.slice(-4)}${amountFormatted > 0 ? ` (${amountFormatted} ${tokenSymbol})` : ''}`;

        // Set locked description
        setLockedProposalDescription(description);

        updateCalldataPreview();
        updateCalldataTranslation();
        updateTargetAddressHint();

        clearAllowanceHelper();
        showStatus(`Proposal form populated: ${action} ${tokenSymbol} allowance`, false);
      }

      // Render user's allowances
      async function renderAllowances(prefetchedAllowances) {
        const allowancesInfo = document.getElementById('allowancesInfo');
        const allowancesSection = document.getElementById('allowancesSection');
        if (!allowancesInfo || !allowancesSection || !currentDAO || !signer) {
          if (allowancesSection) allowancesSection.style.display = 'none';
          return;
        }

        try {
          const userAddress = await signer.getAddress();

          let results;
          if (prefetchedAllowances && prefetchedAllowances.length > 0) {
            // Use prefetched data from multicall batch
            results = prefetchedAllowances;
          } else {
            // Fallback: fetch individually
            const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, provider);

            const tokens = [
              { symbol: 'ETH', address: ethers.ZeroAddress, decimals: 18, icon: TOKEN_ICONS.eth },
              { symbol: 'USDC', address: TOKEN_ADDRESSES.usdc, decimals: 6, icon: TOKEN_ICONS.usdc },
              { symbol: 'USDT', address: TOKEN_ADDRESSES.usdt, decimals: 6, icon: TOKEN_ICONS.usdt },
              { symbol: 'DAI', address: TOKEN_ADDRESSES.dai, decimals: 18, icon: TOKEN_ICONS.dai },
              { symbol: 'wstETH', address: TOKEN_ADDRESSES.wsteth, decimals: 18, icon: TOKEN_ICONS.wsteth },
              { symbol: 'rETH', address: TOKEN_ADDRESSES.reth, decimals: 18, icon: TOKEN_ICONS.reth },
              { symbol: 'Shares', address: currentDAO.dao.meta.sharesToken, decimals: 18, icon: TOKEN_ICONS.defaultCoin },
              { symbol: 'Loot', address: currentDAO.dao.meta.lootToken, decimals: 18, icon: TOKEN_ICONS.defaultCoin }
            ];

            results = await Promise.all(
              tokens.map(token =>
                molochContract.allowance(token.address, userAddress)
                  .then(allowance => ({ token, allowance }))
                  .catch(e => {
                    logger.error(`Error fetching allowance for ${token.symbol}:`, e);
                    return null;
                  })
              )
            );
          }

          const allowances = results
            .filter(r => r !== null && r.allowance > 0n)
            .map(r => ({ ...r.token, allowance: r.allowance }));

          if (allowances.length === 0) {
            allowancesSection.style.display = 'none';
            return;
          }

          allowancesSection.style.display = 'block';

          allowancesInfo.innerHTML = allowances.map(a => {
            const formattedAmount = parseFloat(ethers.formatUnits(a.allowance, a.decimals)).toFixed(4);
            return `
              <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: transparent; border: 1px solid var(--border-muted); margin-bottom: 0.5rem;">
                <div style="display: flex; align-items: center; gap: 0.75rem;">
                  <div style="width: 24px; height: 24px;">${a.icon}</div>
                  <div>
                    <div style="font-size: 0.9rem; color: #000;">${a.symbol}</div>
                    <div style="font-size: 0.75rem; color: var(--fg-dim);">Available: ${formattedAmount}</div>
                  </div>
                </div>
                <button onclick="openSpendAllowanceModal('${a.address}', '${a.symbol}', ${a.decimals}, '${a.allowance.toString()}')"
                        style="padding: 0.5rem 1rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.7rem; letter-spacing: 0.1em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease;"
                        onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--fg)';"
                        onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)';">
                  Spend
                </button>
              </div>
            `;
          }).join('');

        } catch (error) {
          logger.error('Error rendering allowances:', error);
          allowancesSection.style.display = 'none';
        }
      }

      // Open spend allowance modal
      function openSpendAllowanceModal(tokenAddress, tokenSymbol, decimals, maxAllowance) {
        // Create modal if it doesn't exist
        let modal = document.getElementById('spendAllowanceModal');
        if (!modal) {
          modal = document.createElement('div');
          modal.id = 'spendAllowanceModal';
          modal.className = 'wallet-modal-overlay';
          document.body.appendChild(modal);
        }

        const maxFormatted = parseFloat(ethers.formatUnits(BigInt(maxAllowance), decimals)).toFixed(6);

        modal.innerHTML = `
          <div class="wallet-modal" style="max-width: 400px;">
            <div class="wallet-modal-header">
              <h3 class="wallet-modal-title">Spend ${tokenSymbol}</h3>
              <button class="wallet-modal-close" onclick="closeSpendAllowanceModal()">&times;</button>
            </div>
            <div class="wallet-modal-content">
              <div style="padding: 0.75rem; background: var(--surface); border: 1px solid var(--border-muted); margin-bottom: 1rem; font-size: 0.8rem; color: var(--fg); line-height: 1.5;">
                Withdraw ${tokenSymbol} from the DAO treasury using your spending allowance. Maximum available: <strong>${maxFormatted} ${tokenSymbol}</strong>
              </div>
              <div style="margin-bottom: 1rem;">
                <label style="display: block; font-size: 0.75rem; color: var(--fg-dim); margin-bottom: 0.35rem; text-transform: uppercase; letter-spacing: 0.1em;">Amount to Withdraw</label>
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <input type="number" id="spendAllowanceAmount" placeholder="0.0" step="any" min="0" max="${maxFormatted}"
                         style="flex: 1; padding: 0.7rem; background: transparent; border: 1px solid var(--border-muted); color: var(--fg); font-size: 1rem; " />
                  <button onclick="getEl('spendAllowanceAmount').value = '${maxFormatted}';"
                          style="padding: 0.7rem 1rem; background: #f9f9f9; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.75rem; cursor: pointer; white-space: nowrap;">
                    MAX
                  </button>
                </div>
              </div>
              <button id="spendAllowanceBtn" onclick="executeSpendAllowance('${tokenAddress}', ${decimals}, '${maxAllowance}')"
                      style="width: 100%; padding: 12px; background: #000; border: 1px solid #000; color: #fff; font-size: 12px; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; font-weight: 600; transition: all 0.2s;">
                Withdraw ${tokenSymbol}
              </button>
            </div>
          </div>
        `;

        modal.classList.add('active');
        document.body.classList.add('modal-open');
        modal.onclick = (e) => {
          if (e.target === modal) closeSpendAllowanceModal();
        };

        // Focus amount input
        setTimeout(() => {
          getEl('spendAllowanceAmount')?.focus();
        }, 100);
      }

      function closeSpendAllowanceModal() {
        const modal = document.getElementById('spendAllowanceModal');
        if (modal) {
          modal.classList.remove('active');
          document.body.classList.remove('modal-open');
        }
      }

      async function executeSpendAllowance(tokenAddress, decimals, maxAllowance) {
        if (!signer || !currentDAO) {
          showStatus('Please connect your wallet first', true);
          return;
        }

        const amountInput = getEl('spendAllowanceAmount')?.value;
        if (!amountInput || isNaN(parseFloat(amountInput)) || parseFloat(amountInput) <= 0) {
          showStatus('Please enter a valid amount', true);
          return;
        }

        const btn = document.getElementById('spendAllowanceBtn');
        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '<span class="spinner"></span> Processing...';

        try {
          const amount = ethers.parseUnits(amountInput.toString(), decimals);

          // Validate amount doesn't exceed allowance
          const maxAmount = BigInt(maxAllowance);
          if (amount > maxAmount) {
            showStatus('Amount exceeds your allowance', true);
            btn.disabled = false;
            btn.innerHTML = originalText;
            return;
          }

          // Call spendAllowance(address token, uint256 amount)
          const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, signer);
          const tx = await molochContract.spendAllowance(tokenAddress, amount, getWalletConnectTxOverrides());

          showStatus('Transaction submitted, waiting for confirmation...', false);
          await tx.wait();

          showStatus('Allowance spent successfully!', false);
          closeSpendAllowanceModal();

          // Refresh allowances display
          await renderAllowances();
          await renderTreasury();

        } catch (error) {
          logger.error('Error spending allowance:', error);
          let errorMessage = 'Transaction failed';
          if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message?.includes('insufficient')) {
            errorMessage = 'Insufficient allowance or balance';
          } else if (error.message?.includes('user rejected')) {
            errorMessage = 'Transaction rejected by user';
          }
          showStatus(errorMessage, true);
        } finally {
          btn.disabled = false;
          btn.innerHTML = originalText;
        }
      }

      // Proposal payment token dropdown functions
      let selectedProposalPayToken = TOKEN_ADDRESSES.dai;

      function toggleProposalPayTokenDropdown() {
        const dropdown = getEl('proposalPayTokenDropdown');
        if (dropdown) {
          dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
        }
      }

      function selectProposalPayToken(tokenName, tokenAddress) {
        selectedProposalPayToken = tokenAddress;
        const hiddenInput = getEl('salePayToken');
        if (hiddenInput) {
          hiddenInput.value = tokenAddress;
        }

        // Show/hide custom token fields
        const customTokenFields = document.getElementById('customSaleTokenFields');
        if (customTokenFields) {
          customTokenFields.style.display = tokenName === 'custom' ? 'block' : 'none';
        }

        // Update display
        const iconEl = document.getElementById('proposalPayTokenIcon');
        const labelEl = document.getElementById('proposalPayTokenLabel');
        if (iconEl && labelEl) {
          if (tokenName === 'custom') {
            iconEl.innerHTML = TOKEN_ICONS.defaultCoin || salePaymentTokenIcons.defaultCoin;
            labelEl.textContent = 'CUSTOM TOKEN';
          } else if (salePaymentTokenIcons[tokenName]) {
            iconEl.innerHTML = salePaymentTokenIcons[tokenName];
            labelEl.textContent = tokenName.toUpperCase();
          }
        }

        // Close dropdown
        const dropdown = getEl('proposalPayTokenDropdown');
        if (dropdown) {
          dropdown.style.display = 'none';
        }

        // Update hint
        updateProposalSaleHint();
      }

      function initializeProposalPayTokenIcons() {
        // Initialize display icon
        const displayIcon = document.getElementById('proposalPayTokenIcon');
        if (displayIcon && salePaymentTokenIcons.dai) {
          displayIcon.innerHTML = salePaymentTokenIcons.dai;
        }

        // Initialize dropdown icons
        const dropdownIcons = document.querySelectorAll('.proposal-token-icon');
        dropdownIcons.forEach(iconEl => {
          const token = iconEl.getAttribute('data-token');
          if (token && salePaymentTokenIcons[token]) {
            iconEl.innerHTML = salePaymentTokenIcons[token];
          } else if (token === 'defaultCoin' && TOKEN_ICONS.defaultCoin) {
            iconEl.innerHTML = TOKEN_ICONS.defaultCoin;
          }
        });
      }

      // Custom token cache for info fetching
      let customTokenCache = {};

      // Track custom sale tokens across the DAO (populated by renderSalesInfo)
      let customSaleTokens = [];

      async function populateSaleProposal(daoAddress) {
        try {
          let payToken = getEl('salePayToken').value;
          const priceInput = document.getElementById('proposalSalePrice').value.trim();
          const capInput = document.getElementById('proposalSaleCap').value.trim();
          const minting = document.getElementById('proposalSaleMinting').value === 'true';
          const active = document.getElementById('proposalSaleActive').value === 'true';
          const isLoot = document.getElementById('proposalSaleTokenType').value === 'true';

          if (!priceInput || isNaN(parseFloat(priceInput)) || parseFloat(priceInput) <= 0) {
            showStatus('Please enter a valid price', true);
            return;
          }

          // GOVERNANCE SAFETY CHECK for existing DAOs
          const cap = capInput && !isNaN(parseFloat(capInput)) && parseFloat(capInput) > 0 ? ethers.parseEther(capInput) : 0n;
          if (!isLoot && minting && active && currentDAO?.dao?.gov) {
            const proposalThreshold = BigInt(currentDAO.dao.gov.proposalThreshold || 0);
            if (proposalThreshold > 0n) {
              if (cap === 0n) {
                // Unlimited minting of voting shares with threshold - dangerous
                showStatus('âš ï¸ Cannot set unlimited shares sale with a proposal threshold. Set a cap â‰¤ ' + ethers.formatEther(proposalThreshold) + ' or sell LOOT instead.', true);
                return;
              } else if (cap > proposalThreshold) {
                const continueAnyway = confirm(
                  `âš ï¸ GOVERNANCE RISK: Sale cap (${ethers.formatEther(cap)} shares) exceeds proposal threshold (${ethers.formatEther(proposalThreshold)} shares).\n\n` +
                  `A single buyer could accumulate enough voting shares to pass proposals unilaterally.\n\n` +
                  `Consider:\n` +
                  `â€¢ Selling LOOT (non-voting) instead\n` +
                  `â€¢ Reducing the cap to â‰¤ ${ethers.formatEther(proposalThreshold)}\n\n` +
                  `Continue anyway?`
                );
                if (!continueAnyway) return;
              }
            }
          }

          // Handle custom token
          let tokenName, decimals;
          if (payToken === 'custom') {
            const customTokenAddress = document.getElementById('customSaleTokenAddress')?.value?.trim();
            if (!customTokenAddress || !ethers.isAddress(customTokenAddress)) {
              showStatus('Please enter a valid custom token address', true);
              return;
            }

            // Fetch token info
            try {
              const tokenContract = new ethers.Contract(customTokenAddress, ERC20_ABI, provider);
              tokenName = await tokenContract.symbol().catch(() => 'TOKEN');
              decimals = await tokenContract.decimals().catch(() => 18);

              if (Number(decimals) !== 18) {
                showStatus('Custom token must have 18 decimals', true);
                return;
              }

              payToken = customTokenAddress;
            } catch (error) {
              showStatus('Failed to fetch custom token info', true);
              return;
            }
          } else {
            // Standard tokens only (DAI)
            const tokenNames = {
              [TOKEN_ADDRESSES.dai]: 'DAI'
            };

            const tokenDecimals = {
              [TOKEN_ADDRESSES.dai]: 18
            };

            tokenName = tokenNames[payToken];
            decimals = tokenDecimals[payToken];
          }

          // Price is in "token-wei per share-wei" (simple integer ratio)
          // For 1:1 with 18-decimal tokens: user enters "1", price = 1 (not 1e18!)
          // This is because contract does: cost = shareAmount * price (no scaling)
          const pricePerShare = BigInt(Math.round(parseFloat(priceInput)));
          if (pricePerShare === 0n) {
            showStatus('Price must be at least 1 (fractional prices < 1 not supported)', true);
            return;
          }

          // cap was already parsed above for governance check
          const saleCalldata = INTERFACES.setSale.encodeFunctionData('setSale', [payToken, pricePerShare, cap, minting, active, isLoot]);

          const tokenType = isLoot ? 'LOOT' : 'SHARES';
          const statusText = active ? 'Enable' : 'Disable';
          const sourceText = minting ? 'mint new' : 'sell from treasury';
          const capText = cap > 0n ? `, cap ${ethers.formatEther(cap)}` : ', unlimited';
          let description = `${statusText} ${tokenType} sale: ${priceInput} ${tokenName} per token (${sourceText}${capText})`;

          // Always add SALE tag for tracking in UI (treasury, sales section, etc.)
          description += `\n\n<<<SALE token="${payToken}" price="${pricePerShare}" decimals="${decimals}" symbol="${tokenName}" SALE>>>`;

          getEl('proposalTo').value = daoAddress;
          getEl('proposalValue').value = '0';
          getEl('proposalData').value = saleCalldata;

          // Set locked description (user can add notes but can't edit the core description)
          setLockedProposalDescription(description);

          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          showStatus('Proposal form populated!', false);
          clearSaleHelper();

          setTimeout(() => {
            const lockedEl = getEl('proposalDescriptionLocked');
            if (lockedEl && lockedEl.style.display !== 'none') {
              lockedEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            } else {
              getEl('proposalDescription').scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }, 300);
        } catch (error) {
          logger.error('Error populating sale proposal:', error);
          showStatus('Failed to populate form: ' + error.message, true);
        }
      }

      // Copy shareable DAO link to clipboard
      async function copyDAOLink() {
        if (!currentDAO) return;

        const daoAddress = currentDAO.dao.dao;
        const chainId = getNetwork().chainId.toString();
        // Build the shareable URL using the current origin and the DAO hash with chain ID
        const shareUrl = `${window.location.origin}${window.location.pathname}#/dao/${chainId}/${daoAddress}`;

        try {
          await navigator.clipboard.writeText(shareUrl);
          const btn = document.getElementById('daoCopyLinkBtn');
          const originalText = btn.querySelector('span').textContent;
          btn.classList.add('copied');
          btn.querySelector('span').textContent = 'Copied!';

          setTimeout(() => {
            btn.classList.remove('copied');
            btn.querySelector('span').textContent = originalText;
          }, 2000);
        } catch (err) {
          logger.error('Failed to copy:', err);
          showStatus('Failed to copy link', true);
        }
      }

      // Parse URL hash for deep linking - returns { chainId, address } or null
      // Supports: #/dao/{chainId}/{address} and legacy #/dao/{address}
      function parseDAODeepLink() {
        const hash = window.location.hash;
        if (!hash) return null;

        // Try new format with chain ID: #/dao/{chainId}/0x...
        let match = hash.match(/^#\/dao\/(\d+)\/(0x[a-fA-F0-9]{40})$/i);
        if (match) {
          return { chainId: match[1], address: match[2] };
        }

        // Fall back to legacy format: #/dao/0x...
        match = hash.match(/^#\/dao\/(0x[a-fA-F0-9]{40})$/i);
        if (match) {
          return { chainId: null, address: match[1] };
        }
        return null;
      }

      // Open DAO by address (for deep linking and search)
      async function openDAOByAddress(address) {
        // Check if already loaded in allDAOs (from search or prior fetch)
        const normalizedAddress = address.toLowerCase();
        let daoIndex = allDAOs.findIndex(dao =>
          dao.dao.toLowerCase() === normalizedAddress
        );

        if (daoIndex !== -1) {
          await openDAO(daoIndex, 'all');
          return true;
        }

        // Also check userDAOs
        const userIndex = userDAOs.findIndex(ud =>
          ud.dao.dao.toLowerCase() === normalizedAddress
        );
        if (userIndex !== -1) {
          await openDAO(userIndex, 'user');
          return true;
        }

        // Not found locally - fetch the single DAO by address
        try {
          const treasuryTokens = getNetwork().treasuryTokens;
          const result = await withRpcFallback(async (rpcProvider) => {
            const viewHelper = new ethers.Contract(VIEW_HELPER_ADDRESS, VIEW_HELPER_ABI, rpcProvider);
            return await viewHelper.getDAOWithDAICO(
              address,
              0, 5, 0, 5,
              treasuryTokens, treasuryTokens
            );
          });

          const dao = result.base;
          if (dao && dao.meta && dao.meta.name) {
            allDAOs = [dao];
            allDAOsLoaded = true;
            currentDAICO = result;  // Cache DAICO data to avoid re-fetch in renderSalesInfo
            await openDAO(0, 'all');
            return true;
          }
        } catch (error) {
          logger.error('Failed to fetch DAO by address:', error);
        }

        showStatus('DAO not found. It may not exist on this network.', true);
        return false;
      }

      // Open DAO dashboard
      async function openDAO(daoIndex, source = 'user') {
        // Clear cached DAICO data when opening from gallery (not via openDAOByAddress which pre-caches it)
        if (source === 'user') {
          currentDAICO = null;
        }

        // Get the DAO from the appropriate source
        if (source === 'all') {
          const dao = allDAOs[daoIndex];
          // Try to find membership data from userDAOs if available
          // Use userDAOs entry if found - it has more complete data (more messages/proposals)
          const userDaoEntry = userDAOs.find(ud => ud.dao.dao.toLowerCase() === dao.dao.toLowerCase());
          if (userDaoEntry) {
            currentDAO = userDaoEntry;
          } else {
            currentDAO = { dao: dao, member: null };
          }
        } else {
          currentDAO = userDAOs[daoIndex];
        }

        // Guard against null/undefined DAO data
        if (!currentDAO?.dao?.meta) {
          logger.error('Invalid DAO data at index:', daoIndex);
          showStatus('Failed to load DAO', true);
          return;
        }

        // Hide navigation buttons early (before rendering which might fail)
        // nav buttons handled by CSS

        // Journey line removed in light theme

        const dashboardTitle = DOMCache.dashboardTitle;
        if (dashboardTitle) {
          dashboardTitle.textContent = currentDAO.dao.meta.name;
        }

        // Update Etherscan link
        const daoAddress = currentDAO.dao.dao;
        const etherscanLink = DOMCache.daoEtherscanLink;
        const addressText = DOMCache.daoAddressText;
        etherscanLink.href = `${getNetwork().explorer}/address/${daoAddress}`;
        addressText.textContent = `${daoAddress.slice(0, 6)}...${daoAddress.slice(-4)}`;

        // Update URL hash for deep linking (allows sharing direct links to this DAO)
        history.replaceState(null, '', `#/dao/${getNetwork().chainId}/${daoAddress}`);

        // Fire-and-forget (no downstream dependencies)
        renderChatroom().catch(e => logger.error('renderChatroom failed:', e));
        renderDaoStats();

        // Batch all view calls into one RPC round-trip via Multicall3
        const userAddr = signer ? await signer.getAddress() : null;
        let batchData;
        try {
          batchData = await batchDashboardData(daoAddress, userAddr);
        } catch (e) {
          logger.warn('Multicall batch failed, falling back to individual calls:', e.message);
          batchData = { config: undefined, sales: [], allowances: [], tributes: undefined, sharesTransfersLocked: undefined, lootTransfersLocked: undefined, contractURI: undefined };
        }

        // Render with pre-fetched data (falls back to individual RPC if batch data missing)
        renderGovernanceInfo(batchData).catch(e => logger.error('renderGovernanceInfo failed:', e));
        await Promise.all([
          renderProposals(batchData.config),
          renderSalesInfo(batchData.sales),
          renderTributes(batchData.tributes),
          renderAllowances(batchData.allowances),
          renderDAOEmblem(daoAddress, batchData.contractURI)
        ]);

        // Sequential â€” depends on renderSalesInfo completing (needs customSaleTokens)
        await renderTreasury();

        // Show/hide membership tab based on membership status
        const membershipBtn = document.getElementById('viewToggleMembership');
        if (currentDAO.member) {
          membershipBtn.style.display = 'block';
        } else {
          membershipBtn.style.display = 'none';
          // Ensure we're on DAO view if no membership
          switchDaoView('dao');
        }

        hideHeroFire();
        DOMCache.daoGallery.classList.remove('show');
        DOMCache.allDaosGallery.classList.remove('show');
        DOMCache.daoDashboard.classList.add('show');

      }

      // Back to gallery
      function backToGallery() {
        currentDAO = null;
        currentDAICO = null;
        DOMCache.daoDashboard.classList.remove('show');
        DOMCache.daoGallery.classList.add('show');

        // Search section stays hidden until user explicitly opens it
        DOMCache.allDaosGallery.classList.remove('show');

        // Clear URL hash when returning to gallery
        if (window.location.hash) {
          history.pushState('', document.title, window.location.pathname + window.location.search);
        }

        // Reset to DAO view
        switchDaoView('dao');
      }

      // Switch between DAO dashboard, membership, and members view
      function switchDaoView(view) {
        const daoView = document.getElementById('daoDashboardView');
        const membershipView = document.getElementById('daoMembershipView');
        const membersView = document.getElementById('daoMembersView');
        const daoBtn = document.getElementById('viewToggleDao');
        const membershipBtn = document.getElementById('viewToggleMembership');
        const membersBtn = document.getElementById('viewToggleMembers');

        // Hide all views
        daoView.classList.remove('show');
        daoView.classList.add('hide');
        membershipView.classList.remove('show');
        membersView.classList.remove('show');

        // Deactivate all buttons
        daoBtn.classList.remove('active');
        membershipBtn.classList.remove('active');
        membersBtn.classList.remove('active');

        if (view === 'membership') {
          membershipView.classList.add('show');
          membershipBtn.classList.add('active');
          renderMembership();
        } else if (view === 'members') {
          membersView.classList.add('show');
          membersBtn.classList.add('active');
          renderMembers();
        } else {
          daoView.classList.remove('hide');
          daoView.classList.add('show');
          daoBtn.classList.add('active');
        }
      }

      // Render membership dashboard
      async function renderMembership() {
        if (!currentDAO || !currentDAO.member) {
          document.getElementById('badgeContent').innerHTML = '<p class="badge-empty">No membership data available</p>';
          return;
        }

        const member = currentDAO.member;
        const dao = currentDAO.dao;

        // Update balances
        const shares = ethers.formatUnits(member.shares, 18);
        const loot = ethers.formatUnits(member.loot, 18);
        document.getElementById('membershipShares').textContent = parseFloat(shares).toFixed(4);
        document.getElementById('membershipLoot').textContent = parseFloat(loot).toFixed(4);

        // Update Etherscan links for tokens
        if (dao.meta && dao.meta.sharesToken) {
          const sharesLink = document.getElementById('sharesEtherscanLink');
          sharesLink.href = `${getNetwork().explorer}/token/${dao.meta.sharesToken}`;
          sharesLink.classList.add('visible');
        }

        if (dao.meta && dao.meta.lootToken) {
          const lootLink = document.getElementById('lootEtherscanLink');
          lootLink.href = `${getNetwork().explorer}/token/${dao.meta.lootToken}`;
          lootLink.classList.add('visible');
        }

        if (dao.meta && dao.meta.badgesToken) {
          const badgeLink = document.getElementById('badgeEtherscanLink');
          badgeLink.href = `${getNetwork().explorer}/token/${dao.meta.badgesToken}`;
          badgeLink.classList.add('visible');
        }

        // Update badge info
        const badgeSeat = member.seatId;
        const badgePromise = badgeSeat > 0
          ? (document.getElementById('membershipBadge').textContent = `Seat #${badgeSeat}`, renderBadge(dao.dao, badgeSeat))
          : (document.getElementById('membershipBadge').textContent = 'No Badge',
             document.getElementById('badgeContent').innerHTML = '<p class="badge-empty">You don\'t have a badge seat yet</p>',
             Promise.resolve());

        // Render badge, vote receipts, and delegation in parallel (separate DOM targets)
        await Promise.all([badgePromise, renderVoteReceipts(), loadDelegationStatus()]);
      }

      // Render badge NFT
      async function renderBadge(daoAddress, seatId) {
        const badgeContent = document.getElementById('badgeContent');

        try {
          // Get badges contract address (predicted from DAO)
          const predictions = predictMajeurAddresses([], [], ethers.randomBytes(32));
          const badgesAddress = predictions.badges;

          // Use the correct badges contract from the DAO
          const molochContract = new ethers.Contract(daoAddress, MOLOCH_ABI, provider);
          const badgesAddr = await molochContract.badges();

          const badgesABI = [
            'function tokenURI(uint256) view returns (string)',
          ];
          const badgesContract = new ethers.Contract(badgesAddr, badgesABI, provider);

          const tokenURI = await badgesContract.tokenURI(seatId);

          // Parse metadata (could be data URI or IPFS)
          let metadata;
          if (tokenURI.startsWith('data:application/json;base64,')) {
            const json = atob(tokenURI.slice(29));
            metadata = JSON.parse(json);
          } else if (tokenURI.startsWith('data:application/json,')) {
            metadata = JSON.parse(decodeURIComponent(tokenURI.slice(22)));
          } else {
            // Fetch from URL
            const response = await fetch(tokenURI);
            metadata = await response.json();
          }

          // Render badge (convert IPFS URLs to gateway URLs)
          let imageHTML = '';
          if (metadata.image) {
            const imageUrl = toGatewayUrl(metadata.image);
            imageHTML = `<img src="${imageUrl}" class="badge-image" alt="Badge #${seatId}" />`;
          }

          // Render attributes inline
          let attributesHTML = '';
          if (metadata.attributes && Array.isArray(metadata.attributes) && metadata.attributes.length > 0) {
            attributesHTML = `<div class="badge-attributes">${metadata.attributes.map(attr => `<div class="badge-attribute"><span class="badge-attribute-label">${attr.trait_type || attr.type || 'Attribute'}</span><span class="badge-attribute-value">${attr.value}</span></div>`).join('')}</div>`;
          }

          // OpenSea link (network-aware)
          const openseaLink = getOpenSeaUrl(badgesAddr, seatId);
          const metaStr = JSON.stringify(metadata).replace(/"/g, '&quot;');

          badgeContent.innerHTML = `
            <div class="badge-image-link" onclick="openNFTModal(${metaStr}, 'Member Badge')">
              ${imageHTML}
            </div>
            <div class="badge-info">
              <div class="badge-name">${metadata.name || `Badge #${seatId}`}</div>
              ${metadata.description ? `<div class="badge-description">${escapeHtml(metadata.description)}</div>` : ''}
              ${attributesHTML}
              <div class="badge-links">
                <a href="${openseaLink}" target="_blank" rel="noopener noreferrer" class="badge-link">OpenSea â†—</a>
              </div>
            </div>
          `;
        } catch (error) {
          logger.error('Error rendering badge:', error);
          badgeContent.innerHTML = `
            <div class="badge-fallback">
              <div class="badge-fallback-icon">ðŸŽ–ï¸</div>
              <div class="badge-name">Seat #${seatId}</div>
              <div class="badge-empty">Badge metadata unavailable</div>
            </div>
          `;
        }
      }

      // Render vote receipts collection
      async function renderVoteReceipts() {
        const receiptsGrid = document.getElementById('receiptsGrid');
        if (!currentDAO || !connectedAddress) {
          receiptsGrid.innerHTML = '';
          receiptsGrid.appendChild(createEmptyState(
            'ðŸ”Œ',
            'WALLET NOT CONNECTED',
            'Connect your wallet to view your vote receipt collection',
            'Connect Wallet',
            connectWallet
          ));
          return;
        }

        // Show loading state
        showLoadingState(receiptsGrid, 3, 'card');

        const receipts = [];
        const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, provider);

        // Use voters data from view helper to find user's votes (no hasVoted RPC calls!)
        const userVotedProposals = currentDAO.dao.proposals.filter(proposal => {
          return proposal.voters?.some(v => v.voter?.toLowerCase() === connectedAddress.toLowerCase());
        });

        // Pre-compute receipt IDs and vote data
        const voteData = userVotedProposals.map(proposal => {
          const userVote = proposal.voters.find(v => v.voter?.toLowerCase() === connectedAddress.toLowerCase());
          const support = Number(userVote.support); // 0=Against, 1=For, 2=Abstain
          const receiptId = ethers.solidityPackedKeccak256(
            ['string', 'uint256', 'uint8'],
            ['Moloch:receipt', proposal.id, support]
          );
          return { proposal, support, receiptId };
        });

        // Batch all balanceOf calls into a single Multicall3 RPC
        if (voteData.length > 0) {
          try {
            const molochIface = new ethers.Interface(MOLOCH_ABI);
            const calls = voteData.map(({ receiptId }) => ({
              target: currentDAO.dao.dao,
              allowFailure: true,
              callData: molochIface.encodeFunctionData('balanceOf', [connectedAddress, receiptId])
            }));

            const mcResults = await withRpcFallback(async (activeProvider) => {
              const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, activeProvider);
              return await multicall.aggregate3(calls);
            });

            for (let i = 0; i < mcResults.length; i++) {
              const { success, returnData } = mcResults[i];
              const { proposal, support, receiptId } = voteData[i];

              if (!success) continue;

              try {
                const decoded = molochIface.decodeFunctionResult('balanceOf', returnData);
                const balance = decoded[0];
                const hasBalance = balance > 0n;
                const isWinningFutarchyVote = proposal.futarchy?.enabled
                  && proposal.futarchy.resolved
                  && Number(proposal.futarchy.winner) === support;

                if (hasBalance || isWinningFutarchyVote) {
                  receipts.push({
                    proposalId: proposal.id,
                    support,
                    balance,
                    receiptId,
                    claimed: !hasBalance && isWinningFutarchyVote
                  });
                }
              } catch (err) {
                logger.error('Error decoding receipt balance:', err);
              }
            }
          } catch (err) {
            logger.error('Error in multicall balance check:', err);
          }
        }

        if (receipts.length === 0) {
          receiptsGrid.innerHTML = '';
          receiptsGrid.appendChild(createEmptyState(
            'ðŸŽ«',
            'NO VOTE RECEIPTS YET',
            'Vote on proposals to start collecting unique receipt NFTs that track your participation',
            'View Proposals',
            () => switchDaoView('dao')
          ));
          return;
        }

        // Render receipt cards with metadata
        receiptsGrid.innerHTML = '';
        showLoadingState(receiptsGrid, receipts.length, 'card');

        const supportLabels = ['Against', 'For', 'Abstain'];
        const supportColors = ['#e74c3c', '#2d8a2d', '#000'];

        // Fetch metadata for all receipts
        const receiptPromises = receipts.map(async receipt => {
          try {
            const tokenURI = await molochContract.tokenURI(receipt.receiptId);

            // Parse metadata (could be data URI or IPFS)
            let metadata;
            if (tokenURI.startsWith('data:application/json;base64,')) {
              const json = atob(tokenURI.slice(29));
              metadata = JSON.parse(json);
            } else if (tokenURI.startsWith('data:application/json,')) {
              metadata = JSON.parse(decodeURIComponent(tokenURI.slice(22)));
            } else {
              // Fetch from URL
              const response = await fetch(tokenURI);
              metadata = await response.json();
            }

            return { ...receipt, metadata };
          } catch (error) {
            logger.error('Error fetching receipt metadata:', error);
            return { ...receipt, metadata: null };
          }
        });

        const receiptsWithMetadata = await Promise.all(receiptPromises);

        receiptsGrid.innerHTML = '';

        receiptsWithMetadata.forEach((receipt, index) => {
          try {
            const card = document.createElement('div');
            card.className = 'receipt-card card-appear';
            card.style.animationDelay = `${index * 0.05}s`;

            const balanceFormatted = ethers.formatUnits(receipt.balance, 18);
            const supportLabel = supportLabels[receipt.support];
            const supportColor = supportColors[receipt.support];

            let imageHTML = '';
            let nameHTML = '';

            if (receipt.metadata) {
              if (receipt.metadata.image) {
                const imageUrl = toGatewayUrl(receipt.metadata.image);
                imageHTML = `<img src="${imageUrl}" class="receipt-image" alt="Receipt" />`;
              }
              if (receipt.metadata.name) {
                nameHTML = `<div class="receipt-name">${receipt.metadata.name}</div>`;
              }
            }

            // Check for futarchy claim eligibility
            let claimButtonHTML = '';
            const proposal = currentDAO.dao.proposals.find(p => p.id.toString() === receipt.proposalId.toString());

            if (proposal?.futarchy?.enabled && proposal.futarchy.resolved) {
              const winnerSupport = Number(proposal.futarchy.winner);
              const userSupport = Number(receipt.support);

              if (userSupport === winnerSupport) {
                if (receipt.claimed || receipt.balance === 0n) {
                  // Already claimed - show claimed status
                  claimButtonHTML = `
                    <div style="width: 100%; margin-top: 0.75rem; padding: 0.6rem; background: var(--status-success); border: 1px solid var(--border-muted); color: var(--green); font-size: 0.65rem; letter-spacing: 0.1em; text-transform: uppercase; text-align: center; ">
                      âœ“ Rewards Claimed
                    </div>
                  `;
                } else {
                  // Has unclaimed rewards
                  claimButtonHTML = `
                    <button onclick="event.stopPropagation(); claimFutarchyReward('${receipt.proposalId.toString()}', '${receipt.balance.toString()}');"
                            style="width: 100%; margin-top: 0.75rem; padding: 0.6rem; background: #000; border: none; color: #fff; font-size: 0.65rem; letter-spacing: 0.1em; cursor: pointer; text-transform: uppercase; font-weight: 600; transition: all 0.2s ease;">
                      Claim Rewards
                    </button>
                  `;
                }
              }
            }

            // Handle display for claimed vs unclaimed receipts
            const amountDisplay = receipt.claimed || receipt.balance === 0n
              ? '<div class="receipt-amount" style="opacity: 0.6;">Receipt Claimed</div>'
              : `<div class="receipt-amount">${parseFloat(balanceFormatted).toFixed(4)} receipts</div>`;

            // Convert receipt ID from hex to decimal for display
            const receiptIdDecimal = BigInt(receipt.receiptId).toString();
            const receiptIdTruncated = receiptIdDecimal.length > 18
              ? `${receiptIdDecimal.slice(0, 10)}...${receiptIdDecimal.slice(-8)}`
              : receiptIdDecimal;

            // Add transfer button if user has balance
            const transferButtonHTML = receipt.balance > 0n
              ? `
                <button class="transfer-receipt-btn" data-receipt-index="${index}"
                        style="width: 100%; margin-top: 0.5rem; padding: 0.6rem; background: #f9f9f9; border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.65rem; letter-spacing: 0.1em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease;"
                        onmouseover="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'"
                        onmouseout="this.style.background='var(--surface-hover)'; this.style.borderColor='var(--border-muted)'">
                  Transfer Receipt
                </button>
              `
              : '';

            card.innerHTML = `
              ${imageHTML}
              ${nameHTML}
              <div class="receipt-proposal">Proposal #${receipt.proposalId.toString().slice(0, 8)}...</div>
              <div class="receipt-vote" style="color: ${supportColor};">Voted ${supportLabel}</div>
              ${amountDisplay}
              <div style="font-size: 0.65rem; opacity: 0.5; margin-top: 0.5rem; font-family: monospace;" title="Receipt ID (uint256): ${receiptIdDecimal}">ID: ${receiptIdTruncated}</div>
              ${claimButtonHTML}
              ${transferButtonHTML}
            `;

            // Add event listener for transfer button
            if (receipt.balance > 0n) {
              const transferBtn = card.querySelector('.transfer-receipt-btn');
              if (transferBtn) {
                transferBtn.onclick = (e) => {
                  e.stopPropagation();
                  openTransferReceiptModal(receipt);
                };
              }
            }

            // Make card clickable to open modal with receipt data
            card.onclick = (e) => {
              // Don't open modal if clicking the claim button
              if (e.target.tagName === 'BUTTON') return;
              openNFTModal(receipt.metadata, 'Vote Receipt', receipt);
            };

            receiptsGrid.appendChild(card);
          } catch (renderError) {
            logger.error('Error rendering receipt:', renderError);
          }
        });

        // Check for emergency permits
        try {
          const bumpConfigCalldata = INTERFACES.bumpConfig.encodeFunctionData('bumpConfig', []);
          const emergencyNonce = ethers.id("EMERGENCY_CONFIG_BUMP");
          const config = await molochContract.config();
          const permitId = computeProposalId(currentDAO.dao.dao, 0, currentDAO.dao.dao, 0, bumpConfigCalldata, emergencyNonce, config);

          const permitBalance = await molochContract.balanceOf(connectedAddress, permitId);

          if (permitBalance > 0n) {
            // Fetch tokenURI for emergency permit
            let permitMetadata = null;
            try {
              const tokenURI = await molochContract.tokenURI(permitId);

              // Parse metadata (could be data URI or IPFS)
              if (tokenURI.startsWith('data:application/json;base64,')) {
                const json = atob(tokenURI.slice(29));
                permitMetadata = JSON.parse(json);
              } else if (tokenURI.startsWith('data:application/json,')) {
                permitMetadata = JSON.parse(decodeURIComponent(tokenURI.slice(22)));
              } else {
                // Fetch from URL
                const response = await fetch(tokenURI);
                permitMetadata = await response.json();
              }
            } catch (tokenURIError) {
              logger.error('Error fetching emergency permit tokenURI:', tokenURIError);
              // Continue with fallback UI
            }

            // Create emergency permit card
            const permitCard = document.createElement('div');
            permitCard.className = 'receipt-card';
            permitCard.style.cssText = 'background: #fff5f5; border: 1px solid #e8c0c0; cursor: pointer; transition: all 0.2s ease;';

            const usesText = Number(permitBalance) === 1 ? '1 use' : `${Number(permitBalance)} uses`;

            // Build image HTML from metadata if available (convert IPFS URLs to gateway URLs)
            let imageHTML = '';
            if (permitMetadata?.image) {
              const imageUrl = toGatewayUrl(permitMetadata.image);
              imageHTML = `<img src="${imageUrl}" class="receipt-image" alt="Emergency Permit" />`;
            }

            permitCard.innerHTML = `
              ${imageHTML}
              <div style="padding: ${imageHTML ? '0 1rem 1rem 1rem' : '1rem'};">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                  <div style="font-size: 0.75rem; color: #c0392b; letter-spacing: 0.1em;">
                    EMERGENCY PERMIT
                  </div>
                  <div style="background: #fff0f0; padding: 0.25rem 0.5rem; font-size: 0.7rem; color: #e74c3c; font-weight: 600;">
                    ${usesText}
                  </div>
                </div>
                <div style="font-size: 0.85rem; color: #000; margin-bottom: 0.5rem; font-weight: 600;">
                  ${permitMetadata?.name || 'Config Bump Authority'}
                </div>
                <div style="font-size: 0.75rem; color: var(--fg); line-height: 1.4;">
                  ${permitMetadata?.description || 'Emergency power to reset governance state by incrementing config counter. Invalidates all pending proposals and permits.'}
                </div>
                <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid #f5d5d5;">
                  <div style="font-size: 0.7rem; color: var(--fg-dim); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.35rem;">
                    Permit ID
                  </div>
                  <div style="font-family: 'Courier New', monospace; font-size: 0.65rem; color: var(--fg-dim); word-break: break-all;">
                    ${permitId.toString().slice(0, 20)}...${permitId.toString().slice(-20)}
                  </div>
                </div>
                <button
                  onclick="event.stopPropagation(); useEmergencyPermit('${permitId.toString()}');"
                  style="width: 100%; margin-top: 0.75rem; padding: 0.6rem; background: #fff0f0; border: 1px solid var(--red); color: var(--red); font-size: 0.7rem; letter-spacing: 0.1em; cursor: pointer; transition: all 0.2s ease; text-transform: uppercase; font-weight: 600;"
                  onmouseover="this.style.background='#f5d5d5'; this.style.borderColor='#e74c3c';"
                  onmouseout="this.style.background='#fff0f0'; this.style.borderColor='#e8c0c0';"
                >
                  Execute Permit
                </button>
              </div>
            `;

            permitCard.onmouseover = function() {
              this.style.transform = 'translateY(-2px)';
              this.style.boxShadow = '0 4px 12px #f5d5d5';
            };

            permitCard.onmouseout = function() {
              this.style.transform = 'translateY(0)';
              this.style.boxShadow = 'none';
            };

            permitCard.onclick = function() {
              showEmergencyPermitModal(permitId, Number(permitBalance), permitMetadata);
            };

            receiptsGrid.appendChild(permitCard);
          }
        } catch (permitError) {
          logger.error('Error checking emergency permit:', permitError);
        }
      }

      // Show emergency permit modal with use option
      function showEmergencyPermitModal(permitId, balance, metadata = null) {
        const modal = getEl('nftModal');
        const modalContent = document.getElementById('nftModalBody');

        const usesText = balance === 1 ? '1 use remaining' : `${balance} uses remaining`;

        // Build image HTML if metadata available (convert IPFS URLs to gateway URLs)
        let imageHTML = '';
        if (metadata?.image) {
          const imageUrl = toGatewayUrl(metadata.image);
          imageHTML = `
            <div style="text-align: center; margin-bottom: 1.5rem;">
              <img src="${imageUrl}" alt="Emergency Permit" style="max-width: 100%; max-height: 400px; border: 1px solid #f5d5d5;" />
            </div>
          `;
        }

        modalContent.innerHTML = `
          <div style="max-width: 500px; margin: 0 auto;">
            ${imageHTML}
            <div style="text-align: center; margin-bottom: 1.5rem;">
              <div style="font-size: 1.5rem; color: #c0392b; letter-spacing: 0.1em; margin-bottom: 0.5rem;">
                ${metadata?.name || 'EMERGENCY PERMIT'}
              </div>
              <div style="font-size: 1rem; color: #000; margin-bottom: 0.5rem;">
                ${metadata?.description || 'Config Bump Authority'}
              </div>
              <div style="background: #fff0f0; display: inline-block; padding: 0.5rem 1rem; font-size: 0.9rem; color: #e74c3c; font-weight: 600;">
                ${usesText}
              </div>
            </div>

            <div style="background: #fff0f0; border: 1px solid #f5d5d5; padding: 1rem; margin-bottom: 1.5rem;">
              <div style="font-size: 0.85rem; color: var(--fg); line-height: 1.6;">
                <strong style="color: #c0392b;">âš ï¸ Emergency Power:</strong><br><br>
                This permit grants you the authority to execute <code>bumpConfig()</code>, which increments the DAO's config counter.<br><br>
                <strong>Effect:</strong> Invalidates ALL pending proposals and ALL existing permits (including this one after use).<br><br>
                <strong>Use case:</strong> Emergency governance reset when proposals or permits are compromised.
              </div>
            </div>

            <div style="background: transparent; padding: 1rem; margin-bottom: 1.5rem;">
              <div style="font-size: 0.75rem; color: var(--fg-dim); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem;">
                Permit ID
              </div>
              <div style="font-family: 'Courier New', monospace; font-size: 0.75rem; color: var(--fg); word-break: break-all;">
                ${permitId.toString()}
              </div>
            </div>

            <button onclick="useEmergencyPermit('${permitId.toString()}')"
                    onmouseover="this.style.background='#e8c0c0'; this.style.borderColor='#e74c3c';"
                    onmouseout="this.style.background='#fff0f0'; this.style.borderColor='#e8c0c0';"
                    style="width: 100%; padding: 1rem; background: #fff0f0; border: 1px solid #e8c0c0; color: #000; font-size: 0.85rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; transition: all 0.2s ease; font-weight: 600; ">
              ðŸš¨ USE EMERGENCY PERMIT
            </button>

            <div style="text-align: center; margin-top: 1rem;">
              <button onclick="closeNFTModal()"
                      style="background: none; border: none; color: var(--fg-dim); cursor: pointer; font-size: 0.85rem; text-decoration: underline;">
                Close
              </button>
            </div>
          </div>
        `;

        modal.classList.add('active');
      }

      // Use emergency permit to bump config
      async function useEmergencyPermit(permitIdStr) {
        if (!signer) {
          showStatus('Please connect your wallet first', true);
          return;
        }

        try {
          const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, signer);
          const userAddress = await signer.getAddress();

          // Recalculate the permit parameters and ID to ensure consistency
          const bumpConfigCalldata = INTERFACES.bumpConfig.encodeFunctionData('bumpConfig', []);
          const emergencyNonce = ethers.id("EMERGENCY_CONFIG_BUMP");
          const config = await molochContract.config();
          const permitId = computeProposalId(currentDAO.dao.dao, 0, currentDAO.dao.dao, 0, bumpConfigCalldata, emergencyNonce, config);

          // Check if user holds the permit before attempting to spend
          const permitBalance = await molochContract.balanceOf(userAddress, permitId);

          if (permitBalance === 0n || permitBalance === 0) {
            showStatus('You do not hold this emergency permit. Cannot execute.', true);
            return;
          }

          const confirmed = confirm(
            'âš ï¸ EMERGENCY ACTION CONFIRMATION\n\n' +
            'You are about to execute bumpConfig(), which will:\n\n' +
            'â€¢ Invalidate ALL pending proposals\n' +
            'â€¢ Invalidate ALL existing permits\n' +
            'â€¢ Reset the governance state\n\n' +
            'This action is IRREVERSIBLE.\n\n' +
            `You have ${permitBalance} permit(s) remaining.\n\n` +
            'Are you absolutely sure you want to proceed?'
          );

          if (!confirmed) return;

          showStatus('Executing emergency permit...', false);

          const tx = await molochContract.spendPermit(
            0, // op = call
            currentDAO.dao.dao, // to = self
            0, // value = 0
            bumpConfigCalldata, // data = bumpConfig()
            emergencyNonce, // nonce
            getWalletConnectTxOverrides()
          );

          showStatus('Transaction submitted. Waiting for confirmation...', false);
          await tx.wait();

          showStatus('ðŸš¨ Emergency config bump executed! Governance state reset.', false);
          closeNFTModal();

          // Refresh DAO data
          await refreshCurrentDAO(true);

        } catch (error) {
          logger.error('Error using emergency permit:', error);
          showStatus('Failed to execute emergency permit: ' + error.message, true);
        }
      }

      // ==================== DELEGATION FUNCTIONS ====================

      // ABI for Shares contract delegation functions
      const SHARES_DELEGATION_ABI = [
        'function splitDelegationOf(address) view returns (address[], uint32[])',
        'function delegates(address) view returns (address)',
        'function delegate(address)',
        'function setSplitDelegation(address[], uint32[])',
        'function clearSplitDelegation()',
        'function getVotes(address) view returns (uint256)',
        'function balanceOf(address) view returns (uint256)'
      ];

      // Load and display current delegation status
      async function loadDelegationStatus() {
        const statusDisplay = document.getElementById('currentDelegationDisplay');
        const ownedSharesDisplay = document.getElementById('ownedSharesDisplay');
        const totalVotesDisplay = document.getElementById('totalVotesDisplay');
        const votingPowerBreakdown = document.getElementById('votingPowerBreakdown');

        if (!currentDAO || !connectedAddress) {
          statusDisplay.innerHTML = '<span class="delegation-muted">Not connected</span>';
          ownedSharesDisplay.textContent = '0';
          totalVotesDisplay.textContent = '0';
          return;
        }

        try {
          const dao = currentDAO.dao;
          const sharesAddress = dao.meta?.sharesToken;
          const badgesAddress = dao.meta?.badgesToken;

          if (!sharesAddress) {
            statusDisplay.innerHTML = '<span class="delegation-muted">Shares contract not found</span>';
            return;
          }

          const sharesContract = new ethers.Contract(sharesAddress, SHARES_DELEGATION_ABI, provider);

          // Load voting power data
          const [ownedShares, totalVotes, [delegates, bps]] = await Promise.all([
            sharesContract.balanceOf(connectedAddress),
            sharesContract.getVotes(connectedAddress),
            sharesContract.splitDelegationOf(connectedAddress)
          ]);

          // Display voting power
          const ownedFormatted = parseFloat(ethers.formatUnits(ownedShares, 18)).toFixed(2);
          const votesFormatted = parseFloat(ethers.formatUnits(totalVotes, 18)).toFixed(2);

          ownedSharesDisplay.textContent = ownedFormatted;
          totalVotesDisplay.textContent = votesFormatted;

          // Highlight if receiving delegations
          const receivedVotes = totalVotes - ownedShares;
          if (receivedVotes > 0n) {
            totalVotesDisplay.classList.add('has-delegation');
            const receivedFormatted = parseFloat(ethers.formatUnits(receivedVotes, 18)).toFixed(2);
            votingPowerBreakdown.innerHTML = `${ownedFormatted} owned + <strong class="delegation-received">${receivedFormatted} delegated</strong>`;
          } else {
            totalVotesDisplay.classList.remove('has-delegation');
            votingPowerBreakdown.textContent = 'Same as owned shares';
          }

          // Resolve ENS names for all delegates in parallel
          const delegateInfoPromises = delegates.map(async (addr) => {
            const isSelf = addr.toLowerCase() === connectedAddress.toLowerCase();
            const ensName = isSelf ? null : await lookupENS(addr);
            return { address: addr, ensName, isSelf };
          });
          const delegateInfos = await Promise.all(delegateInfoPromises);

          // Display delegation status
          if (delegates.length === 1 && bps[0] === 10000) {
            // Single delegate (100%)
            const info = delegateInfos[0];
            let displayText, displayClass, titleAttr;

            if (info.isSelf) {
              displayText = 'Self';
              displayClass = 'delegation-delegate';
              titleAttr = '';
            } else if (info.ensName) {
              displayText = info.ensName;
              displayClass = 'delegation-delegate ens-name';
              titleAttr = `title="${info.address}"`;
            } else {
              displayText = formatAddress(info.address);
              displayClass = 'delegation-delegate';
              titleAttr = `title="${info.address}"`;
            }

            statusDisplay.innerHTML = `<strong class="${displayClass}" ${titleAttr}>${displayText}</strong> (100%)`;
          } else {
            // Split delegation
            let html = '<div class="delegation-split-list">';
            for (let i = 0; i < delegates.length; i++) {
              const info = delegateInfos[i];
              const percentage = (Number(bps[i]) / 100).toFixed(2);

              let displayText, displayClass;
              if (info.isSelf) {
                displayText = 'Self';
                displayClass = 'delegation-split-address';
              } else if (info.ensName) {
                displayText = info.ensName;
                displayClass = 'delegation-split-address ens-name';
              } else {
                displayText = formatAddress(info.address);
                displayClass = 'delegation-split-address';
              }

              html += `
                <div class="delegation-split-item">
                  <span class="${displayClass}" title="${info.address}">${displayText}</span>
                  <span class="delegation-split-weight">${percentage}%</span>
                </div>
              `;
            }
            html += '</div>';
            statusDisplay.innerHTML = html;
          }

          // Load received delegations (only for badge holders to keep it efficient)
          await loadReceivedDelegations(sharesContract, badgesAddress);

        } catch (error) {
          logger.warn('Delegation not available:', error.message);
          statusDisplay.innerHTML = '<span class="delegation-muted">Self (default)</span>';
        }
      }

      // Load and display delegations received from others
      async function loadReceivedDelegations(sharesContract, badgesAddress) {
        if (!currentDAO || !connectedAddress) return;

        const receivedContainer = document.getElementById('receivedDelegationsContainer');
        const receivedList = document.getElementById('receivedDelegationsList');

        if (!receivedContainer || !receivedList) return;

        try {
          // Only check badge holders (top 256 members) for efficiency
          const members = currentDAO.dao?.members || [];
          const badgeHolders = members.filter(m => m && m[3] && m[3] > 0); // m[3] = seatId

          if (badgeHolders.length === 0) {
            receivedContainer.classList.remove('visible');
            return;
          }

          const delegatorsToMe = [];
          const connectedLower = connectedAddress.toLowerCase();

          // Batch check delegations - limit concurrency to avoid overwhelming RPC
          const BATCH_SIZE = 10;
          for (let i = 0; i < badgeHolders.length; i += BATCH_SIZE) {
            const batch = badgeHolders.slice(i, i + BATCH_SIZE);

            await Promise.all(batch.map(async (member) => {
              const memberAddress = member[0];
              if (!memberAddress || memberAddress.toLowerCase() === connectedLower) return;

              try {
                // Fetch delegation and balance in parallel for this member
                const [[delegateAddrs, weights], memberBalance] = await Promise.all([
                  sharesContract.splitDelegationOf(memberAddress),
                  sharesContract.balanceOf(memberAddress)
                ]);

                // Check if any delegation points to me
                for (let i = 0; i < delegateAddrs.length; i++) {
                  if (delegateAddrs[i].toLowerCase() === connectedLower) {
                    const delegatedAmount = (memberBalance * BigInt(weights[i])) / 10000n;
                    if (delegatedAmount > 0n) {
                      delegatorsToMe.push({
                        address: memberAddress,
                        amount: delegatedAmount,
                        percentage: Number(weights[i]) / 100, // Convert BPS to percentage
                        seatId: member[3]
                      });
                    }
                    break;
                  }
                }
              } catch (err) {
                // Silently skip members that error (could be rate limits or contract issues)
                logger.warn(`Skipping delegation check for ${memberAddress}:`, err.message);
              }
            }));
          }

          // Display received delegations
          if (delegatorsToMe.length > 0) {
            receivedContainer.classList.add('visible');
            receivedList.innerHTML = '';

            // Resolve ENS names in parallel
            const delegatorsWithENS = await Promise.all(
              delegatorsToMe.map(async (delegator) => ({
                ...delegator,
                ensName: await lookupENS(delegator.address)
              }))
            );

            // Sort by amount descending
            delegatorsWithENS.sort((a, b) => Number(b.amount - a.amount));

            delegatorsWithENS.forEach(delegator => {
              const displayName = delegator.ensName || formatAddress(delegator.address);
              const amountFormatted = parseFloat(ethers.formatUnits(delegator.amount, 18)).toFixed(2);

              const item = document.createElement('div');
              item.className = 'received-delegation-item';
              item.innerHTML = `
                <div class="delegator-info">
                  <div class="delegator-badge" title="Badge Seat #${delegator.seatId}">
                    ${delegator.seatId}
                  </div>
                  <span class="delegator-address ${delegator.ensName ? 'ens-name' : ''}" title="${delegator.address}">
                    ${displayName}
                  </span>
                </div>
                <span class="delegated-amount" title="${delegator.percentage.toFixed(2)}% of their voting power">
                  ${amountFormatted} votes
                </span>
              `;
              receivedList.appendChild(item);
            });
          } else {
            receivedContainer.classList.remove('visible');
          }
        } catch (error) {
          logger.error('Error loading received delegations:', error);
          receivedContainer.classList.remove('visible');
        }
      }

      // Toggle delegation form visibility
      function toggleDelegationForm() {
        const form = document.getElementById('delegationForm');
        const actions = document.getElementById('delegationActions');

        if (!form || !actions) {
          logger.error('Delegation form elements not found');
          return;
        }

        if (!form.classList.contains('visible')) {
          form.classList.add('visible');
          actions.classList.add('hidden');

          // Initialize event listeners
          initializeDelegationTypeSelectors();

          // Initialize with default single delegate
          const singleRadio = document.querySelector('input[name="delegationType"][value="single"]');
          if (singleRadio) singleRadio.checked = true;

          // Update visual selection state for cards
          const typeOptions = document.querySelectorAll('.delegation-type-option');
          typeOptions.forEach(option => {
            if (option.getAttribute('data-type') === 'single') {
              option.classList.add('selected');
            } else {
              option.classList.remove('selected');
            }
          });

          updateDelegationTypeUI();
          initializeDelegateInputs();
        } else {
          form.classList.remove('visible');
          actions.classList.remove('hidden');
        }
      }

      // Initialize delegation type selectors (called when form opens)
      function initializeDelegationTypeSelectors() {
        const typeRadios = document.querySelectorAll('input[name="delegationType"]');
        const typeOptions = document.querySelectorAll('.delegation-type-option');

        // Remove any existing listeners to prevent duplicates
        typeRadios.forEach(radio => {
          radio.removeEventListener('change', updateDelegationTypeUI);
          radio.addEventListener('change', updateDelegationTypeUI);
        });

        // Add click handlers to delegation type option cards
        typeOptions.forEach(option => {
          option.onclick = function() {
            // Remove selected class from all options
            typeOptions.forEach(opt => opt.classList.remove('selected'));
            // Add selected class to clicked option
            this.classList.add('selected');
            // Trigger the radio button
            const radio = this.querySelector('input[type="radio"]');
            if (radio) {
              radio.checked = true;
              updateDelegationTypeUI();
            }
          };
        });
      }

      function updateDelegationTypeUI() {
        const type = document.querySelector('input[name="delegationType"]:checked')?.value;
        const singleSection = document.getElementById('singleDelegateSection');
        const splitSection = document.getElementById('splitDelegateSection');

        // Update visual selection state
        const typeOptions = document.querySelectorAll('.delegation-type-option');
        typeOptions.forEach(option => {
          const optionType = option.getAttribute('data-type');
          if (optionType === type) {
            option.classList.add('selected');
          } else {
            option.classList.remove('selected');
          }
        });

        // Show/hide appropriate sections
        if (type === 'single') {
          singleSection.classList.remove('delegation-section-hidden');
          splitSection.classList.add('delegation-section-hidden');
        } else {
          singleSection.classList.add('delegation-section-hidden');
          splitSection.classList.remove('delegation-section-hidden');
        }
      }

      // Initialize delegate inputs for split delegation
      function initializeDelegateInputs() {
        const container = document.getElementById('delegateInputs');
        container.innerHTML = '';
        addDelegateInput(); // Start with one input
        updateDelegationTotal(); // Initialize the total display
      }

      // Add a delegate input row
      let delegateInputCounter = 0;
      function addDelegateInput() {
        const container = document.getElementById('delegateInputs');
        const currentCount = container.children.length;

        if (currentCount >= 4) {
          alert('Maximum 4 delegates allowed');
          return;
        }

        const inputId = `delegate-${delegateInputCounter++}`;
        const row = document.createElement('div');
        row.className = 'delegate-input-row';
        row.innerHTML = `
          <div class="delegate-input-group delegate-address-input">
            <label class="delegate-input-label">Delegate Address or ENS</label>
            <input
              type="text"
              class="modal-input delegate-address"
              placeholder="0x... or vitalik.eth"
              data-input-id="${inputId}"
            />
          </div>
          <div class="delegate-input-group delegate-weight-input">
            <label class="delegate-input-label">Weight (%)</label>
            <input
              type="number"
              class="modal-input delegate-weight"
              placeholder="25.00"
              min="0.01"
              max="100"
              step="0.01"
              data-input-id="${inputId}"
              oninput="updateDelegationTotal()"
            />
          </div>
          ${currentCount > 0 ? '<button class="remove-delegate-btn" onclick="removeDelegateInput(this)">âœ•</button>' : ''}
        `;

        container.appendChild(row);
        updateAddDelegateButton();
        updateDelegationTotal();
      }

      // Remove a delegate input row
      function removeDelegateInput(button) {
        const row = button.closest('.delegate-input-row');
        row.remove();
        updateAddDelegateButton();
        updateDelegationTotal();
      }

      // Update delegation total percentage display
      function updateDelegationTotal() {
        const weightInputs = document.querySelectorAll('.delegate-weight');
        let total = 0;

        // Validate and cap individual inputs
        weightInputs.forEach(input => {
          let value = parseFloat(input.value) || 0;

          // Cap individual values at 100%
          if (value > 100) {
            value = 100;
            input.value = '100';
          }

          // Ensure non-negative
          if (value < 0) {
            value = 0;
            input.value = '0';
          }

          total += value;
        });

        const totalDisplay = document.getElementById('totalDelegatedPercent');
        const selfDisplay = document.getElementById('selfDelegatedPercent');
        const warningDisplay = document.getElementById('delegationWarning');

        if (totalDisplay) {
          totalDisplay.textContent = total.toFixed(2) + '%';

          // Color code based on validity
          totalDisplay.classList.remove('over', 'exact');
          if (total > 100) {
            totalDisplay.classList.add('over');
          } else if (total === 100) {
            totalDisplay.classList.add('exact');
          }
        }

        // Show/hide warning if over 100%
        if (warningDisplay) {
          warningDisplay.classList.toggle('visible', total > 100);
        }

        if (selfDisplay) {
          const remaining = Math.max(0, 100 - total);
          selfDisplay.textContent = remaining.toFixed(2) + '%';

          // Show/hide self delegation info based on whether there's a remainder
          const selfInfo = document.getElementById('selfDelegationInfo');
          if (selfInfo) {
            selfInfo.classList.toggle('visible', remaining > 0 && total <= 100);
          }
        }
      }

      // Update add delegate button state
      function updateAddDelegateButton() {
        const container = document.getElementById('delegateInputs');
        const button = document.getElementById('addDelegateBtn');

        if (!container || !button) return;

        const currentCount = container.children.length;

        if (currentCount >= 4) {
          button.disabled = true;
          button.style.opacity = '0.4';
        } else {
          button.disabled = false;
          button.style.opacity = '1';
        }
      }

      // Submit delegation
      async function submitDelegation() {
        if (!currentDAO || !connectedAddress) {
          showStatus('Please connect your wallet first', true);
          return;
        }

        const type = document.querySelector('input[name="delegationType"]:checked')?.value;

        try {
          const dao = currentDAO.dao;
          const sharesAddress = dao.meta?.sharesToken;

          if (!sharesAddress) {
            showStatus('Shares contract not found', true);
            return;
          }

          const signer = await provider.getSigner();
          const sharesContract = new ethers.Contract(sharesAddress, SHARES_DELEGATION_ABI, signer);

          if (type === 'single') {
            // Single delegation
            let addressInput = document.getElementById('singleDelegateAddress')?.value.trim() || '';

            if (!addressInput) {
              // Empty means self-delegate
              addressInput = connectedAddress;
            }

            // Resolve ENS if needed
            let address;
            if (addressInput.endsWith('.eth')) {
              showStatus('Resolving ENS name...', false);
              address = await provider.resolveName(addressInput);
              if (!address) {
                showStatus(`Could not resolve ENS name: ${addressInput}`, true);
                return;
              }
            } else {
              address = addressInput;
            }

            if (!ethers.isAddress(address)) {
              showStatus('Invalid Ethereum address', true);
              return;
            }

            // Call delegate function
            showStatus('Submitting delegation transaction...', false);
            const tx = await sharesContract.delegate(address, getWalletConnectTxOverrides());
            showStatus('Transaction submitted! Waiting for confirmation...', false);
            await tx.wait();
            showStatus('Delegation updated successfully!', false);

          } else {
            // Split delegation
            const rows = document.querySelectorAll('.delegate-input-row');
            if (rows.length === 0) {
              showStatus('Please add at least one delegate', true);
              return;
            }

            const addressInputs = [];
            const weightInputs = [];

            // Collect inputs first
            for (const row of rows) {
              const addrInput = row.querySelector('.delegate-address')?.value.trim();
              const weightInput = row.querySelector('.delegate-weight')?.value;

              if (!addrInput || !weightInput) {
                showStatus('Please fill in all delegate addresses and weights', true);
                return;
              }

              const weight = parseFloat(weightInput);
              if (isNaN(weight) || weight <= 0 || weight > 100) {
                showStatus('Invalid weight value. Must be between 0.01 and 100', true);
                return;
              }

              addressInputs.push(addrInput);
              weightInputs.push(weight);
            }

            // Resolve all ENS names in parallel
            showStatus('Resolving addresses...', false);
            const addresses = await Promise.all(
              addressInputs.map(async (addrInput) => {
                if (addrInput.endsWith('.eth')) {
                  const resolved = await provider.resolveName(addrInput);
                  if (!resolved) {
                    throw new Error(`Could not resolve ENS name: ${addrInput}`);
                  }
                  return resolved;
                } else {
                  if (!ethers.isAddress(addrInput)) {
                    throw new Error(`Invalid address: ${addrInput}`);
                  }
                  return addrInput;
                }
              })
            );

            // Validate total weight
            const totalWeight = weightInputs.reduce((sum, w) => sum + w, 0);

            if (totalWeight > 100) {
              showStatus(`Total weight cannot exceed 100% (currently ${totalWeight.toFixed(2)}%)`, true);
              return;
            }

            // If total is less than 100%, add self-delegation for the remainder
            let finalAddresses = [...addresses];
            let finalWeights = [...weightInputs];

            if (totalWeight < 100) {
              const remaining = 100 - totalWeight;

              // Confirm with user about auto-adding self delegation
              const confirmSelf = confirm(
                `Your delegation totals ${totalWeight.toFixed(2)}%.\n\n` +
                `The remaining ${remaining.toFixed(2)}% will be automatically delegated to yourself.\n\n` +
                `Continue?`
              );

              if (!confirmSelf) {
                return;
              }

              // Add user's own address with remaining percentage
              finalAddresses.push(connectedAddress);
              finalWeights.push(remaining);

              showStatus(`Auto-adding ${remaining.toFixed(2)}% self-delegation...`, false);
            }

            // Convert percentages to basis points (10000 = 100%)
            const bps = finalWeights.map(w => Math.round(w * 100));

            // Adjust for rounding errors - ensure sum is exactly 10000
            const bpsSum = bps.reduce((a, b) => a + b, 0);
            if (bpsSum !== 10000) {
              bps[bps.length - 1] += (10000 - bpsSum);
            }

            // Call setSplitDelegation
            showStatus('Submitting split delegation transaction...', false);
            const tx = await sharesContract.setSplitDelegation(finalAddresses, bps, getWalletConnectTxOverrides());
            showStatus('Transaction submitted! Waiting for confirmation...', false);
            await tx.wait();
            showStatus('Split delegation updated successfully!', false);
          }

          // Reload delegation status
          await loadDelegationStatus();
          toggleDelegationForm();

        } catch (error) {
          logger.error('Error setting delegation:', error);
          const errorMsg = error.message || 'Failed to set delegation';
          showStatus(`Error: ${errorMsg}`, true);
        }
      }

      // Clear delegation and revert to self-delegation
      async function clearDelegation() {
        if (!currentDAO || !connectedAddress) {
          showStatus('Please connect your wallet first', true);
          return;
        }

        if (!confirm('This will clear your current delegation and revert to 100% self-delegation. Continue?')) {
          return;
        }

        try {
          const dao = currentDAO.dao;
          const sharesAddress = dao.meta?.sharesToken;

          if (!sharesAddress) {
            showStatus('Shares contract not found', true);
            return;
          }

          const signer = await provider.getSigner();
          const sharesContract = new ethers.Contract(sharesAddress, SHARES_DELEGATION_ABI, signer);

          showStatus('Clearing delegation...', false);
          const tx = await sharesContract.clearSplitDelegation(getWalletConnectTxOverrides());
          showStatus('Transaction submitted! Waiting for confirmation...', false);
          await tx.wait();
          showStatus('Delegation cleared! Now self-delegating.', false);

          // Reload delegation status
          await loadDelegationStatus();
          toggleDelegationForm();

        } catch (error) {
          logger.error('Error clearing delegation:', error);
          const errorMsg = error.message || 'Failed to clear delegation';
          showStatus(`Error: ${errorMsg}`, true);
        }
      }

      // Helper function to format addresses
      function formatAddress(address) {
        if (!address) return '';
        return `${address.slice(0, 6)}...${address.slice(-4)}`;
      }

      // ==================== END DELEGATION FUNCTIONS ====================

      // Render DAO emblem from contractURI
      async function renderDAOEmblem(daoAddress, prefetchedContractURI) {
        const emblem = document.getElementById('daoEmblem');
        if (!emblem) return;

        try {
          // Clear any previous styling classes
          emblem.classList.remove('url-image', 'description-only');

          const contractURI = prefetchedContractURI !== undefined ? prefetchedContractURI : await withRpcFallback(async (activeProvider) => {
            const molochContract = new ethers.Contract(daoAddress, MOLOCH_ABI, activeProvider);
            return await molochContract.contractURI();
          });

          if (!contractURI) {
            emblem.style.display = 'none';
            return;
          }

          // Check if contractURI is a direct image URL (by file extension)
          const isDirectImageURL = /\.(svg|png|jpg|jpeg|gif|webp|avif)(\?.*)?$/i.test(contractURI);

          // If it's a direct image URL, use it directly
          if (isDirectImageURL) {
            const imageUrl = toGatewayUrl(contractURI);
            emblem.innerHTML = `<img src="${imageUrl}" alt="DAO Emblem" />`;
            emblem.classList.add('url-image');
            emblem.style.display = 'block';
            emblem.onclick = () => openNFTModal({ image: imageUrl }, 'DAO Contract');
            return;
          }

          // Parse metadata (JSON format)
          let metadata;
          if (contractURI.startsWith('data:application/json;base64,')) {
            const json = atob(contractURI.slice(29));
            metadata = JSON.parse(json);
          } else if (contractURI.startsWith('data:application/json;utf8,')) {
            // UTF-8 encoded JSON (used by DAICO.html buildContractURI)
            metadata = JSON.parse(contractURI.slice(27));
          } else if (contractURI.startsWith('data:application/json,')) {
            metadata = JSON.parse(decodeURIComponent(contractURI.slice(22)));
          } else if (contractURI.startsWith('data:image/')) {
            // Direct data URI image (e.g., data:image/svg+xml,...)
            emblem.innerHTML = `<img src="${contractURI}" alt="DAO Emblem" />`;
            emblem.style.display = 'block';
            emblem.onclick = () => openNFTModal({ image: contractURI }, 'DAO Contract');
            return;
          } else {
            // Try to fetch as JSON (convert IPFS URLs to gateway URLs)
            const fetchUrl = toGatewayUrl(contractURI);
            const response = await fetch(fetchUrl);

            // Check if fetch was successful
            if (!response.ok) {
              emblem.style.display = 'none';
              return;
            }

            const contentType = response.headers.get('content-type');

            // Check if response is an image
            if (contentType && contentType.startsWith('image/')) {
              emblem.innerHTML = `<img src="${fetchUrl}" alt="DAO Emblem" />`;
              emblem.classList.add('url-image');
              emblem.style.display = 'block';
              emblem.onclick = () => openNFTModal({ image: fetchUrl }, 'DAO Contract');
              return;
            }

            // Check if response is JSON before parsing
            if (!contentType || !contentType.includes('application/json')) {
              emblem.style.display = 'none';
              return;
            }

            // Otherwise parse as JSON metadata
            metadata = await response.json();
          }

          if (metadata && metadata.image) {
            const imageUrl = toGatewayUrl(metadata.image);
            emblem.innerHTML = `<img src="${imageUrl}" alt="DAO Emblem" />`;
            // Check if image URL is external (not data URI)
            if (!metadata.image.startsWith('data:')) {
              emblem.classList.add('url-image');
            }
            emblem.style.display = 'block';
            emblem.onclick = () => openNFTModal({ ...metadata, image: imageUrl }, 'DAO Contract');
          } else if (metadata && metadata.description) {
            // No image but has description - show description text elegantly
            emblem.classList.add('description-only');
            const truncatedDesc = metadata.description.length > 150
              ? metadata.description.slice(0, 147) + '...'
              : metadata.description;
            emblem.innerHTML = `<div class="dao-emblem-description">${escapeHtml(truncatedDesc)}</div>`;
            emblem.style.display = 'block';
            emblem.onclick = () => openNFTModal(metadata, 'DAO Contract');
          } else {
            emblem.style.display = 'none';
          }
        } catch (error) {
          logger.error('Error rendering DAO emblem:', error);
          emblem.style.display = 'none';
        }
      }

      // Open NFT modal
      function openNFTModal(metadata, title, receiptData = null) {
        if (!metadata) return;

        const modal = getEl('nftModal');
        const modalBody = document.getElementById('nftModalBody');

        let imageHTML = '';
        if (metadata.image) {
          // Convert IPFS URLs to gateway URLs and add url-image class for external URLs
          const imageUrl = toGatewayUrl(metadata.image);
          const urlImageClass = imageUrl.startsWith('data:') ? '' : ' url-image';
          imageHTML = `<img src="${imageUrl}" class="nft-modal-image${urlImageClass}" alt="${title}" />`;
        }

        let attributesHTML = '';
        if (metadata.attributes && Array.isArray(metadata.attributes)) {
          attributesHTML = `
            <div class="nft-modal-attributes">
              ${metadata.attributes.map(attr => `
                <div class="nft-modal-attribute">
                  <div class="nft-modal-attribute-label">${attr.trait_type || attr.type || 'Attribute'}</div>
                  <div class="nft-modal-attribute-value">${attr.value}</div>
                </div>
              `).join('')}
            </div>
          `;
        }

        // Check for futarchy claim eligibility if this is a vote receipt
        let futarchyClaimHTML = '';
        if (receiptData && currentDAO) {
          const proposal = currentDAO.dao.proposals.find(p => p.id.toString() === receiptData.proposalId.toString());

          if (proposal?.futarchy?.enabled && proposal.futarchy.resolved) {
            const winnerSupport = Number(proposal.futarchy.winner); // 0 or 1
            const userSupport = Number(receiptData.support);

            // Check if user voted on winning side (0=Against, 1=For)
            if (userSupport === winnerSupport) {
              const balanceFormatted = ethers.formatUnits(receiptData.balance, 18);
              const payoutPerUnit = proposal.futarchy.payoutPerUnit;
              const estimatedReward = (receiptData.balance * payoutPerUnit) / (10n ** 18n);
              const estimatedRewardFormatted = ethers.formatUnits(estimatedReward, 18);

              futarchyClaimHTML = `
                <div style="margin-top: 1.5rem; padding: 1rem; background: var(--status-success); border: 1px solid var(--border-muted); ">
                  <div style="font-size: 0.85rem; color: var(--green); letter-spacing: 0.1em; margin-bottom: 0.75rem; text-align: center;">
                    ðŸŽ‰ FUTARCHY REWARDS AVAILABLE
                  </div>
                  <div style="font-size: 0.9rem; color: #000; text-align: center; margin-bottom: 0.75rem;">
                    You voted on the winning side! You have <strong>${parseFloat(balanceFormatted).toFixed(4)}</strong> winning receipts.
                  </div>
                  <div style="font-size: 0.85rem; color: var(--fg); text-align: center; margin-bottom: 1rem;">
                    Estimated reward: <strong>${parseFloat(estimatedRewardFormatted).toFixed(4)} LOOT</strong>
                  </div>
                  <button onclick="claimFutarchyFromReceipt('${receiptData.proposalId.toString()}', '${receiptData.balance.toString()}')"
                          style="width: 100%; padding: 0.875rem; background: #000; border: none; color: #fff; font-size: 0.8rem; letter-spacing: 0.15em; cursor: pointer; text-transform: uppercase; font-weight: 600; transition: all 0.2s ease; min-height: 44px;">
                    Claim Rewards
                  </button>
                </div>
              `;
            }
          }
        }

        modalBody.innerHTML = `
          ${imageHTML}
          <div class="nft-modal-title">${metadata.name || title}</div>
          ${metadata.description ? `<div class="nft-modal-description">${escapeHtml(metadata.description)}</div>` : ''}
          ${attributesHTML}
          ${futarchyClaimHTML}
        `;

        modal.classList.add('active');
        document.body.classList.add('modal-open');
      }

      // Claim futarchy rewards from receipt modal
      async function claimFutarchyFromReceipt(proposalId, amountStr) {
        closeNFTModal();
        await claimFutarchyReward(proposalId, amountStr);
      }

      // Close NFT modal
      function closeNFTModal() {
        const modal = getEl('nftModal');
        modal.classList.remove('active');
        document.body.classList.remove('modal-open');
      }

      // Render tile emblem (for gallery tiles)
      async function renderTileEmblem(daoAddress, emblemId) {
        const emblem = document.getElementById(emblemId);
        if (!emblem) return;

        try {
          // Clear any previous styling classes
          emblem.classList.remove('url-image', 'description-only');

          const molochContract = new ethers.Contract(daoAddress, MOLOCH_ABI, provider);
          const contractURI = await molochContract.contractURI();

          if (!contractURI) return;

          // Check if contractURI is a direct image URL (by file extension)
          const isDirectImageURL = /\.(svg|png|jpg|jpeg|gif|webp|avif)(\?.*)?$/i.test(contractURI);

          // If it's a direct image URL, use it directly
          if (isDirectImageURL) {
            const imageUrl = toGatewayUrl(contractURI);
            emblem.innerHTML = `<img src="${imageUrl}" alt="DAO Emblem" />`;
            emblem.classList.add('url-image');
            return;
          }

          // Parse metadata (JSON format)
          let metadata;
          if (contractURI.startsWith('data:application/json;base64,')) {
            const json = atob(contractURI.slice(29));
            metadata = JSON.parse(json);
          } else if (contractURI.startsWith('data:application/json;utf8,')) {
            // UTF-8 encoded JSON (used by DAICO.html buildContractURI)
            metadata = JSON.parse(contractURI.slice(27));
          } else if (contractURI.startsWith('data:application/json,')) {
            metadata = JSON.parse(decodeURIComponent(contractURI.slice(22)));
          } else if (contractURI.startsWith('data:image/')) {
            // Direct data URI image (e.g., data:image/svg+xml,...)
            emblem.innerHTML = `<img src="${contractURI}" alt="DAO Emblem" />`;
            return;
          } else {
            // Try to fetch as JSON (convert IPFS URLs to gateway URLs)
            const fetchUrl = toGatewayUrl(contractURI);
            const response = await fetch(fetchUrl);

            // Check if fetch was successful
            if (!response.ok) {
              // Silently fail for tile emblems (non-critical)
              return;
            }

            const contentType = response.headers.get('content-type');

            // Check if response is an image
            if (contentType && contentType.startsWith('image/')) {
              emblem.innerHTML = `<img src="${fetchUrl}" alt="DAO Emblem" />`;
              emblem.classList.add('url-image');
              return;
            }

            // Check if response is JSON before parsing
            if (!contentType || !contentType.includes('application/json')) {
              // Not JSON, can't parse metadata
              return;
            }

            // Otherwise parse as JSON metadata
            metadata = await response.json();
          }

          if (metadata && metadata.image) {
            const imageUrl = toGatewayUrl(metadata.image);
            emblem.innerHTML = `<img src="${imageUrl}" alt="DAO Emblem" />`;
            // Check if image URL is external (not data URI)
            if (!metadata.image.startsWith('data:')) {
              emblem.classList.add('url-image');
            }
          } else if (metadata && metadata.description) {
            // No image but has description - show truncated description in tile
            emblem.classList.add('description-only');
            const truncatedDesc = metadata.description.length > 80
              ? metadata.description.slice(0, 77) + '...'
              : metadata.description;
            emblem.innerHTML = `<div class="tile-emblem-description">${escapeHtml(truncatedDesc)}</div>`;
          }
        } catch (error) {
          logger.error('Error rendering tile emblem:', error);
        }
      }

      // Render Members List
      async function renderMembers() {
        if (!currentDAO) {
          return;
        }

        const membersList = document.getElementById('membersList');
        const memberCount = document.getElementById('memberCount');
        const badgeHolderCount = document.getElementById('badgeHolderCount');

        if (!membersList) {
          return;
        }

        membersList.innerHTML = '<p style="text-align: center; color: var(--fg-dim); font-style: italic;">Loading members...</p>';

        const members = currentDAO.dao.members;
        memberCount.textContent = members.length;

        let badgeHolders = 0;
        members.forEach(member => {
          // member[3] = seatId
          if (member[3] && member[3] > 0) badgeHolders++;
        });
        badgeHolderCount.textContent = badgeHolders;

        membersList.innerHTML = '';

        // Calculate total supply for ownership %
        const totalShares = currentDAO.dao.supplies.sharesTotalSupply;
        const totalLoot = currentDAO.dao.supplies.lootTotalSupply;
        const totalSupply = totalShares + totalLoot;

        // Reverse ENS resolution for each member (with caching, batched to limit concurrency)
        const membersWithENS = [];
        const BATCH_SIZE = 10;
        for (let i = 0; i < members.length; i += BATCH_SIZE) {
          const batch = members.slice(i, i + BATCH_SIZE);
          const batchResults = await Promise.all(
            batch.map(async (member) => {
              const memberAddress = member[0];
              const ensName = memberAddress ? await lookupENS(memberAddress) : null;
              return { ...member, ensName };
            })
          );
          membersWithENS.push(...batchResults);
        }

        // Render each member
        try {
          membersWithENS.forEach((member, index) => {
            // Member structure from view helper uses numeric indices:
            // [0] = address, [1] = shares, [2] = loot, [3] = seatId, [4] = delegatedShares
            const memberAddress = member[0] || member.account || member.address;
            const sharesBN = member[1] !== null && member[1] !== undefined ? member[1] : 0n;
            const lootBN = member[2] !== null && member[2] !== undefined ? member[2] : 0n;
            const seatId = member[3] || 0;

            if (!memberAddress) {
              return;
            }

            const memberDiv = document.createElement('div');
            memberDiv.className = 'member-item';

            const shares = parseFloat(ethers.formatUnits(sharesBN, 18)).toFixed(4);
            const loot = parseFloat(ethers.formatUnits(lootBN, 18)).toFixed(4);
            const badgeText = (seatId && seatId > 0) ? `Seat #${seatId}` : 'None';

            // Calculate ownership %
            const memberTotal = sharesBN + lootBN;
            const ownershipPercent = totalSupply > 0n
              ? (Number(memberTotal * 10000n / totalSupply) / 100).toFixed(2)
              : '0.00';

            memberDiv.innerHTML = `
              <div class="member-address" style="cursor: pointer;" onclick="showMemberCollectiblesModal('${memberAddress}', '${member.ensName || memberAddress}')">
                ${member.ensName ? `<div class="member-ens">${member.ensName}</div>` : ''}
                <div class="member-address-hex">${memberAddress.slice(0, 10)}...${memberAddress.slice(-8)}</div>
              </div>
              <div class="member-shares">
                <div class="member-label">Shares</div>
                <div class="member-value">${shares}</div>
              </div>
              <div class="member-loot">
                <div class="member-label">Loot</div>
                <div class="member-value">${loot}</div>
              </div>
              <div class="member-badge">
                <div class="member-label">Badge</div>
                <div class="member-value">${badgeText}</div>
              </div>
              <div class="member-ownership">
                <div class="member-label">Ownership</div>
                <div class="member-value">${ownershipPercent}%</div>
              </div>
              <a href="${getNetwork().explorer}/address/${memberAddress}" target="_blank" rel="noopener noreferrer" class="member-link" title="View on Explorer" onclick="event.stopPropagation();">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                  <polyline points="15 3 21 3 21 9"></polyline>
                  <line x1="10" y1="14" x2="21" y2="3"></line>
                </svg>
              </a>
            `;

            membersList.appendChild(memberDiv);
          });
        } catch (error) {
          logger.error('Error rendering members:', error);
          membersList.innerHTML = `<p style="text-align: center; color: #e74c3c; padding: 2rem;">Error rendering members: ${escapeHtml(error.message)}<br><small>Check console for details</small></p>`;
        }
      }

      // Show member collectibles modal
      async function showMemberCollectiblesModal(memberAddress, displayName) {
        if (!currentDAO) return;

        const modal = getEl('nftModal');
        const modalContent = document.getElementById('nftModalBody');

        // Show loading state
        modalContent.innerHTML = `
          <div style="text-align: center; padding: 3rem;">
            <div style="font-size: 1.5rem; color: #000; letter-spacing: 0.1em; margin-bottom: 1rem;">
              Loading Collectibles...
            </div>
            <div style="font-size: 0.9rem; color: var(--fg-dim);">
              ${displayName}
            </div>
          </div>
        `;
        modal.classList.add('active');

        try {
          const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, provider);
          const molochIface = new ethers.Interface(MOLOCH_ABI);
          const collectibles = [];

          // Phase 1: Batch all balanceOf calls via Multicall3
          const voteChecks = [];
          for (const proposal of currentDAO.dao.proposals) {
            const voterData = proposal.voters?.find(v => v.voter?.toLowerCase() === memberAddress.toLowerCase());
            if (voterData) {
              const support = Number(voterData.support);
              const receiptId = ethers.solidityPackedKeccak256(
                ['string', 'uint256', 'uint8'],
                ['Moloch:receipt', proposal.id, support]
              );
              voteChecks.push({ proposal, support, receiptId });
            }
          }

          // Also prepare emergency permit check
          let permitId = null;
          try {
            const bumpConfigCalldata = INTERFACES.bumpConfig.encodeFunctionData('bumpConfig', []);
            const emergencyNonce = ethers.id("EMERGENCY_CONFIG_BUMP");
            const config = await molochContract.config();
            permitId = computeProposalId(currentDAO.dao.dao, 0, currentDAO.dao.dao, 0, bumpConfigCalldata, emergencyNonce, config);
          } catch (permitError) {
            logger.error('Error computing emergency permit:', permitError);
          }

          // Build multicall for all balanceOf checks
          const balanceCalls = voteChecks.map(({ receiptId }) => ({
            target: currentDAO.dao.dao,
            allowFailure: true,
            callData: molochIface.encodeFunctionData('balanceOf', [memberAddress, receiptId])
          }));
          if (permitId) {
            balanceCalls.push({
              target: currentDAO.dao.dao,
              allowFailure: true,
              callData: molochIface.encodeFunctionData('balanceOf', [memberAddress, permitId])
            });
          }

          if (balanceCalls.length > 0) {
            try {
              const mcResults = await withRpcFallback(async (activeProvider) => {
                const multicall = new ethers.Contract(MULTICALL3_ADDRESS, MULTICALL3_ABI, activeProvider);
                return await multicall.aggregate3(balanceCalls);
              });

              // Decode vote receipt balances
              for (let i = 0; i < voteChecks.length; i++) {
                const { success, returnData } = mcResults[i];
                if (!success) continue;
                try {
                  const decoded = molochIface.decodeFunctionResult('balanceOf', returnData);
                  const balance = decoded[0];
                  if (balance > 0n) {
                    collectibles.push({
                      type: 'receipt',
                      proposalId: voteChecks[i].proposal.id,
                      support: voteChecks[i].support,
                      balance,
                      receiptId: voteChecks[i].receiptId
                    });
                  }
                } catch (e) { /* skip */ }
              }

              // Decode emergency permit balance
              if (permitId && mcResults.length > voteChecks.length) {
                const { success, returnData } = mcResults[voteChecks.length];
                if (success) {
                  try {
                    const decoded = molochIface.decodeFunctionResult('balanceOf', returnData);
                    if (decoded[0] > 0n) {
                      collectibles.push({
                        type: 'emergency_permit',
                        permitId,
                        balance: decoded[0]
                      });
                    }
                  } catch (e) { /* skip */ }
                }
              }
            } catch (err) {
              logger.error('Error in multicall collectibles balance check:', err);
            }
          }

          // Render collectibles
          if (collectibles.length === 0) {
            modalContent.innerHTML = `
              <div style="text-align: center; padding: 3rem;">
                <div style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;">ðŸ“¦</div>
                <div style="font-size: 1.2rem; color: #000; letter-spacing: 0.1em; margin-bottom: 0.5rem;">
                  NO COLLECTIBLES
                </div>
                <div style="font-size: 0.9rem; color: var(--fg-dim); margin-bottom: 1.5rem;">
                  ${displayName}
                </div>
                <button onclick="closeNFTModal()" style="padding: 0.75rem 1.5rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.85rem; cursor: pointer; ">
                  Close
                </button>
              </div>
            `;
            return;
          }

          const supportLabels = ['Against', 'For', 'Abstain'];
          const supportColors = ['#e74c3c', '#2d8a2d', '#000'];

          // Fetch metadata for all collectibles in parallel
          const metadataResults = await Promise.all(collectibles.map(async (item) => {
            if (item.type === 'receipt') {
              try {
                const tokenURI = await molochContract.tokenURI(item.receiptId);
                let metadata;
                if (tokenURI.startsWith('data:application/json;base64,')) {
                  const json = atob(tokenURI.slice(29));
                  metadata = JSON.parse(json);
                } else if (tokenURI.startsWith('data:application/json,')) {
                  metadata = JSON.parse(decodeURIComponent(tokenURI.slice(22)));
                } else {
                  const response = await fetch(tokenURI);
                  metadata = await response.json();
                }

                const balanceFormatted = ethers.formatUnits(item.balance, 18);
                const supportLabel = supportLabels[item.support];
                const supportColor = supportColors[item.support];

                let imageHTML = '';
                if (metadata.image) {
                  const imageUrl = toGatewayUrl(metadata.image);
                  imageHTML = `<img src="${imageUrl}" style="width: 100%; margin-bottom: 1rem;" alt="Receipt" />`;
                }

                return `
                  <div style="background: var(--surface); border: 1px solid var(--border-muted); padding: 1rem; margin-bottom: 1rem;">
                    ${imageHTML}
                    <div style="font-size: 0.75rem; color: #000; letter-spacing: 0.1em; margin-bottom: 0.5rem;">
                      VOTE RECEIPT
                    </div>
                    <div style="font-size: 0.95rem; color: #000; margin-bottom: 0.5rem;">
                      ${metadata.name || 'Vote Receipt'}
                    </div>
                    <div style="font-size: 0.85rem; color: var(--fg); margin-bottom: 0.5rem;">
                      Proposal #${item.proposalId.toString().slice(0, 8)}...
                    </div>
                    <div style="font-size: 0.85rem; color: ${supportColor}; margin-bottom: 0.5rem;">
                      Voted ${supportLabel}
                    </div>
                    <div style="font-size: 0.85rem; color: var(--fg);">
                      Balance: ${parseFloat(balanceFormatted).toFixed(4)} receipts
                    </div>
                  </div>
                `;
              } catch (metadataError) {
                logger.error('Error fetching receipt metadata:', metadataError);
                return '';
              }
            } else if (item.type === 'emergency_permit') {
              try {
                const tokenURI = await molochContract.tokenURI(item.permitId);
                let metadata = null;
                if (tokenURI.startsWith('data:application/json;base64,')) {
                  const json = atob(tokenURI.slice(29));
                  metadata = JSON.parse(json);
                } else if (tokenURI.startsWith('data:application/json,')) {
                  metadata = JSON.parse(decodeURIComponent(tokenURI.slice(22)));
                } else {
                  const response = await fetch(tokenURI);
                  metadata = await response.json();
                }

                const usesText = Number(item.balance) === 1 ? '1 use' : `${Number(item.balance)} uses`;

                let imageHTML = '';
                if (metadata?.image) {
                  const imageUrl = toGatewayUrl(metadata.image);
                  imageHTML = `<img src="${imageUrl}" style="width: 100%; margin-bottom: 1rem;" alt="Emergency Permit" />`;
                }

                const bumpConfigCalldata = INTERFACES.bumpConfig.encodeFunctionData('bumpConfig', []);
                let actionDescription = 'Execute bumpConfig() - Resets governance state';
                if (bumpConfigCalldata.startsWith('0x7ec924db')) {
                  actionDescription = 'âš¡ <strong>Use Permit:</strong> Execute config bump (invalidates all proposals & permits)';
                }

                return `
                  <div style="background: #fff5f5; border: 1px solid #e8c0c0; padding: 1rem; margin-bottom: 1rem;">
                    ${imageHTML}
                    <div style="font-size: 0.75rem; color: #c0392b; letter-spacing: 0.1em; margin-bottom: 0.5rem;">
                      EMERGENCY PERMIT
                    </div>
                    <div style="font-size: 0.95rem; color: #000; margin-bottom: 0.5rem;">
                      ${metadata?.name || 'Config Bump Authority'}
                    </div>
                    <div style="font-size: 0.85rem; color: var(--fg); margin-bottom: 0.75rem; line-height: 1.4;">
                      ${metadata?.description || 'Emergency power to reset governance state by incrementing config counter.'}
                    </div>
                    <div style="background: #fff0f0; padding: 0.5rem 0.75rem; font-size: 0.8rem; color: #000; margin-bottom: 0.5rem;">
                      ${actionDescription}
                    </div>
                    <div style="background: #fff0f0; display: inline-block; padding: 0.35rem 0.75rem; font-size: 0.8rem; color: #e74c3c; font-weight: 600;">
                      ${usesText}
                    </div>
                  </div>
                `;
              } catch (metadataError) {
                logger.error('Error fetching permit metadata:', metadataError);
                return '';
              }
            }
            return '';
          }));

          const collectiblesHTML = metadataResults.join('');

          modalContent.innerHTML = `
            <div style="max-width: 600px; margin: 0 auto;">
              <div style="text-align: center; margin-bottom: 1.5rem;">
                <div style="font-size: 1.5rem; color: #000; letter-spacing: 0.1em; margin-bottom: 0.5rem;">
                  COLLECTIBLES
                </div>
                <div style="font-size: 0.95rem; color: var(--fg); margin-bottom: 0.5rem;">
                  ${displayName}
                </div>
                <div style="font-family: 'Courier New', monospace; font-size: 0.75rem; color: var(--fg-dim);">
                  ${memberAddress.slice(0, 10)}...${memberAddress.slice(-8)}
                </div>
              </div>

              <div style="max-height: 500px; overflow-y: auto; margin-bottom: 1.5rem;">
                ${collectiblesHTML}
              </div>

              <div style="text-align: center;">
                <button onclick="closeNFTModal()" style="padding: 0.75rem 1.5rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.85rem; cursor: pointer; transition: all 0.2s ease;">
                  Close
                </button>
              </div>
            </div>
          `;

        } catch (error) {
          logger.error('Error loading member collectibles:', error);
          modalContent.innerHTML = `
            <div style="text-align: center; padding: 3rem;">
              <div style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.3;">âš ï¸</div>
              <div style="font-size: 1.2rem; color: #e74c3c; letter-spacing: 0.1em; margin-bottom: 0.5rem;">
                ERROR LOADING COLLECTIBLES
              </div>
              <div style="font-size: 0.85rem; color: var(--fg-dim); margin-bottom: 1.5rem;">
                ${error.message}
              </div>
              <button onclick="closeNFTModal()" style="padding: 0.75rem 1.5rem; background: var(--surface-hover); border: 1px solid var(--border-muted); color: var(--fg); font-size: 0.85rem; cursor: pointer; ">
                Close
              </button>
            </div>
          `;
        }
      }

      // Toggle long message expand/collapse
      function toggleMessageExpand(msgId, btn) {
        const shortEl = document.getElementById(msgId + '-short');
        const fullEl = document.getElementById(msgId + '-full');
        if (shortEl.style.display === 'none') {
          shortEl.style.display = '';
          fullEl.style.display = 'none';
          btn.textContent = 'More';
        } else {
          shortEl.style.display = 'none';
          fullEl.style.display = '';
          btn.textContent = 'Less';
        }
      }

      // Render chatroom messages
      let chatroomRenderId = 0; // Counter to track the most recent render
      async function renderChatroom() {
        const chatroomMessages = document.getElementById('chatroomMessages');
        if (!chatroomMessages || !currentDAO) return;

        // Increment render ID and capture it - only the most recent render should update DOM
        const thisRenderId = ++chatroomRenderId;

        // Capture DAO state at start to avoid race conditions with async operations
        const daoAddress = currentDAO.dao.dao;
        const messages = [...currentDAO.dao.messages];

        // Show loading state immediately (clears old DAO's messages)
        if (messages.length === 0) {
          chatroomMessages.innerHTML = '<p style="text-align: center; color: var(--fg-dim); font-style: italic;">No messages yet. Be the first to chat!</p>';
          return;
        }
        chatroomMessages.innerHTML = '<p style="text-align: center; color: var(--fg-dim); font-style: italic;">Loading messages...</p>';

        // Query Message events to get senders (chunked to respect RPC block limits)
        const messageSenders = {};
        try {
          await withRpcFallback(async (activeProvider) => {
            const molochContract = new ethers.Contract(daoAddress, MOLOCH_ABI, activeProvider);
            const currentBlock = await activeProvider.getBlockNumber();
            const chunkSize = 10000;

            // Query backwards until we find all senders or reach block 0
            for (let toBlock = currentBlock; toBlock >= 0; toBlock -= chunkSize) {
              const fromBlock = Math.max(0, toBlock - chunkSize + 1);
              const events = await molochContract.queryFilter(molochContract.filters.Message(), fromBlock, toBlock);
              events.forEach(e => { messageSenders[String(e.args.index)] = e.args.from; });
              if (Object.keys(messageSenders).length >= messages.length || fromBlock === 0) break;
            }
          });
        } catch (e) {
          logger.warn('Could not fetch message senders:', e.message);
        }

        // Check if this render is stale (newer render started, or DAO changed)
        if (thisRenderId !== chatroomRenderId || currentDAO?.dao?.dao !== daoAddress) {
          return; // A newer render is in progress, skip this stale one
        }

        // Clear and render - do this after async work to prevent duplicates from concurrent renders
        chatroomMessages.innerHTML = '';

        // Reverse to show most recent first
        const messagesReversed = [...messages].reverse();

        // Show only the most recent messages initially; hide older ones behind a button
        const INITIAL_DISPLAY_LIMIT = 50;
        const recentMessages = messagesReversed.slice(0, INITIAL_DISPLAY_LIMIT);
        const olderMessages = messagesReversed.slice(INITIAL_DISPLAY_LIMIT);

        // Collect unique sender addresses for batched ENS lookup
        const uniqueSenders = [...new Set(
          messagesReversed
            .map(msg => messageSenders[String(msg.index)])
            .filter(addr => addr)
        )];

        function renderMessageDiv(message) {
          const msgDiv = document.createElement('div');
          const proposalData = decodeProposalMessage(message.text);

          msgDiv.className = 'chatroom-message' + (proposalData ? ' proposal' : '');

          // Get sender address for this message
          const senderAddress = messageSenders[String(message.index)];
          const senderDisplay = senderAddress
            ? ` (<a href="${getExplorerAddressUrl(senderAddress)}" target="_blank" rel="noopener noreferrer" class="chatroom-sender-link" data-address="${senderAddress}">${senderAddress.slice(0, 10)}...${senderAddress.slice(-8)}</a>)`
            : '';

          const MAX_MESSAGE_LENGTH = 203;
          const isLongMessage = !proposalData && message.text.length > MAX_MESSAGE_LENGTH;
          let messageContent;

          if (isLongMessage) {
            const truncatedText = escapeHtml(message.text.slice(0, MAX_MESSAGE_LENGTH));
            const fullText = escapeHtml(message.text);
            const msgId = `msg-${message.index}`;
            messageContent = `<span id="${msgId}-short">${truncatedText}...</span><span id="${msgId}-full" style="display: none;">${fullText}</span><button class="chatroom-message-more" onclick="toggleMessageExpand('${msgId}', this)">More</button>`;
          } else {
            messageContent = escapeHtml(message.text);
          }

          if (proposalData) {
            // Format proposal message nicely
            const isETHTransfer = proposalData.value !== '0' && proposalData.data === '0x';
            const isTokenTransfer = proposalData.data.startsWith('0xa9059cbb');

            let formattedDetails = '';
            if (isETHTransfer) {
              const ethAmount = ethers.formatEther(proposalData.value);
              formattedDetails = `
                <div style="margin-top: 0.5rem; padding: 0.75rem; background: #f9f9f9; border-left: 3px solid #000;">
                  <div style="font-size: 0.85rem; opacity: 0.8; margin-bottom: 0.35rem;">ETH Transfer</div>
                  <div style="font-size: 0.9rem;">Amount: <strong>${escapeHtml(ethAmount)} ETH</strong></div>
                  <div style="font-size: 0.85rem; margin-top: 0.25rem;">To: <code style="background: var(--surface-hover); padding: 0.2rem 0.4rem;">${escapeHtml(proposalData.to)}</code></div>
                </div>
              `;
            } else if (isTokenTransfer) {
              try {
                const abiCoder = new ethers.AbiCoder();
                const decoded = abiCoder.decode(['address', 'uint256'], '0x' + proposalData.data.slice(10));
                const recipient = decoded[0];
                const amount = decoded[1];
                // Try to identify token
                let tokenSymbol = 'TOKEN';
                if (proposalData.to.toLowerCase() === TOKEN_ADDRESSES.usdc.toLowerCase()) tokenSymbol = 'USDC';
                else if (proposalData.to.toLowerCase() === TOKEN_ADDRESSES.usdt.toLowerCase()) tokenSymbol = 'USDT';
                else if (proposalData.to.toLowerCase() === TOKEN_ADDRESSES.dai.toLowerCase()) tokenSymbol = 'DAI';
                else if (proposalData.to.toLowerCase() === TOKEN_ADDRESSES.wsteth.toLowerCase()) tokenSymbol = 'wstETH';
                else if (proposalData.to.toLowerCase() === TOKEN_ADDRESSES.reth.toLowerCase()) tokenSymbol = 'rETH';

                const decimals = (tokenSymbol === 'USDC' || tokenSymbol === 'USDT') ? 6 : 18;
                const formattedAmount = ethers.formatUnits(amount, decimals);

                formattedDetails = `
                  <div style="margin-top: 0.5rem; padding: 0.75rem; background: #f9f9f9; border-left: 3px solid #000;">
                    <div style="font-size: 0.85rem; opacity: 0.8; margin-bottom: 0.35rem;">${escapeHtml(tokenSymbol)} Transfer</div>
                    <div style="font-size: 0.9rem;">Amount: <strong>${escapeHtml(formattedAmount)} ${escapeHtml(tokenSymbol)}</strong></div>
                    <div style="font-size: 0.85rem; margin-top: 0.25rem;">To: <code style="background: var(--surface-hover); padding: 0.2rem 0.4rem;">${escapeHtml(recipient)}</code></div>
                  </div>
                `;
              } catch (e) {
                formattedDetails = '';
              }
            }

            // Add SwissKnife link if calldata exists and is not empty
            let calldataLinkForMessage = '';
            if (proposalData.data && proposalData.data !== '0x' && proposalData.data.length > 2) {
              calldataLinkForMessage = `
                <div style="margin-top: 0.5rem;">
                  <a href="https://calldata.swiss-knife.xyz/decoder?calldata=${proposalData.data}"
                     target="_blank"
                     rel="noopener noreferrer"
                     style="font-size: 0.75rem; color: var(--fg); text-decoration: none; display: inline-flex; align-items: center; gap: 0.35rem; opacity: 0.75; transition: opacity 0.3s ease;"
                     onmouseover="this.style.opacity='1'"
                     onmouseout="this.style.opacity='0.75'">
                    <span>ðŸ”</span> Decode calldata on SwissKnife
                  </a>
                </div>
              `;
            }

            messageContent = `
              <strong style="color: #000; font-size: 0.85rem; letter-spacing: 0.1em;">PROPOSAL</strong>
              <div style="margin-top: 0.5rem; font-size: 1rem;">${escapeHtml(proposalData.description)}</div>
              ${formattedDetails}
              ${calldataLinkForMessage}
              <details style="margin-top: 0.75rem; opacity: 0.6;">
                <summary style="cursor: pointer; font-size: 0.75rem; letter-spacing: 0.05em; text-transform: uppercase;">Technical Details</summary>
                <pre style="margin-top: 0.5rem; padding: 0.5rem; background: var(--surface-hover); overflow-x: auto; font-size: 0.7rem; border: 1px solid var(--border-muted);">${escapeHtml(JSON.stringify({op: proposalData.op, to: proposalData.to, value: proposalData.value, data: proposalData.data.slice(0, 66) + (proposalData.data.length > 66 ? '...' : ''), nonce: proposalData.nonce}, null, 2))}</pre>
              </details>
            `;
          }

          msgDiv.innerHTML = `
            <div class="chatroom-message-header">
              <span>Message #${message.index}${senderDisplay}</span>
            </div>
            <div class="chatroom-message-text">
              ${messageContent}
            </div>
          `;

          return msgDiv;
        }

        // Render recent messages
        recentMessages.forEach(message => {
          chatroomMessages.appendChild(renderMessageDiv(message));
        });

        // Add "Show older messages" button if there are older messages
        if (olderMessages.length > 0) {
          const showOlderBtn = document.createElement('button');
          showOlderBtn.className = 'chatroom-message-more';
          showOlderBtn.style.cssText = 'display: block; width: 100%; text-align: center; padding: 0.75rem; margin: 0.5rem 0; font-size: 0.85rem;';
          showOlderBtn.textContent = `Show ${olderMessages.length} older messages`;
          showOlderBtn.onclick = function() {
            this.remove();
            olderMessages.forEach(message => {
              chatroomMessages.appendChild(renderMessageDiv(message));
            });
          };
          chatroomMessages.appendChild(showOlderBtn);
        }

        // Batch ENS lookups to improve performance - limit concurrency to avoid overwhelming RPC
        const BATCH_SIZE = 10;
        for (let i = 0; i < uniqueSenders.length; i += BATCH_SIZE) {
          const batch = uniqueSenders.slice(i, i + BATCH_SIZE);

          // Process batch in parallel
          Promise.all(batch.map(async (senderAddress) => {
            try {
              const ensName = await lookupENS(senderAddress);
              if (ensName) {
                // Update all messages from this sender
                const senderLinks = chatroomMessages.querySelectorAll(`.chatroom-sender-link[data-address="${senderAddress}"]`);
                senderLinks.forEach(link => {
                  link.textContent = ensName;
                  link.title = senderAddress; // Show full address on hover
                });
              }
            } catch (e) {
              // Ignore errors for individual lookups
            }
          })).catch(() => {});
        }

        // No auto-scroll since newest messages are now at the top
      }

      // Send chat message
      async function sendChatMessage() {
        if (!currentDAO || !signer) return;

        // Prevent race condition: set flag immediately before any async work
        if (isSendingMessage) return;
        isSendingMessage = true;

        const chatInput = document.getElementById('chatInput');
        const message = chatInput.value.trim();

        if (!message) {
          isSendingMessage = false;
          return;
        }
        try {
          const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, signer);

          chatInput.value = 'Sending...';
          chatInput.disabled = true;

          const tx = await molochContract.chat(message, getWalletConnectTxOverrides());
          await tx.wait();

          chatInput.value = '';
          chatInput.disabled = false;

          // Refresh messages
          await refreshCurrentDAO();
          await renderChatroom();
        } catch (error) {
          logger.error('Error sending message:', error);
          chatInput.value = message; // Restore the message
          chatInput.disabled = false;

          if (isUserRejection(error)) {
            showStatus('Message cancelled', false);
            return;
          }

          let errorMessage = 'Failed to send message';
          if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message) {
            const msg = error.message.split('\n')[0];
            if (msg.length < 100) {
              errorMessage = msg;
            }
          }

          showStatus(errorMessage, true);
        } finally {
          isSendingMessage = false;
        }
      }

      // Render proposals
      async function renderProposals(prefetchedConfig) {
        const proposalsList = document.getElementById('proposalsList');
        if (!proposalsList || !currentDAO?.dao) return;

        try {
          proposalsList.innerHTML = '';

          const proposals = currentDAO.dao.proposals || [];
          if (proposals.length === 0) {
          proposalsList.innerHTML = '<p style="text-align: center; color: var(--fg-dim); font-style: italic; margin-top: 1rem;">No proposals yet.</p>';
          return;
        }

        // Get config once for all proposals
        let daoConfig;
        let configFetched = false;
        if (prefetchedConfig !== undefined) {
          daoConfig = prefetchedConfig;
          configFetched = true;
        } else {
          try {
            daoConfig = await withRpcFallback(async (activeProvider) => {
              const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, activeProvider);
              return await molochContract.config();
            });
            configFetched = true;
          } catch (e) {
            logger.warn('Error getting DAO config:', e.message);
            daoConfig = 0n; // fallback (but we know it failed)
          }
        }

        // Must match Moloch.sol enum ProposalState (line 79-87)
        const PROPOSAL_STATES = ['Unopened', 'Active', 'Queued', 'Succeeded', 'Defeated', 'Expired', 'Executed'];

        // Deduplicate proposals by ID
        const seenProposalIds = new Set();
        const uniqueProposals = currentDAO.dao.proposals.filter(proposal => {
          const id = proposal.id.toString();
          if (seenProposalIds.has(id)) {
            return false;
          }
          seenProposalIds.add(id);
          return true;
        });

        // Reverse to show most recent first
        const proposalsReversed = [...uniqueProposals].reverse();

        // Check if user has voted on any proposals (use voters data from view helper - no RPC calls!)
        const userVoteStatus = {};

        if (connectedAddress) {
          proposalsReversed.forEach(proposal => {
            // Check if user is in the voters array (already provided by view helper)
            const userVote = proposal.voters?.find(v =>
              v.voter?.toLowerCase() === connectedAddress.toLowerCase()
            );
            // userVoteStatus: 0 = not voted, 1 = Against, 2 = For, 3 = Abstain
            userVoteStatus[proposal.id.toString()] = userVote ? (Number(userVote.support) + 1) : 0;
          });
        }

        // Check if we have a complete message history (vs a partial window)
        // The view helper returns a limited number of messages. If messages don't
        // form a contiguous block from index 0, we have a partial window and should
        // not flag proposals as "unverified" (their message may simply not be loaded).
        const allMsgs = currentDAO.dao.messages || [];
        const hasCompleteMessages = allMsgs.length > 0 &&
          allMsgs[0].index === 0 &&
          allMsgs[allMsgs.length - 1].index === allMsgs.length - 1;

        // Pre-build proposal verification map: proposalId => { description, data }
        // This avoids O(proposals * messages * configs) by computing all IDs upfront
        const proposalVerificationMap = new Map();
        if (allMsgs.length > 0) {
          const currentConfig = configFetched ? Number(daoConfig) : 0;
          for (const msg of allMsgs) {
            const propData = decodeProposalMessage(msg.text);
            if (!propData) continue;
            try {
              for (let cfg = currentConfig; cfg >= 0; cfg--) {
                const recomputedId = computeProposalId(
                  currentDAO.dao.dao,
                  propData.op,
                  propData.to,
                  BigInt(propData.value),
                  propData.data,
                  propData.nonce,
                  BigInt(cfg)
                );
                const idStr = recomputedId.toString();
                if (!proposalVerificationMap.has(idStr)) {
                  proposalVerificationMap.set(idStr, { description: propData.description, data: propData.data });
                }
              }
            } catch (e) {
              logger.error('Error pre-computing proposal ID:', e);
            }
          }
        }

        proposalsReversed.forEach(proposal => {
          const proposalDiv = document.createElement('div');
          proposalDiv.className = 'proposal-item';

          // Convert state to number for comparison (might be BigInt)
          // Default to 0 if invalid to prevent NaN
          const state = proposal.state !== undefined && proposal.state !== null ? Number(proposal.state) : 0;
          const stateText = PROPOSAL_STATES[state] || `State ${state}`;
          const stateClass = stateText.toLowerCase();

          const forVotes = ethers.formatUnits(proposal.forVotes, 18);
          const againstVotes = ethers.formatUnits(proposal.againstVotes, 18);
          const abstainVotes = ethers.formatUnits(proposal.abstainVotes, 18);

          // Determine button state based on proposal state and timelock settings
          // State 2 = Queued (timelock running), State 3 = Succeeded (passed, ready to execute)
          const timelockDelay = Number(currentDAO.dao.gov?.timelockDelay || 0);
          const queuedAt = Number(proposal.queuedAt || 0);
          const currentTime = Math.floor(Date.now() / 1000);

          let buttonText = '';
          let buttonAction = '';
          let buttonDisabled = false;
          let timeRemaining = '';

          if (state === 3) {
            // Succeeded - check if already queued and timelock elapsed
            if (timelockDelay > 0) {
              if (queuedAt > 0) {
                // Already queued, check if timelock elapsed
                const unlockTime = queuedAt + timelockDelay;
                if (currentTime >= unlockTime) {
                  buttonText = 'Execute';
                  buttonAction = `executeProposalFromData('${proposal.id.toString()}')`;
                } else {
                  // Shouldn't normally be in Succeeded state during timelock, but handle it
                  buttonText = 'Queue';
                  buttonAction = `queueProposal('${proposal.id.toString()}')`;
                }
              } else {
                // Not queued yet, show queue button
                buttonText = 'Queue';
                buttonAction = `queueProposal('${proposal.id.toString()}')`;
              }
            } else {
              buttonText = 'Execute';
              buttonAction = `executeProposalFromData('${proposal.id.toString()}')`;
            }
          } else if (state === 2) {
            // Queued - check if timelock has elapsed
            if (queuedAt > 0 && timelockDelay > 0) {
              const unlockTime = queuedAt + timelockDelay;
              if (currentTime < unlockTime) {
                // Still in timelock
                const secondsRemaining = unlockTime - currentTime;
                const hours = Math.floor(secondsRemaining / 3600);
                const minutes = Math.floor((secondsRemaining % 3600) / 60);
                timeRemaining = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
                buttonText = `Queued (${timeRemaining})`;
                buttonAction = '';
                buttonDisabled = true;
              } else {
                // Timelock elapsed, ready to execute
                buttonText = 'Execute';
                buttonAction = `executeProposalFromData('${proposal.id.toString()}')`;
              }
            } else {
              // Queued but no timelock data, assume executable
              buttonText = 'Execute';
              buttonAction = `executeProposalFromData('${proposal.id.toString()}')`;
            }
          }

          const isExecutable = buttonText !== '';

          // Check if user has voted (0 = not voted, 1 = voted against, 2 = voted for, 3 = voted abstain)
          const hasVotedValue = userVoteStatus[proposal.id.toString()] || 0;
          const userHasVoted = hasVotedValue > 0;
          const userVoteType = hasVotedValue > 0 ? ['Against', 'For', 'Abstain'][hasVotedValue - 1] : null;

          // Find proposal description from pre-built verification map (O(1) lookup)
          let description = `Proposal #${proposal.id.toString()}`;
          let isVerified = false;
          let verificationBadge = '';
          let proposalCalldata = null;
          let hasMessages = currentDAO.dao.messages && currentDAO.dao.messages.length > 0;

          const verifiedData = proposalVerificationMap.get(proposal.id.toString());
          if (verifiedData) {
            description = verifiedData.description || description;
            isVerified = true;
            proposalCalldata = verifiedData.data;
          }

          // Only show unverified badge if we have a COMPLETE message history AND config
          // When the message window is partial (chat messages push proposal messages out
          // of the loaded window), suppress the badge to avoid false positives
          if (hasCompleteMessages && configFetched && !isVerified) {
            verificationBadge = '<span style="color: #e74c3c; font-size: 0.9rem; margin-left: 0.5rem;" title="âš  Proposal data not found in messages - cannot verify integrity">âš  Unverified</span>';
          }

          // Create SwissKnife link if calldata exists and is not empty
          let calldataLink = '';
          if (proposalCalldata && proposalCalldata !== '0x' && proposalCalldata.length > 2) {
            calldataLink = `
              <div style="margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px solid var(--border-muted);">
                <a href="https://calldata.swiss-knife.xyz/decoder?calldata=${proposalCalldata}"
                   target="_blank"
                   rel="noopener noreferrer"
                   style="font-size: 0.8rem; color: #000; text-decoration: none; display: inline-flex; align-items: center; gap: 0.35rem; opacity: 0.8; transition: opacity 0.3s ease;"
                   onmouseover="this.style.opacity='1'"
                   onmouseout="this.style.opacity='0.8'">
                  <span>ðŸ”</span> Decode calldata on SwissKnife
                </a>
              </div>
            `;
          }

          // Check futarchy state and user receipts
          let futarchyUI = '';
          if (proposal.futarchy && proposal.futarchy.enabled && connectedAddress) {
            const futarchy = proposal.futarchy;
            const isResolved = futarchy.resolved;

            if (isResolved) {
              // Compute receipt ID for winning side
              const winnerSupport = Number(futarchy.winner); // 0 or 1
              const receiptId = ethers.solidityPackedKeccak256(
                ['string', 'uint256', 'uint8'],
                ['Moloch:receipt', proposal.id, winnerSupport]
              );

              // Check if user holds winning receipts (this will be checked async below)
              futarchyUI = `<div class="futarchy-reward-box" id="futarchy-${proposal.id.toString()}">
                <div class="futarchy-reward-title">Futarchy Rewards</div>
                <div class="futarchy-reward-info" id="futarchy-info-${proposal.id.toString()}">Checking your rewards...</div>
              </div>`;

              // Async check receipt balance and update UI
              (async () => {
                try {
                  const userReceiptBalance = await withRpcFallback(async (rpcProvider) => {
                    const mc = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, rpcProvider);
                    return await mc.balanceOf(connectedAddress, receiptId);
                  });
                  const infoDiv = document.getElementById(`futarchy-info-${proposal.id.toString()}`);
                  const boxDiv = document.getElementById(`futarchy-${proposal.id.toString()}`);

                  if (userReceiptBalance > 0n) {
                    const receiptAmount = ethers.formatUnits(userReceiptBalance, 18);
                    const payoutPerUnit = futarchy.payoutPerUnit;
                    const estimatedReward = (userReceiptBalance * payoutPerUnit) / (10n ** 18n);
                    const estimatedRewardFormatted = ethers.formatUnits(estimatedReward, 18);

                    infoDiv.innerHTML = `You have <strong>${parseFloat(receiptAmount).toFixed(4)} winning receipts</strong><br>Estimated reward: <strong>${parseFloat(estimatedRewardFormatted).toFixed(4)} LOOT</strong>`;

                    const claimBtn = document.createElement('button');
                    claimBtn.className = 'proposal-button claim';
                    claimBtn.textContent = 'Claim Rewards';
                    claimBtn.onclick = () => claimFutarchyReward(proposal.id.toString(), userReceiptBalance.toString());
                    boxDiv.appendChild(claimBtn);
                  } else {
                    boxDiv.style.display = 'none';
                  }
                } catch (e) {
                  logger.error('Error checking futarchy receipts:', e);
                  const boxDiv = document.getElementById(`futarchy-${proposal.id.toString()}`);
                  if (boxDiv) boxDiv.style.display = 'none';
                }
              })();
            }
          }

          const fullProposalId = proposal.id.toString();
          const truncatedId = fullProposalId.length > 16 ?
            fullProposalId.slice(0, 6) + '\u2026' + fullProposalId.slice(-4) :
            fullProposalId;

          // Proposer display
          const proposerAddr = proposal.proposer || '';
          const proposerDisplay = proposerAddr
            ? `<a href="${getNetwork().explorer}/address/${proposerAddr}" target="_blank" rel="noopener" title="${proposerAddr}">${proposerAddr.slice(0, 6)}\u2026${proposerAddr.slice(-4)}</a>`
            : '';

          // Vote bar percentages
          const forFloat = parseFloat(forVotes) || 0;
          const againstFloat = parseFloat(againstVotes) || 0;
          const abstainFloat = parseFloat(abstainVotes) || 0;
          const totalVotes = forFloat + againstFloat + abstainFloat;
          const forPct = totalVotes > 0 ? (forFloat / totalVotes * 100) : 0;
          const againstPct = totalVotes > 0 ? (againstFloat / totalVotes * 100) : 0;
          const abstainPct = totalVotes > 0 ? (abstainFloat / totalVotes * 100) : 0;

          proposalDiv.innerHTML = `
            <div class="proposal-header">
              <div class="proposal-header-left">
                <div class="proposal-description">${escapeHtml(description)}</div>
                <div class="proposal-meta">
                  <span title="${fullProposalId}" style="cursor: pointer;" onclick="copyProposalId('${fullProposalId}', '${proposal.id}')" id="copy-proposal-${proposal.id}">${truncatedId}</span>
                  ${proposerDisplay ? `<span class="proposal-meta-sep">&middot;</span>${proposerDisplay}` : ''}
                  ${verificationBadge}
                </div>
              </div>
              <span class="proposal-state ${stateClass}">${stateText}</span>
            </div>
            ${totalVotes > 0 ? `<div class="proposal-vote-bar"><div class="proposal-vote-bar-for" style="width:${forPct}%"></div><div class="proposal-vote-bar-against" style="width:${againstPct}%"></div><div class="proposal-vote-bar-abstain" style="width:${abstainPct}%"></div></div>` : ''}
            <div class="proposal-votes">
              <div class="proposal-vote-stat">
                <span class="proposal-vote-label for">For</span>
                <span class="proposal-vote-value">${forVotes}</span>
              </div>
              <div class="proposal-vote-stat">
                <span class="proposal-vote-label against">Against</span>
                <span class="proposal-vote-value">${againstVotes}</span>
              </div>
              <div class="proposal-vote-stat">
                <span class="proposal-vote-label">Abstain</span>
                <span class="proposal-vote-value">${abstainVotes}</span>
              </div>
            </div>
            ${calldataLink}
            <div class="proposal-actions">
              ${!userHasVoted && state === 1 ? `
                <button class="proposal-button for" onclick="voteOnProposal('${proposal.id.toString()}', 1)">Vote For</button>
                <button class="proposal-button against" onclick="voteOnProposal('${proposal.id.toString()}', 0)">Vote Against</button>
                <button class="proposal-button" onclick="voteOnProposal('${proposal.id.toString()}', 2)">Abstain</button>
              ` : ''}
              ${userHasVoted && state === 1 ? `
                <span class="user-vote-indicator">You voted: <strong>${userVoteType}</strong></span>
                <button class="proposal-button cancel" onclick="cancelVoteOnProposal('${proposal.id.toString()}')">Cancel Vote</button>
              ` : ''}
              ${isExecutable ?
                `<button class="proposal-button ${buttonText.toLowerCase().includes('queue') ? 'queue' : 'execute'}"
                         onclick="${buttonAction}"
                         ${buttonDisabled ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>${buttonText}</button>` :
                ''}
            </div>
            ${futarchyUI}
          `;

          proposalsList.appendChild(proposalDiv);
        });
        } catch (error) {
          logger.error('Error rendering proposals:', error);
          proposalsList.innerHTML = '<p style="text-align: center; color: #e74c3c; font-style: italic; margin-top: 1rem;">Failed to load proposals. Please try refreshing.</p>';
          showStatus('Failed to load proposals', true);
        }
      }

      // Vote on proposal
      async function voteOnProposal(proposalId, support) {
        if (!currentDAO || !signer) {
          showStatus('Please connect wallet and select a DAO', true);
          return;
        }

        // Prevent race condition: set flag immediately before any async work
        if (isVoting) return;
        isVoting = true;

        // Validate proposalId before converting to BigInt
        if (!proposalId || proposalId === '' || (typeof proposalId === 'string' && !/^\d+$/.test(proposalId))) {
          showStatus('Invalid proposal ID', true);
          isVoting = false;
          return;
        }
        try {
          const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, signer);

          // Convert string to BigInt (passed as string to avoid overflow in onclick)
          const proposalIdBigInt = BigInt(proposalId);

          const voteType = support === 1 ? 'For' : support === 0 ? 'Against' : 'Abstain';
          showStatus(`Casting vote ${voteType}...`, false);

          const tx = await molochContract.castVote(proposalIdBigInt, support, getWalletConnectTxOverrides());

          showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);
          await tx.wait();

          showStatus(`âœ¨ Vote ${voteType} cast! Refreshing...`, false);

          // Refresh DAO data with loading feedback
          await refreshCurrentDAO(true);
          await renderProposals();
        } catch (error) {
          logger.error('Error voting:', error);

          if (isUserRejection(error)) {
            showStatus('Vote cancelled', false);
            return;
          }

          let errorMessage = 'Failed to cast vote';

          if (error.message?.includes('already voted')) {
            errorMessage = 'You have already voted on this proposal';
          } else if (error.message?.includes('not active')) {
            errorMessage = 'Proposal is not active for voting';
          } else if (error.message?.includes('insufficient')) {
            errorMessage = 'Insufficient voting power or funds';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message) {
            const msg = error.message.split('\n')[0];
            if (msg.length < 100) {
              errorMessage = msg;
            }
          }

          showStatus(errorMessage, true);
        } finally {
          isVoting = false;
        }
      }

      // Cancel vote on proposal
      async function cancelVoteOnProposal(proposalId) {
        if (!currentDAO || !signer) {
          showStatus('Please connect wallet and select a DAO', true);
          return;
        }

        if (!confirm('Are you sure you want to cancel your vote on this proposal?')) {
          return;
        }

        // Prevent race condition: set flag immediately before any async work
        if (isCancellingVote) return;
        isCancellingVote = true;

        // Validate proposalId before converting to BigInt
        if (!proposalId || proposalId === '' || (typeof proposalId === 'string' && !/^\d+$/.test(proposalId))) {
          showStatus('Invalid proposal ID', true);
          isCancellingVote = false;
          return;
        }
        try {
          const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, signer);

          // Convert string to BigInt (passed as string to avoid overflow in onclick)
          const proposalIdBigInt = BigInt(proposalId);

          showStatus('Cancelling vote...', false);
          const tx = await molochContract.cancelVote(proposalIdBigInt, getWalletConnectTxOverrides());

          showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);
          await tx.wait();

          showStatus(`âœ¨ Vote cancelled! Refreshing...`, false);

          // Refresh DAO data with loading feedback
          await refreshCurrentDAO(true);
          await renderProposals();
        } catch (error) {
          logger.error('Error cancelling vote:', error);

          if (isUserRejection(error)) {
            showStatus('Vote cancellation aborted', false);
            return;
          }

          let errorMessage = 'Failed to cancel vote';

          if (error.message?.includes('not voted')) {
            errorMessage = 'You have not voted on this proposal';
          } else if (error.message?.includes('not active')) {
            errorMessage = 'Proposal is not active';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message) {
            const msg = error.message.split('\n')[0];
            if (msg.length < 100) {
              errorMessage = msg;
            }
          }

          showStatus(errorMessage, true);
        } finally {
          isCancellingVote = false;
        }
      }

      // Claim futarchy rewards
      async function claimFutarchyReward(proposalId, amountStr) {
        if (!currentDAO || !signer) {
          showStatus('Please connect wallet and select a DAO', true);
          return;
        }

        // Validate inputs before converting to BigInt
        if (!proposalId || proposalId === '' || (typeof proposalId === 'string' && !/^\d+$/.test(proposalId))) {
          showStatus('Invalid proposal ID', true);
          return;
        }
        if (!amountStr || amountStr === '' || (typeof amountStr === 'string' && !/^\d+$/.test(amountStr))) {
          showStatus('Invalid amount', true);
          return;
        }

        try {
          const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, signer);

          // Convert string to BigInt
          const proposalIdBigInt = BigInt(proposalId);
          const amount = BigInt(amountStr);

          showStatus('Claiming futarchy rewards...', false);
          const tx = await molochContract.cashOutFutarchy(proposalIdBigInt, amount, getWalletConnectTxOverrides());

          showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);
          const receipt = await tx.wait();

          showStatus(`âœ¨ Rewards claimed! Refreshing...`, false);

          // Refresh DAO data with loading feedback
          await refreshCurrentDAO(true);
          await renderProposals();
        } catch (error) {
          logger.error('Error claiming futarchy rewards:', error);

          if (isUserRejection(error)) {
            showStatus('Claim cancelled', false);
            return;
          }

          let errorMessage = 'Failed to claim rewards';

          if (error.message?.includes('not enabled')) {
            errorMessage = 'Futarchy not enabled for this proposal';
          } else if (error.message?.includes('not resolved')) {
            errorMessage = 'Futarchy market not yet resolved';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message) {
            const msg = error.message.split('\n')[0];
            if (msg.length < 100) {
              errorMessage = msg;
            }
          }

          showStatus(errorMessage, true);
        }
      }

      // Update calldata preview link in proposal form
      function updateCalldataPreview() {
        const calldataInput = getEl('proposalData');
        const previewDiv = document.getElementById('calldataPreview');
        const previewLink = document.getElementById('calldataPreviewLink');

        if (!calldataInput || !previewDiv || !previewLink) return;

        const calldata = calldataInput.value.trim();

        // Show link only if calldata is not empty and not just "0x"
        if (calldata && calldata !== '0x' && calldata.length > 2) {
          previewLink.href = `https://calldata.swiss-knife.xyz/decoder?calldata=${calldata}`;
          previewDiv.style.display = 'block';
        } else {
          previewDiv.style.display = 'none';
        }
      }

      // Update target address hint to show token symbol if recognized
      function updateTargetAddressHint() {
        const addressInput = getEl('proposalTo');
        const hintDiv = document.getElementById('targetAddressHint');
        const hintBadge = document.getElementById('targetAddressHintBadge');
        const valueGroup = document.getElementById('proposalValueGroup');

        if (!addressInput || !hintDiv || !hintBadge) return;

        const address = addressInput.value.trim().toLowerCase();

        // Check if address matches any known tokens
        const tokenMap = {
          [TOKEN_ADDRESSES.usdc.toLowerCase()]: 'USDC Token',
          [TOKEN_ADDRESSES.usdt.toLowerCase()]: 'USDT Token',
          [TOKEN_ADDRESSES.dai.toLowerCase()]: 'DAI Token',
          [TOKEN_ADDRESSES.wsteth.toLowerCase()]: 'wstETH Token',
          [TOKEN_ADDRESSES.reth.toLowerCase()]: 'rETH Token'
        };

        // Add shares and loot tokens if currentDAO is available
        if (currentDAO && currentDAO.dao && currentDAO.dao.meta) {
          if (currentDAO.dao.meta.sharesToken) {
            tokenMap[currentDAO.dao.meta.sharesToken.toLowerCase()] = `${currentDAO.dao.meta.symbol} Shares`;
          }
          if (currentDAO.dao.meta.lootToken) {
            tokenMap[currentDAO.dao.meta.lootToken.toLowerCase()] = `${currentDAO.dao.meta.symbol} Loot`;
          }
        }

        // Add the DAO's own address for self-calls
        if (currentDAO && currentDAO.dao && currentDAO.dao.dao) {
          if (address === currentDAO.dao.dao.toLowerCase()) {
            tokenMap[address] = `${currentDAO.dao.meta.symbol} DAO (Self-Call)`;
          }
        }

        if (tokenMap[address]) {
          hintBadge.textContent = `ðŸ“ ${tokenMap[address]}`;
          hintDiv.style.display = 'block';

          // Hide ETH value field for ERC20 tokens (no reason to send ETH to them)
          if (valueGroup) {
            valueGroup.style.display = 'none';
            getEl('proposalValue').value = '0';
          }
        } else {
          hintDiv.style.display = 'none';

          // Show ETH value field for non-token addresses
          if (valueGroup) {
            valueGroup.style.display = 'block';
          }
        }

        // Update calldata translation when target changes
        updateCalldataTranslation();
      }

      // Translate calldata for known ERC20 functions
      function updateCalldataTranslation() {
        const targetInput = getEl('proposalTo');
        const calldataInput = getEl('proposalData');
        const translationDiv = document.getElementById('calldataTranslation');

        if (!targetInput || !calldataInput || !translationDiv) return;

        const target = targetInput.value.trim().toLowerCase();
        const calldata = calldataInput.value.trim();

        // Only translate if targeting a known ERC20 token
        const tokenInfo = {
          [TOKEN_ADDRESSES.usdc.toLowerCase()]: { symbol: 'USDC', decimals: 6 },
          [TOKEN_ADDRESSES.usdt.toLowerCase()]: { symbol: 'USDT', decimals: 6 },
          [TOKEN_ADDRESSES.dai.toLowerCase()]: { symbol: 'DAI', decimals: 18 },
          [TOKEN_ADDRESSES.wsteth.toLowerCase()]: { symbol: 'wstETH', decimals: 18 },
          [TOKEN_ADDRESSES.reth.toLowerCase()]: { symbol: 'rETH', decimals: 18 }
        };

        // Add shares and loot tokens if currentDAO is available
        if (currentDAO && currentDAO.dao && currentDAO.dao.meta) {
          if (currentDAO.dao.meta.sharesToken) {
            tokenInfo[currentDAO.dao.meta.sharesToken.toLowerCase()] = {
              symbol: currentDAO.dao.meta.symbol,
              decimals: 18
            };
          }
          if (currentDAO.dao.meta.lootToken) {
            tokenInfo[currentDAO.dao.meta.lootToken.toLowerCase()] = {
              symbol: `${currentDAO.dao.meta.symbol}-LOOT`,
              decimals: 18
            };
          }
        }

        const token = tokenInfo[target];

        // Check if this is a DAO self-call
        let isDaoSelfCall = false;
        if (currentDAO && currentDAO.dao && currentDAO.dao.dao) {
          isDaoSelfCall = (target === currentDAO.dao.dao.toLowerCase());
        }

        if (!calldata || calldata === '0x' || calldata.length < 10) {
          translationDiv.style.display = 'none';
          return;
        }

        // If it's neither a token nor a DAO self-call, don't translate
        if (!token && !isDaoSelfCall) {
          translationDiv.style.display = 'none';
          return;
        }

        try {
          const functionSelector = calldata.slice(0, 10).toLowerCase();
          const abiCoder = new ethers.AbiCoder();
          let translation = '';

          // setAutoFutarchy(uint256 param, uint256 cap) - 0x92a023a9 (for DAO self-calls)
          if (isDaoSelfCall && functionSelector === '0x92a023a9' && calldata.length >= 138) {
            const decoded = abiCoder.decode(['uint256', 'uint256'], '0x' + calldata.slice(10));
            const param = decoded[0];
            const cap = decoded[1];

            let futarchyDesc = 'Disabled';
            if (param > 0n && cap > 0n) {
              const paramBps = Number(param);
              const paramPercent = (paramBps / 100).toFixed(2);
              const capFormatted = parseFloat(ethers.formatEther(cap)).toFixed(1);
              futarchyDesc = `${paramPercent}% of supply, ${capFormatted} LOOT cap`;
            }

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Configure Auto-Futarchy</div>
              <div>Set voter rewards: <strong>${futarchyDesc}</strong></div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">DAO self-call (governance)</div>
            `;
          }
          // setQuorumBps(uint16) - 0x0527aab6
          else if (isDaoSelfCall && functionSelector === '0x0527aab6' && calldata.length >= 74) {
            const decoded = abiCoder.decode(['uint16'], '0x' + calldata.slice(10));
            const bps = Number(decoded[0]);
            const percent = (bps / 100).toFixed(2);

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Change Quorum</div>
              <div>Set quorum to: <strong>${percent}%</strong></div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">DAO self-call (governance)</div>
            `;
          }
          // setRagequittable(bool) - 0x174c480e
          else if (isDaoSelfCall && functionSelector === '0x174c480e' && calldata.length >= 74) {
            const decoded = abiCoder.decode(['bool'], '0x' + calldata.slice(10));
            const enabled = decoded[0];
            const status = enabled ? 'Enable' : 'Disable';

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Toggle Ragequit</div>
              <div><strong>${status}</strong> ragequit functionality</div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">DAO self-call (governance)</div>
            `;
          }
          // setTransfersLocked(bool,bool) - 0x80fe038f
          else if (isDaoSelfCall && functionSelector === '0x80fe038f' && calldata.length >= 138) {
            const decoded = abiCoder.decode(['bool', 'bool'], '0x' + calldata.slice(10));
            const sharesLocked = decoded[0];
            const lootLocked = decoded[1];

            const sharesStatus = sharesLocked ? 'Locked (non-transferable)' : 'Unlocked (transferable)';
            const lootStatus = lootLocked ? 'Locked (non-transferable)' : 'Unlocked (transferable)';

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Configure Transferability</div>
              <div style="margin-bottom: 0.25rem;"><strong>Shares:</strong> ${sharesStatus}</div>
              <div><strong>Loot:</strong> ${lootStatus}</div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">DAO self-call (governance)</div>
            `;
          }
          // setProposalTTL(uint64) - 0xff391467
          else if (isDaoSelfCall && functionSelector === '0xff391467' && calldata.length >= 74) {
            const decoded = abiCoder.decode(['uint64'], '0x' + calldata.slice(10));
            const ttlSeconds = Number(decoded[0]);
            const ttlFormatted = formatDuration(ttlSeconds);

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Change Proposal TTL</div>
              <div>Set proposal expiration to: <strong>${ttlFormatted}</strong></div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">DAO self-call (governance)</div>
            `;
          }
          // setTimelockDelay(uint64) - 0x3821933a
          else if (isDaoSelfCall && functionSelector === '0x3821933a' && calldata.length >= 74) {
            const decoded = abiCoder.decode(['uint64'], '0x' + calldata.slice(10));
            const delaySeconds = Number(decoded[0]);
            const delayFormatted = formatDuration(delaySeconds);

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Change Timelock Delay</div>
              <div>Set execution delay to: <strong>${delayFormatted}</strong></div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">DAO self-call (governance)</div>
            `;
          }
          // setProposalThreshold(uint96) - 0x80ca42a1
          else if (isDaoSelfCall && functionSelector === '0x80ca42a1' && calldata.length >= 74) {
            const decoded = abiCoder.decode(['uint96'], '0x' + calldata.slice(10));
            const thresholdWei = decoded[0];
            const thresholdFormatted = parseFloat(ethers.formatUnits(thresholdWei, 18)).toFixed(2);

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Change Proposal Threshold</div>
              <div>Set minimum shares to: <strong>${thresholdFormatted}</strong></div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">DAO self-call (governance)</div>
            `;
          }
          // setSale(address payToken, uint256 pricePerShare, uint256 cap, bool minting, bool active, bool isLoot) - 0x48b7fef2
          else if (isDaoSelfCall && functionSelector === '0x48b7fef2' && calldata.length >= 394) {
            const decoded = abiCoder.decode(['address', 'uint256', 'uint256', 'bool', 'bool', 'bool'], '0x' + calldata.slice(10));
            const payToken = decoded[0];
            const pricePerShare = decoded[1];
            const cap = decoded[2];
            const minting = decoded[3];
            const active = decoded[4];
            const isLoot = decoded[5];

            const tokenNames = {
              [ethers.ZeroAddress.toLowerCase()]: 'ETH',
              [TOKEN_ADDRESSES.usdc.toLowerCase()]: 'USDC',
              [TOKEN_ADDRESSES.usdt.toLowerCase()]: 'USDT',
              [TOKEN_ADDRESSES.dai.toLowerCase()]: 'DAI',
              [TOKEN_ADDRESSES.wsteth.toLowerCase()]: 'wstETH',
              [TOKEN_ADDRESSES.reth.toLowerCase()]: 'rETH'
            };

            const tokenDecimals = {
              [ethers.ZeroAddress.toLowerCase()]: 18,
              [TOKEN_ADDRESSES.usdc.toLowerCase()]: 6,
              [TOKEN_ADDRESSES.usdt.toLowerCase()]: 6,
              [TOKEN_ADDRESSES.dai.toLowerCase()]: 18,
              [TOKEN_ADDRESSES.wsteth.toLowerCase()]: 18,
              [TOKEN_ADDRESSES.reth.toLowerCase()]: 18
            };

            // Check customTokenCache for custom tokens
            let tokenName = tokenNames[payToken.toLowerCase()];
            let decimals = tokenDecimals[payToken.toLowerCase()];

            if (!tokenName && customTokenCache[payToken.toLowerCase()]) {
              tokenName = customTokenCache[payToken.toLowerCase()].symbol;
              decimals = customTokenCache[payToken.toLowerCase()].decimals;
            }

            tokenName = tokenName || 'Unknown';
            decimals = decimals || 18;

            // pricePerShare is a simple integer ratio (token-wei per share-wei)
            // For display, just show the raw number (e.g., "1" for 1:1, "2" for 2:1)
            const price = pricePerShare.toString();
            const tokenType = isLoot ? 'LOOT' : 'SHARES';
            const statusText = active ? 'Enable' : 'Disable';
            const capText = cap > 0n ? `${ethers.formatEther(cap)} cap` : 'unlimited';
            const sourceText = minting ? 'mint new' : 'from treasury';

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Configure ${tokenType} Sale</div>
              <div>${statusText}: <strong>${price}:1 ratio</strong> (${price} ${tokenName} per ${tokenType} token)</div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">${sourceText}, ${capText}</div>
            `;
          }
          // setRenderer(address) - 0x56d3163d
          else if (isDaoSelfCall && functionSelector === '0x56d3163d' && calldata.length >= 74) {
            const decoded = abiCoder.decode(['address'], '0x' + calldata.slice(10));
            const newRenderer = decoded[0];

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Change Renderer</div>
              <div>Set renderer to:</div>
              <div style="margin-top: 0.25rem; font-size: 0.8rem;"><code style="background: var(--surface-hover); padding: 0.15rem 0.35rem;">${newRenderer}</code></div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">DAO self-call (governance)</div>
            `;
          }
          // bumpConfig() - 0x7ec924db
          else if (isDaoSelfCall && functionSelector === '0x7ec924db') {
            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem; color: #c0392b;">ðŸš¨ Emergency Action</div>
              <div><strong>Bump Config Counter</strong></div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">Invalidates all pending proposals and permits</div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">DAO self-call (governance)</div>
            `;
          }
          // setPermit(uint8 op, address to, uint256 value, bytes data, bytes32 nonce, address spender, uint256 count) - 0x12374b04
          else if (isDaoSelfCall && functionSelector === '0x12374b04' && calldata.length >= 458) {
            const decoded = abiCoder.decode(['uint8', 'address', 'uint256', 'bytes', 'bytes32', 'address', 'uint256'], '0x' + calldata.slice(10));
            const op = decoded[0];
            const targetAddress = decoded[1];
            const value = decoded[2];
            const permitData = decoded[3];
            const nonce = decoded[4];
            const spender = decoded[5];
            const count = Number(decoded[6]);

            const opType = op === 0 ? 'call' : 'delegatecall';
            const action = count === 0 ? 'Revoke' : (count === 1 ? 'Grant 1 permit' : `Grant ${count} permits`);
            const usesText = count === 0 ? 'Revoke all permits' : (count === 1 ? '1 use' : `${count} uses`);

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem; color: #c0392b;">âš¡ ${action}</div>
              <div style="margin-bottom: 0.25rem;"><strong>To:</strong> ${spender.slice(0, 6)}...${spender.slice(-4)}</div>
              <div style="margin-bottom: 0.25rem;"><strong>Uses:</strong> ${usesText}</div>
              <div style="margin-bottom: 0.25rem; font-size: 0.75rem; opacity: 0.7;"><strong>Action:</strong> ${opType} to ${targetAddress.slice(0, 6)}...${targetAddress.slice(-4)}</div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">DAO self-call (governance)</div>
            `;
          }
          // spendPermit(uint8 op, address to, uint256 value, bytes data, bytes32 nonce) - 0xa8841366
          else if (isDaoSelfCall && functionSelector === '0xa8841366' && calldata.length >= 330) {
            const decoded = abiCoder.decode(['uint8', 'address', 'uint256', 'bytes', 'bytes32'], '0x' + calldata.slice(10));
            const op = decoded[0];
            const targetAddress = decoded[1];
            const value = decoded[2];
            const permitData = decoded[3];
            const nonce = decoded[4];

            const opType = op === 0 ? 'call' : 'delegatecall';

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem; color: #c0392b;">âš¡ Use Permit</div>
              <div style="margin-bottom: 0.25rem;"><strong>Execute:</strong> ${opType} to ${targetAddress.slice(0, 6)}...${targetAddress.slice(-4)}</div>
              <div style="margin-bottom: 0.25rem; font-size: 0.75rem; opacity: 0.7;">Burns 1 permit to execute action</div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">DAO self-call (permit execution)</div>
            `;
          }
          // setAllowance(address spender, address token, uint256 amount) - 0xda46098c
          else if (isDaoSelfCall && functionSelector === '0xda46098c' && calldata.length >= 202) {
            const decoded = abiCoder.decode(['address', 'address', 'uint256'], '0x' + calldata.slice(10));
            const spender = decoded[0];
            const tokenAddr = decoded[1];
            const amount = decoded[2];

            const tokenNames = {
              [ethers.ZeroAddress.toLowerCase()]: { name: 'ETH', decimals: 18 },
              [TOKEN_ADDRESSES.usdc.toLowerCase()]: { name: 'USDC', decimals: 6 },
              [TOKEN_ADDRESSES.usdt.toLowerCase()]: { name: 'USDT', decimals: 6 },
              [TOKEN_ADDRESSES.dai.toLowerCase()]: { name: 'DAI', decimals: 18 },
              [TOKEN_ADDRESSES.wsteth.toLowerCase()]: { name: 'wstETH', decimals: 18 },
              [TOKEN_ADDRESSES.reth.toLowerCase()]: { name: 'rETH', decimals: 18 }
            };

            // Add Shares and Loot if available
            if (currentDAO && currentDAO.dao && currentDAO.dao.meta) {
              if (currentDAO.dao.meta.sharesToken) {
                tokenNames[currentDAO.dao.meta.sharesToken.toLowerCase()] = { name: 'Shares', decimals: 18 };
              }
              if (currentDAO.dao.meta.lootToken) {
                tokenNames[currentDAO.dao.meta.lootToken.toLowerCase()] = { name: 'Loot', decimals: 18 };
              }
            }

            const tokenInfo = tokenNames[tokenAddr.toLowerCase()] || { name: 'Unknown', decimals: 18 };
            const formattedAmount = ethers.formatUnits(amount, tokenInfo.decimals);
            const action = amount === 0n ? 'Revoke' : 'Set';

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">${action} Spending Allowance</div>
              <div style="margin-bottom: 0.25rem;"><strong>${tokenInfo.name}:</strong> ${formattedAmount}</div>
              <div style="margin-bottom: 0.25rem;"><strong>Spender:</strong> <code style="background: var(--surface-hover); padding: 0.15rem 0.35rem;">${spender.slice(0, 6)}...${spender.slice(-4)}</code></div>
              <div style="margin-top: 0.25rem; font-size: 0.75rem; opacity: 0.7;">DAO self-call (governance)</div>
            `;
          }
          // mintFromMoloch(address recipient, uint256 amount) - 0x2806b0af
          else if (token && functionSelector === '0x2806b0af' && calldata.length >= 138) {
            const decoded = abiCoder.decode(['address', 'uint256'], '0x' + calldata.slice(10));
            const recipient = decoded[0];
            const amount = decoded[1];
            const formattedAmount = ethers.formatUnits(amount, token.decimals);

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Mint Tokens</div>
              <div>Mint <strong>${formattedAmount} ${token.symbol}</strong></div>
              <div style="margin-top: 0.25rem; font-size: 0.8rem;">To: <code style="background: var(--surface-hover); padding: 0.15rem 0.35rem;">${recipient}</code></div>
            `;
          }
          // transfer(address recipient, uint256 amount) - 0xa9059cbb
          else if (token && functionSelector === '0xa9059cbb' && calldata.length >= 138) {
            const decoded = abiCoder.decode(['address', 'uint256'], '0x' + calldata.slice(10));
            const recipient = decoded[0];
            const amount = decoded[1];
            const formattedAmount = ethers.formatUnits(amount, token.decimals);

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Transfer</div>
              <div>Send <strong>${formattedAmount} ${token.symbol}</strong></div>
              <div style="margin-top: 0.25rem; font-size: 0.8rem;">To: <code style="background: var(--surface-hover); padding: 0.15rem 0.35rem;">${recipient}</code></div>
            `;
          }
          // approve(address spender, uint256 amount) - 0x095ea7b3
          else if (token && functionSelector === '0x095ea7b3' && calldata.length >= 138) {
            const decoded = abiCoder.decode(['address', 'uint256'], '0x' + calldata.slice(10));
            const spender = decoded[0];
            const amount = decoded[1];
            const formattedAmount = amount === ethers.MaxUint256 ? 'Unlimited' : ethers.formatUnits(amount, token.decimals);

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Approve</div>
              <div>Allow <strong>${formattedAmount} ${token.symbol}</strong></div>
              <div style="margin-top: 0.25rem; font-size: 0.8rem;">Spender: <code style="background: var(--surface-hover); padding: 0.15rem 0.35rem;">${spender}</code></div>
            `;
          }
          // transferFrom(address sender, address recipient, uint256 amount) - 0x23b872dd
          else if (token && functionSelector === '0x23b872dd' && calldata.length >= 202) {
            const decoded = abiCoder.decode(['address', 'address', 'uint256'], '0x' + calldata.slice(10));
            const sender = decoded[0];
            const recipient = decoded[1];
            const amount = decoded[2];
            const formattedAmount = ethers.formatUnits(amount, token.decimals);

            translation = `
              <div style="opacity: 0.8; margin-bottom: 0.35rem; font-size: 0.8rem;">Transfer From</div>
              <div>Send <strong>${formattedAmount} ${token.symbol}</strong></div>
              <div style="margin-top: 0.25rem; font-size: 0.8rem;">From: <code style="background: var(--surface-hover); padding: 0.15rem 0.35rem;">${sender}</code></div>
              <div style="margin-top: 0.25rem; font-size: 0.8rem;">To: <code style="background: var(--surface-hover); padding: 0.15rem 0.35rem;">${recipient}</code></div>
            `;
          }

          if (translation) {
            translationDiv.innerHTML = translation;
            translationDiv.style.display = 'block';
          } else {
            translationDiv.style.display = 'none';
          }
        } catch (e) {
          logger.error('Error translating calldata:', e);
          translationDiv.style.display = 'none';
        }
      }

      // Set locked proposal description (called by populate* functions)
      // This shows the auto-generated description as locked/read-only with optional notes field
      function setLockedProposalDescription(lockedText, displayText = null) {
        const lockedDiv = getEl('proposalDescriptionLocked');
        const lockedTextEl = document.getElementById('proposalDescriptionLockedText');
        const notesField = document.getElementById('proposalDescriptionNotes');
        const regularTextarea = getEl('proposalDescription');
        const fullDescField = document.getElementById('proposalDescriptionFull');

        if (!lockedDiv || !lockedTextEl || !regularTextarea || !fullDescField) return;

        // Store the full locked text (with machine-readable tags)
        fullDescField.value = lockedText;

        // Display a cleaner version (hide the <<<TAG>>> parts for readability)
        const cleanDisplay = displayText || lockedText.replace(/<<<[\s\S]*?>>>/g, '').trim();
        lockedTextEl.textContent = cleanDisplay;

        // Show locked view, hide regular textarea
        lockedDiv.style.display = 'block';
        regularTextarea.style.display = 'none';
        regularTextarea.value = ''; // Clear regular textarea

        // Clear notes field
        if (notesField) notesField.value = '';
      }

      // Clear locked description and return to manual editing
      function clearLockedDescription() {
        const lockedDiv = getEl('proposalDescriptionLocked');
        const regularTextarea = getEl('proposalDescription');
        const fullDescField = document.getElementById('proposalDescriptionFull');
        const notesField = document.getElementById('proposalDescriptionNotes');

        if (lockedDiv) lockedDiv.style.display = 'none';
        if (regularTextarea) {
          regularTextarea.style.display = 'block';
          regularTextarea.value = '';
        }
        if (fullDescField) fullDescField.value = '';
        if (notesField) notesField.value = '';
      }

      // Get the final proposal description (locked + notes, or manual)
      function getProposalDescription() {
        const fullDescField = document.getElementById('proposalDescriptionFull');
        const notesField = document.getElementById('proposalDescriptionNotes');
        const regularTextarea = getEl('proposalDescription');

        // If we have a locked description, use it + optional notes
        if (fullDescField && fullDescField.value) {
          let desc = fullDescField.value;
          if (notesField && notesField.value.trim()) {
            // Insert notes before the machine-readable tags
            const tagMatch = desc.match(/(<<<[\s\S]*?>>>)/);
            if (tagMatch) {
              const tagIndex = desc.indexOf(tagMatch[0]);
              desc = desc.slice(0, tagIndex).trimEnd() + '\n\n--- Additional Notes ---\n' + notesField.value.trim() + '\n\n' + desc.slice(tagIndex);
            } else {
              desc += '\n\n--- Additional Notes ---\n' + notesField.value.trim();
            }
          }
          return desc;
        }

        // Otherwise use the regular textarea
        return regularTextarea ? regularTextarea.value : '';
      }

      // Create and publish proposal
      async function createProposal() {
        if (!currentDAO || !signer) {
          showStatus('Please connect wallet and select a DAO', true);
          return;
        }

        // Prevent race condition: don't allow multiple simultaneous proposal creations
        if (isCreatingProposal) return;

        const op = parseInt(document.getElementById('proposalOp').value);
        const to = getEl('proposalTo').value;
        const value = getEl('proposalValue').value;
        let data = getEl('proposalData').value || '0x';
        const description = getProposalDescription();

        if (!to || !value || !description) {
          showStatus('Please fill in all required fields', true);
          return;
        }

        // Validate and normalize inputs
        try {
          // Ensure data is valid hex
          if (!data.startsWith('0x')) {
            data = '0x' + data;
          }
          if (data.length % 2 !== 0) {
            throw new Error('Data must be valid hex (even number of characters)');
          }

          // Validate address
          if (!ethers.isAddress(to)) {
            throw new Error('Invalid target address');
          }
        } catch (validationError) {
          showStatus('Validation error: ' + validationError.message, true);
          return;
        }

        // Generate random nonce (32 bytes)
        const nonce = ethers.hexlify(ethers.randomBytes(32));

        isCreatingProposal = true;
        try {
          const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, signer);

          // Get config from DAO
          const config = await molochContract.config();

          // Compute proposal ID locally
          const valueWei = ethers.parseEther(value);
          const computedProposalId = computeProposalId(currentDAO.dao.dao, op, to, valueWei, data, nonce, config);

          // Encode proposal as message
          // The tagged JSON contains all execution parameters
          // The description is included in the JSON for readability
          const proposalMessage = encodeProposalMessage(op, to, valueWei, data, nonce, description);

          // Create interface for encoding multicall data
          const iface = new ethers.Interface(MOLOCH_ABI);

          // Encode chat call
          const chatCalldata = iface.encodeFunctionData('chat', [proposalMessage]);

          // Encode openProposal call
          const openProposalCalldata = iface.encodeFunctionData('openProposal', [computedProposalId]);

          // Execute multicall (chat + openProposal in one transaction)
          showStatus('Creating proposal...', false);
          const tx = await molochContract.multicall([chatCalldata, openProposalCalldata], getWalletConnectTxOverrides());

          showStatus('Transaction submitted. Waiting for confirmation...', false);
          await tx.wait();

          showStatus(`âœ¨ Proposal created! Refreshing...`, false);

          // Clear form (reset op to 0/call)
          document.getElementById('proposalOp').value = '0';
          getEl('proposalTo').value = '';
          getEl('proposalValue').value = '';
          getEl('proposalData').value = '';
          getEl('proposalDescription').value = '';

          // Clear locked description if present
          clearLockedDescription();

          // Clear UI hints
          updateTargetAddressHint();
          updateCalldataTranslation();
          updateCalldataPreview();

          // Refresh with loading feedback
          await refreshCurrentDAO(true);
          await renderChatroom();
          await renderProposals();
        } catch (error) {
          logger.error('Error creating proposal:', error);

          if (isUserRejection(error)) {
            showStatus('Proposal creation cancelled', false);
            return;
          }

          let errorMessage = 'Failed to create proposal';

          if (error.message?.includes('insufficient funds')) {
            errorMessage = 'Insufficient funds for transaction';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message) {
            // Only show concise error, not the full dump
            const msg = error.message.split('\n')[0]; // Take first line only
            if (msg.length < 100) {
              errorMessage = msg;
            }
          }

          showStatus(errorMessage, true);
        } finally {
          isCreatingProposal = false;
        }
      }

      // Queue a proposal (start timelock countdown)
      async function queueProposal(proposalId) {
        if (!currentDAO || !signer) {
          showStatus('Please connect wallet and select a DAO', true);
          return;
        }

        // Validate proposalId before converting to BigInt
        if (!proposalId || proposalId === '' || (typeof proposalId === 'string' && !/^\d+$/.test(proposalId))) {
          showStatus('Invalid proposal ID', true);
          return;
        }

        // Convert string to BigInt
        const proposalIdBigInt = BigInt(proposalId);

        try {
          const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, signer);

          showStatus('Queueing proposal...', false);
          const tx = await molochContract.queue(proposalIdBigInt, getWalletConnectTxOverrides());

          showStatus('Transaction submitted. Waiting for confirmation...', false);
          await tx.wait();

          showStatus('âœ¨ Proposal queued! Timelock started.', false);

          // Refresh to show updated state
          await refreshCurrentDAO(true);
          await renderProposals();
        } catch (error) {
          logger.error('Error queueing proposal:', error);

          if (isUserRejection(error)) {
            showStatus('Queue cancelled', false);
            return;
          }

          let errorMessage = 'Failed to queue proposal';
          if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message) {
            const msg = error.message.split('\n')[0];
            if (msg.length < 100) {
              errorMessage = msg;
            }
          }

          showStatus(errorMessage, true);
        }
      }

      // Execute proposal by extracting parameters from tagged message
      async function executeProposalFromData(proposalId) {
        // Prevent race condition: don't allow multiple simultaneous executions
        if (isExecutingProposal) return;

        // Validate proposalId before converting to BigInt
        if (!proposalId || proposalId === '' || (typeof proposalId === 'string' && !/^\d+$/.test(proposalId))) {
          showStatus('Invalid proposal ID', true);
          return;
        }

        // Convert string to BigInt (passed as string to avoid overflow in onclick)
        const proposalIdBigInt = BigInt(proposalId);

        isExecutingProposal = true;
        try {
          const molochContract = new ethers.Contract(currentDAO.dao.dao, MOLOCH_ABI, signer);
          const currentConfig = await molochContract.config();

          // Find the proposal data from messages by matching the proposal ID
          // Iterate from current config down to 0 to handle proposals created before config bumps
          let proposalData = null;
          for (const msg of currentDAO.dao.messages) {
            const propData = decodeProposalMessage(msg.text);
            if (propData) {
              const valueBigInt = BigInt(propData.value);
              for (let c = Number(currentConfig); c >= 0; c--) {
                const computedId = computeProposalId(
                  currentDAO.dao.dao,
                  propData.op,
                  propData.to,
                  valueBigInt,
                  propData.data,
                  propData.nonce,
                  BigInt(c)
                );

                if (computedId.toString() === proposalIdBigInt.toString()) {
                  proposalData = propData;
                  break;
                }
              }
              if (proposalData) break;
            }
          }

          if (!proposalData) {
            showStatus('Could not find proposal data in messages', true);
            return;
          }

          // Convert stored string value back to BigInt for proper encoding
          const valueBigInt = BigInt(proposalData.value);

          if (!confirm(`Execute proposal:\n\n${proposalData.description}\n\nOp: ${proposalData.op}\nTo: ${proposalData.to}\nValue: ${ethers.formatEther(valueBigInt)} ETH\nData: ${proposalData.data.slice(0, 66)}${proposalData.data.length > 66 ? '...' : ''}`)) {
            return;
          }

          showStatus('Executing proposal...', false);

          const tx = await molochContract.executeByVotes(
            proposalData.op,
            proposalData.to,
            valueBigInt,  // Use BigInt, not string
            proposalData.data,
            proposalData.nonce,
            getWalletConnectTxOverrides()
          );

          showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`, false);
          await tx.wait();

          showStatus(`âœ¨ Proposal executed! Refreshing...`, false);

          // Refresh with loading feedback
          await refreshCurrentDAO(true);
          await renderProposals();
          await renderSalesInfo(); // Refresh sales in case it was a sale proposal
        } catch (error) {
          logger.error('Error executing proposal:', error);

          if (isUserRejection(error)) {
            showStatus('Execution cancelled', false);
            return;
          }

          let errorMessage = 'Failed to execute proposal';

          if (error.message?.includes('not succeeded')) {
            errorMessage = 'Proposal has not passed or is not ready for execution';
          } else if (error.message?.includes('already executed')) {
            errorMessage = 'Proposal has already been executed';
          } else if (error.message?.includes('insufficient funds')) {
            errorMessage = 'Insufficient funds in treasury';
          } else if (error.shortMessage) {
            errorMessage = error.shortMessage;
          } else if (error.reason) {
            errorMessage = error.reason;
          } else if (error.message) {
            const msg = error.message.split('\n')[0];
            if (msg.length < 100) {
              errorMessage = msg;
            }
          }

          showStatus(errorMessage, true);
        } finally {
          isExecutingProposal = false;
        }
      }

      // Refresh current DAO data
      async function refreshCurrentDAO(showLoading = false) {
        if (!currentDAO || !provider || !connectedAddress) return;

        try {
          if (showLoading) {
            showStatus('Refreshing...', false);
          }

          const treasuryTokens = getNetwork().treasuryTokens;

          // Fetch more proposals and messages to ensure we see new items
          const updatedDAOs = await withRpcFallback(async (activeProvider) => {
            const viewHelper = new ethers.Contract(VIEW_HELPER_ADDRESS, VIEW_HELPER_ABI, activeProvider);
            return await viewHelper.getUserDAOsFullState(
              connectedAddress,
              0,  // daoStart
              10, // daoCount
              0,  // proposalStart
              20, // proposalCount
              0,  // messageStart
              200, // messageCount (fetch many to ensure we see recent ones)
              treasuryTokens
            );
          });

          // Find current DAO in updated list
          for (let i = 0; i < updatedDAOs.length; i++) {
            if (updatedDAOs[i].dao.dao.toLowerCase() === currentDAO.dao.dao.toLowerCase()) {
              currentDAO = updatedDAOs[i];
              userDAOs = updatedDAOs;
              break;
            }
          }

          if (showLoading) {
            showStatus('Refreshed', false);
            // Clear status after a short delay
            setTimeout(() => {
              const statusEl = document.getElementById('status');
              if (statusEl && statusEl.textContent === 'Refreshed') {
                statusEl.textContent = '';
              }
            }, 1500);
          }
        } catch (error) {
          logger.error('Error refreshing DAO:', error);
          if (showLoading) {
            showStatus('Error refreshing DAO', true);
          }
        }
      }

      // Manual refresh with button animation + rate limiting
      let lastRefreshTime = 0;
      let isRefreshing = false;

      async function manualRefreshDAO() {
        const refreshBtn = document.getElementById('refreshButton');
        if (!refreshBtn || !currentDAO) return;

        // Prevent race condition: don't allow multiple simultaneous refreshes
        if (isRefreshing) return;

        // Rate limiting check
        const now = Date.now();
        const timeSinceLastRefresh = now - lastRefreshTime;
        if (timeSinceLastRefresh < CONSTANTS.REFRESH_COOLDOWN_MS) {
          const remainingSeconds = Math.ceil((CONSTANTS.REFRESH_COOLDOWN_MS - timeSinceLastRefresh) / 1000);
          showStatus(`Please wait ${remainingSeconds}s before refreshing again`, false);
          return;
        }

        isRefreshing = true;

        // Add spinning animation
        const svg = refreshBtn.querySelector('svg');
        svg.style.animation = 'spin 1s linear infinite';
        refreshBtn.disabled = true;
        refreshBtn.style.cursor = 'not-allowed';

        try {
          // Refresh DAO data
          await refreshCurrentDAO(true);

          // Re-render all views using multicall batching (mirrors openDAO pattern)
          renderDaoStats();
          const daoAddress = currentDAO.dao.dao;
          const userAddr = signer ? await signer.getAddress() : null;

          // Fire-and-forget (no downstream dependencies)
          renderChatroom().catch(e => logger.error('renderChatroom failed:', e));

          // Batch all view calls into one RPC round-trip via Multicall3
          let batchData;
          try {
            batchData = await batchDashboardData(daoAddress, userAddr);
          } catch (e) {
            logger.warn('Multicall batch failed, falling back to individual calls:', e.message);
            batchData = { config: undefined, sales: [], allowances: [], tributes: undefined, sharesTransfersLocked: undefined, lootTransfersLocked: undefined, contractURI: undefined };
          }

          renderGovernanceInfo(batchData).catch(e => logger.error('renderGovernanceInfo failed:', e));
          await Promise.all([
            renderProposals(batchData.config),
            renderSalesInfo(batchData.sales),
            renderTributes(batchData.tributes),
            renderAllowances(batchData.allowances),
            renderDAOEmblem(daoAddress, batchData.contractURI),
          ]);

          // Sequential â€” depends on renderSalesInfo completing (needs customSaleTokens)
          await renderTreasury();
          await renderMembership();
          await renderMembers();

          // Only update lastRefreshTime after successful completion
          lastRefreshTime = Date.now();
        } catch (error) {
          logger.error('Error during manual refresh:', error);
          showStatus('Failed to refresh DAO', true);
        } finally {
          // Remove spinning animation
          svg.style.animation = '';
          refreshBtn.disabled = false;
          refreshBtn.style.cursor = 'pointer';
          isRefreshing = false;
        }
      }

      let memberIdCounter = 0;

      function createMemberRow(address = '', shares = '', isFirst = false) {
        const row = document.createElement('div');
        row.className = 'member-row';
        row.dataset.memberId = memberIdCounter++;

        row.innerHTML = `
          <input type="text" class="form-input member-address" placeholder="0x... or ENS name" value="${address}" ${isFirst ? 'readonly' : ''}>
          <input type="number" class="form-input member-shares" placeholder="Shares" value="${shares}" min="0.000000000000000001" step="any">
          ${!isFirst ? '<button type="button" class="remove-member" onclick="removeMember(this)">Ã—</button>' : ''}
        `;

        return row;
      }

      function addMemberRow() {
        const memberRow = createMemberRow();
        document.getElementById('foundingMembersList').appendChild(memberRow);
        updateLootInputs();
      }

      function removeMember(button) {
        button.parentElement.remove();
        updateLootInputs();
      }

      function toggleAdvanced() {
        const advanced = document.getElementById('advancedSettings');
        advanced.classList.toggle('show');
        document.querySelector('.advanced-toggle').textContent =
          advanced.classList.contains('show') ? 'â–² Advanced Settings' : 'â–¼ Advanced Settings';
      }

      async function resolveENS(input) {
        if (input.endsWith('.eth')) {
          try {
            const address = await provider.resolveName(input);
            if (address) return address;
            throw new Error(`Could not resolve ENS name: ${input}`);
          } catch (e) {
            logger.error('ENS resolution failed:', e);
            throw new Error(`Invalid ENS name: ${input}`);
          }
        }
        return input;
      }

      // Debounce utility for performance optimization
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Create enhanced empty state
      function createEmptyState(icon, title, description, actionText = null, actionCallback = null) {
        const container = document.createElement('div');
        container.style.cssText = `
          grid-column: 1/-1;
          text-align: center;
          padding: 3rem 1.5rem;
          color: var(--fg-dim);
        `;

        container.innerHTML = `
          <div style="font-size: 3rem; margin-bottom: 1rem; opacity: 0.6;">${icon}</div>
          <div style="font-size: 1rem; color: var(--fg); margin-bottom: 0.5rem; letter-spacing: 0.1em;">${title}</div>
          <div style="font-size: 0.9rem; font-style: italic; max-width: 400px; margin: 0 auto;">${description}</div>
        `;

        if (actionText && actionCallback) {
          const button = document.createElement('button');
          button.textContent = actionText;
          button.style.cssText = `
            margin-top: 1.5rem;
            padding: 0.75rem 1.5rem;
            background: var(--surface-hover);
            border: 1px solid var(--border-muted);
            color: var(--fg);
            font-size: 0.8rem;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            `;
          button.onclick = actionCallback;
          button.onmouseover = () => {
            button.style.background = '#ddd';
            button.style.borderColor = '#000';
            button.style.transform = 'translateY(-2px)';
          };
          button.onmouseout = () => {
            button.style.background = cssVar('--surface-hover');
            button.style.borderColor = '#ccc';
            button.style.transform = 'translateY(0)';
          };
          container.appendChild(button);
        }

        return container;
      }

      // Create loading skeleton
      function createSkeleton(type = 'card') {
        const skeleton = document.createElement('div');
        skeleton.className = 'skeleton';

        if (type === 'card') {
          skeleton.style.cssText = 'height: 200px; width: 100%; margin-bottom: 1rem;';
        } else if (type === 'text') {
          skeleton.style.cssText = 'height: 1rem; width: 100%; margin-bottom: 0.5rem;';
        } else if (type === 'title') {
          skeleton.style.cssText = 'height: 1.5rem; width: 60%; margin-bottom: 1rem;';
        }

        return skeleton;
      }

      // Black fire canvas animation
      function initFireCanvas(canvas, scale = 1.0) {
        const W = Math.round(200 * scale);
        const H = Math.round(280 * scale);
        const PIXEL = Math.max(1, Math.round(3 * scale));
        const cols = Math.ceil(W / PIXEL);
        const rows = Math.ceil(H / PIXEL);

        canvas.width = W;
        canvas.height = H;
        canvas.style.width = (W * 2) + 'px';
        canvas.style.height = (H * 2) + 'px';
        canvas.style.imageRendering = 'pixelated';

        const ctx = canvas.getContext('2d');

        function buildPalette(dark) {
          const p = [];
          for (let i = 0; i < 64; i++) {
            const t = i / 63;
            let r, g, b;
            if (dark) {
              // Inverted: white â†’ light gray â†’ gray â†’ dark
              if (t < 0.33) {
                const s = t / 0.33;
                r = Math.round(232 - 12 * s);
                g = Math.round(232 - 17 * s);
                b = Math.round(224 - 14 * s);
              } else if (t < 0.66) {
                const s = (t - 0.33) / 0.33;
                r = Math.round(220 - 80 * s);
                g = Math.round(215 - 75 * s);
                b = Math.round(210 - 70 * s);
              } else {
                const s = (t - 0.66) / 0.34;
                r = Math.round(140 - 120 * s);
                g = Math.round(140 - 120 * s);
                b = Math.round(140 - 120 * s);
              }
            } else {
              // Original: black â†’ dark gray â†’ gray â†’ white
              if (t < 0.33) {
                const s = t / 0.33;
                r = Math.round(20 * s);
                g = Math.round(15 * s);
                b = Math.round(10 * s);
              } else if (t < 0.66) {
                const s = (t - 0.33) / 0.33;
                r = Math.round(20 + 60 * s);
                g = Math.round(15 + 55 * s);
                b = Math.round(10 + 50 * s);
              } else {
                const s = (t - 0.66) / 0.34;
                r = Math.round(80 + 175 * s);
                g = Math.round(70 + 185 * s);
                b = Math.round(60 + 195 * s);
              }
            }
            p.push(`rgb(${r},${g},${b})`);
          }
          return p;
        }

        let palette = buildPalette(isDark());
        let bgColor = isDark() ? '#0a0a0a' : '#fff';

        const fire = new Uint8Array(cols * rows);
        let animId = null;
        let running = false;

        function seed() {
          for (let x = 0; x < cols; x++) {
            fire[(rows - 1) * cols + x] = Math.random() > 0.3 ? 63 : Math.floor(Math.random() * 20);
          }
        }

        function spread() {
          for (let y = 0; y < rows - 1; y++) {
            for (let x = 0; x < cols; x++) {
              const src = (y + 1) * cols + x;
              const randX = Math.round(Math.random() * 3) - 1;
              const decay = Math.round(Math.random() * 2);
              const dst = y * cols + Math.min(Math.max(x + randX, 0), cols - 1);
              fire[dst] = Math.max(0, fire[src] - decay);
            }
          }
        }

        function render() {
          ctx.fillStyle = bgColor;
          ctx.fillRect(0, 0, W, H);
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              const val = fire[y * cols + x];
              if (val > 0) {
                ctx.fillStyle = palette[val];
                ctx.fillRect(x * PIXEL, y * PIXEL, PIXEL, PIXEL);
              }
            }
          }
        }

        function updateTheme() {
          const dark = isDark();
          palette = buildPalette(dark);
          bgColor = dark ? '#0a0a0a' : '#fff';
        }

        function loop() {
          if (!running) return;
          seed();
          spread();
          render();
          animId = requestAnimationFrame(loop);
        }

        function start() {
          if (running) return;
          running = true;
          loop();
        }

        function stop() {
          running = false;
          if (animId) {
            cancelAnimationFrame(animId);
            animId = null;
          }
        }

        start();
        return { start, stop, updateTheme };
      }

      function showFireLoading(container) {
        const div = document.createElement('div');
        div.className = 'fire-loading';
        const canvas = document.createElement('canvas');
        div.appendChild(canvas);
        container.innerHTML = '';
        container.appendChild(div);
        return initFireCanvas(canvas, 0.5);
      }

      function hideHeroFire() {
        const el = document.getElementById('fireHero');
        if (el) el.classList.add('hide');
        if (heroFire) { heroFire.stop(); }
      }

      // Show loading state
      function showLoadingState(container, count = 3, type = 'card') {
        if (!container) return;
        container.innerHTML = '';
        for (let i = 0; i < count; i++) {
          container.appendChild(createSkeleton(type));
        }
      }

      // Toast notification system
      function showToast(message, type = 'info', duration = 4000) {
        const container = document.getElementById('toastContainer');
        if (!container) return;

        const toast = document.createElement('div');
        toast.className = 'toast';

        let icon = 'â„¹ï¸';
        let color = '#000';

        if (type === 'success') {
          icon = 'âœ¨';
          color = '#2d8a2d';
        } else if (type === 'error') {
          icon = 'âš ï¸';
          color = '#e74c3c';
        } else if (type === 'warning') {
          icon = 'âš¡';
          color = '#ffc107';
        }

        toast.innerHTML = `
          <div style="display: flex; align-items: center; gap: 0.75rem;">
            <div style="font-size: 1.5rem;">${icon}</div>
            <div style="flex: 1; color: ${color}; ">${message}</div>
          </div>
        `;

        container.appendChild(toast);

        // Auto remove
        setTimeout(() => {
          toast.style.animation = 'fadeOut 0.3s ease-out forwards';
          setTimeout(() => {
            container.removeChild(toast);
          }, 300);
        }, duration);
      }

      // Keyboard shortcuts (consolidated)
      document.addEventListener('keydown', (e) => {
        // ESC to close modals
        if (e.key === 'Escape') {
          closeNFTModal();
          closeWalletModal();
          closePurchaseModal();
          closeRagequitModal();
        }

        // Ctrl/Cmd + B to go back to gallery
        if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
          e.preventDefault();
          if (currentDAO) {
            backToGallery();
          }
        }

        // Ctrl/Cmd + / to show keyboard shortcuts
        if ((e.ctrlKey || e.metaKey) && e.key === '/') {
          e.preventDefault();
          showToast('Keyboard Shortcuts: Cmd/Ctrl+B = Back to Gallery | ESC = Close Modals', 'info', 6000);
        }
      });

      let statusTimeout = null;

      function showStatus(message, isError = false, type = 'info', autoDismiss = true) {
        const statusEl = document.getElementById('statusMessage');

        // Clear existing timeout
        if (statusTimeout) {
          clearTimeout(statusTimeout);
          statusTimeout = null;
        }

        // Determine status class
        let statusClass = 'status-message';
        if (isError) {
          statusClass += ' error-message';
        } else if (type === 'success') {
          statusClass += ' success';
        } else if (type === 'warning') {
          statusClass += ' warning';
        }

        // Add spinner for loading states
        const spinner = message.includes('...') && !message.includes('âœ¨') && !message.includes('href=')
          ? '<span class="spinner"></span>'
          : '';

        statusEl.innerHTML = `<div class="${statusClass}">${spinner}${message}</div>`;

        // Auto-dismiss success messages after delay
        if (autoDismiss && !isError) {
          const delay = message.includes('âœ¨') ? 8000 : 6000;
          statusTimeout = setTimeout(() => {
            const msgEl = statusEl.querySelector('.status-message');
            if (msgEl) {
              msgEl.style.animation = 'fadeOut 0.3s ease-out forwards';
              setTimeout(() => {
                statusEl.innerHTML = '';
              }, 300);
            }
          }, delay);
        }
      }



      function copyProposalId(proposalId, proposalIdForButton) {
        // Use modern clipboard API
        navigator.clipboard.writeText(proposalId).then(() => {
          // Visual feedback on the element
          const el = document.getElementById(`copy-proposal-${proposalIdForButton}`);
          if (el) {
            const originalText = el.textContent;
            const originalColor = el.style.color;

            el.textContent = 'copied';
            el.style.color = '#2d8a2d';

            // Reset after 2 seconds
            setTimeout(() => {
              el.textContent = originalText;
              el.style.color = originalColor || '';
            }, 2000);
          }

          showStatus('Proposal ID copied to clipboard', false);
        }).catch((err) => {
          logger.error('Failed to copy:', err);
          showStatus('Failed to copy proposal ID', true);
        });
      }

      // Sale payment token dropdown functions
      let selectedSalePaymentToken = 'eth';
      const salePaymentTokenIcons = {
        eth: TOKEN_ICONS.eth,
        usdc: TOKEN_ICONS.usdc,
        usdt: TOKEN_ICONS.usdt,
        dai: TOKEN_ICONS.dai,
        wsteth: TOKEN_ICONS.wsteth,
        reth: TOKEN_ICONS.reth,
        defaultCoin: TOKEN_ICONS.defaultCoin
      };

      function toggleSalePaymentTokenDropdown() {
        const dropdown = getEl('salePaymentTokenDropdown');
        dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
      }

      function selectSalePaymentToken(token) {
        const preset = getEl('initialSalePreset')?.value;
        const isDaico = preset === 'daico';

        // For internal sale, don't allow 6-decimal tokens (USDC, USDT)
        if (!isDaico && (token === 'usdc' || token === 'usdt')) {
          showStatus(`${token.toUpperCase()} (6 decimals) is only available for DAICO sales`, true);
          return;
        }

        selectedSalePaymentToken = token;
        getEl('salePaymentToken').value = token;

        // Show/hide custom token fields (address input only - decimals are fetched automatically)
        const customTokenFields = document.getElementById('customTokenFields');
        if (customTokenFields) {
          customTokenFields.style.display = token === 'custom' ? 'block' : 'none';
        }

        // Update display
        const iconEl = document.getElementById('salePaymentTokenIcon');
        const labelEl = document.getElementById('salePaymentTokenLabel');
        if (iconEl && labelEl) {
          if (token === 'custom') {
            iconEl.innerHTML = salePaymentTokenIcons.defaultCoin;
            labelEl.textContent = 'CUSTOM TOKEN';
          } else {
            iconEl.innerHTML = salePaymentTokenIcons[token] || salePaymentTokenIcons.defaultCoin;
            labelEl.textContent = token.toUpperCase();
          }
        }

        // Close dropdown
        getEl('salePaymentTokenDropdown').style.display = 'none';

        // Update hint and DAICO labels
        if (typeof updateSummonerSaleHint === 'function') {
          updateSummonerSaleHint();
        }
        updateDaicoLabels();
        updateDaicoSaleSummary();
      }

      // Toggle internal payment token dropdown
      function toggleInternalPaymentTokenDropdown() {
        const dropdown = document.getElementById('internalPaymentTokenDropdown');
        if (dropdown) {
          dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
        }
      }

      // Select internal payment token (Custom or DAI)
      function selectInternalPaymentToken(token) {
        document.getElementById('internalPaymentToken').value = token;

        // Show/hide custom token fields
        const customTokenFields = document.getElementById('customTokenFields');
        if (customTokenFields) {
          customTokenFields.style.display = token === 'custom' ? 'block' : 'none';
        }

        // Update display
        const iconEl = document.getElementById('internalPaymentTokenIcon');
        const labelEl = document.getElementById('internalPaymentTokenLabel');
        const summaryEl = document.getElementById('internalWrapSummary');

        if (iconEl && labelEl) {
          if (token === 'custom') {
            iconEl.innerHTML = salePaymentTokenIcons.defaultCoin || TOKEN_ICONS.defaultCoin;
            labelEl.textContent = 'Custom Token (18 decimals)';
            if (summaryEl) {
              summaryEl.innerHTML = 'Users deposit tokens â†’ receive DAO shares 1:1<br><span style="opacity: 0.7;">With ragequit enabled, users can burn shares to reclaim tokens anytime.</span>';
            }
          } else if (token === 'dai') {
            iconEl.innerHTML = salePaymentTokenIcons.dai;
            labelEl.textContent = 'DAI';
            if (summaryEl) {
              summaryEl.innerHTML = 'Users deposit DAI â†’ receive DAO shares 1:1<br><span style="opacity: 0.7;">DAI goes to DAO treasury. With ragequit enabled, users can exit to claim treasury share.</span>';
            }
          }
        }

        // Close dropdown
        document.getElementById('internalPaymentTokenDropdown').style.display = 'none';
      }

      // Close internal payment dropdown when clicking outside
      document.addEventListener('click', function(e) {
        const dropdown = document.getElementById('internalPaymentTokenDropdown');
        const display = document.getElementById('internalPaymentTokenDisplay');
        if (dropdown && display && !dropdown.contains(e.target) && !display.contains(e.target)) {
          dropdown.style.display = 'none';
        }
      });

      // Format number with commas for DAICO inputs
      function formatDaicoNumberInput(input) {
        // Get cursor position
        const cursorPos = input.selectionStart;
        const oldLength = input.value.length;

        // Remove non-numeric chars except decimal point
        let value = input.value.replace(/[^\d.]/g, '');

        // Handle multiple decimal points
        const parts = value.split('.');
        if (parts.length > 2) {
          value = parts[0] + '.' + parts.slice(1).join('');
        }

        // Format with commas
        if (value) {
          const [intPart, decPart] = value.split('.');
          const formattedInt = intPart.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
          value = decPart !== undefined ? formattedInt + '.' + decPart : formattedInt;
        }

        input.value = value;

        // Adjust cursor position
        const newLength = input.value.length;
        const diff = newLength - oldLength;
        input.setSelectionRange(cursorPos + diff, cursorPos + diff);
      }

      // Parse formatted number (remove commas)
      function parseDaicoNumber(str) {
        if (!str) return NaN;
        return parseFloat(str.replace(/,/g, ''));
      }

      // Update DAICO field labels based on selected tokens
      function updateDaicoLabels() {
        const payToken = getEl('salePaymentToken')?.value || 'eth';
        const tokenType = getEl('saleTokenType')?.value || 'shares';

        const tokenNames = {
          'eth': 'ETH', 'dai': 'DAI', 'usdc': 'USDC', 'usdt': 'USDT',
          'wsteth': 'wstETH', 'reth': 'rETH', 'custom': 'TOKEN'
        };

        const payLabel = document.getElementById('daicoPayTokenLabel');
        const receiveLabel = document.getElementById('daicoReceiveLabel');

        if (payLabel) payLabel.textContent = `(${tokenNames[payToken] || 'TOKEN'})`;
        if (receiveLabel) receiveLabel.textContent = `(${tokenType === 'loot' ? 'Loot' : 'Shares'})`;
      }

      // Update DAICO sale summary
      function updateDaicoSaleSummary() {
        const preset = getEl('initialSalePreset')?.value;
        if (preset !== 'daico') return;

        const tribAmt = parseDaicoNumber(document.getElementById('daicoTribAmt')?.value);
        const forAmt = parseDaicoNumber(document.getElementById('daicoForAmt')?.value);
        const supply = parseDaicoNumber(getEl('daicoSaleSupply')?.value);
        const payToken = getEl('salePaymentToken')?.value || 'eth';
        const tokenType = getEl('saleTokenType')?.value || 'shares';

        // Check LP and Tap settings
        const enableLP = getEl('daicoSummonEnableLP')?.checked;
        const lpBps = parseInt(document.getElementById('daicoSummonLpBps')?.value || '0');
        const enableTap = getEl('daicoSummonEnableTap')?.checked;

        const summaryBox = document.getElementById('daicoSaleSummaryBox');
        const summaryText = document.getElementById('daicoSaleSummaryText');
        const priceText = document.getElementById('daicoSalePriceText');

        if (!summaryBox || !summaryText || !priceText) return;

        const tokenNames = {
          'eth': 'ETH', 'dai': 'DAI', 'usdc': 'USDC', 'usdt': 'USDT',
          'wsteth': 'wstETH', 'reth': 'rETH', 'custom': 'tokens'
        };
        const payName = tokenNames[payToken] || 'tokens';
        const tokenTypeName = tokenType === 'loot' ? 'Loot' : 'Shares';

        if (!tribAmt || !forAmt || isNaN(tribAmt) || isNaN(forAmt) || tribAmt <= 0 || forAmt <= 0) {
          summaryBox.style.display = 'none';
          return;
        }

        summaryBox.style.display = 'block';

        // Format numbers nicely
        const formatNum = (n) => n >= 1000 ? n.toLocaleString() : n.toString();

        // Main summary: "1 ETH â†’ 1,000,000 Shares"
        let mainSummary = `<span style="color: #000;">${formatNum(tribAmt)} ${payName}</span> â†’ <span style="color: #000;">${formatNum(forAmt)} ${tokenTypeName}</span>`;

        // Show effective rate if LP is enabled
        if (enableLP && lpBps > 0 && lpBps < 100) {
          const effectiveTokens = forAmt * (100 - lpBps) / 100;
          mainSummary += `<br><span style="color: #4466aa; font-size: 0.85rem;">With ${lpBps}% LP: buyer receives ${formatNum(Math.round(effectiveTokens))} ${tokenTypeName}</span>`;
        }

        summaryText.innerHTML = mainSummary;

        // Price calculation
        const pricePerToken = tribAmt / forAmt;
        const tokensPerUnit = forAmt / tribAmt;

        let priceStr = '';
        if (pricePerToken < 0.0001) {
          priceStr = `${formatNum(tokensPerUnit)} ${tokenTypeName} per ${payName}`;
        } else {
          priceStr = `${pricePerToken.toFixed(6)} ${payName} per ${tokenTypeName.slice(0, -1)}`;
        }

        // Add max raise if supply is set
        if (supply && !isNaN(supply) && supply > 0) {
          const maxRaise = supply * pricePerToken;
          priceStr += ` â€¢ Max raise: ${formatNum(Math.round(maxRaise * 100) / 100)} ${payName}`;
        }

        // Add feature badges
        let features = [];
        if (enableLP && lpBps > 0) features.push(`<span style="color: #4466aa;">LP ${lpBps}%</span>`);
        if (enableTap) features.push(`<span style="color: #b8860b;">Tap</span>`);
        if (features.length > 0) {
          priceStr += ` â€¢ ${features.join(' + ')}`;
        }

        priceText.innerHTML = priceStr;
      }

      // Validate custom payment token for DAICO (auto-fetch decimals)
      let customPaymentTokenTimeout = null;
      async function validateCustomPaymentToken() {
        const inputEl = getEl('customTokenAddress');
        const tokenAddress = inputEl?.value?.trim();
        const infoDiv = document.getElementById('customPaymentTokenInfo');
        const decimalsInput = document.getElementById('customTokenDecimals');

        if (!infoDiv) return;

        // Clear previous timeout for debouncing
        if (customPaymentTokenTimeout) {
          clearTimeout(customPaymentTokenTimeout);
        }

        if (!tokenAddress || tokenAddress.length === 0) {
          infoDiv.innerHTML = '';
          return;
        }

        if (!ethers.isAddress(tokenAddress)) {
          infoDiv.innerHTML = '<span style="color: #e74c3c;">Invalid address format</span>';
          return;
        }

        // Debounce the validation
        customPaymentTokenTimeout = setTimeout(async () => {
          if (!provider) {
            infoDiv.innerHTML = '<span style="color: #e74c3c;">Connect wallet to validate token</span>';
            return;
          }

          infoDiv.innerHTML = '<span style="opacity: 0.6;">Fetching token info...</span>';

          try {
            const checksummedAddress = ethers.getAddress(tokenAddress);
            const tokenContract = new ethers.Contract(checksummedAddress, ERC20_ABI, provider);

            // Fetch token info
            let name = 'Unknown', symbol = 'TOKEN', decimals = 18;

            try {
              [name, symbol, decimals] = await Promise.all([
                tokenContract.name().catch(() => 'Unknown'),
                tokenContract.symbol().catch(() => 'TOKEN'),
                tokenContract.decimals().catch(() => 18)
              ]);
              decimals = Number(decimals);
            } catch (e) {
              logger.warn('Failed to fetch some token info:', e);
            }

            // Store decimals in hidden field
            if (decimalsInput) {
              decimalsInput.value = decimals;
            }

            infoDiv.innerHTML = `<span style="color: #000;">âœ“ ${name} (${symbol})</span> <span style="opacity: 0.6;">â€¢ ${decimals} decimals</span>`;
          } catch (err) {
            logger.error('Token validation error:', err);
            infoDiv.innerHTML = '<span style="color: #e74c3c;">Failed to validate token. Ensure it\'s a valid ERC20.</span>';
          }
        }, 500); // 500ms debounce
      }

      // Validate custom sale token in summoning form
      async function validateCustomSaleToken() {
        try {
          const inputEl = document.getElementById('customSaleTokenAddress');
          const tokenAddress = inputEl?.value?.trim();
          const infoDiv = document.getElementById('customSaleTokenInfo');

          if (!infoDiv) {
            return;
          }

          if (!tokenAddress || tokenAddress.length === 0) {
            infoDiv.innerHTML = '<span style="color: #e74c3c;">Please enter a token address</span>';
            return;
          }

          if (!ethers.isAddress(tokenAddress)) {
            infoDiv.innerHTML = '<span style="color: #e74c3c;">Invalid Ethereum address format</span>';
            return;
          }

          // Normalize to checksummed address
          const checksummedAddress = ethers.getAddress(tokenAddress);

          if (!provider) {
            infoDiv.innerHTML = '<span style="color: #e74c3c;">Wallet not connected</span>';
            showStatus('Please connect your wallet first', true);
            return;
          }

          infoDiv.innerHTML = 'Validating token...';

          const tokenContract = new ethers.Contract(checksummedAddress, ERC20_ABI, provider);

          // Fetch token info with individual error handling
          let name, symbol, decimals;

          try {
            name = await tokenContract.name();
          } catch (e) {
            logger.warn('Failed to fetch token name:', e);
            name = 'Unknown';
          }

          try {
            symbol = await tokenContract.symbol();
          } catch (e) {
            logger.warn('Failed to fetch token symbol:', e);
            symbol = 'UNKNOWN';
          }

          try {
            decimals = await tokenContract.decimals();
          } catch (e) {
            logger.warn('Failed to fetch token decimals:', e);
            infoDiv.innerHTML = '<span style="color: #e74c3c;">Failed to fetch decimals - not a valid ERC20 token</span>';
            return;
          }

          // Validate it's 18 decimals (required for sales)
          const decimalsNum = Number(decimals);
          if (decimalsNum !== 18) {
            infoDiv.innerHTML = `<span style="color: #e74c3c;">âŒ Invalid: Token has ${decimalsNum} decimals (must be 18)</span>`;
            return;
          }

          // Success - show token info
          infoDiv.innerHTML = `
            <div style="padding: 0.5rem; background: var(--status-success); border-left: 3px solid var(--green); ">
              <div>âœ“ <strong>${name}</strong> (${symbol})</div>
              <div style="font-size: 0.7rem; opacity: 0.8; margin-top: 0.25rem;">${decimals} decimals - Valid for sale</div>
              <div style="font-size: 0.65rem; opacity: 0.6; margin-top: 0.25rem; font-family: monospace;">${checksummedAddress}</div>
            </div>
          `;

          // Cache the result
          customTokenCache[checksummedAddress.toLowerCase()] = { name, symbol, decimals: decimalsNum };

        } catch (error) {
          logger.error('Error validating custom sale token:', error);
          const infoDiv = document.getElementById('customSaleTokenInfo');

          let errorMsg = 'Failed to validate token';
          if (error.message) {
            if (error.message.includes('network') || error.message.includes('connection')) {
              errorMsg = 'Network error - check your connection';
            } else if (error.message.includes('invalid') || error.message.includes('not a contract')) {
              errorMsg = 'Invalid token address - not an ERC20 contract';
            } else {
              errorMsg = `Error: ${error.message.slice(0, 100)}`;
            }
          }

          if (infoDiv) {
            infoDiv.innerHTML = `<span style="color: #e74c3c;">${errorMsg}</span>`;
          }
        }
      }

      // Initialize token icons in summoning form dropdown
      function initializeSalePaymentTokenIcons() {
        // Initialize DAICO display icon with ETH (default selection)
        const displayIcon = document.getElementById('salePaymentTokenIcon');
        if (displayIcon) {
          displayIcon.innerHTML = salePaymentTokenIcons.eth;
        }

        // Initialize internal payment token icon (default: custom/defaultCoin)
        const internalIcon = document.getElementById('internalPaymentTokenIcon');
        if (internalIcon) {
          internalIcon.innerHTML = salePaymentTokenIcons.defaultCoin || TOKEN_ICONS.defaultCoin;
        }

        // Initialize dropdown icons
        const dropdownIcons = document.querySelectorAll('.token-dropdown-icon');
        dropdownIcons.forEach(iconEl => {
          const token = iconEl.getAttribute('data-token');
          if (token && salePaymentTokenIcons[token]) {
            iconEl.innerHTML = salePaymentTokenIcons[token];
          } else if (token === 'defaultCoin' && TOKEN_ICONS.defaultCoin) {
            iconEl.innerHTML = TOKEN_ICONS.defaultCoin;
          }
        });
      }

      // Toggle DAICO summon LP configuration fields
      function toggleDaicoSummonLPFields() {
        const enableLP = getEl('daicoSummonEnableLP');
        const lpFields = document.getElementById('daicoSummonLPFields');
        if (lpFields) {
          lpFields.style.display = enableLP?.checked ? 'block' : 'none';
        }
      }

      // Toggle DAICO summon Tap configuration fields
      function toggleDaicoSummonTapFields() {
        const enableTap = getEl('daicoSummonEnableTap');
        const tapFields = document.getElementById('daicoSummonTapFields');
        if (tapFields) {
          tapFields.style.display = enableTap?.checked ? 'block' : 'none';
        }
      }

      // Update DAICO summon Tap preview
      function updateDaicoSummonTapPreview() {
        const paymentToken = getEl('salePaymentToken')?.value || 'eth';
        const tapRateInput = document.getElementById('daicoSummonTapRate');
        const tapBudgetInput = document.getElementById('daicoSummonTapBudget');
        const preview = document.getElementById('daicoSummonTapPreview');

        if (!preview) return;

        // Get token symbol
        const tokenSymbols = { eth: 'ETH', usdc: 'USDC', usdt: 'USDT', dai: 'DAI', wsteth: 'wstETH', reth: 'rETH', custom: 'tokens' };
        const tribSymbol = tokenSymbols[paymentToken] || 'tokens';

        const ratePerMonth = parseFloat(tapRateInput?.value?.replace(/,/g, '') || '0');
        const budget = parseFloat(tapBudgetInput?.value?.replace(/,/g, '') || '0');

        if (ratePerMonth > 0) {
          const ratePerYear = ratePerMonth * 12;
          let text = `<strong>Tap:</strong> ${ratePerMonth.toLocaleString()} ${tribSymbol}/month (~${ratePerYear.toLocaleString()} ${tribSymbol}/year)`;
          if (budget > 0) {
            const months = budget / ratePerMonth;
            text += ` â€¢ Budget lasts ~${months.toFixed(1)} months`;
          }
          preview.innerHTML = text;
          preview.style.display = 'block';
        } else {
          preview.style.display = 'none';
        }
      }

      function toggleSaleConfig() {
        const preset = getEl('initialSalePreset').value;
        const section = document.getElementById('saleConfigSection');
        const isDaico = preset === 'daico';
        const isInternal = preset === 'internal';

        section.style.display = (isDaico || isInternal) ? 'block' : 'none';

        // Toggle field visibility based on sale type
        const internalFields = document.getElementById('internalSaleFields');
        const daicoFields = document.getElementById('daicoSaleFields');
        const daicoSupplyField = document.getElementById('daicoSupplyField');
        const saleTypeDesc = document.getElementById('saleTypeDescText');
        const internalPaymentGroup = document.getElementById('internalPaymentTokenGroup');
        const daicoPaymentGroup = document.getElementById('daicoPaymentTokenGroup');
        const tokenTypeGroup = getEl('saleTokenType')?.parentElement;

        // DAICO LP and Tap sections
        const daicoLPSection = document.getElementById('daicoSummonLPSection');
        const daicoTapSection = document.getElementById('daicoSummonTapSection');

        if (internalFields) internalFields.style.display = isInternal ? 'block' : 'none';
        if (daicoFields) daicoFields.style.display = isDaico ? 'block' : 'none';
        if (daicoSupplyField) daicoSupplyField.style.display = isDaico ? 'block' : 'none';

        // Show LP and Tap sections only for DAICO
        if (daicoLPSection) daicoLPSection.style.display = isDaico ? 'block' : 'none';
        if (daicoTapSection) daicoTapSection.style.display = isDaico ? 'block' : 'none';

        // Show appropriate payment token selector
        if (internalPaymentGroup) internalPaymentGroup.style.display = isInternal ? 'block' : 'none';
        if (daicoPaymentGroup) daicoPaymentGroup.style.display = isDaico ? 'block' : 'none';

        // Update sale type description
        if (saleTypeDesc) {
          if (isInternal) {
            saleTypeDesc.innerHTML = '<strong>Token Wrapping (1:1 Mint):</strong> Users deposit tokens and receive DAO shares at a 1:1 ratio. Built into the DAO contract. Ideal for token upgrades, migrations, or accepting stablecoin contributions.';
          } else if (isDaico) {
            saleTypeDesc.innerHTML = '<strong>Token Sale (DAICO):</strong> Flexible token sale with custom pricing. Supports any payment token (ETH, USDC, DAI, etc). Set your own price ratio to raise funds.';
          }
        }

        // Set up event listeners for real-time hints when section is shown
        if (isDaico || isInternal) {
          setTimeout(() => {
            const priceInput = getEl('salePrice');
            const capInput = getEl('saleCap');
            const tokenInput = getEl('salePaymentToken');
            const typeInput = getEl('saleTokenType');
            const customTokenInput = getEl('customTokenAddress');
            const daicoTribAmt = document.getElementById('daicoTribAmt');
            const daicoForAmt = document.getElementById('daicoForAmt');
            const daicoSupply = getEl('daicoSaleSupply');

            // Remove old listeners before adding new ones to prevent memory leaks
            if (priceInput) priceInput.removeEventListener('input', updateSummonerSaleHint);
            if (capInput) capInput.removeEventListener('input', updateSummonerSaleHint);
            if (tokenInput) tokenInput.removeEventListener('change', updateSummonerSaleHint);
            if (typeInput) typeInput.removeEventListener('change', updateSummonerSaleHint);
            if (customTokenInput) customTokenInput.removeEventListener('input', updateSummonerSaleHint);
            if (daicoTribAmt) daicoTribAmt.removeEventListener('input', updateSummonerSaleHint);
            if (daicoForAmt) daicoForAmt.removeEventListener('input', updateSummonerSaleHint);
            if (daicoSupply) daicoSupply.removeEventListener('input', updateSummonerSaleHint);

            // Combined update function for hints and warnings
            const updateSaleUI = () => {
              updateSummonerSaleHint();
              updateSaleThresholdWarning();
            };

            // Add fresh listeners
            if (priceInput) priceInput.addEventListener('input', updateSaleUI);
            if (capInput) capInput.addEventListener('input', updateSaleUI);
            if (tokenInput) tokenInput.addEventListener('change', updateSaleUI);
            if (typeInput) typeInput.addEventListener('change', updateSaleUI);
            if (customTokenInput) customTokenInput.addEventListener('input', updateSaleUI);
            if (daicoTribAmt) daicoTribAmt.addEventListener('input', updateSaleUI);
            if (daicoForAmt) daicoForAmt.addEventListener('input', updateSaleUI);
            if (daicoSupply) daicoSupply.addEventListener('input', updateSaleUI);

            // Also listen for minting checkbox changes
            const mintingCheckbox = document.getElementById('saleMinting');
            if (mintingCheckbox) mintingCheckbox.addEventListener('change', updateSaleUI);

            // Listen for proposal threshold changes
            const thresholdInput = getEl('proposalThreshold');
            if (thresholdInput) thresholdInput.addEventListener('input', updateSaleUI);

            updateSaleUI(); // Initial update
          }, 10);
        }
      }

      // Update proposal threshold warning for shares sales
      function updateSaleThresholdWarning() {
        const preset = getEl('initialSalePreset')?.value;
        const tokenType = getEl('saleTokenType')?.value;
        const proposalThreshold = getEl('proposalThreshold')?.value;
        const warning = document.getElementById('saleThresholdWarning');
        const warningText = document.getElementById('saleThresholdWarningText');

        if (!warning) return;

        // Show warning if selling shares AND proposal threshold is set
        const isSellingShares = tokenType === 'shares';
        const hasThreshold = proposalThreshold && parseFloat(proposalThreshold) > 0;
        const isDaico = preset === 'daico';
        const isInternal = preset === 'internal';

        // Internal sale (1:1 wrapping) is a different use case - show info instead of warning
        if (isInternal && isSellingShares && hasThreshold && warningText) {
          const thresholdVal = parseFloat(proposalThreshold);
          warningText.innerHTML = `<strong>Note:</strong> Token wrapping gives holders voting shares. Since this is 1:1 wrapping (not a sale), the value transferred equals voting power gained. Consider using LOOT if you want non-voting wrappers.`;
          warning.style.display = 'block';
          warning.style.background = '#f5f8ff';
          warning.style.borderLeftColor = '#aac8e8';
          return;
        }

        // DAICO sale warnings
        if (isDaico && isSellingShares && hasThreshold && warningText) {
          const thresholdVal = parseFloat(proposalThreshold);
          const supplyInput = getEl('daicoSaleSupply')?.value?.replace(/,/g, '');
          const saleAmount = supplyInput ? parseFloat(supplyInput) : 0;

          // Reset to warning style
          warning.style.background = '#fdf8f0';
          warning.style.borderLeftColor = '#ddc040';

          if (saleAmount > 0 && saleAmount > thresholdVal) {
            warningText.innerHTML = `Sale supply (${saleAmount.toLocaleString()} shares) exceeds proposal threshold (${thresholdVal.toLocaleString()} shares). A single buyer could gain enough voting power to pass proposals. Consider selling LOOT instead or reducing the supply.`;
          } else if (saleAmount > 0 && saleAmount <= thresholdVal) {
            warningText.innerHTML = `Sale supply (${saleAmount.toLocaleString()}) is within threshold (${thresholdVal.toLocaleString()}). This is safer, but buyers could still accumulate shares if the sale is renewed.`;
          } else {
            warningText.innerHTML = `Selling voting shares with a proposal threshold may allow buyers to accumulate enough shares to pass proposals. Consider selling LOOT (non-voting) for public sales.`;
          }
          warning.style.display = 'block';
        } else {
          warning.style.display = 'none';
        }
      }

      // Update summoner form sale hint
      function updateSummonerSaleHint() {
        const preset = getEl('initialSalePreset')?.value;
        const isDaico = preset === 'daico';
        const isInternal = preset === 'internal';

        const tokenType = getEl('saleTokenType')?.value || 'shares';
        const internalPaymentToken = document.getElementById('internalPaymentToken')?.value || 'custom';

        const hint = document.getElementById('summonerSaleHint');
        const hintText = document.getElementById('summonerSaleHintText');

        if (!hint || !hintText) return;

        const tokenTypeText = tokenType === 'loot' ? 'Loot' : 'Shares';

        if (isDaico) {
          // DAICO uses the inline summary box instead
          hint.style.display = 'none';
          return;
        } else if (isInternal) {
          // Internal sale is always 1:1 now - show simple summary
          const tokenNames = { 'custom': 'Custom Token', 'dai': 'DAI' };
          const payTokenName = tokenNames[internalPaymentToken] || 'Token';

          hintText.innerHTML = `<strong>1:1 Wrapping:</strong> 1 ${payTokenName} â†’ 1 ${tokenTypeText}. Open-ended mint with no cap.`;
          hint.style.display = 'block';
          return;
        }

        // Hide hint when no sale selected
        hint.style.display = 'none';
      }


      // Add loot distribution toggle handler
      getEl('distributeLoot')?.addEventListener('change', (e) => {
        document.getElementById('lootDistribution').style.display = e.target.checked ? 'block' : 'none';
        if (e.target.checked) {
          updateLootInputs();
        }
      });

      // Add equal loot toggle handler
      document.getElementById('equalLoot')?.addEventListener('change', (e) => {
        document.getElementById('customLootAmounts').style.display = e.target.checked ? 'none' : 'block';
        updateLootInputs();
      });

      // Update loot inputs when members change
      function updateLootInputs() {
        if (!getEl('distributeLoot').checked) return;
        if (document.getElementById('equalLoot').checked) return;

        const customLootDiv = document.getElementById('customLootAmounts');
        const memberRows = document.querySelectorAll('.member-row');

        customLootDiv.innerHTML = '<div style="font-size: 0.8rem; color: var(--fg-dim); margin-bottom: 0.5rem;">Custom loot per member:</div>';

        memberRows.forEach((row, index) => {
          const addressInput = row.querySelector('.member-address').value || `Member ${index + 1}`;
          const shortAddr = addressInput.startsWith('0x') ?
            addressInput.slice(0, 6) + '...' + addressInput.slice(-4) :
            addressInput;

          const lootInput = document.createElement('div');
          lootInput.style.marginBottom = '0.5rem';
          lootInput.innerHTML = `
            <label style="font-size: 0.8rem; color: var(--fg);">${shortAddr}</label>
            <input type="number" class="form-input custom-loot-amount" data-member-index="${index}"
                   placeholder="0" min="0" step="any" style="margin-top: 0.25rem;">
          `;
          customLootDiv.appendChild(lootInput);
        });
      }

      // Helper to calculate seconds from value and unit
      function getSecondsFromInput(valueId, unitId) {
        const value = parseInt(document.getElementById(valueId).value || 0);
        const unit = parseInt(document.getElementById(unitId).value || 1);
        return value * unit;
      }

      // Update quorum votes display in summoning form
      function updateSummonQuorumDisplay() {
        const quorumBpsInput = getEl('quorumBps');
        const display = document.getElementById('quorumVotesDisplay');
        const warning = document.getElementById('quorumWarning');
        const votesValue = document.getElementById('quorumVotesValue');
        const totalSupplySpan = document.getElementById('quorumTotalSupply');

        if (!quorumBpsInput || !display || !warning) return;

        // Calculate total shares from all members
        const memberRows = document.querySelectorAll('.member-row');
        let totalShares = 0n;

        for (const row of memberRows) {
          const sharesInput = row.querySelector('.member-shares');
          if (sharesInput && sharesInput.value) {
            try {
              const shares = ethers.parseEther(sharesInput.value.trim());
              totalShares += shares;
            } catch (e) {
              // Invalid input, skip
            }
          }
        }

        const quorumBps = Math.floor(parseFloat(quorumBpsInput.value || 50) * 100);

        if (totalShares > 0n) {
          // Calculate required votes: floor(quorumBps * totalShares / 10_000)
          const requiredVotes = (BigInt(quorumBps) * totalShares) / 10000n;
          const totalSharesFormatted = parseFloat(ethers.formatEther(totalShares)).toFixed(2);

          votesValue.textContent = ethers.formatEther(requiredVotes);
          totalSupplySpan.textContent = totalSharesFormatted;
          display.style.display = 'block';

          // Show warning if rounds to 0
          if (quorumBps > 0 && totalShares > 0n && requiredVotes === 0n) {
            warning.style.display = 'block';
          } else {
            warning.style.display = 'none';
          }
        } else {
          display.style.display = 'none';
          warning.style.display = 'none';
        }
      }

      // Set up event listeners for quorum display updates
      getEl('quorumBps')?.addEventListener('input', updateSummonQuorumDisplay);

      // Update quorum display when members change (debounced)
      let quorumUpdateTimeout;
      document.addEventListener('input', (e) => {
        if (e.target.classList.contains('member-shares') || e.target.classList.contains('member-address')) {
          clearTimeout(quorumUpdateTimeout);
          quorumUpdateTimeout = setTimeout(updateSummonQuorumDisplay, 300);
        }
      });

      // Also update when members are added/removed
      const foundingMembersList = document.getElementById('foundingMembersList');
      if (foundingMembersList) {
        const observer = new MutationObserver(() => {
          updateSummonQuorumDisplay();
        });
        observer.observe(foundingMembersList, { childList: true });
      }

      document.getElementById('summonForm').addEventListener('submit', async (e) => {
        e.preventDefault();

        if (!signer) {
          await connectWallet();
          if (!signer) return;
        }

        const summonBtn = document.getElementById('summonBtn');
        summonBtn.disabled = true;
        summonBtn.textContent = 'SUMMONING...';

        try {
          // Check network
          if (!connectedWalletProvider) {
            throw new Error('Wallet not connected');
          }
          const walletChainIdHex = await connectedWalletProvider.request({ method: 'eth_chainId' });
          if (BigInt(walletChainIdHex) !== 1n) {
            throw new Error('Please switch to Ethereum Mainnet');
          }

          // Recreate provider/signer to ensure we're on the correct network
          provider = new ethers.BrowserProvider(connectedWalletProvider);
          signer = await provider.getSigner();

          // Gather form data
          const daoName = getEl('daoName').value;
          const daoSymbol = getEl('daoSymbol').value;
          const daoDescription = document.getElementById('daoDescription').value.trim();
          const daoImageURI = document.getElementById('daoImageURI')?.value.trim() || '';

          // Build contractURI with description (defaults to DUNA if empty) and optional image
          const daoURI = buildContractURI(daoName, daoSymbol, daoDescription, daoImageURI);
          const quorumBps = Math.floor(parseFloat(getEl('quorumBps').value || 50) * 100);
          const ragequittable = document.getElementById('ragequittable').checked;

          // Collect members
          const memberRows = document.querySelectorAll('.member-row');
          const initHolders = [];
          const initShares = [];

          for (const row of memberRows) {
            const addressInput = row.querySelector('.member-address').value.trim();
            const sharesInput = row.querySelector('.member-shares').value;

            if (addressInput && sharesInput) {
              const address = await resolveENS(addressInput);
              if (!ethers.isAddress(address)) {
                throw new Error(`Invalid address: ${addressInput}`);
              }

              initHolders.push(address);
              // Convert shares to wei (18 decimals) - ethers v6
              initShares.push(ethers.parseEther(sharesInput));
            }
          }

          if (initHolders.length === 0) {
            throw new Error('At least one member is required');
          }

          // Calculate total initial shares for validation
          let totalShares = 0n;
          for (const shares of initShares) {
            totalShares += shares;
          }

          // Validate quorum settings
          const requiredVotes = (BigInt(quorumBps) * totalShares) / 10000n;
          if (quorumBps > 0 && totalShares > 0n && requiredVotes === 0n) {
            const continueAnyway = confirm(
              'âš ï¸ WARNING: Your quorum percentage and initial supply combination results in 0 required votes for quorum.\n\n' +
              'This effectively disables dynamic quorum for proposals.\n\n' +
              'Recommendations:\n' +
              'â€¢ Increase quorum percentage\n' +
              'â€¢ Increase initial supply\n' +
              'â€¢ Set an absolute quorum after deployment\n\n' +
              'Do you want to continue anyway?'
            );
            if (!continueAnyway) {
              throw new Error('Summoning cancelled due to invalid quorum configuration');
            }
          }

          // Validate proposal threshold if specified
          const proposalThresholdInput = getEl('proposalThreshold').value;
          let proposalThresholdWei = 0n;
          if (proposalThresholdInput && parseFloat(proposalThresholdInput) > 0) {
            proposalThresholdWei = ethers.parseEther(proposalThresholdInput);

            // Calculate max potential voting shares (initial + DAICO sale if selling shares)
            let maxPotentialShares = totalShares;
            const salePreset = getEl('initialSalePreset').value;
            const saleTokenType = getEl('saleTokenType').value;

            if (salePreset === 'daico' && saleTokenType === 'shares') {
              const daicoSupplyInput = getEl('daicoSaleSupply').value?.replace(/,/g, '');
              if (daicoSupplyInput && parseFloat(daicoSupplyInput) > 0) {
                maxPotentialShares += ethers.parseEther(daicoSupplyInput);
              }
            }

            if (proposalThresholdWei > maxPotentialShares) {
              const supplyDesc = salePreset === 'daico' && saleTokenType === 'shares'
                ? `total potential shares (${ethers.formatEther(totalShares)} initial + ${getEl('daicoSaleSupply').value || '0'} DAICO = ${ethers.formatEther(maxPotentialShares)})`
                : `total initial shares (${ethers.formatEther(totalShares)})`;
              throw new Error(`Proposal threshold (${proposalThresholdInput}) cannot exceed ${supplyDesc}`);
            }
          }

          // Generate random salt ONCE for this entire summon operation
          const salt = ethers.randomBytes(32);
          const saltHex = ethers.hexlify(salt);


          // Connect to summoner
          const summoner = new ethers.Contract(SUMMONER_ADDRESS, SUMMONER_ABI, signer);

          // Ensure initShares are BigInt for consistent encoding
          const initSharesForPrediction = initShares.map(s => BigInt(s.toString()));

          // Predict all addresses using the Solidity reference implementation
          const predictions = predictMajeurAddresses(
            initHolders,
            initSharesForPrediction,
            salt
          );

          const predictedDao = predictions.dao;
          const predictedShares = predictions.shares;
          const predictedLoot = predictions.loot;

          // Prepare init calls with predicted DAO address
          const initCalls = [];

          // Add proposal TTL setting if specified
          const proposalTTL = getSecondsFromInput('proposalTTL', 'proposalTTLUnit');
          if (proposalTTL > 0) {
            initCalls.push({
              target: predictedDao, // Self-call to the DAO
              value: 0n,
              data: INTERFACES.setProposalTTL.encodeFunctionData('setProposalTTL', [proposalTTL])
            });
          }

          // Add timelock delay setting if specified
          const timelockDelay = getSecondsFromInput('timelockDelay', 'timelockDelayUnit');
          if (timelockDelay > 0) {
            initCalls.push({
              target: predictedDao, // Self-call to the DAO
              value: 0n,
              data: INTERFACES.setTimelockDelay.encodeFunctionData('setTimelockDelay', [timelockDelay])
            });
          }

          // Add loot distribution if enabled
          const distributeLoot = getEl('distributeLoot').checked;
          if (distributeLoot) {
            // Collect loot amounts for each member
            const lootAmounts = [];
            const equalLoot = document.getElementById('equalLoot').checked;

            if (equalLoot) {
              // Equal distribution
              const lootPerMember = document.getElementById('lootPerMember').value || '100';
              const lootAmount = ethers.parseEther(lootPerMember);
              for (let i = 0; i < initHolders.length; i++) {
                lootAmounts.push(lootAmount);
              }
            } else {
              // Custom amounts
              const customInputs = document.querySelectorAll('.custom-loot-amount');
              for (let i = 0; i < initHolders.length; i++) {
                const input = customInputs[i];
                const amount = input?.value || '0';
                lootAmounts.push(ethers.parseEther(amount));
              }
            }

            // To mint loot during init, we use the predicted loot proxy address
            // Create direct loot minting calls

            for (let i = 0; i < initHolders.length; i++) {
              if (lootAmounts[i] > 0n) {
                initCalls.push({
                  target: predictedLoot,
                  value: 0n,
                  data: INTERFACES.mintFromMoloch.encodeFunctionData('mintFromMoloch', [
                    initHolders[i],
                    lootAmounts[i]
                  ])
                });
              }
            }

          }

          // Add proposal threshold setting if specified
          if (proposalThresholdWei > 0n) {
            initCalls.push({
              target: predictedDao, // Self-call to the DAO
              value: 0n,
              data: INTERFACES.setProposalThreshold.encodeFunctionData('setProposalThreshold', [proposalThresholdWei])
            });
          }

          // Add transferability settings if either is enabled
          const enableSharesTransfer = document.getElementById('enableSharesTransfer').checked;
          const enableLootTransfer = document.getElementById('enableLootTransfer').checked;

          if (enableSharesTransfer || enableLootTransfer) {
            // Call setTransfersLocked(bool sharesLocked, bool lootLocked)
            // Note: false = unlocked/transferable, true = locked/non-transferable
            initCalls.push({
              target: predictedDao, // Self-call to the DAO
              value: 0n,
              data: INTERFACES.setTransfersLocked.encodeFunctionData('setTransfersLocked', [
                !enableSharesTransfer, // Invert: checkbox=true means unlocked, so sharesLocked=false
                !enableLootTransfer    // Invert: checkbox=true means unlocked, so lootLocked=false
              ])
            });
          }

          // Add auto-futarchy preset if not "off"
          const futarchyPreset = document.getElementById('autoFutarchyPreset').value;
          if (futarchyPreset !== 'off') {
            let param = 0n;
            let cap = 0n;

            // Configure based on preset
            if (futarchyPreset === 'low') {
              param = 5n;  // 5 bps (0.05%)
              cap = ethers.parseEther('2');  // 2 LOOT
            } else if (futarchyPreset === 'standard') {
              param = 10n;  // 10 bps (0.1%)
              cap = ethers.parseEther('5');  // 5 LOOT
            } else if (futarchyPreset === 'high') {
              param = 50n;  // 50 bps (0.5%)
              cap = ethers.parseEther('10');  // 10 LOOT
            }

            // Add setAutoFutarchy call
            initCalls.push({
              target: predictedDao, // Self-call to the DAO
              value: 0n,
              data: INTERFACES.setAutoFutarchy.encodeFunctionData('setAutoFutarchy', [param, cap])
            });
          }

          // Add initial sale configuration if enabled
          const salePreset = getEl('initialSalePreset').value;
          if (salePreset === 'internal') {
            // Internal sale (1:1 token wrapping): uses DAO's built-in setSale function
            const paymentToken = document.getElementById('internalPaymentToken').value;
            const tokenType = getEl('saleTokenType').value;

            // Internal sale is always 1:1, unlimited, minting
            const priceInput = '1';
            const capInput = '0';
            const minting = true;

            // Always configure internal 1:1 sale
            let payToken;

            // Check if custom token is selected
            if (paymentToken === 'custom') {
              const customTokenAddress = getEl('customTokenAddress').value.trim();
              if (!customTokenAddress || !ethers.isAddress(customTokenAddress)) {
                showStatus('Please enter a valid custom token address for wrapping', true);
                throw new Error('Invalid custom token address');
              }
              payToken = customTokenAddress;
            } else if (paymentToken === 'dai') {
              payToken = TOKEN_ADDRESSES.dai;
            } else {
              showStatus('Please select a token to wrap (Custom or DAI)', true);
              throw new Error('No wrap token selected');
            }

            // Internal sale is always 1:1 (pricePerShare = 1), unlimited (cap = 0), minting = true
            const pricePerShare = 1n;
            const cap = 0n;
            const isLoot = tokenType === 'loot';

            // Add setSale call for 1:1 token wrapping
            initCalls.push({
              target: predictedDao, // Self-call to the DAO
              value: 0n,
              data: INTERFACES.setSale.encodeFunctionData('setSale', [
                payToken, pricePerShare, cap, minting, true, isLoot
              ])
            });
          } else if (salePreset === 'daico') {
            // DAICO sale: uses external DAICO contract
            // Required steps:
            // 1. Mint sale supply to DAO itself (shares or loot)
            // 2. Approve DAICO contract to spend the minted tokens
            // 3. Call DAICO.setSale() to configure the sale parameters

            const paymentToken = getEl('salePaymentToken').value;
            const tokenType = getEl('saleTokenType').value;
            // Parse comma-formatted numbers
            const tribAmtInput = document.getElementById('daicoTribAmt').value?.replace(/,/g, '');
            const forAmtInput = document.getElementById('daicoForAmt').value?.replace(/,/g, '');
            const saleSupplyInput = getEl('daicoSaleSupply').value?.replace(/,/g, '');

            // Validate inputs
            if (!tribAmtInput || isNaN(parseFloat(tribAmtInput)) || parseFloat(tribAmtInput) <= 0) {
              showStatus('Please enter a valid payment amount for the sale', true);
              throw new Error('Invalid payment amount');
            }
            if (!forAmtInput || isNaN(parseFloat(forAmtInput)) || parseFloat(forAmtInput) <= 0) {
              showStatus('Please enter a valid token amount to receive', true);
              throw new Error('Invalid receive amount');
            }
            if (!saleSupplyInput || isNaN(parseFloat(saleSupplyInput)) || parseFloat(saleSupplyInput) <= 0) {
              showStatus('Please enter a valid total sale supply', true);
              throw new Error('Invalid sale supply');
            }

            // Determine payment token address and decimals
            let tribToken;
            let tribDecimals = 18;

            if (paymentToken === 'eth') {
              tribToken = ethers.ZeroAddress;
              tribDecimals = 18;
            } else if (paymentToken === 'usdc') {
              tribToken = TOKEN_ADDRESSES.usdc;
              tribDecimals = 6;
            } else if (paymentToken === 'usdt') {
              tribToken = TOKEN_ADDRESSES.usdt;
              tribDecimals = 6;
            } else if (paymentToken === 'dai') {
              tribToken = TOKEN_ADDRESSES.dai;
              tribDecimals = 18;
            } else if (paymentToken === 'wsteth') {
              tribToken = TOKEN_ADDRESSES.wsteth;
              tribDecimals = 18;
            } else if (paymentToken === 'reth') {
              tribToken = TOKEN_ADDRESSES.reth;
              tribDecimals = 18;
            } else if (paymentToken === 'custom') {
              const customTokenAddress = getEl('customTokenAddress').value.trim();
              if (!customTokenAddress || !ethers.isAddress(customTokenAddress)) {
                showStatus('Please enter a valid custom token address', true);
                throw new Error('Invalid custom token address');
              }
              tribToken = customTokenAddress;
              // Always fetch decimals from the token contract for accuracy
              try {
                showStatus('Verifying token decimals...');
                const tokenContract = new ethers.Contract(customTokenAddress, ['function decimals() view returns (uint8)'], provider);
                tribDecimals = await tokenContract.decimals();
                tribDecimals = Number(tribDecimals);
              } catch (decErr) {
                logger.error('Failed to fetch token decimals:', decErr);
                showStatus('Could not fetch token decimals. Please verify the token address is a valid ERC20.', true);
                throw new Error('Failed to fetch token decimals');
              }
            }

            // Parse amounts with correct decimals
            // tribAmt: amount of payment token required (in payment token's decimal units)
            // forAmt: amount of shares/loot received (always 18 decimals)
            // saleSupply: total tokens to make available (always 18 decimals)
            const tribAmt = ethers.parseUnits(tribAmtInput, tribDecimals);
            const forAmt = ethers.parseEther(forAmtInput); // shares/loot are 18 decimals
            const saleSupply = ethers.parseEther(saleSupplyInput); // shares/loot are 18 decimals

            const isLoot = tokenType === 'loot';

            // GOVERNANCE SAFETY CHECK: Prevent DAICO shares sales that could exceed proposal threshold
            if (!isLoot && proposalThresholdWei > 0n && saleSupply > proposalThresholdWei) {
              // DAICO mints new voting shares - supply exceeds threshold
              const continueAnyway = confirm(
                `âš ï¸ GOVERNANCE RISK: DAICO sale supply (${ethers.formatEther(saleSupply)} shares) exceeds proposal threshold (${ethers.formatEther(proposalThresholdWei)} shares).\n\n` +
                `A single buyer could accumulate enough voting shares to pass proposals unilaterally.\n\n` +
                `Consider:\n` +
                `â€¢ Selling LOOT (non-voting) instead\n` +
                `â€¢ Reducing supply to â‰¤ ${ethers.formatEther(proposalThresholdWei)}\n\n` +
                `Continue anyway?`
              );
              if (!continueAnyway) {
                throw new Error('DAICO sale cancelled due to governance risk');
              }
            }

            // Determine which token contract to use (shares or loot)
            const forToken = isLoot ? predictedLoot : predictedShares;

            // Check LP configuration
            const enableLP = getEl('daicoSummonEnableLP')?.checked;
            const lpBpsInput = document.getElementById('daicoSummonLpBps')?.value?.trim();
            const feeOrHookInput = document.getElementById('daicoSummonFeeOrHook')?.value?.trim() || '30';

            // Check Tap configuration
            const enableTap = getEl('daicoSummonEnableTap')?.checked;
            const tapOpsInput = document.getElementById('daicoSummonTapOps')?.value?.trim();
            const tapRateInput = document.getElementById('daicoSummonTapRate')?.value?.replace(/,/g, '');
            const tapBudgetInput = document.getElementById('daicoSummonTapBudget')?.value?.replace(/,/g, '');

            // Validate LP if enabled
            if (enableLP) {
              if (!lpBpsInput || parseInt(lpBpsInput) < 1 || parseInt(lpBpsInput) > 99) {
                showStatus('LP percentage must be between 1 and 99', true);
                throw new Error('Invalid LP percentage');
              }
            }

            // Validate Tap if enabled
            if (enableTap) {
              const resolvedTapOps = await resolveENS(tapOpsInput || '');
              if (!resolvedTapOps || !ethers.isAddress(resolvedTapOps)) {
                showStatus('Please enter a valid Ops address for the tap', true);
                throw new Error('Invalid tap ops address');
              }
              if (!tapRateInput || isNaN(parseFloat(tapRateInput)) || parseFloat(tapRateInput) <= 0) {
                showStatus('Please enter a valid tap rate', true);
                throw new Error('Invalid tap rate');
              }
              if (!tapBudgetInput || isNaN(parseFloat(tapBudgetInput)) || parseFloat(tapBudgetInput) <= 0) {
                showStatus('Please enter a valid tap budget', true);
                throw new Error('Invalid tap budget');
              }
            }

            // LP parameters (convert percentage to basis points: 50% = 5000 bps)
            const lpBps = enableLP ? parseInt(lpBpsInput) * 100 : 0;
            const maxSlipBps = 100; // 1% default slippage
            const feeOrHook = parseInt(feeOrHookInput) || 30;

            // Tap parameters (convert rate from per-month to per-second)
            // Solidity expects smallest units per second; 1 month â‰ˆ 30.44 days â‰ˆ 2629746 seconds
            const SECONDS_PER_MONTH = 2629746n;
            let tapOps = ethers.ZeroAddress;
            let tapRatePerSec = 0n;
            let tapBudget = 0n;

            if (enableTap) {
              tapOps = await resolveENS(tapOpsInput);
              const ratePerMonth = ethers.parseUnits(tapRateInput, tribDecimals);
              tapRatePerSec = ratePerMonth / SECONDS_PER_MONTH;
              tapBudget = ethers.parseUnits(tapBudgetInput, tribDecimals);

              // Ensure rate is at least 1 wei/sec if specified
              if (tapRatePerSec === 0n && ratePerMonth > 0n) {
                tapRatePerSec = 1n;
              }
            }

            // Step 1: Mint sale supply to DAO
            initCalls.push({
              target: forToken,
              value: 0n,
              data: INTERFACES.mintFromMoloch.encodeFunctionData('mintFromMoloch', [
                predictedDao,
                saleSupply
              ])
            });

            // Step 2: Approve DAICO contract to spend the minted tokens
            initCalls.push({
              target: forToken,
              value: 0n,
              data: INTERFACES.erc20Approve.encodeFunctionData('approve', [
                DAICO_ADDRESS,
                saleSupply
              ])
            });

            // Step 3: If tap is enabled, set allowance for DAICO to spend from DAO treasury
            if (enableTap && tapBudget > 0n) {
              initCalls.push({
                target: predictedDao,
                value: 0n,
                data: INTERFACES.setAllowance.encodeFunctionData('setAllowance', [
                  DAICO_ADDRESS,
                  tribToken,
                  tapBudget
                ])
              });
            }

            // Step 4: Call appropriate DAICO function based on LP/Tap configuration
            // deadline = 0 means no expiration
            let setSaleCalldata;

            if (enableLP && enableTap) {
              // setSaleWithLPAndTap(tribTkn, tribAmt, forTkn, forAmt, deadline, lpBps, maxSlipBps, feeOrHook, ops, ratePerSec)
              setSaleCalldata = INTERFACES.daicoSetSaleWithLPAndTap.encodeFunctionData('setSaleWithLPAndTap', [
                tribToken, tribAmt, forToken, forAmt, 0, lpBps, maxSlipBps, feeOrHook, tapOps, tapRatePerSec
              ]);
            } else if (enableLP) {
              // setSaleWithLP(tribTkn, tribAmt, forTkn, forAmt, deadline, lpBps, maxSlipBps, feeOrHook)
              setSaleCalldata = INTERFACES.daicoSetSaleWithLP.encodeFunctionData('setSaleWithLP', [
                tribToken, tribAmt, forToken, forAmt, 0, lpBps, maxSlipBps, feeOrHook
              ]);
            } else if (enableTap) {
              // setSaleWithTap(tribTkn, tribAmt, forTkn, forAmt, deadline, ops, ratePerSec)
              setSaleCalldata = INTERFACES.daicoSetSaleWithTap.encodeFunctionData('setSaleWithTap', [
                tribToken, tribAmt, forToken, forAmt, 0, tapOps, tapRatePerSec
              ]);
            } else {
              // setSale(tribTkn, tribAmt, forTkn, forAmt, deadline)
              setSaleCalldata = INTERFACES.daicoSetSale.encodeFunctionData('setSale', [
                tribToken, tribAmt, forToken, forAmt, 0
              ]);
            }

            initCalls.push({
              target: DAICO_ADDRESS,
              value: 0n,
              data: setSaleCalldata
            });
          }

          showStatus('Preparing transaction...');

          // Get initial ETH deposit if specified
          const initialEthDepositInput = document.getElementById('initialEthDeposit').value;
          const initialEthDeposit = initialEthDepositInput && parseFloat(initialEthDepositInput) > 0
            ? ethers.parseEther(initialEthDepositInput)
            : 0n;

          // Call summon
          showStatus('Please confirm the transaction in your wallet...');

          // For WalletConnect, skip local gas estimation (use generous limit, wallet will refine)
          const txOptions = { value: initialEthDeposit };
          if (walletConnectProvider) {
            txOptions.gasLimit = 2_000_000n;
          }

          const tx = await summoner.summon(
            daoName,
            daoSymbol,
            daoURI,
            quorumBps,
            ragequittable,
            '0x000000000011C799980827F52d3137b4abD6E654', // default renderer
            salt,
            initHolders,
            initShares,
            initCalls,
            txOptions
          );

          showStatus(`Transaction submitted. <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View on Explorer</a>`);

          const receipt = await tx.wait();

          // Find DAO address from events - ethers v6 syntax
          const event = receipt.logs
            .map(log => {
              try {
                return summoner.interface.parseLog(log);
              } catch {
                return null;
              }
            })
            .find(e => e && e.name === 'NewDAO');

          const daoAddress = event?.args?.dao;

          showStatus(`âœ¨ DAO summoned successfully at: <a href="${getNetwork().explorer}/address/${daoAddress}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">${daoAddress}</a> | <a href="${getNetwork().explorer}/tx/${tx.hash}" target="_blank" rel="noopener" style="color: #000; text-decoration: underline;">View transaction</a>`);

          // Refresh DAO list to include newly summoned DAO
          if (connectedAddress) {
            await fetchUserDAOs();
            if (userDAOs.length > 0) renderDAOGallery();
          }

          // Reset form
          document.getElementById('summonForm').reset();
          document.getElementById('foundingMembersList').innerHTML = '';
          const memberRow = createMemberRow(await signer.getAddress(), '1', true);
          document.getElementById('foundingMembersList').appendChild(memberRow);

          // Reset time units to defaults
          document.getElementById('proposalTTLUnit').value = '86400';
          document.getElementById('timelockDelayUnit').value = '86400';

          // Reset auto-futarchy preset to default
          document.getElementById('autoFutarchyPreset').value = 'off';

          // Reset and update loot inputs
          getEl('distributeLoot').checked = false;
          document.getElementById('lootDistribution').style.display = 'none';
          updateLootInputs();

          // Reset DAICO sale config
          getEl('initialSalePreset').value = 'off';
          toggleSaleConfig();

          // Reset DAICO LP/Tap fields
          const lpCheckbox = getEl('daicoSummonEnableLP');
          const tapCheckbox = getEl('daicoSummonEnableTap');
          if (lpCheckbox) lpCheckbox.checked = false;
          if (tapCheckbox) tapCheckbox.checked = false;
          toggleDaicoSummonLPFields();
          toggleDaicoSummonTapFields();

        } catch (error) {
          logger.error(error);

          if (isUserRejection(error)) {
            showStatus('Summoning cancelled', false);
          } else {
            // Handle common wallet errors with user-friendly messages
            let errorMessage = 'Summoning failed';

            if (error.code === 'UNKNOWN_ERROR' && error.message?.includes('eth_blockNumber')) {
              errorMessage = 'Network connection issue. Please check your wallet is connected to the correct network and try again.';
            } else if (error.code === 'NETWORK_ERROR' || error.message?.includes('network')) {
              errorMessage = 'Network error. Please check your connection and try again.';
            } else if (error.code === -32000 || error.message?.includes('insufficient funds')) {
              errorMessage = 'Insufficient funds for transaction';
            } else if (error.message?.includes('nonce')) {
              errorMessage = 'Transaction nonce issue - please reset your wallet';
            } else if (error.shortMessage) {
              errorMessage = error.shortMessage;
            } else if (error.reason) {
              errorMessage = error.reason;
            } else if (error.message) {
              const msg = error.message.split('\n')[0];
              if (msg.length < 100) {
                errorMessage = msg;
              }
            }

            showStatus(errorMessage, true);
          }
        } finally {
          summonBtn.disabled = false;
          summonBtn.textContent = 'SUMMON DAO';
        }
      });

      // Auto-connect on load if already authorized
      window.addEventListener('load', async () => {
        // Initialize DOM cache for performance
        DOMCache.init();

        // Start hero fire animation
        heroFire = initFireCanvas(document.getElementById('fireCanvas'));

        // Enable wheel scrolling on chatroom/proposals/members without requiring click focus
        ['chatroomMessages', 'proposalsList', 'membersList'].forEach(id => {
          const el = document.getElementById(id);
          if (el) {
            // Disable smooth scroll to prevent trembling with manual scrollTop
            el.style.scrollBehavior = 'auto';
            el.addEventListener('wheel', (e) => {
              // Only capture if there's scrollable content
              if (el.scrollHeight > el.clientHeight) {
                e.preventDefault();
                el.scrollTop += e.deltaY * 2.5;
              }
            }, { passive: false });
          }
        });

        // Initialize EIP-6963 support for modern wallet detection
        initEIP6963();

        // Initialize read-only provider for deep links and browsing without wallet
        try {
          readOnlyProvider = new ethers.JsonRpcProvider(getNetwork().rpcs[0]);
        } catch (error) {
          logger.error('Failed to initialize read-only provider:', error);
        }

        // Check for deep link - if present, load DAOs immediately (read-only)
        const deepLink = parseDAODeepLink();
        if (deepLink && readOnlyProvider) {
          try {
            showStatus('Loading DAO...', false);
            await openDAOByAddress(deepLink.address);
            // Note: Scroll is handled after auto-reconnect check below
          } catch (error) {
            logger.error('Failed to load deep-linked DAO:', error);
            showStatus('Failed to load DAO. Please try connecting your wallet.', true);
          }
        }

        // Small delay to allow EIP-6963 providers to announce themselves
        await new Promise(resolve => setTimeout(resolve, 100));

        // Auto-reconnect logic with improved wallet preference handling
        let autoReconnected = false;
        const preferredWallet = getWalletPreference();

        // WalletConnect sessions don't persist across page reloads - clear stale preference
        if (preferredWallet === 'walletconnect') {
          clearWalletPreference();
        } else if (window.ethereum) {
          try {
            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
            if (accounts.length > 0) {
              // Try to reconnect with the user's preferred wallet
              const wallets = detectWallets();

              if (preferredWallet && wallets.some(w => w.key === preferredWallet)) {
                // Reconnect with preferred wallet
                await connectWithWallet(preferredWallet);
                autoReconnected = true;
              } else if (wallets.length > 0) {
                // Fallback: connect with first detected wallet (skip walletconnect)
                const nonWCWallet = wallets.find(w => w.key !== 'walletconnect');
                if (nonWCWallet) {
                  await connectWithWallet(nonWCWallet.key);
                  autoReconnected = true;
                }
              }
            }
          } catch (error) {
            logger.error('Auto-reconnect failed:', error);
            // Silently fail auto-reconnect, user can manually connect
          }
        }

        // If we have a deep link and a DAO was loaded (either read-only or via auto-reconnect),
        // ensure we scroll to the dashboard
        if (deepLink && currentDAO) {
          // Use a longer delay to ensure DOM is fully rendered after auto-reconnect
          requestAnimationFrame(() => {
            setTimeout(() => {
              const dashboard = document.getElementById('daoDashboard');
              if (dashboard) {
                dashboard.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }
            }, autoReconnected ? 500 : 100);
          });
        }
      });

    </script>
  <script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"8510b592df8f4a69b87bbf8e840f200c","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>

