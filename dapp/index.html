<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>SWAP</title>
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 400' width='400' height='400'%3E%3Crect width='400' height='400' fill='%23000'/%3E%3CclipPath id='frame'%3E%3Crect width='400' height='400'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23frame)'%3E%3Cpath d='M-60-20L460-20L460 90L80 310L460 310L460 420L-60 420L-60 310L320 90L-60 90Z' fill='white'/%3E%3C/g%3E%3C/svg%3E" type="image/svg+xml">
<script>
// Prevent dark-mode FOUC: apply class before first paint
try{var d=localStorage.getItem('dark');if(d==='1'||(d===null&&matchMedia('(prefers-color-scheme:dark)').matches))document.documentElement.classList.add('dark')}catch(_){}
</script>
<style>
:root {
  --bg:#fff;--fg:#000;--fg-muted:#666;--fg-dim:#999;
  --border:#000;--border-muted:#ddd;--input-ph:#aaa;
  --surface:#f9f9f9;--surface-hover:#f5f5f5;--list-hover:#f0f0f0;
  --btn-bg:#000;--btn-fg:#fff;--btn-hover:#333;
  --btn-dis-bg:transparent;--btn-dis-border:#ccc;--btn-dis-fg:#999;
  --sec-bg:#fff;--sec-border:#000;
  --card-border:#ccc;--card-shadow:none;
  --modal-overlay:rgba(0,0,0,0.8);--modal-bg:#fff;--modal-border:#000;
  --status-error:#fff0f0;--status-success:#f0fff0;
  --slip-border:rgba(0,0,0,0.25);--slip-hover:rgba(0,0,0,0.45);--slip-focus:#000;
  --refresh-color:#bbb;--refresh-hover:#888;--countdown:#bbb;
  --info-border:#999;--info-hover:#000;
  --info-tip-bg:#fff;--info-tip-border:#ddd;--info-tip-fg:#333;--info-tip-shadow:0 2px 8px rgba(0,0,0,0.08);
  --toggle-bg:#eee;--toggle-fg:#000;
  --loading-border:#666;--loading-top:#fff;
  --token-bal:#888;--group-border:#eee;
  --routes-fg:#666;--routes-hover:#000;--routes-list:#444;
  --badge-bg:#000;--badge-fg:#fff;
  --link-fg:inherit;--remove-fg:#999;
}
.dark {
  --bg:#0a0a0a;--fg:#e8e8e0;--fg-muted:#888;--fg-dim:#666;
  --border:#333;--border-muted:#333;--input-ph:#555;
  --surface:#111;--surface-hover:#151515;--list-hover:#1a1a1a;
  --btn-bg:#e8e8e0;--btn-fg:#0a0a0a;--btn-hover:#ccc;
  --btn-dis-bg:transparent;--btn-dis-border:#444;--btn-dis-fg:#666;
  --sec-bg:#0a0a0a;--sec-border:#333;
  --card-border:#333;--card-shadow:none;
  --modal-overlay:rgba(0,0,0,0.85);--modal-bg:#111;--modal-border:#333;
  --status-error:#1a0000;--status-success:#001a00;
  --slip-border:rgba(255,255,255,0.15);--slip-hover:rgba(255,255,255,0.3);--slip-focus:#e8e8e0;
  --refresh-color:#555;--refresh-hover:#999;--countdown:#555;
  --info-border:#555;--info-hover:#e8e8e0;
  --info-tip-bg:#111;--info-tip-border:#333;--info-tip-fg:#aaa;--info-tip-shadow:0 2px 8px rgba(0,0,0,0.3);
  --toggle-bg:#e8e8e0;--toggle-fg:#000;
  --loading-border:#444;--loading-top:#0a0a0a;
  --token-bal:#666;--group-border:#222;
  --routes-fg:#666;--routes-hover:#e8e8e0;--routes-list:#999;
  --badge-bg:#e8e8e0;--badge-fg:#0a0a0a;
  --link-fg:#e8e8e0;--remove-fg:#555;
}
.zorg-bg{fill:#fff}.zorg-fg{fill:#000}
.dark .zorg-bg{fill:#000}.dark .zorg-fg{fill:#fff}
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body {
  font-family: Helvetica, Arial, sans-serif;
  background: var(--bg);
  color: var(--fg);
  min-height: 100vh;
  padding: 60px 20px 20px;
  max-width: 480px;
  margin: 0 auto;
  overflow-x: hidden;
}
a { color: var(--link-fg); }
h1 {
  font-size: 14px;
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  margin-bottom: 24px;
}
.section {
  margin-bottom: 16px;
}
label {
  display: block;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 8px;
  color: var(--fg-muted);
}
input[type="number"], input[type="text"], .amount-input {
  width: 100%;
  padding: 8px 0;
  font-size: 24px;
  font-family: inherit;
  border: none;
  border-bottom: 1.5px solid var(--border);
  outline: none;
  background: transparent;
  color: var(--fg);
}
input::placeholder { color: var(--input-ph); }
input:focus { border-bottom-width: 2.5px; margin-bottom: -1px; }
button {
  display: inline-block;
  padding: 12px 24px;
  font-size: 12px;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  background: var(--btn-bg);
  color: var(--btn-fg);
  border: 1px solid var(--btn-bg);
  cursor: pointer;
  margin-right: 8px;
  margin-top: 8px;
  transition: background 0.2s, border-color 0.2s, color 0.2s;
}
button:hover { background: var(--btn-hover); }
button:disabled { background: var(--btn-dis-bg); border-color: var(--btn-dis-border); color: var(--btn-dis-fg); cursor: not-allowed; }
button.secondary {
  background: var(--sec-bg);
  color: var(--fg);
  border-color: var(--sec-border);
}
button.secondary:hover { background: var(--surface-hover); }

.wallet {
  position: fixed;
  top: max(20px, env(safe-area-inset-top, 0px));
  right: max(20px, env(safe-area-inset-right, 0px));
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  z-index: 100;
}
.wallet button { margin: 0; padding: 8px 16px; text-transform: none; }


.token-select {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: transparent;
  border: none;
  padding: 4px 2px;
  cursor: pointer;
  transition: opacity 0.15s;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}
.token-select:hover { opacity: 0.6; }
.token-icon { width: 24px; height: 24px; display: inline-flex; align-items: center; }
.pp-icon-16, .pp-icon-18 { display: inline-flex; align-items: center; line-height: 0; }
.pp-icon-16 svg { width: 16px; height: 16px; }
.pp-icon-18 svg { width: 18px; height: 18px; }
.token-symbol { font-weight: 600; color: var(--fg); }
.token-chevron { font-size: 10px; color: var(--fg-dim); margin-left: -2px; }

/* Quick-pick token row */
.quick-tokens {
  display: flex;
  align-items: center;
  gap: 6px;
}
.quick-token {
  width: 26px; height: 26px;
  border-radius: 50%;
  border: 1.5px solid transparent;
  background: transparent;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  transition: transform 0.15s ease, border-color 0.15s ease, filter 0.15s ease, opacity 0.15s ease;
  position: relative;
  filter: grayscale(0.6);
  opacity: 0.55;
}
.quick-token:hover {
  transform: scale(1.15);
  filter: grayscale(0);
  opacity: 1;
}
.quick-token .qi { width: 22px; height: 22px; border-radius: 50%; pointer-events: none; }
.quick-token[aria-label]::after {
  content: attr(aria-label);
  position: absolute;
  bottom: calc(100% + 4px);
  left: 50%;
  transform: translateX(-50%);
  font-size: 10px;
  letter-spacing: 0.03em;
  padding: 2px 5px;
  border-radius: 3px;
  background: var(--info-tip-bg);
  border: 1px solid var(--info-tip-border);
  color: var(--info-tip-fg);
  box-shadow: var(--info-tip-shadow);
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.12s ease;
}
.quick-token:hover::after { opacity: 1; }

/* Token input sections */
.token-section {
  margin-bottom: 12px;
}
.token-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  gap: 8px;
  min-width: 0;
}
.amount-input { font-weight: 400; }
.balance {
  font-size: 12px;
  color: var(--fg-muted);
  margin-top: 6px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.max-btn {
  padding: 2px 4px;
  border: none;
  background: none;
  color: var(--fg-dim);
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.03em;
  text-transform: uppercase;
  cursor: pointer;
  transition: color 0.15s, background 0.15s;
  margin: 0;
  border-radius: 3px;
}
.max-btn:hover { color: var(--fg); background: var(--surface-hover); }
.max-btn:disabled { opacity: 0.4; cursor: not-allowed; background: none; }

/* Swap arrow */
.swap-arrow {
  display: flex;
  justify-content: center;
  margin: 2px 0 8px;
}
.arrow-btn {
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 0;
  width: 32px;
  height: 32px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  transition: transform 0.3s ease, background 0.2s, border-color 0.2s;
  margin: 0;
}
.arrow-btn:hover { transform: rotate(180deg); background: var(--btn-bg); border-color: var(--btn-bg); }
.arrow-btn:hover svg { stroke: var(--btn-fg); }
.arrow-btn svg { stroke: var(--fg); transition: stroke 0.2s; }

/* Swap button */
.swap-btn {
  background: var(--btn-bg);
  color: var(--btn-fg);
  border: 1px solid var(--btn-bg);
  padding: 14px 24px;
  font-size: 13px;
  font-weight: 600;
  text-transform: none;
  letter-spacing: 0.02em;
  cursor: pointer;
  width: 100%;
  margin-top: 12px;
  transition: all 0.2s;
}
.swap-btn:hover:not(:disabled) { background: var(--btn-hover); }
.swap-btn:disabled { background: var(--btn-dis-bg); border-color: var(--btn-dis-border); color: var(--btn-dis-fg); cursor: not-allowed; }

/* Quote info */
.quote-info {
  padding: 12px;
  background: var(--surface);
  margin-top: 16px;
  font-size: 13px;
  color: var(--fg);
  overflow: hidden;
}
.quote-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 3px 0;
}
.quote-rate {
  font-size: 12px;
  color: var(--fg-muted);
  padding: 6px 0 2px;
  border-top: 1px solid var(--card-border);
  margin-top: 4px;
}
.quote-row > :nth-child(2) {
  margin-left: auto;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  text-align: right;
}
#routeInfo {
  max-width: 65%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
#routeInfo[data-size="sm"] { font-size: 12px; }
#routeInfo[data-size="xs"] { font-size: 11px; }

/* Slippage inline */
.slip-inline {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  cursor: text;
}
.slip-unit {
  color: var(--fg-muted);
  font-weight: 600;
  pointer-events: none;
}
.slip-num {
  -webkit-appearance: none;
  appearance: textfield;
  background: transparent;
  border: 0;
  border-bottom: 1px solid var(--slip-border);
  border-radius: 0;
  padding: 2px 0;
  width: 4.5ch;
  min-width: 3.5ch;
  text-align: right;
  font-size: 13px;
  color: var(--fg);
  outline: none;
  transition: border-color 0.15s ease;
}
.slip-num:hover { border-bottom-color: var(--slip-hover); }
.slip-num:focus { border-bottom-color: var(--slip-focus); }
.slip-num::-webkit-outer-spin-button,
.slip-num::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
.slip-num[type="number"] { -moz-appearance: textfield; }

/* Refresh button & countdown */
.refresh-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: none;
  border: none;
  cursor: pointer;
  padding: 2px;
  margin: 0;
  color: var(--refresh-color);
  transition: color 0.15s;
  opacity: 0.7;
}
.refresh-btn:hover { color: var(--refresh-hover); opacity: 1; }
.refresh-btn svg { display: block; }
.quote-countdown { color: var(--countdown); font-size: 11px; opacity: 0.7; }

/* Price impact */
.impact-warn { color: #e67e22; }
.impact-danger { color: #e74c3c; font-weight: 600; }
.quote-info.impact-high { background: rgba(231,76,60,0.06); }
.dark .quote-info.impact-high { background: rgba(231,76,60,0.1); }

/* All routes collapsible */
.routes-toggle {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  user-select: none;
  color: var(--routes-fg);
  font-size: 12px;
  margin-top: 6px;
}
.routes-toggle:hover { color: var(--routes-hover); }
.routes-list {
  margin-top: 4px;
  font-size: 12px;
  color: var(--routes-list);
}
.routes-list-item {
  display: flex;
  justify-content: space-between;
  padding: 3px 0;
}
.routes-list-item .best-badge {
  background: var(--badge-bg);
  color: var(--badge-fg);
  font-size: 10px;
  padding: 1px 5px;
  margin-left: 6px;
  letter-spacing: 0.03em;
}

/* Loading spinner */
.loading {
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid var(--loading-border);
  border-top: 2px solid var(--loading-top);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  vertical-align: middle;
}
@keyframes spin { 0% { transform: rotate(0); } 100% { transform: rotate(360deg); } }

/* Token modal */
.modal-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--modal-overlay);
  backdrop-filter: blur(4px);
  z-index: 2000;
  justify-content: center;
  align-items: center;
  padding: 20px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.modal-overlay.active { display: flex; }
body.modal-open { overflow: hidden; }
.modal {
  background: var(--modal-bg);
  border: 1px solid var(--modal-border);
  padding: 16px;
  width: 100%;
  max-width: 380px;
  max-height: calc(100vh - 40px);
  max-height: calc(100dvh - 40px);
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}
.modal-title {
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}
.modal-close {
  background: none;
  border: none;
  color: var(--fg);
  font-size: 20px;
  cursor: pointer;
  line-height: 1;
  padding: 4px;
  margin: -4px;
  opacity: 0.4;
  transition: opacity 0.15s;
}
.modal-close:hover { opacity: 1; }

/* Wallet modal options */
.wallet-option {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: var(--modal-bg);
  border: 1px solid var(--border);
  color: var(--fg);
  cursor: pointer;
  margin-bottom: 8px;
  transition: background 0.15s, color 0.15s;
}
.wallet-option:hover { background: var(--btn-bg); color: var(--btn-fg); }
.wallet-option-icon { font-size: 1.5rem; }
.wallet-option-name { font-weight: 600; }
.wallet-option.disconnect {
  border-color: #f00;
  color: #f00;
  justify-content: center;
}
.wallet-option.disconnect:hover { background: #f00; color: #fff; }

/* Token list in modal */
.token-list-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 12px;
  cursor: pointer;
  transition: background 0.12s;
  border-radius: 4px;
  margin: 0 4px;
}
.token-list-item:hover { background: var(--list-hover); }
.token-list-item.highlight {
  background: var(--surface);
  outline: 1px solid var(--border);
  outline-offset: -1px;
}
.token-balance { margin-left: auto; font-size: 11px; color: var(--token-bal); font-variant-numeric: tabular-nums; opacity: 0.7; }

/* Custom token input */
.custom-token-input, .token-search {
  width: 100%;
  padding: 10px 0;
  border: none;
  border-bottom: 1px solid var(--border);
  font-size: 14px;
  font-family: inherit;
  outline: none;
  background: transparent;
  color: var(--fg);
}
.custom-token-input { margin-top: 8px; font-size: 12px; padding: 8px 0; }
.custom-token-input:focus, .token-search:focus { border-bottom-color: var(--fg); }
.token-search-status {
  font-size: 11px;
  color: var(--fg-dim);
  margin: 4px 0 6px;
  min-height: 14px;
}
.token-search-status.error { color: #e74c3c; }
.token-group-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--fg-dim);
  padding: 10px 16px 4px;
  margin-top: 4px;
  border-top: 1px solid var(--group-border);
  display: flex;
  justify-content: space-between;
  align-items: center;
  opacity: 0.6;
}
.wei-list-remove {
  background: none;
  border: none;
  color: var(--remove-fg);
  font-size: 14px;
  cursor: pointer;
  padding: 0 4px;
  margin: 0;
  line-height: 1;
}
.wei-list-remove:hover { color: #e74c3c; }
#tokenList { scrollbar-width: thin; scrollbar-color: var(--border) transparent; }
#tokenList::-webkit-scrollbar { width: 4px; }
#tokenList::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
#tokenList::-webkit-scrollbar-track { background: transparent; }

/* Status */
.status {
  font-size: 13px;
  margin-top: 16px;
  padding: 12px;
  background: var(--surface);
  color: var(--fg);
  display: none;
}
.status.show { display: block; }
.status.error { background: var(--status-error); }
.status.success { background: var(--status-success); }

/* Footer */
.site-footer {
  position: relative;
  text-align: center;
  padding: 48px 20px;
  font-size: 11px;
  opacity: 0.35;
  letter-spacing: 0.5px;
  font-weight: 300;
}
.site-footer a {
  color: inherit;
  text-decoration: underline;
  margin: 0 2px;
}
.site-footer a:hover { opacity: 0.7; }
.site-footer .tagline { opacity:1; color:#000; font-weight:500; }
.dark .site-footer .tagline { opacity:1; color:#fff; font-weight:500; }

/* Responsive */
@media (max-width: 700px) {
  body { padding: 80px 16px 20px; }
  .wallet { top: 16px; right: 16px; }
  .wallet button { padding: 10px 14px; font-size: 11px; }
  h1 { margin-bottom: 30px; font-size: 13px; }
  input[type="number"], input[type="text"] { font-size: 20px; padding: 8px 0; }
  .amount-input { font-size: 20px; }
  .swap-btn { padding: 12px 20px; }
  .modal { max-width: 100%; margin: 0 10px; max-height: calc(100vh - 40px); overflow-y: auto; }
  .dark-toggle { top: 18px; left: 16px; }
  .swap-card { padding: 20px 16px; }
  .quick-token { min-width: 26px; min-height: 26px; padding: 4px; }
  /* Privacy tab mobile */
  .pp-note-area { font-size: 10px; }
  .pp-asset-btn { padding: 8px 6px; font-size: 12px; min-height: 40px; }
}
@media (max-width: 380px) {
  body { padding: 70px 12px 20px; }
  input[type="number"], input[type="text"] { font-size: 18px; }
  .amount-input { font-size: 18px; }
  h1 { font-size: 12px; }
  .swap-card { padding: 16px 12px; }
  .token-select { padding: 4px 2px; gap: 4px; font-size: 11px; }
  .token-icon { width: 20px; height: 20px; }
  .quick-tokens { gap: 4px; }
  .quick-token { width: 24px; height: 24px; }
  .quick-token .qi { width: 20px; height: 20px; }
  .quote-info { padding: 10px 8px; font-size: 12px; }
  .balance { font-size: 11px; gap: 4px; flex-wrap: wrap; }
  .max-btn { font-size: 9px; padding: 2px 3px; }
  /* Privacy tab tight mobile */
  .pp-asset-btn { padding: 6px 4px; font-size: 11px; }
  .pp-note-area { font-size: 9px; }
}

/* Info tooltip */
.info-tip {
  position: relative;
  display: inline-flex;
}
.info-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  height: 16px;
  color: var(--info-border);
  cursor: help;
  opacity: 0.4;
}
.info-icon:hover { opacity: 0.8; }
.info-icon:hover { border-color: var(--info-hover); color: var(--info-hover); }
.info-tooltip {
  display: none;
  position: absolute;
  top: 28px;
  left: 0;
  width: 280px;
  padding: 14px 16px;
  background: var(--info-tip-bg);
  border: 1px solid var(--info-tip-border);
  font-size: 12px;
  font-weight: 400;
  line-height: 1.6;
  letter-spacing: 0;
  text-transform: none;
  color: var(--info-tip-fg);
  z-index: 200;
  box-shadow: var(--info-tip-shadow);
}
.info-tip.open .info-tooltip { display: block; }

/* Dark mode toggle */
.dark-toggle {
  position: fixed;
  top: max(22px, env(safe-area-inset-top, 0px));
  left: max(20px, env(safe-area-inset-left, 0px));
  border: none;
  cursor: pointer;
  padding: 0;
  margin: 0;
  opacity: 0.5;
  transition: opacity 0.2s;
  z-index: 100;
  background: #000;
  border-radius: 50%;
  width: 14px;
  height: 14px;
}
:root.dark .dark-toggle { background: #fff; }
.dark-toggle:hover { opacity: 1; }

/* Tab bar */
.tab-bar {
  display: flex;
  gap: 0;
  margin-bottom: 24px;
}
.tab-bar .tab {
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  padding: 6px 16px;
  font-size: 14px;
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--fg-muted);
  cursor: pointer;
  font-family: inherit;
}
.tab-bar .tab.active {
  color: var(--fg);
  border-bottom-color: var(--fg);
}
.tab-bar .tab:hover:not(.active) {
  color: var(--fg);
}

/* Swap card container */
.swap-card {
  border: 1px solid var(--card-border);
  border-radius: 0;
  padding: 24px;
  background: var(--bg);
}

/* Receiver accordion */
.receiver-toggle {
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  user-select: none;
  padding: 8px 0;
  margin-top: 4px;
  border-top: 1px solid var(--card-border);
}
.receiver-toggle label {
  cursor: pointer;
  pointer-events: none;
  margin: 0;
}
</style>
</head>
<body>

<button class="dark-toggle" onclick="toggleDark()" title="Toggle dark mode"></button>

<!-- Wallet button (fixed top-right) -->
<div class="wallet">
  <button id="walletBtn" onclick="toggleWallet()">connect</button>
</div>

<div class="tab-bar">
  <button class="tab active" data-tab="swap" onclick="switchTab('swap')">Swap</button>
  <button class="tab" data-tab="privacy" onclick="switchTab('privacy')">Privacy</button>
</div>

<div id="swapTab">
<div style="display:flex;align-items:center;gap:8px;margin-bottom:12px"><span class="info-tip"><span class="info-icon" onclick="this.parentElement.classList.toggle('open');event.stopPropagation()"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg></span><span class="info-tooltip"><a href="https://github.com/zammdefi/zrouter" target="_blank" rel="noopener" style="color:inherit;font-weight:600">zRouter</a> is a fully on-chain DEX aggregator. Routes are discovered and optimized by zQuoter directly on the blockchain â€” no off-chain APIs, no solvers, no servers.<br><br>Aggregates Uniswap V2/V3/V4, SushiSwap, Curve, zAMM, and Lido with atomic multi-hop execution, split routing, and per-leg slippage protection.<br><br>Zero protocol fees. No intermediaries. Your trade goes directly from your wallet to the liquidity pools.</span></span></div>

<!-- Swap card -->
<div class="swap-card">

<!-- From token section -->
<div class="section token-section">
  <div class="token-header">
    <label style="margin:0">From</label>
    <div class="token-select" onclick="openTokenModal('from')">
      <span id="fromTokenIcon" class="token-icon"></span>
      <span id="fromTokenSymbol" class="token-symbol">ETH</span>
      <span class="token-chevron">&#9662;</span>
    </div>
  </div>
  <input type="number" id="fromAmount" class="amount-input" placeholder="0.0" step="any">
  <div class="balance"><span id="fromBalance">Balance: --</span> <span style="color:var(--fg-dim)">&middot;</span> <button class="max-btn" type="button" onclick="setPercentBalance(25)">25%</button> <button class="max-btn" type="button" onclick="setPercentBalance(50)">50%</button> <button class="max-btn" type="button" onclick="setPercentBalance(75)">75%</button> <button class="max-btn" type="button" onclick="setPercentBalance(100)">100%</button></div>
</div>

<!-- Swap direction arrow -->
<div class="swap-arrow">
  <button class="arrow-btn" onclick="swapTokens()">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke-width="2.5"><path d="M7 10L12 15L17 10"/></svg>
  </button>
</div>

<!-- To token section -->
<div class="section token-section">
  <div class="token-header">
    <label style="margin:0">To</label>
    <div style="display:flex;align-items:center;gap:10px">
      <div id="quickTokens" class="quick-tokens"></div>
      <div class="token-select" onclick="openTokenModal('to')">
        <span id="toTokenIcon" class="token-icon"></span>
        <span id="toTokenSymbol" class="token-symbol">zOrg</span>
        <span class="token-chevron">&#9662;</span>
      </div>
    </div>
  </div>
  <input type="number" id="toAmount" class="amount-input" placeholder="0.0" step="any">
  <div id="toBalance" class="balance">Balance: --</div>
</div>

<!-- Quote info -->
<div id="quoteInfo" class="quote-info" style="display:none">
  <div class="quote-row">
    <span>Route:</span><span id="routeInfo">--</span><a id="chartLink" href="#" target="_blank" rel="noopener" title="View chart" style="display:none;margin-left:4px;opacity:0.7;transition:opacity 0.15s;line-height:1" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.7'"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg></a>
  </div>
  <div class="quote-row" id="impactRow">
    <span>Impact:</span><span id="impactInfo">--</span>
  </div>
  <div class="quote-row" id="slippageRow">
    <span>Slippage:</span>
    <span class="slip-inline">
      <input id="slippagePct" class="slip-num" type="number" inputmode="decimal" min="0" max="20" step="0.1" value="0.5" aria-label="Slippage (%)">
      <span class="slip-unit">%</span>
      <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" style="opacity:0.35;margin-left:-2px"><path d="M17 3a2.83 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg>
      <span id="splitSlipNote" style="display:none;font-size:11px;color:var(--fg-muted);margin-left:6px"></span>
    </span>
  </div>
  <div class="quote-row" id="refreshRow">
    <span class="quote-countdown" id="quoteCountdown"></span>
    <span>
      <button class="refresh-btn" onclick="manualRefresh()" title="Refresh quote">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6.7L3 16"/></svg>
      </button>
    </span>
  </div>
  <div id="quoteRate" class="quote-rate" style="display:none"></div>
  <div id="allRoutesWrap" style="display:none">
    <div class="routes-toggle" onclick="toggleAllRoutes()">
      <span class="chevron" id="routesChevron" style="font-size:9px">&#9654;</span>
      <span>All routes</span>
    </div>
    <div id="allRoutesList" class="routes-list" style="display:none"></div>
  </div>
  <a id="calldataLink" href="#" target="_blank" rel="noopener" title="Preview calldata â€” final tx may differ slightly (fresh quote at execution)" style="display:none;font-size:11px;color:var(--fg-muted);text-decoration:none;opacity:0.6;transition:opacity 0.15s" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.6'">Inspect calldata &#8599;</a>
</div>

<!-- Receiver (optional) -->
<div>
  <div class="receiver-toggle" onclick="const w=document.getElementById('receiverWrap');const open=w.style.maxHeight==='0px';w.style.maxHeight=open?'80px':'0px';w.style.opacity=open?'1':'0';this.querySelector('.chevron').textContent=open?'\u25BC':'\u25B6'">
    <span class="chevron" style="font-size:9px;color:var(--fg-muted)">&#9654;</span>
    <label style="margin:0;cursor:pointer;pointer-events:none">Receiver</label>
  </div>
  <div id="receiverWrap" style="max-height:0px;opacity:0;overflow:hidden;transition:max-height .2s ease,opacity .2s ease;margin-top:8px">
    <input type="text" id="receiverAddress" placeholder="0x address, name.wei, or name.eth" style="font-size:14px;padding:8px 0">
    <div id="receiverResolved" style="display:none;font-size:12px;margin-top:4px;color:var(--fg-muted);word-break:break-all"></div>
    <div id="receiverWarn" style="display:none;font-size:11px;margin-top:4px;color:#c0392b"></div>
  </div>
</div>

<div>
  <div class="receiver-toggle" onclick="togglePPSwap()">
    <span class="chevron" id="ppSwapChevron" style="font-size:9px;color:var(--fg-muted)">&#9654;</span>
    <label style="margin:0;cursor:pointer;pointer-events:none">Privacy Pool Deposit</label>
  </div>
  <div id="ppSwapWrap" style="max-height:0px;opacity:0;overflow:hidden;transition:max-height .2s ease,opacity .2s ease;margin-top:4px">
    <label style="display:flex;align-items:center;gap:6px;font-size:12px;color:var(--fg-muted);cursor:pointer;margin-bottom:0;text-transform:none;letter-spacing:0">
      <input type="checkbox" id="ppSwapToggle" onchange="onPPSwapToggle()"> Deposit swap output into <a href="https://privacypools.com" target="_blank" style="color:var(--link-fg)">Privacy Pools</a>
    </label>
    <div id="ppSwapAssetWrap" style="display:none;margin-top:6px">
      <div style="display:flex;gap:6px;align-items:center">
        <span style="font-size:11px;color:var(--fg-muted)">Deposit as:</span>
        <button id="ppSwapAssetETH" style="display:inline-flex;align-items:center;gap:4px;padding:3px 8px;font-size:11px;border-radius:6px;border:2px solid var(--btn-bg);cursor:pointer;background:var(--btn-bg);color:var(--btn-fg)" onclick="ppSwapSelectAsset('ETH')"><span class="pp-icon-16" data-icon="ETH"></span>ETH</button>
        <button id="ppSwapAssetBOLD" style="display:inline-flex;align-items:center;gap:4px;padding:3px 8px;font-size:11px;border-radius:6px;border:2px solid transparent;cursor:pointer;background:var(--surface);color:var(--fg-muted)" onclick="ppSwapSelectAsset('BOLD')"><span class="pp-icon-16" data-icon="BOLD"></span>BOLD</button>
      </div>
      <div id="ppSwapNote" style="font-size:11px;color:var(--fg-muted);margin-top:4px">You&#39;ll receive a note &mdash; withdraw via the Privacy tab or <a href="https://privacypools.com" target="_blank" style="color:var(--link-fg)">privacypools.com</a>.</div>
    </div>
  </div>
</div>

<!-- Swap button -->
<button id="swapBtn" class="swap-btn" disabled>Connect Wallet</button>

<!-- Privacy note display (swap tab) -->
<div id="ppSwapNoteBox" style="display:none;margin-top:16px" class="quote-info">
  <div style="font-weight:600;color:#c0392b;margin-bottom:8px">Warning: Save this note! You need it to withdraw.</div>
  <textarea id="ppSwapNoteText" readonly rows="3" class="pp-note-area" style="width:100%;box-sizing:border-box;font-family:monospace;font-size:11px;background:var(--surface);color:var(--fg);border:1px solid var(--border-muted);padding:8px;resize:vertical"></textarea>
  <div style="display:flex;gap:8px;margin-top:8px">
    <button onclick="navigator.clipboard.writeText($('ppSwapNoteText').value)" class="swap-btn" style="flex:1;padding:6px">Copy</button>
    <button onclick="ppSwapDownloadNote()" class="swap-btn" style="flex:1;padding:6px">Download</button>
  </div>
  <p style="font-size:11px;margin-top:8px;color:var(--fg-muted)">
    Withdraw directly below, or via <a href="https://privacypools.com" target="_blank">privacypools.com</a>. Same wallet works on both.
  </p>
  <button onclick="setShown('ppSwapNoteBox',false)" class="swap-btn" style="margin-top:6px;padding:4px 12px;font-size:11px;opacity:0.6">Dismiss</button>
</div>

</div><!-- end swap-card -->

<!-- Direct ZAMM stake / ragequit links -->
<div id="directStakeLink" style="text-align:center;margin-top:10px;font-size:13px;opacity:0.7">
  <a href="#" onclick="setupDirectZammStake();return false" style="color:var(--link-fg);text-decoration:underline;cursor:pointer">Stake ZAMM directly to zOrg</a>
  <span style="color:var(--fg-dim)">&middot;</span>
  <a href="#" onclick="setupRagequit();return false" style="color:var(--link-fg);text-decoration:underline;cursor:pointer">Ragequit zOrg to ZAMM</a>
</div>
</div><!-- end swapTab -->

<div id="privacyTab" style="display:none">
<div class="swap-card">
  <h2 style="font-size:14px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase;margin-bottom:12px">Deposit to Privacy Pool</h2>
  <p style="font-size:12px;color:var(--fg-muted);margin-bottom:16px;line-height:1.5">Deposit ETH or BOLD into <a href="https://privacypools.com" target="_blank">Privacy Pools</a> (0xbow). Save the note you receive &mdash; withdraw below or at <a href="https://privacypools.com" target="_blank">privacypools.com</a> with the same wallet.</p>

  <div style="display:flex;gap:8px;margin-bottom:12px">
    <button id="ppAssetETH" class="swap-btn pp-asset-btn active" style="flex:1;padding:6px;font-size:12px;display:inline-flex;align-items:center;justify-content:center;gap:6px;border-radius:8px;border:2px solid var(--btn-bg);background:var(--btn-bg);color:var(--btn-fg)" onclick="ppSelectAsset('ETH')"><span class="pp-icon-18" data-icon="ETH"></span>ETH</button>
    <button id="ppAssetBOLD" class="swap-btn pp-asset-btn" style="flex:1;padding:6px;font-size:12px;display:inline-flex;align-items:center;justify-content:center;gap:6px;border-radius:8px;border:2px solid transparent;background:var(--surface);color:var(--fg-muted)" onclick="ppSelectAsset('BOLD')"><span class="pp-icon-18" data-icon="BOLD"></span>BOLD</button>
  </div>

  <div class="section token-section">
    <div class="token-header">
      <label style="margin:0"><span id="ppAmountLabel">Amount (ETH)</span></label>
    </div>
    <input type="number" id="ppAmount" class="amount-input" placeholder="0.0" min="0" step="any">
    <div class="balance"><span id="ppBalance"></span> <span style="color:var(--fg-dim)">&middot;</span> <button class="max-btn" type="button" onclick="setPPPercentBalance(25)">25%</button> <button class="max-btn" type="button" onclick="setPPPercentBalance(50)">50%</button> <button class="max-btn" type="button" onclick="setPPPercentBalance(75)">75%</button> <button class="max-btn" type="button" onclick="setPPPercentBalance(100)">100%</button></div>
  </div>

  <div id="ppFeeInfo" style="display:none;font-size:12px;color:var(--fg-muted);margin-bottom:16px">
    Vetting fee: <span id="ppFeeBps">--</span> bps &middot; Min deposit: <span id="ppMinDeposit">--</span> <span id="ppMinUnit">ETH</span>
  </div>

  <button id="ppDepositBtn" class="swap-btn" disabled>Connect Wallet</button>

  <div id="ppNoteBox" style="display:none;margin-top:16px" class="quote-info">
    <div style="font-weight:600;color:#c0392b;margin-bottom:8px">Warning: Save this note! You need it to withdraw.</div>
    <textarea id="ppNote" readonly rows="3" class="pp-note-area" style="width:100%;box-sizing:border-box;font-family:monospace;font-size:11px;background:var(--surface);color:var(--fg);border:1px solid var(--border-muted);padding:8px;resize:vertical"></textarea>
    <div style="display:flex;gap:8px;margin-top:8px">
      <button onclick="navigator.clipboard.writeText($('ppNote').value)" class="swap-btn" style="flex:1;padding:6px">Copy</button>
      <button onclick="downloadNote()" class="swap-btn" style="flex:1;padding:6px">Download</button>
    </div>
    <p style="font-size:11px;margin-top:8px;color:var(--fg-muted)">
      Withdraw directly below, or via <a href="https://privacypools.com" target="_blank">privacypools.com</a>. Same wallet works on both.
    </p>
    <button onclick="setShown('ppNoteBox',false)" class="swap-btn" style="margin-top:6px;padding:4px 12px;font-size:11px;opacity:0.6">Dismiss</button>
  </div>

  <details style="margin-top:12px;font-size:12px">
    <summary style="cursor:pointer;opacity:0.6">Saved notes (<span id="ppNoteCount">0</span>)</summary>
    <div id="ppNotesList" style="margin-top:8px"></div>
  </details>
</div>

<div class="swap-card" style="margin-top:16px">
  <h2 style="font-size:14px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase;margin-bottom:12px">Withdraw from Privacy Pool</h2>
  <p style="font-size:12px;color:var(--fg-muted);margin-bottom:16px;line-height:1.5">Paste or upload your deposit note to withdraw. You can also manually fill in values from Etherscan logs. Check <a href="https://wenwithdraw.xyz/" target="_blank" rel="noopener">wenwithdraw.xyz</a> for optimal withdrawal timing.</p>

  <div class="section" style="margin-bottom:12px">
    <label style="margin:0;font-size:12px">Note JSON</label>
    <textarea id="ppwNote" rows="3" placeholder='{"nullifier":"0x...","secret":"0x...",...}' class="pp-note-area" style="width:100%;box-sizing:border-box;font-family:monospace;font-size:11px;background:var(--surface);color:var(--fg);border:1px solid var(--border-muted);padding:8px;resize:vertical;margin-top:4px"></textarea>
    <div style="display:flex;gap:8px;margin-top:6px">
      <button onclick="ppwParseNote()" class="swap-btn" style="flex:1;padding:6px;font-size:11px;margin:0">Parse Note</button>
      <button class="swap-btn" style="flex:1;padding:6px;font-size:11px;margin:0" onclick="this.querySelector('input').click()">Upload JSON<input type="file" accept=".json" onchange="ppwUploadNote(event)" style="display:none"></button>
    </div>
  </div>

  <div id="ppwParsed" style="display:none">
    <div style="font-size:11px;color:var(--fg-muted);margin-bottom:8px;font-weight:600">Parsed Note</div>
    <div style="display:grid;gap:6px;font-size:11px;margin-bottom:12px">
      <div><label style="color:var(--fg-muted);margin:0">Nullifier</label><div id="ppwNullifier" style="font-family:monospace;word-break:break-all;opacity:0.7">--</div></div>
      <div><label style="color:var(--fg-muted);margin:0">Secret</label><div id="ppwSecret" style="font-family:monospace;word-break:break-all;opacity:0.7">--</div></div>
      <div><label style="color:var(--fg-muted);margin:0">Precommitment (computed)</label><div id="ppwPrecommitment" style="font-family:monospace;word-break:break-all;opacity:0.7">--</div></div>
    </div>

    <details style="margin-bottom:12px;font-size:12px">
      <summary style="cursor:pointer;opacity:0.6">On-chain values (from logs)</summary>
      <div style="display:grid;gap:8px;margin-top:8px">
        <div class="section" style="margin:0">
          <label style="margin:0;font-size:11px">Leaf Index</label>
          <input type="number" id="ppwLeafIndex" class="amount-input" placeholder="e.g. 6404" style="font-size:12px">
        </div>
        <div class="section" style="margin:0">
          <label style="margin:0;font-size:11px">Value (wei)</label>
          <input type="text" id="ppwValue" class="amount-input" placeholder="Value in wei" style="font-size:12px">
        </div>
        <div class="section" style="margin:0">
          <label style="margin:0;font-size:11px">Label</label>
          <input type="text" id="ppwLabel" class="amount-input" placeholder="0x... or decimal" style="font-size:12px">
        </div>
        <div class="section" style="margin:0">
          <label style="margin:0;font-size:11px">Commitment</label>
          <input type="text" id="ppwCommitment" class="amount-input" placeholder="0x... or decimal" style="font-size:12px">
        </div>
        <div class="section" style="margin:0">
          <label style="margin:0;font-size:11px">State Root</label>
          <input type="text" id="ppwRoot" class="amount-input" placeholder="0x... or decimal" style="font-size:12px">
        </div>
      </div>
    </details>

    <div class="section" style="margin-bottom:12px">
      <label style="margin:0;font-size:11px">Withdraw Amount (wei) <span style="opacity:0.5">â€” leave blank for full withdrawal</span></label>
      <input type="text" id="ppwWithdrawAmt" class="amount-input" placeholder="Leave blank for full withdrawal" style="font-size:12px">
    </div>

    <div class="section" style="margin-bottom:12px">
      <label style="margin:0;font-size:11px">Recipient Address</label>
      <input type="text" id="ppwRecipient" class="amount-input" placeholder="0x... (default: connected wallet)" style="font-size:12px">
    </div>

    <details style="margin-bottom:12px;font-size:12px">
      <summary style="cursor:pointer;opacity:0.6">Etherscan API Key (for fetching tree data)</summary>
      <div style="margin-top:6px">
        <input type="text" id="ppwEtherscanKey" class="amount-input" placeholder="Your etherscan.io API key" style="font-size:11px"
          oninput="localStorage.setItem('pp_etherscan_key',this.value.trim())">
        <div style="font-size:10px;color:var(--fg-muted);margin-top:4px">Free to create. Stored in your browser only.</div>
      </div>
    </details>

    <div id="ppwVerify" style="display:none;margin-bottom:12px;font-size:11px;padding:8px;border:1px solid var(--border-muted);background:var(--surface);overflow-x:auto;word-break:break-word">
      <div id="ppwVerifyStatus"></div>
    </div>

    <button id="ppwWithdrawBtn" class="swap-btn" disabled onclick="ppwWithdraw()">Verify &amp; Prepare Withdrawal</button>

    <div id="ppwResult" style="display:none;margin-top:12px" class="quote-info">
      <div style="font-size:11px;font-weight:600;margin-bottom:6px">Withdrawal Data</div>
      <textarea id="ppwResultText" readonly rows="6" class="pp-note-area" style="width:100%;box-sizing:border-box;font-family:monospace;font-size:10px;background:var(--surface);color:var(--fg);border:1px solid var(--border-muted);padding:8px;resize:vertical"></textarea>
    </div>
  </div>
</div>

</div><!-- end privacyTab -->

<!-- Status -->
<div id="status" class="status"></div>

<!-- Wallet Modal -->
<div class="modal-overlay" id="walletModal" onclick="if(event.target===this)closeWalletModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Connect Wallet</div>
      <button class="modal-close" onclick="closeWalletModal()">&times;</button>
    </div>
    <div class="modal-body" id="walletOptions"></div>
  </div>
</div>

<!-- Token Modal -->
<div class="modal-overlay" id="tokenModal" onclick="if(event.target===this)closeTokenModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Select Token</div>
      <button class="modal-close" onclick="closeTokenModal()">&times;</button>
    </div>
    <input type="text" id="tokenSearchInput" class="token-search" placeholder="Search or enter list.wei" autocomplete="off">
    <div id="weiListStatus" class="token-search-status"></div>
    <div id="tokenList" style="max-height:320px;overflow-y:auto"></div>
    <div style="border-top:1px solid var(--border);padding-top:10px;margin-top:8px;display:flex;gap:8px;align-items:center">
      <input type="text" id="customTokenAddress" class="custom-token-input" placeholder="Paste token address" style="margin:0;flex:1">
      <button style="white-space:nowrap;font-size:12px;padding:6px 12px" onclick="addCustomToken()">Add</button>
    </div>
  </div>
</div>

<!-- Footer web ring -->
<div class="site-footer">
  <a href="./domains/">Domains</a> &middot; <a href="./dao/">DAO</a> &middot; <a href="./ico/">ICO</a> &middot; built by <a href="https://opensea.io/collection/zorgz" target="_blank" rel="noopener"><svg width="14" height="14" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin:0 2px;image-rendering:pixelated"><rect width="16" height="16" fill="#0a0a0a"/><rect x="3" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="5" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="10" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="12" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="4" y="4" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="5" width="10" height="1" fill="#e8e8e0"/><rect x="2" y="6" width="12" height="3" fill="#e8e8e0"/><rect x="3" y="9" width="10" height="1" fill="#e8e8e0"/><rect x="4" y="10" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="10" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="5" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="9" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="2" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="7" y="12" width="2" height="1" fill="#e8e8e0"/><rect x="11" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="1" y="13" width="2" height="1" fill="#e8e8e0"/><rect x="13" y="13" width="2" height="1" fill="#e8e8e0"/></svg></a><a href="./dao/#/dao/1/0x5E58BA0e06ED0F5558f83bE732a4b899a674053E">zOrg</a> &middot; <a href="https://x.com/z_fi_" target="_blank" rel="noopener" title="X"><svg width="14" height="14" viewBox="0 0 300 300.251" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;fill:currentColor"><path d="M178.57 127.15 290.27 0h-26.46l-97.03 110.38L89.34 0H0l117.13 166.93L0 300.25h26.46l102.4-116.59 81.8 116.59h89.34M36.01 19.54H76.66l187.13 262.13h-40.66"/></svg></a>
  <div style="margin-top:8px;letter-spacing:1px"><a href="https://github.com/z-fi/zFi" target="_blank" rel="noopener" style="text-decoration:none;color:inherit">zfi.wei</a></div>
  <div class="tagline" style="margin-top:4px;font-size:12px;letter-spacing:0.5px;font-style:italic">the most secure-by-default exchange that does everything onchain</div>
  <div style="margin-top:2px;font-size:11px;letter-spacing:0.5px;opacity:0.5">powered by $zorg the governance reward token of the zfi stack</div>
  <div style="margin-top:2px;font-size:11px;opacity:0.5"><a href="https://etherscan.io/token/0x00a6bA94BBb5474725515De88fE04F854f2dCb12" target="_blank" rel="noopener" style="color:inherit">0x00a6bA94BBb5474725515De88fE04F854f2dCb12</a></div>
</div>

<script src="./ethers.min.js"></script>
<script src="./walletconnect.min.js"></script>
<script src="./poseidon2.min.js"></script>
<script src="./poseidon1.min.js"></script>
<script src="./poseidon3.min.js"></script>
<script>
// ---- Dark mode ----
function toggleDark() {
  const on = document.documentElement.classList.toggle('dark');
  localStorage.setItem('dark', on ? '1' : '0');
}
document.addEventListener('click', () => document.querySelectorAll('.info-tip.open').forEach(t => t.classList.remove('open')));

// ---- Constants ----
const CHAIN_ID = 1;
const ZQUOTER_ADDRESS = "0xBe3d86dc8FFfd8FFC1B6fC7e1320417c9C7F18c5";
const ZROUTER_ADDRESS = "0x000000000000FB114709235f1ccBFfb925F600e4";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
const USDT_ADDRESS = "0xdAC17F958D2ee523a2206206994597C13D831ec7";
const WBTC_ADDRESS = "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599";
const WETH_ADDRESS = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
const STETH_ADDRESS = "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84";
const WSTETH_ADDRESS = "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0";
const RETH_ADDRESS = "0xae78736Cd615f374D3085123A210448E74Fc6393";
const DAI_ADDRESS = "0x6B175474E89094C44Da98b954EedeAC495271d0F";
const BOLD_ADDRESS = "0x6440f144b7e50D6a8439336510312d2F54beB01D";
const LUSD_ADDRESS = "0x5f98805A4E8be255a32880FDeC7F6728C6568bA0";
const PNKSTR_ADDRESS = "0xc50673EDb3A7b94E8CAD8a7d4E0cD68864E33eDF";
const PERMIT2_ADDRESS = "0x000000000022D473030F116dDEE9F6B43aC78BA3";
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
const WEINS_ADDRESS = "0x0000000000696760E15f265e828DB644A0c242EB";
const PNKSTR_HOOK_ADDRESS = "0xfAaad5B731F52cDc9746F2414c823eca9B06E844";
const V4_ROUTER_ADDRESS = "0x00000000000044a361Ae3cAc094c9D1b14Eece97";
// V4 USDC/PNKSTR hookless pool params (fee=10000, tickSpacing=200)
const MULTICALL3_ADDRESS = "0xcA11bde05977b3631167028862bE2a173976CA11";
const ZAMM_HOOKED = "0x000000000000040470635EB91b7CE4D132D616eD";
const ZAMM_HOOKLESS = "0x00000000000008882D72EfA6cCE4B6a40b24C860";
const ZAMM_POOLS_ABI = ["function pools(uint256) view returns (uint112, uint112, uint32, uint256, uint256, uint256, uint256)"];
const ZORG_TOKEN = "0x0000000000009710cd229bf635c4500029651ee8";
const ZORG_ID = 1334160193485309697971829933264346612480800613613n;
const ZORG_PAY_TOKEN = "0xe9b1cfea55baa219e34301f2f31b9fd0921664ed"; // ERC20 equivalent of the ERC6909 swap output
const ZORG_DAO = "0x5E58BA0e06ED0F5558f83bE732a4b899a674053E";
const ZORG_DAO_TOKEN = "0x00a6bA94BBb5474725515De88fE04F854f2dCb12";
const WEINS_ABI = ["function computeId(string) pure returns (uint256)", "function text(uint256,string) view returns (string)", "function contenthash(uint256) view returns (bytes)", "function reverseResolve(address) view returns (string)", "function ownerOf(uint256) view returns (address)"];
const IPFS_GATEWAYS = ["https://content.wrappr.wtf/ipfs/", "https://dweb.link/ipfs/"];
const BUILTIN_ADDRS = new Set([ZERO_ADDRESS, WETH_ADDRESS, ZORG_DAO_TOKEN, ZORG_PAY_TOKEN, BOLD_ADDRESS, LUSD_ADDRESS, DAI_ADDRESS, USDC_ADDRESS, USDT_ADDRESS, WBTC_ADDRESS, STETH_ADDRESS, WSTETH_ADDRESS, RETH_ADDRESS, PNKSTR_ADDRESS].map(a => a.toLowerCase()));

// ---- DOM helpers ----
const $ = id => document.getElementById(id);

function setText(id, s) {
  const el = typeof id === 'string' ? $(id) : id;
  if (!el) return;
  if (el.textContent !== s) el.textContent = s;
}
let _htmlCache = new WeakMap();
function setHTML(id, s) {
  const el = typeof id === 'string' ? $(id) : id;
  if (!el) return;
  if (_htmlCache.get(el) === s) return;
  el.innerHTML = s;
  _htmlCache.set(el, s);
}
function setShown(id, shown) {
  const el = typeof id === 'string' ? $(id) : id;
  if (!el) return;
  const want = shown ? '' : 'none';
  if (el.style.display !== want) el.style.display = want;
}
function setDisabled(btn, disabled) {
  const el = typeof btn === 'string' ? $(btn) : btn;
  if (!el) return;
  if (!!el.disabled !== !!disabled) el.disabled = !!disabled;
}
const _escTextMap = { '&': '&amp;', '<': '&lt;', '>': '&gt;' };
function escText(s) {
  return String(s).replace(/[&<>]/g, m => _escTextMap[m]);
}
function escAttr(s) {
  return escText(s).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}
function debounce(fn, wait) {
  let t;
  return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), wait); };
}

// ---- Wallet state ----
let provider = null;
let signer = null;
let connectedAddress = null;
let connectedWalletProvider = null;
let walletConnectProvider = null;
let isConnecting = false;
let walletEventHandlers = null;
let isWalletConnect = false;
let wcDeepLink = null;

const eip6963Providers = new Map();

window.addEventListener('eip6963:announceProvider', (event) => {
  try {
    const { info, provider } = event.detail || {};
    if (info?.uuid && provider) {
      eip6963Providers.set(info.uuid, { info, provider });
    }
  } catch (e) {}
});
window.dispatchEvent(new Event('eip6963:requestProvider'));

// ---- Wallet helpers ----
function findProvider(checkFn) {
  if (window.ethereum?.providers?.length) {
    for (const p of window.ethereum.providers) {
      if (checkFn(p)) return p;
    }
  }
  if (window.ethereum && checkFn(window.ethereum)) return window.ethereum;
  return null;
}

const WALLET_CONFIG = {
  metamask: { name: 'MetaMask', icon: 'ðŸ¦Š', detect: () => findProvider(p => p.isMetaMask), getProvider: () => findProvider(p => p.isMetaMask) },
  coinbase: { name: 'Coinbase', icon: 'ðŸ”µ', detect: () => findProvider(p => p.isCoinbaseWallet), getProvider: () => findProvider(p => p.isCoinbaseWallet) },
  rabby: { name: 'Rabby', icon: 'ðŸ°', detect: () => findProvider(p => p.isRabby), getProvider: () => findProvider(p => p.isRabby) },
  rainbow: { name: 'Rainbow', icon: 'ðŸŒˆ', detect: () => findProvider(p => p.isRainbow), getProvider: () => findProvider(p => p.isRainbow) },
  walletconnect: { name: 'WalletConnect', icon: 'ðŸ“±' }
};

function detectWallets() {
  const detected = [];
  const seenNames = new Set();

  // 1. EIP-6963 providers first
  for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
    const name = info?.name || 'Unknown';
    if (!seenNames.has(name.toLowerCase())) {
      const iconUrl = info.icon && (info.icon.startsWith('data:image/') || info.icon.startsWith('https://')) ? info.icon : null;
      const safeIconUrl = iconUrl ? iconUrl.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c])) : null;
      detected.push({
        key: `eip6963_${uuid}`,
        name: name,
        icon: safeIconUrl ? `<img src="${safeIconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : 'ðŸ”Œ',
        getProvider: () => provider
      });
      seenNames.add(name.toLowerCase());
    }
  }

  // 2. Check window.ethereum.providers array
  if (window.ethereum?.providers?.length) {
    for (let i = 0; i < window.ethereum.providers.length; i++) {
      const p = window.ethereum.providers[i];
      const name = p.isMetaMask ? 'MetaMask' : p.isCoinbaseWallet ? 'Coinbase' : p.isRabby ? 'Rabby' : p.isRainbow ? 'Rainbow' : null;
      if (name && !seenNames.has(name.toLowerCase())) {
        detected.push({ key: `provider_${i}`, name, icon: 'ðŸ”—', getProvider: () => p });
        seenNames.add(name.toLowerCase());
      }
    }
  }

  // 3. Legacy WALLET_CONFIG detection
  for (const [key, config] of Object.entries(WALLET_CONFIG)) {
    if (key === 'walletconnect') continue;
    try {
      if (config.detect && config.detect() && !seenNames.has(config.name.toLowerCase())) {
        detected.push({ key, ...config });
        seenNames.add(config.name.toLowerCase());
      }
    } catch (e) {}
  }

  // 4. Fallback: if nothing detected but window.ethereum exists
  if (detected.length === 0 && window.ethereum) {
    detected.push({ key: 'injected', name: 'Browser Wallet', icon: 'ðŸ”—', getProvider: () => window.ethereum });
  }

  // 5. WalletConnect
  const wcModule = globalThis['@walletconnect/ethereum-provider'];
  if (wcModule?.EthereumProvider) {
    detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: 'ðŸ“±' });
  }

  return detected;
}

function showWalletModal() {
  $('walletModal').classList.add('active');
  document.body.classList.add('modal-open');
  $('walletOptions').innerHTML = '<div style="padding:12px;text-align:center;">Detecting wallets...</div>';

  window.dispatchEvent(new Event('eip6963:requestProvider'));

  const doDetect = (attempt = 1) => {
    const wallets = detectWallets();
    const hasBrowserWallet = wallets.some(w => w.key !== 'walletconnect');
    if (!hasBrowserWallet && attempt < 2) {
      setTimeout(() => doDetect(attempt + 1), 250);
    } else {
      renderWalletModal(wallets);
    }
  };

  setTimeout(() => doDetect(), 150);
}

function renderWalletModal(wallets) {
  const container = $('walletOptions');

  if (connectedAddress) {
    const displayName = $('walletBtn').textContent;
    const showName = displayName && displayName !== 'connect' && !displayName.startsWith('0x');
    container.innerHTML = `
      <div style="padding: 12px; border: 1px solid currentColor; margin-bottom: 12px;">
        <div style="font-weight: 600; margin-bottom: 6px;">Connected</div>
        ${showName ? `<div style="font-size: 16px; margin-bottom: 4px;">${escText(displayName)}</div>` : ''}
        <div style="font-size: 12px; word-break: break-all; opacity: 0.6;">${escText(connectedAddress)}</div>
      </div>
      <div class="wallet-option disconnect" onclick="disconnectWallet()">
        <span class="wallet-option-name">Disconnect</span>
      </div>
    `;
  } else {
    container.innerHTML = wallets.length > 0 ? wallets.map(w => `
      <div class="wallet-option" data-wallet-key="${escAttr(w.key)}">
        <span class="wallet-option-icon">${w.icon}</span>
        <span class="wallet-option-name">${escText(w.name)}</span>
      </div>
    `).join('') : '<div style="padding:12px;text-align:center;">No wallets detected.</div>';
    container.querySelectorAll('[data-wallet-key]').forEach(el => {
      el.addEventListener('click', () => connectWithWallet(el.dataset.walletKey));
    });
  }
}

function closeWalletModal() {
  $('walletModal').classList.remove('active');
  document.body.classList.remove('modal-open');
}

function toggleWallet() { showWalletModal(); }

// ---- WalletConnect transaction helper ----
async function wcTransaction(txPromise, message = 'Confirm in your wallet app') {
  if (!isWalletConnect) return txPromise;

  const notif = document.createElement('div');
  notif.id = 'wcNotif';
  notif.innerHTML = `
    <div style="position:fixed;top:0;left:0;right:0;background:#1a1a2e;color:#fff;padding:16px;text-align:center;z-index:10000;font-size:14px;">
      <div style="margin-bottom:8px;">ðŸ“± ${escText(message)}</div>
      <div style="font-size:12px;opacity:0.7;">Open your wallet app to approve the transaction</div>
      ${wcDeepLink && /^https?:\/\//i.test(wcDeepLink) ? `<a href="${escAttr(wcDeepLink)}" style="display:inline-block;margin-top:8px;padding:8px 16px;background:#fff;color:#000;border-radius:4px;text-decoration:none;">Open Wallet</a>` : ''}
    </div>
  `;
  document.body.appendChild(notif);

  try {
    const result = await txPromise;
    return result;
  } finally {
    notif.remove();
  }
}

// ---- waitForTx - robust tx confirmation ----
async function waitForTx(tx, timeoutMs = 90000) {
  const txHash = tx.hash;

  async function pollReceipt(maxAttempts = 45) {
    const p = quoteRPC ? await quoteRPC.call(rpc => rpc) : provider;
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const receipt = await p.getTransactionReceipt(txHash);
        if (receipt) {
          if (receipt.status === 0) throw new Error('Transaction reverted');
          return receipt;
        }
      } catch (rpcErr) {
        if (/Transaction reverted/i.test(rpcErr?.message) || i === maxAttempts - 1) throw rpcErr;
      }
      await new Promise(r => setTimeout(r, 2000));
    }
    return null;
  }

  // For WalletConnect, always use polling
  if (isWalletConnect) {
    const receipt = await pollReceipt();
    if (receipt) return receipt;
    throw new Error('Transaction confirmation timeout');
  }

  // Race tx.wait() against timeout
  let receipt = null;
  let waitError = null;

  try {
    receipt = await Promise.race([
      tx.wait(),
      new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeoutMs))
    ]);
  } catch (e) {
    waitError = e;
    const msg = (e.message || '').toLowerCase();
    const shouldPoll = msg.includes('timeout') ||
                       msg.includes('index') ||
                       msg.includes('invalid_argument') ||
                       msg.includes('invalid argument') ||
                       msg.includes('could not coalesce') ||
                       msg.includes('missing response');

    if (shouldPoll && txHash) {
      receipt = await pollReceipt();
    }
  }

  if (receipt) return receipt;
  throw waitError || new Error('Transaction confirmation timeout');
}

// ---- Connect with wallet ----
async function connectWithWallet(walletKey) {
  if (isConnecting) return;
  isConnecting = true;

  try {
    closeWalletModal();
    let walletProvider;

    if (walletKey === 'walletconnect') {
      const wcModule = globalThis['@walletconnect/ethereum-provider'];
      const WCProvider = wcModule?.EthereumProvider;

      if (!WCProvider?.init) throw new Error('WalletConnect not available');

      if (walletConnectProvider) {
        try { await walletConnectProvider.disconnect?.(); } catch (e) {}
        walletConnectProvider = null;
      }

      walletConnectProvider = await WCProvider.init({
        projectId: '1e8390ef1c1d8a185e035912a1409749',
        chains: [1],
        showQrModal: true,
        rpcMap: { 1: 'https://1rpc.io/eth' },
        metadata: {
          name: 'ETH Swap by zAMM',
          description: 'Onchain DEX aggregator',
          url: window.location.origin,
          icons: []
        }
      });

      walletConnectProvider.on('display_uri', (uri) => {
        try {
          const session = walletConnectProvider.session;
          const peerMeta = session?.peer?.metadata;
          if (peerMeta?.redirect?.native && /^https?:\/\//i.test(peerMeta.redirect.native)) wcDeepLink = peerMeta.redirect.native;
          else if (peerMeta?.redirect?.universal && /^https?:\/\//i.test(peerMeta.redirect.universal)) wcDeepLink = peerMeta.redirect.universal;
        } catch (e) {}
      });

      await walletConnectProvider.enable();
      walletProvider = walletConnectProvider;
      isWalletConnect = true;

      try {
        const session = walletConnectProvider.session;
        const peerMeta = session?.peer?.metadata;
        if (peerMeta?.redirect?.native && /^https?:\/\//i.test(peerMeta.redirect.native)) wcDeepLink = peerMeta.redirect.native;
        else if (peerMeta?.redirect?.universal && /^https?:\/\//i.test(peerMeta.redirect.universal)) wcDeepLink = peerMeta.redirect.universal;
      } catch (e) {}
    } else if (walletKey.startsWith('eip6963_')) {
      const uuid = walletKey.replace('eip6963_', '');
      walletProvider = eip6963Providers.get(uuid)?.provider;
      if (!walletProvider) {
        const savedName = localStorage.getItem('zswap_wallet_name')?.toLowerCase();
        if (savedName) {
          for (const [, { info, provider }] of eip6963Providers) {
            if (info?.name?.toLowerCase() === savedName) {
              walletProvider = provider;
              break;
            }
          }
        }
      }
      isWalletConnect = false;
      wcDeepLink = null;
    } else {
      walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
      isWalletConnect = false;
      wcDeepLink = null;
    }

    if (!walletProvider) throw new Error('Wallet not found');

    if (walletKey !== 'walletconnect') {
      await walletProvider.request({ method: 'eth_requestAccounts' });
    }

    // Check/switch chain
    const chainId = await walletProvider.request({ method: 'eth_chainId' });
    if (BigInt(chainId) !== 1n) {
      try {
        await walletProvider.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: '0x1' }]
        });
        const newChainId = await walletProvider.request({ method: 'eth_chainId' });
        if (BigInt(newChainId) !== 1n) throw new Error('Chain switch failed');
      } catch (switchErr) {
        showStatus('Please switch to Ethereum Mainnet', 'error');
        if (walletKey === 'walletconnect') {
          try { walletConnectProvider?.disconnect(); } catch (e) {}
          walletConnectProvider = null;
        }
        isWalletConnect = false;
        wcDeepLink = null;
        return;
      }
    }

    // Initialize globals
    provider = new ethers.BrowserProvider(walletProvider);
    signer = await provider.getSigner();
    connectedAddress = await signer.getAddress();
    const oldWalletProvider = connectedWalletProvider;
    connectedWalletProvider = walletProvider;
    updateWalletDisplay();

    if (oldWalletProvider && walletEventHandlers) {
      try {
        oldWalletProvider.removeListener('accountsChanged', walletEventHandlers.accountsChanged);
        oldWalletProvider.removeListener('chainChanged', walletEventHandlers.chainChanged);
      } catch (e) {}
    }
    walletEventHandlers = {
      accountsChanged: () => window.location.reload(),
      chainChanged: () => window.location.reload()
    };
    walletProvider.on('accountsChanged', walletEventHandlers.accountsChanged);
    walletProvider.on('chainChanged', walletEventHandlers.chainChanged);

    try {
      localStorage.setItem('zswap_wallet', walletKey);
      if (walletKey.startsWith('eip6963_')) {
        const uuid = walletKey.replace('eip6963_', '');
        const name = eip6963Providers.get(uuid)?.info?.name;
        if (name) localStorage.setItem('zswap_wallet_name', name);
      }
    } catch (e) {}

    // Clear caches (provider changed)
    _erc20Read.clear();
    _balanceCache.clear();
    _allowCache.clear();

    // Update swap UI
    setText('swapBtn', 'Enter an amount');
    setDisabled('swapBtn', true);
    updateBalances();
    updateWcBanner();

    const preAmt = _inputMode === 'exactOut' ? $('toAmount')?.value?.trim() : $('fromAmount')?.value?.trim();
    if (preAmt) handleAmountChange();

    // Update Privacy tab if visible
    if ($('privacyTab')?.style.display !== 'none') { updatePPBalance(); updatePPButton(); }

  } catch (error) {
    handleError(error);
  } finally {
    isConnecting = false;
  }
}

function updateWcBanner() {
  const existing = $('wcBanner');
  if (existing) existing.remove();

  if (isWalletConnect && connectedAddress) {
    const banner = document.createElement('div');
    banner.id = 'wcBanner';
    banner.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#1a1a2e;color:#fff;padding:10px 16px;display:flex;justify-content:space-between;align-items:center;z-index:9000;font-size:13px;';
    banner.innerHTML = `
      <span>ðŸ“± Connected via WalletConnect</span>
      <button onclick="disconnectWallet()" style="background:#fff;color:#000;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:12px;">Disconnect</button>
    `;
    document.body.prepend(banner);
    document.body.style.paddingTop = '44px';
  } else {
    document.body.style.paddingTop = '';
  }
}

function updateWalletDisplay() {
  if (!connectedAddress) {
    $('walletBtn').textContent = 'connect';
    updateWcBanner();
    return;
  }
  $('walletBtn').textContent = connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
  updateWcBanner();
  // Resolve .wei name in background
  const _capturedAddr = connectedAddress;
  quoteRPC.call(async (rpc) => {
    const ns = getWeinsContract(rpc);
    const name = await ns.reverseResolve(_capturedAddr);
    if (name && connectedAddress === _capturedAddr) $('walletBtn').textContent = name.toLowerCase();
  }).catch(() => {});
}

function disconnectWallet() {
  if (connectedWalletProvider && walletEventHandlers) {
    try {
      connectedWalletProvider.removeListener('accountsChanged', walletEventHandlers.accountsChanged);
      connectedWalletProvider.removeListener('chainChanged', walletEventHandlers.chainChanged);
    } catch (e) {}
  }
  walletEventHandlers = null;

  if (walletConnectProvider) {
    try { walletConnectProvider.disconnect(); } catch (e) {}
    walletConnectProvider = null;
  }
  provider = null;
  signer = null;
  connectedAddress = null;
  connectedWalletProvider = null;
  isWalletConnect = false;
  wcDeepLink = null;
  $('walletBtn').textContent = 'connect';
  updateWcBanner();
  closeWalletModal();
  try { localStorage.removeItem('zswap_wallet'); localStorage.removeItem('zswap_wallet_name'); } catch (e) {}

  // Reset swap UI
  setText('swapBtn', 'Connect Wallet');
  setDisabled('swapBtn', false);
  setText('fromBalance', 'Balance: --');
  setText('toBalance', 'Balance: --');
  setShown('quoteInfo', false);
  stopQuoteRefresh();
  $('toAmount').value = '';
  _erc20Read.clear();
  _balanceCache.clear();
  _allowCache.clear();
  _ppMasterKeys = null;

  // Update Privacy tab
  updatePPButton(); setText('ppBalance', '');
}

function showStatus(msg, type) {
  const el = $('status');
  if (!el) return;
  el.textContent = msg;
  el.className = 'status show' + (type ? ' ' + type : '');
  setTimeout(() => { el.className = 'status'; }, type === 'error' ? 8000 : 5000);
}

function handleError(e) {
  const msg = (e.message || e.reason || String(e)).toLowerCase();
  if (msg.includes('user rejected') || msg.includes('user denied') || msg.includes('user cancelled')) return;
  showStatus(e.message || 'An error occurred', 'error');
}

// ---- Token data ----
let currentModal = null;
const tokens = {
  ETH: { address: ZERO_ADDRESS, symbol: "ETH", decimals: 18 },
  WETH: { address: WETH_ADDRESS, symbol: "WETH", decimals: 18 },
  zOrg: { address: ZORG_DAO_TOKEN, symbol: "zOrg", decimals: 18, _isZOrg: true },
  ZAMM: { address: ZORG_PAY_TOKEN, symbol: "ZAMM", decimals: 18, _isZammStake: true },
  BOLD: { address: BOLD_ADDRESS, symbol: "BOLD", decimals: 18 },
  LUSD: { address: LUSD_ADDRESS, symbol: "LUSD", decimals: 18 },
  DAI: { address: DAI_ADDRESS, symbol: "DAI", decimals: 18 },
  USDC: { address: USDC_ADDRESS, symbol: "USDC", decimals: 6 },
  USDT: { address: USDT_ADDRESS, symbol: "USDT", decimals: 6 },
  WBTC: { address: WBTC_ADDRESS, symbol: "WBTC", decimals: 8 },
  stETH: { address: STETH_ADDRESS, symbol: "stETH", decimals: 18 },
  wstETH: { address: WSTETH_ADDRESS, symbol: "wstETH", decimals: 18 },
  rETH: { address: RETH_ADDRESS, symbol: "rETH", decimals: 18 },
  PNKSTR: { address: PNKSTR_ADDRESS, symbol: "PNKSTR", decimals: 18 },
};

// Load custom tokens from localStorage
try {
  const saved = JSON.parse(localStorage.getItem('zswap_custom_tokens') || '[]');
  for (const t of saved) {
    if (t.address && t.symbol && t.decimals != null && !tokens[t.symbol]) {
      tokens[t.symbol] = { address: t.address, symbol: t.symbol, decimals: t.decimals };
    }
  }
} catch (_) {}

function saveCustomTokens() {
  try {
    const custom = Object.values(tokens).filter(t => !BUILTIN_ADDRS.has(t.address.toLowerCase()) && !weiListTokenSource.has(t.symbol));
    localStorage.setItem('zswap_custom_tokens', JSON.stringify(custom));
  } catch (_) {}
}

// ---- .wei token list state ----
const weiLists = new Map();       // name â†’ { tokens: [...], loadedAt }
const weiListTokenSource = new Map(); // symbol â†’ listName
let _tokenListAutoLoaded = false;  // true once auto-load of token-list.wei attempted

function saveWeiLists() {
  try {
    const obj = {};
    for (const [name, data] of weiLists) obj[name] = data;
    localStorage.setItem('zswap_wei_lists', JSON.stringify(obj));
  } catch (_) {}
}

function loadWeiLists() {
  try {
    const raw = JSON.parse(localStorage.getItem('zswap_wei_lists') || '{}');
    for (const [name, data] of Object.entries(raw)) {
      if (data && Array.isArray(data.tokens)) {
        weiLists.set(name, data);
        mergeWeiListTokens(name, data.tokens);
      }
    }
  } catch (_) {}
}

function validateTokenList(rawArray) {
  if (!Array.isArray(rawArray)) return [];
  const seen = new Set();
  const result = [];
  for (const entry of rawArray) {
    if (!entry || typeof entry !== 'object') continue;
    const { address, symbol, decimals } = entry;
    if (!address || !symbol || decimals == null) continue;
    const addrClean = String(address).trim().toLowerCase();
    if (!ethers.isAddress(addrClean)) continue;
    const checksummed = ethers.getAddress(addrClean);
    if (checksummed === ZERO_ADDRESS) continue;
    const addrLower = checksummed.toLowerCase();
    if (seen.has(addrLower)) continue;
    const sym = String(symbol).trim();
    if (!sym || sym.length > 24 || !/^[A-Za-z0-9.$_-]+$/.test(sym)) continue;
    const dec = Number(decimals);
    if (!Number.isInteger(dec) || dec < 0 || dec > 36) continue;
    seen.add(addrLower);
    const item = { address: checksummed, symbol: sym, decimals: dec };
    if (entry.icon && typeof entry.icon === 'string') {
      const url = entry.icon.trim();
      if (url.startsWith('https://') || url.startsWith('data:image/')) item.icon = url;
    }
    result.push(item);
  }
  return result;
}

function mergeWeiListTokens(listName, validated) {
  const builtInAddrs = BUILTIN_ADDRS;
  for (const t of validated) {
    if (builtInAddrs.has(t.address.toLowerCase())) continue;
    let sym = t.symbol;
    // Handle symbol collision with different address
    if (tokens[sym] && tokens[sym].address.toLowerCase() !== t.address.toLowerCase()) {
      sym = sym + '.' + listName.replace(/\.wei$/, '');
    }
    if (!tokens[sym]) {
      tokens[sym] = { address: t.address, symbol: sym, decimals: t.decimals };
      if (t.icon) tokens[sym].icon = t.icon;
    }
    weiListTokenSource.set(sym, listName);
  }
}

// ---- ENSIP-7 contenthash â†’ IPFS CID decoder ----
const BASE32_ALPHA = 'abcdefghijklmnopqrstuvwxyz234567';
function bytesToBase32(bytes) {
  let bits = 0, value = 0, out = '';
  for (const b of bytes) {
    value = (value << 8) | b;
    bits += 8;
    while (bits >= 5) { bits -= 5; out += BASE32_ALPHA[(value >> bits) & 31]; }
  }
  if (bits > 0) out += BASE32_ALPHA[(value << (5 - bits)) & 31];
  return out;
}

function decodeContenthash(hex) {
  try {
    const bytes = ethers.getBytes(hex);
    if (bytes.length < 3) return null;
    let proto = 0, shift = 0, offset = 0;
    for (; offset < bytes.length; offset++) {
      proto |= (bytes[offset] & 0x7f) << shift;
      shift += 7;
      if (!(bytes[offset] & 0x80)) { offset++; break; }
    }
    if (proto !== 0xe3) return null; // IPFS only
    const cidBytes = bytes.slice(offset);
    if (cidBytes[0] === 0x01) return 'b' + bytesToBase32(cidBytes); // CIDv1
    return null;
  } catch { return null; }
}

async function fetchIPFS(cid) {
  let lastErr;
  for (const gw of IPFS_GATEWAYS) {
    try {
      const resp = await fetch(gw + cid);
      if (!resp.ok) throw new Error(resp.status);
      return await resp.text();
    } catch (e) { lastErr = e; }
  }
  throw new Error('All IPFS gateways failed: ' + lastErr?.message);
}

let _weiResolveSeq = 0;
let _weiResolving = false;

async function resolveWeiList(nameInput) {
  let name = nameInput.toLowerCase().trim();
  if (name.endsWith('.wei')) name = name.slice(0, -4);
  if (!name) return;
  const fullName = name + '.wei';

  if (weiLists.has(fullName)) {
    setHTML('weiListStatus', escText(fullName) + ' already loaded');
    return;
  }

  const seq = ++_weiResolveSeq;
  _weiResolving = true;
  const statusEl = $('weiListStatus');
  statusEl.className = 'token-search-status';
  statusEl.textContent = 'Loading ' + fullName + '...';

  try {
    // Read both contenthash and text record in parallel
    const { ch, txt } = await quoteRPC.call(async (rpc) => {
      const ns = getWeinsContract(rpc);
      const tokenId = await ns.computeId(fullName);
      const [ch, txt] = await Promise.all([
        ns.contenthash(tokenId).catch(() => '0x'),
        ns.text(tokenId, 'tokens').catch(() => ''),
      ]);
      return { ch, txt };
    });

    if (seq !== _weiResolveSeq) { _weiResolving = false; return; }

    let raw = null;

    // Try contenthash first (IPFS)
    if (ch && ch !== '0x' && ch.length > 2) {
      const cid = decodeContenthash(ch);
      if (cid) {
        statusEl.textContent = 'Fetching from IPFS...';
        raw = await fetchIPFS(cid);
        if (seq !== _weiResolveSeq) { _weiResolving = false; return; }
      }
    }

    // Fall back to text record
    if (!raw || !raw.trim()) {
      raw = txt;
    }

    if (!raw || !raw.trim()) {
      statusEl.className = 'token-search-status error';
      statusEl.textContent = 'No token list found on ' + fullName;
      _weiResolving = false;
      return;
    }

    let parsed;
    try { parsed = JSON.parse(raw); } catch (e) {
      statusEl.className = 'token-search-status error';
      statusEl.textContent = 'Invalid JSON from ' + fullName;
      _weiResolving = false;
      return;
    }

    const validated = validateTokenList(parsed);
    if (validated.length === 0) {
      statusEl.className = 'token-search-status error';
      statusEl.textContent = 'No valid tokens in ' + fullName;
      _weiResolving = false;
      return;
    }

    weiLists.set(fullName, { tokens: validated, loadedAt: Date.now() });
    mergeWeiListTokens(fullName, validated);
    saveWeiLists();
    statusEl.className = 'token-search-status';
    statusEl.textContent = 'Loaded ' + validated.length + ' tokens from ' + fullName;

    _weiResolving = false;
    const filter = $('tokenSearchInput')?.value || '';
    renderTokenList(filter);
  } catch (e) {
    _weiResolving = false;
    if (seq !== _weiResolveSeq) return;
    statusEl.className = 'token-search-status error';
    statusEl.textContent = 'Failed to resolve ' + fullName;
    console.error('.wei resolve error:', e);
    renderTokenList($('tokenSearchInput')?.value || '');
  }
}

function removeWeiList(listName) {
  const entry = weiLists.get(listName);
  if (!entry) return;
  // Collect symbols to remove (avoid mutating map during iteration)
  const toRemove = [];
  for (const [sym, src] of weiListTokenSource) {
    if (src !== listName) continue;
    // Don't remove if currently selected
    if (sym === fromToken || sym === toToken) continue;
    toRemove.push(sym);
  }
  for (const sym of toRemove) {
    delete tokens[sym];
    weiListTokenSource.delete(sym);
  }
  weiLists.delete(listName);
  saveWeiLists();
  if (listName === 'token-list.wei') _tokenListAutoLoaded = false;
}

function renderTokenList(filter) {
  const list = $('tokenList');
  if (!list) return;
  list.textContent = '';
  const frag = document.createDocumentFragment();
  const q = (filter || '').toLowerCase().trim();

  const builtInAddrs = BUILTIN_ADDRS;

  function matchesFilter(sym, addr) {
    if (!q) return true;
    return sym.toLowerCase().includes(q) || addr.toLowerCase().includes(q);
  }

  function makeRow(symbol) {
    const t = tokens[symbol];
    const row = document.createElement('div');
    row.className = 'token-list-item';
    row.setAttribute('data-symbol', symbol);
    const iconSpan = document.createElement('span');
    iconSpan.className = 'token-icon';
    iconSpan.innerHTML = iconForSymbol(symbol);
    const nameSpan = document.createElement('span');
    nameSpan.className = 'token-symbol';
    nameSpan.textContent = symbol;
    const balSpan = document.createElement('span');
    balSpan.className = 'token-balance';
    if (connectedAddress && t) {
      const cached = getCachedBalance(t.address);
      if (cached != null && cached > 0n) {
        const formatted = t.address === ZERO_ADDRESS
          ? ethers.formatEther(cached) : ethers.formatUnits(cached, t.decimals);
        balSpan.textContent = fmt(formatted);
      }
    }
    row.append(iconSpan, nameSpan, balSpan);
    return row;
  }

  // Built-in tokens
  let hasAny = false;
  for (const sym of Object.keys(tokens)) {
    if (!builtInAddrs.has(tokens[sym].address.toLowerCase())) continue;
    if (!matchesFilter(sym, tokens[sym].address)) continue;
    frag.appendChild(makeRow(sym));
    hasAny = true;
  }

  // Pre-index weiListTokenSource by list name (O(n) instead of O(n*m))
  const _weiByList = new Map();
  for (const [sym, src] of weiListTokenSource) {
    if (!tokens[sym]) continue;
    if (!_weiByList.has(src)) _weiByList.set(src, []);
    _weiByList.get(src).push(sym);
  }

  // Per-.wei-list groups
  for (const [listName] of weiLists) {
    const srcTokens = _weiByList.get(listName) || [];
    const listTokens = [];
    for (const sym of srcTokens) {
      if (!matchesFilter(sym, tokens[sym].address)) continue;
      listTokens.push(sym);
    }
    if (listTokens.length === 0) continue;
    const label = document.createElement('div');
    label.className = 'token-group-label';
    label.innerHTML = escText(listName) + ' <button class="wei-list-remove" data-list="' + escAttr(listName) + '" title="Remove list">&times;</button>';
    frag.appendChild(label);
    for (const sym of listTokens) frag.appendChild(makeRow(sym));
    hasAny = true;
  }

  // Custom tokens (not built-in, not from .wei lists)
  const customTokens = [];
  for (const sym of Object.keys(tokens)) {
    if (tokens[sym]._isZammStake) continue; // ZAMM is in built-in section, skip here
    if (builtInAddrs.has(tokens[sym].address.toLowerCase())) continue;
    if (weiListTokenSource.has(sym)) continue;
    if (!matchesFilter(sym, tokens[sym].address)) continue;
    customTokens.push(sym);
  }
  if (customTokens.length > 0) {
    const label = document.createElement('div');
    label.className = 'token-group-label';
    label.textContent = 'Custom';
    frag.appendChild(label);
    for (const sym of customTokens) frag.appendChild(makeRow(sym));
    hasAny = true;
  }

  if (!hasAny) {
    const empty = document.createElement('div');
    empty.style.cssText = 'padding:16px 12px;color:#999;font-size:13px;text-align:center';
    if (q && !_tokenListAutoLoaded && !weiLists.has('token-list.wei') && !q.endsWith('.wei')) {
      _tokenListAutoLoaded = true;
      empty.textContent = 'Searching extended token list\u2026';
      frag.appendChild(empty);
      resolveWeiList('token-list.wei');
    } else if (q && _weiResolving) {
      empty.textContent = 'Searching extended token list\u2026';
      frag.appendChild(empty);
    } else {
      empty.textContent = q ? 'No tokens match \u201c' + q + '\u201d' : 'No tokens';
      frag.appendChild(empty);
    }
  }

  list.appendChild(frag);

  // Highlight best match when searching
  if (q && q.length >= 2) {
    const rows = list.querySelectorAll('.token-list-item');
    let bestRow = null;
    for (const row of rows) {
      const sym = (row.getAttribute('data-symbol') || '').toLowerCase();
      const t = tokens[row.getAttribute('data-symbol')];
      // Exact symbol or address match gets priority
      if (sym === q || (t && t.address.toLowerCase() === q)) {
        bestRow = row;
        break;
      }
      // First partial match as fallback
      if (!bestRow && (sym.includes(q) || (t && t.address.toLowerCase().includes(q)))) {
        bestRow = row;
      }
    }
    if (bestRow) {
      bestRow.classList.add('highlight');
      bestRow.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }
  }
}

let _weiDebounceTimer = null;

function initTokenSearch() {
  const input = $('tokenSearchInput');
  if (!input) return;

  const debouncedRender = debounce((val) => renderTokenList(val), 150);
  input.addEventListener('input', () => {
    const val = input.value.trim();
    debouncedRender(val);
    clearTimeout(_weiDebounceTimer);
    if (val.endsWith('.wei') && val.length > 4) {
      _weiDebounceTimer = setTimeout(() => resolveWeiList(val), 800);
    }
  });

  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      const val = input.value.trim();
      if (val.endsWith('.wei') && val.length > 4) {
        clearTimeout(_weiDebounceTimer);
        resolveWeiList(val);
      }
    }
  });

}

let fromToken = "ETH";
let toToken = "zOrg";
let _balSeq = 0;
let slippageBps = 50;

// ---- Token Icons ----
const ETH_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><polygon fill="#80D8FF" points="7.62,18.83 16.01,30.5 16.01,24.1"/><polygon fill="#42A5F5" points="16.01,30.5 24.38,18.78 16.01,24.1"/><polygon fill="#FFF176" points="16.01,1.5 7.62,16.23 16.01,12.3"/><polygon fill="#FF8A80" points="24.38,16.18 16.01,1.5 16.01,12.3"/><polygon fill="#C1AEE1" points="16.01,21.5 24.38,16.18 16.01,12.3"/><polygon fill="#55FB9B" points="16.01,12.3 7.62,16.23 16.01,21.5"/></svg>`;
const WETH_ICON = `<svg width="24" height="24" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg"><circle cx="18" cy="18" r="17" fill="none" stroke="#90CAF9" stroke-width="1.5" stroke-dasharray="4 2.5"/><g transform="translate(2,2)"><polygon fill="#80D8FF" points="7.62,18.83 16.01,30.5 16.01,24.1"/><polygon fill="#42A5F5" points="16.01,30.5 24.38,18.78 16.01,24.1"/><polygon fill="#FFF176" points="16.01,1.5 7.62,16.23 16.01,12.3"/><polygon fill="#FF8A80" points="24.38,16.18 16.01,1.5 16.01,12.3"/><polygon fill="#C1AEE1" points="16.01,21.5 24.38,16.18 16.01,12.3"/><polygon fill="#55FB9B" points="16.01,12.3 7.62,16.23 16.01,21.5"/></g></svg>`;
const USDC_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#2775CA" cx="16" cy="16" r="16"/><g fill="#FFF"><path d="M20.022 18.124c0-2.124-1.28-2.852-3.84-3.156-1.828-.243-2.193-.728-2.193-1.578 0-.85.61-1.396 1.828-1.396 1.097 0 1.707.364 2.011 1.275a.458.458 0 00.427.303h.975a.416.416 0 00.427-.425v-.06a3.04 3.04 0 00-2.743-2.489V9.142c0-.243-.183-.425-.487-.486h-.915c-.243 0-.426.182-.487.486v1.396c-1.829.242-2.986 1.456-2.986 2.974 0 2.002 1.218 2.791 3.778 3.095 1.707.303 2.255.668 2.255 1.639 0 .97-.853 1.638-2.011 1.638-1.585 0-2.133-.667-2.316-1.578-.06-.242-.244-.364-.427-.364h-1.036a.416.416 0 00-.426.425v.06c.243 1.518 1.219 2.61 3.23 2.914v1.457c0 .242.183.425.487.485h.915c.243 0 .426-.182.487-.485V21.34c1.829-.303 3.047-1.578 3.047-3.217z"/><path d="M12.892 24.497c-4.754-1.7-7.192-6.98-5.424-11.653.914-2.55 2.925-4.491 5.424-5.402.244-.121.365-.303.365-.607v-.85c0-.242-.121-.424-.365-.485-.061 0-.183 0-.244.06a10.895 10.895 0 00-7.13 13.717c1.096 3.4 3.717 6.01 7.13 7.102.244.121.488 0 .548-.243.061-.06.061-.122.061-.243v-.85c0-.182-.182-.424-.365-.546zm6.46-18.936c-.244-.122-.488 0-.548.242-.061.061-.061.122-.061.243v.85c0 .243.182.485.365.607 4.754 1.7 7.192 6.98 5.424 11.653-.914 2.55-2.925 4.491-5.424 5.402-.244.121-.365.303-.365.607v.85c0 .242.121.424.365.485.061 0 .183 0 .244-.06a10.895 10.895 0 007.13-13.717c-1.096-3.46-3.778-6.07-7.13-7.162z"/></g></g></svg>`;
const USDT_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle cx="16" cy="16" r="16" fill="#26A17B"/><path fill="#FFF" d="M17.922 17.383v-.002c-.11.008-.677.042-1.942.042-1.01 0-1.721-.03-1.971-.042v.003c-3.888-.171-6.79-.848-6.79-1.658 0-.809 2.902-1.486 6.79-1.66v2.644c.254.018.982.061 1.988.061 1.207 0 1.812-.05 1.925-.06v-2.643c3.88.173 6.775.85 6.775 1.658 0 .81-2.895 1.485-6.775 1.657m0-3.59v-2.366h5.414V7.819H8.595v3.608h5.414v2.365c-4.4.202-7.709 1.074-7.709 2.118 0 1.044 3.309 1.915 7.709 2.118v7.582h3.913v-7.584c4.393-.202 7.694-1.073 7.694-2.116 0-1.043-3.301-1.914-7.694-2.117"/></g></svg>`;
const WBTC_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle cx="16" cy="16" r="16" fill="#F7931A"/><path fill="#FFF" fill-rule="nonzero" d="M23.189 14.02c.314-2.096-1.283-3.223-3.465-3.975l.708-2.84-1.728-.43-.69 2.765c-.454-.114-.92-.22-1.385-.326l.695-2.783L15.596 6l-.708 2.839c-.376-.086-.746-.17-1.104-.26l.002-.009-2.384-.595-.46 1.846s1.283.294 1.256.312c.7.175.826.638.805 1.006l-.806 3.235c.048.012.11.03.18.057l-.183-.045-1.13 4.532c-.086.212-.303.531-.793.41.018.025-1.256-.313-1.256-.313l-.858 1.978 2.25.561c.418.105.828.215 1.231.318l-.715 2.872 1.727.43.708-2.84c.472.127.93.245 1.378.357l-.706 2.828 1.728.43.715-2.866c2.948.558 5.164.333 6.097-2.333.752-2.146-.037-3.385-1.588-4.192 1.13-.26 1.98-1.003 2.207-2.538zm-3.95 5.538c-.533 2.147-4.148.986-5.32.695l.95-3.805c1.172.293 4.929.872 4.37 3.11zm.535-5.569c-.487 1.953-3.495.96-4.47.717l.86-3.45c.975.243 4.118.696 3.61 2.733z"/></g></svg>`;
const STETH_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#00A3FF" cx="16" cy="16" r="16"/><path d="M16.005 4.805l-5.655 8.668 5.655-3.233V4.805z" fill="#FFF"/><path opacity=".6" d="M16.004 10.238l5.658 3.23-5.658-8.674v5.444z" fill="#FFF"/><path opacity=".6" d="M16.005 10.239l-5.655 3.229 5.655 3.23v-6.46z" fill="#FFF"/><path opacity=".2" d="M16.004 10.239v6.459l5.654-3.23-5.654-3.229z" fill="#FFF"/><path d="M10.35 14.864c-2.048 3.097-1.603 7.253 1.034 9.824 1.561 1.521 3.622 2.353 5.683 2.353 2.061 0 4.122-.832 5.683-2.353 2.637-2.571 3.082-6.727 1.034-9.824L16.067 18.611 10.35 14.864z" fill="#FFF" opacity=".6"/></g></svg>`;
const WSTETH_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#00A3FF" cx="16" cy="16" r="16"/><path d="M9.437 14.864l-.181.275c-2.048 3.097-1.603 7.253 1.034 9.824 1.561 1.521 3.622 2.353 5.683 2.353 0 0 0 0-6.536-12.452z" fill="#FFF"/><path opacity=".6" d="M15.997 18.611l-6.56-3.747c6.56 12.452 6.56 12.452 6.56 12.452 0-2.683 0-5.623 0-8.705z" fill="#FFF"/><path opacity=".6" d="M22.563 14.864l.181.275c2.048 3.097 1.603 7.253-1.034 9.824-1.561 1.521-3.622 2.353-5.683 2.353 0 0 0 0 6.536-12.452z" fill="#FFF"/><path opacity=".2" d="M16.003 18.611l6.56-3.747c-6.56 12.452-6.56 12.452-6.56 12.452 0-2.683 0-5.623 0-8.705z" fill="#FFF"/><path opacity=".2" d="M16.004 10.239v6.459l5.654-3.23-5.654-3.229z" fill="#FFF"/><path opacity=".6" d="M16.005 10.239l-5.655 3.229 5.655 3.23v-6.46z" fill="#FFF"/><path d="M16.005 4.805l-5.655 8.668 5.655-3.233V4.805z" fill="#FFF"/><path opacity=".6" d="M16.004 10.238l5.658 3.23-5.658-8.674v5.444z" fill="#FFF"/></g></svg>`;
const RETH_ICON = `<svg width="24" height="24" viewBox="0 0 33 32" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#reth_clip)"><mask id="reth_m0" style="mask-type:luminance" maskUnits="userSpaceOnUse" x="0" y="0" width="33" height="32"><path d="M32.5 0H0.5V32H32.5V0Z" fill="white"/></mask><g mask="url(#reth_m0)"><path d="M16.5 32C25.3365 32 32.5 24.8365 32.5 16C32.5 7.16347 25.3365 0 16.5 0C7.66347 0 0.5 7.16347 0.5 16C0.5 24.8365 7.66347 32 16.5 32Z" fill="url(#reth_rg0)"/><mask id="reth_m1" style="mask-type:alpha" maskUnits="userSpaceOnUse" x="0" y="0" width="33" height="32"><path d="M16.5 32C25.3365 32 32.5 24.8365 32.5 16C32.5 7.16347 25.3365 0 16.5 0C7.66347 0 0.5 7.16347 0.5 16C0.5 24.8365 7.66347 32 16.5 32Z" fill="url(#reth_rg1)"/></mask><g mask="url(#reth_m1)"><path opacity="0.2" d="M-0.0333252 8.80003C-0.0333252 8.44659 0.253212 8.16003 0.606675 8.16003H9.35334C9.70678 8.16003 9.99334 8.44659 9.99334 8.80003V23.68C9.99334 24.0335 9.70678 24.32 9.35334 24.32H0.606675C0.253212 24.32-0.0333252 24.0335-0.0333252 23.68V8.80003Z" fill="url(#reth_lg0)"/><path opacity="0.2" d="M19.8068 21.7067C19.8068 21.3532 20.0933 21.0667 20.4468 21.0667H31.8601C32.2135 21.0667 32.5001 21.3532 32.5001 21.7067V27.2533C32.5001 27.6068 32.2135 27.8933 31.8601 27.8933H20.4468C20.0933 27.8933 19.8068 27.6068 19.8068 27.2533V21.7067Z" fill="#E74310"/><path opacity="0.2" d="M27.22 23.4133C27.5735 23.4133 27.86 23.6999 27.86 24.0533V34.8267C27.86 35.1801 27.5735 35.4667 27.22 35.4667H23.0067C22.6533 35.4667 22.3667 35.1801 22.3667 34.8267V24.0533C22.3667 23.6999 22.6533 23.4133 23.0067 23.4133H27.22Z" fill="#DF3600"/><path opacity="0.1" d="M13.46 10.4C13.8135 10.4 14.1 10.6866 14.1 11.04V19.6267C14.1 19.9801 13.8135 20.2667 13.46 20.2667H8.71336C8.35992 20.2667 8.07336 19.9801 8.07336 19.6267V11.04C8.07336 10.6866 8.35992 10.4 8.71336 10.4H13.46Z" fill="url(#reth_lg1)"/><path opacity="0.1" d="M3.54004 12.9601C3.54004 12.6066 3.82658 12.3201 4.18004 12.3201H11.9667C12.3201 12.3201 12.6067 12.6066 12.6067 12.9601V21.1201C12.6067 21.4735 12.3201 21.7601 11.9667 21.7601H4.18004C3.82658 21.7601 3.54004 21.4735 3.54004 21.1201V12.9601Z" fill="url(#reth_lg2)"/><path opacity="0.2" d="M32.5001 4.37341C32.8535 4.37341 33.1401 4.65995 33.1401 5.01341V15.7867C33.1401 16.1402 32.8535 16.4267 32.5001 16.4267H22.5801C22.2266 16.4267 21.9401 16.1402 21.9401 15.7867V5.01341C21.9401 4.65995 22.2266 4.37341 22.5801 4.37341H32.5001Z" fill="#FF9776"/><path opacity="0.2" d="M26.4734-2.77332C26.8268-2.77332 27.1134-2.48678 27.1134-2.13332V9.70668C27.1134 10.0601 26.8268 10.3467 26.4734 10.3467H20.9267C20.5733 10.3467 20.2867 10.0601 20.2867 9.70668V-2.13332C20.2867-2.48678 20.5733-2.77332 20.9267-2.77332H26.4734Z" fill="#FFCA8C"/><path opacity="0.2" d="M29.3534-0.640015C29.7068-0.640015 29.9934-0.353477 29.9934-1.41182e-05V13.1733C29.9934 13.5268 29.7068 13.8133 29.3534 13.8133H17.3C16.9466 13.8133 16.66 13.5268 16.66 13.1733V-1.43216e-05C16.66-0.353477 16.9466-0.640015 17.3-0.640015H29.3534Z" fill="url(#reth_lg3)"/><path opacity="0.1" d="M21.7267 18.8267C22.0802 18.8267 22.3667 19.1132 22.3667 19.4667V31.36C22.3667 31.7134 22.0802 32 21.7267 32H9.46007C9.10663 32 8.82007 31.7134 8.82007 31.36V19.4667C8.82007 19.1132 9.10663 18.8267 9.46007 18.8267H21.7267Z" fill="#FFD494"/></g><path d="M16.4763 19.4523L10.3889 15.8513L16.4763 5.75293L22.5583 15.8513L16.4763 19.4523Z" fill="white"/><path d="M16.4763 25.5835L10.3889 17.0098L16.4763 20.6054L22.5638 17.0098L16.4763 25.5835Z" fill="white"/></g></g><defs><radialGradient id="reth_rg0" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(10.9533 7.65333) rotate(54.1675) scale(26.511)"><stop stop-color="#FFD794"/><stop offset="1" stop-color="#ED5A37"/></radialGradient><radialGradient id="reth_rg1" cx="0" cy="0" r="1" gradientUnits="userSpaceOnUse" gradientTransform="translate(10.9533 7.65333) rotate(54.1675) scale(26.511)"><stop stop-color="#FFD794"/><stop offset="1" stop-color="#ED5A37"/></radialGradient><linearGradient id="reth_lg0" x1="4.98001" y1="8.16003" x2="4.98001" y2="24.32" gradientUnits="userSpaceOnUse"><stop stop-color="#FFE090"/><stop offset="1" stop-color="#FFE090" stop-opacity="0"/></linearGradient><linearGradient id="reth_lg1" x1="11.06" y1="10.4" x2="11.06" y2="19.52" gradientUnits="userSpaceOnUse"><stop stop-color="#DF3600"/><stop offset="1" stop-color="#DF3600" stop-opacity="0"/></linearGradient><linearGradient id="reth_lg2" x1="3.54004" y1="17.0818" x2="11.9206" y2="17.0818" gradientUnits="userSpaceOnUse"><stop stop-color="#DF3600"/><stop offset="1" stop-color="#DF3600" stop-opacity="0"/></linearGradient><linearGradient id="reth_lg3" x1="23.3267" y1="-0.640015" x2="23.3267" y2="13.8133" gradientUnits="userSpaceOnUse"><stop stop-color="#DF3600"/><stop offset="1" stop-color="#DF3600" stop-opacity="0"/></linearGradient><clipPath id="reth_clip"><rect width="32" height="32" fill="white" transform="translate(0.5)"/></clipPath></defs></svg>`;
const DAI_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle fill="#F4B731" fill-rule="nonzero" cx="16" cy="16" r="16"/><path d="M9.277 8h6.552c3.985 0 7.006 2.116 8.13 5.194H26v1.861h-1.611c.031.294.047.594.047.898v.046c0 .342-.02.68-.06 1.01H26v1.86h-2.08C22.767 21.905 19.77 24 15.83 24H9.277v-5.131H7v-1.86h2.277v-1.954H7v-1.86h2.277V8zm1.831 10.869v3.462h4.72c2.914 0 5.078-1.387 6.085-3.462H11.108zm11.366-1.86H11.108v-1.954h11.37c.041.307.063.622.063.944v.045c0 .329-.023.65-.067.964zM15.83 9.665c2.926 0 5.097 1.424 6.098 3.528h-10.82V9.666h4.72z" fill="#FFF"/></g></svg>`;
const BOLD_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_1_6)"><path d="M32 16C32 7.16406 24.8359 0 16 0C7.16406 0 0 7.16406 0 16C0 24.8359 7.16406 32 16 32C24.8359 32 32 24.8359 32 16Z" fill="#63D77D"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12.1719 4.56641H8.58203V26.1016H15.7617V25.2422C16.8398 25.793 18.0586 26.1055 19.3555 26.1055C23.7148 26.1055 27.25 22.5703 27.25 18.207C27.25 13.8438 23.7148 10.3086 19.3555 10.3086C18.0586 10.3086 16.8398 10.6211 15.7617 11.1719V4.56641H12.1719ZM15.7617 11.1719C13.207 12.4805 11.457 15.1406 11.457 18.207C11.457 21.2734 13.207 23.9336 15.7617 25.2422V11.1719Z" fill="#1C1D4F"/></g><defs><clipPath id="clip0_1_6"><rect width="32" height="32" fill="white"/></clipPath></defs></svg>`;
const LUSD_ICON = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256" width="24" height="24"><circle cx="128" cy="132" r="102" fill="#29C9EB"/><rect x="110" y="4" width="36" height="32" rx="9" fill="#29C9EB"/><rect x="110" y="228" width="36" height="24" rx="9" fill="#29C9EB"/><path d="M 128 30 A 102 102 0 0 1 128 234 Z" fill="#7B6AD6"/><path d="M 128 4 L 137 4 Q 146 4 146 13 L 146 36 L 128 36 Z" fill="#7B6AD6"/><path d="M 128 228 L 146 228 L 146 243 Q 146 252 137 252 L 128 252 Z" fill="#7B6AD6"/><g fill="none" stroke="white" stroke-width="26" stroke-linecap="round" stroke-linejoin="round"><path d="M 154 90 C 146 78, 134 72, 120 74 C 98 78, 82 94, 82 112 C 82 132, 98 142, 128 150 C 158 158, 174 168, 174 186 C 174 206, 158 218, 136 220 C 120 222, 106 216, 98 204"/><line x1="128" y1="74" x2="128" y2="15"/><line x1="128" y1="220" x2="128" y2="241"/></g></svg>`;
// PNKSTR animated SVG is large (~4KB); lazy-loaded on first use
let _pnkstrIcon = null;
function getPNKSTRIcon() {
  if (_pnkstrIcon) return _pnkstrIcon;
  _pnkstrIcon = `<svg width="24" height="24" viewBox="0 0 296 296" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision" text-rendering="geometricPrecision"><style>#em3zDC0HIkr3{animation:em3zDC0HIkr3__rd 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr3__rd{0%{rx:93.77px;ry:93.77px}3.125%{rx:93.77px;ry:93.77px}18.75%{rx:93.77px;ry:93.77px}34.375%{rx:93.77px;ry:93.77px}56.25%{rx:0px;ry:0px}93.75%{rx:0px;ry:0px}100%{rx:0px;ry:0px}}#em3zDC0HIkr3_to{animation:em3zDC0HIkr3_to__to 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr3_to__to{0%{transform:translate(180.943141px,95.15235px)}3.125%{transform:translate(180.943141px,95.15235px)}18.75%{transform:translate(180.122px,95.152354px)}34.375%{transform:translate(148.075px,148.655006px)}56.25%{transform:translate(148.5px,148.655005px)}71.875%{transform:translate(180.122px,120.865004px)}84.375%{transform:translate(180.122px,95.152352px)}93.75%{transform:translate(180.122px,95.152351px)}100%{transform:translate(180.122px,95.152351px)}}#em3zDC0HIkr3_tr{animation:em3zDC0HIkr3_tr__tr 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr3_tr__tr{0%{transform:rotate(0deg)}34.375%{transform:rotate(0deg)}42.5%{transform:rotate(90deg)}100%{transform:rotate(90deg)}}#em3zDC0HIkr3_ts{animation:em3zDC0HIkr3_ts__ts 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr3_ts__ts{0%{transform:scale(0,0)}3.125%{transform:scale(0,0)}18.75%{transform:scale(0.8,0.8)}34.375%{transform:scale(1.319281,1.320365)}56.25%{transform:scale(1,1)}71.875%{transform:scale(0.697529,0.658712)}93.75%{transform:scale(0,0)}100%{transform:scale(0,0)}}#em3zDC0HIkr12_tr{animation:em3zDC0HIkr12_tr__tr 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr12_tr__tr{0%{transform:translate(135.33781px,207.03926px) rotate(720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}24.0625%{transform:translate(135.33781px,207.03926px) rotate(0deg);animation-timing-function:step-end}31.25%{transform:translate(135.33781px,207.03926px) rotate(720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}55.3125%{transform:translate(135.33781px,207.03926px) rotate(0deg);animation-timing-function:step-end}62.5%{transform:translate(135.33781px,207.03926px) rotate(720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}86.5625%{transform:translate(135.33781px,207.03926px) rotate(0deg);animation-timing-function:step-end}93.75%{transform:translate(135.33781px,207.03926px) rotate(720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}100%{transform:translate(135.33781px,207.03926px) rotate(532.987013deg)}}#em3zDC0HIkr12{animation:em3zDC0HIkr12_f_p 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr12_f_p{0%{fill:#d2dbed}24.0625%{fill:#d2dbec}31.25%{fill:#d2dbed}55.3125%{fill:#d2dbec}62.5%{fill:#d2dbed}86.5625%{fill:#d2dbec}93.75%{fill:#d2dbed}100%{fill:#d2dbed}}#em3zDC0HIkr13_tr{animation:em3zDC0HIkr13_tr__tr 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr13_tr__tr{0%{transform:translate(11.12px,29.9px) rotate(-720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}24.0625%{transform:translate(11.12px,29.9px) rotate(0deg);animation-timing-function:step-end}31.25%{transform:translate(11.12px,29.9px) rotate(-720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}55.3125%{transform:translate(11.12px,29.9px) rotate(0deg);animation-timing-function:step-end}62.5%{transform:translate(11.12px,29.9px) rotate(-720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}86.5625%{transform:translate(11.12px,29.9px) rotate(0deg);animation-timing-function:step-end}93.75%{transform:translate(11.12px,29.9px) rotate(-720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}100%{transform:translate(11.12px,29.9px) rotate(-532.987013deg)}}</style><circle r="148" transform="translate(148 148)" fill="#0d0d0d"/><g id="em3zDC0HIkr3_to" transform="translate(180.943141,95.15235)"><g id="em3zDC0HIkr3_tr" transform="rotate(0)"><g id="em3zDC0HIkr3_ts" transform="scale(0,0)"><rect id="em3zDC0HIkr3" width="187.538" height="187.538" rx="93.77" ry="93.77" transform="translate(-93.769,-93.769005)" fill="#f2f2f2"/></g></g></g><g style="mix-blend-mode:difference"><path d="M141.692,120.865v-43.1014h11.213v43.1014h-11.213ZM125.299,78.8923v-9.4526h43.857v9.4526h-43.857Zm53.228,41.9727L164.05,69.4397h11.425l9.51,39.2913h-.923l10.007-39.2913h10.716l9.864,39.2913h-.852l9.581-39.2913h11.567L220.184,120.865h-12.135l-9.084-36.0472h.994l-9.155,36.0472h-12.277Z" fill="#fff"/></g></svg>`;
  return _pnkstrIcon;
}
const ZORG_ICON = `<svg width="24" height="24" viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg"><clipPath id="zorg-clip"><circle cx="200" cy="200" r="200"/></clipPath><g clip-path="url(#zorg-clip)"><rect class="zorg-bg" width="400" height="400"/><path class="zorg-fg" d="M-60-20L460-20L460 90L80 310L460 310L460 420L-60 420L-60 310L320 90L-60 90Z"/></g></svg>`;
const ZAMM_ICON = `<svg width="24" height="24" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><circle cx="100" cy="100" r="99" fill="#fff"/><circle cx="100" cy="100" r="93" fill="none" stroke="#000" stroke-width="1.2"/><path d="M 69 65 L 96 64 L 97 65 L 98 64 L 120 64 L 121 65 L 122 64 L 130 64 L 130 70 L 117 85 L 118 86 L 104 100 L 105 101 L 91 115 L 92 116 L 78 130 L 96 130 L 97 131 L 98 130 L 120 130 L 121 131 L 122 130 L 132 131 L 120 136 L 119 135 L 118 136 L 96 136 L 95 135 L 94 136 L 71 136 L 71 130 L 84 115 L 83 114 L 97 100 L 96 99 L 110 85 L 109 84 L 123 70 L 105 70 L 104 69 L 103 70 L 83 70 L 82 69 L 81 70 L 69 69 Z" fill="#000"/></svg>`;
const DEFAULT_ICON = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/><text x="12" y="16" text-anchor="middle" fill="currentColor" font-size="12" font-weight="bold">?</text></svg>`;

const ICONS = {
  ETH: ETH_ICON, WETH: WETH_ICON, USDC: USDC_ICON, USDT: USDT_ICON, WBTC: WBTC_ICON,
  stETH: STETH_ICON, wstETH: WSTETH_ICON, rETH: RETH_ICON, DAI: DAI_ICON, BOLD: BOLD_ICON, LUSD: LUSD_ICON, zOrg: ZORG_ICON, ZAMM: ZAMM_ICON,
};

const _letterIconCache = new Map();
function iconForSymbol(sym) {
  const s = String(sym);
  if (ICONS[s]) return ICONS[s];
  if (s === 'PNKSTR') return getPNKSTRIcon();
  const t = tokens[s];
  if (t?.icon) {
    const img = document.createElement('img');
    img.src = t.icon;
    img.width = 24;
    img.height = 24;
    img.style.borderRadius = '50%';
    img.alt = s;
    img.onerror = function() { this.outerHTML = makeLetterIcon(s); };
    return img.outerHTML;
  }
  if (_letterIconCache.has(s)) return _letterIconCache.get(s);
  const svg = makeLetterIcon(s);
  _letterIconCache.set(s, svg);
  return svg;
}

function makeLetterIcon(sym) {
  try {
    const full = String(sym ?? '').trim();
    // Preserve original casing (stETH, crvUSD, frxETH, etc.)
    const clean = full.replace(/[^A-Za-z0-9]/g, '') || '?';
    const show = clean.length <= 7 ? clean : clean.slice(0, 6) + '\u2026';
    const L = show.length;
    const fontSize = L <= 1 ? 10 : L === 2 ? 8.5 : L === 3 ? 7.2 : L === 4 ? 6 : L === 5 ? 5.2 : L === 6 ? 4.6 : 4;
    // Deterministic hue from full symbol (case-sensitive for better spread)
    let hash = 0;
    for (let i = 0; i < clean.length; i++) hash = ((hash << 5) - hash + clean.charCodeAt(i)) | 0;
    const hue = ((hash % 360) + 360) % 360;
    // textLength compresses longer symbols to fit within the circle
    const tl = L >= 5 ? ` textLength="${L >= 7 ? 19 : 18}" lengthAdjust="spacingAndGlyphs"` : '';
    return `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-label="${escAttr(full)}">` +
      `<title>${escText(full)}</title>` +
      `<circle cx="12" cy="12" r="11" fill="hsl(${hue},50%,50%)" stroke="hsl(${hue},35%,38%)" stroke-width="1"/>` +
      `<text x="12" y="12.3" text-anchor="middle" dominant-baseline="middle"` +
      ` font-family="Helvetica,Arial,sans-serif"` +
      ` font-size="${fontSize}" font-weight="700" fill="#fff"${tl}>${escText(show)}</text>` +
      `</svg>`;
  } catch (e) {
    return DEFAULT_ICON;
  }
}

// ---- RPC fallback system ----
const RPCS = [
  "https://eth.llamarpc.com",
  "https://ethereum.publicnode.com",
  "https://1rpc.io/eth",
  "https://eth.drpc.org",
];

function makeWalletReader() {
  try {
    if (!window.ethereum) return null;
    const bp = new ethers.BrowserProvider(window.ethereum, CHAIN_ID);
    return bp;
  } catch { return null; }
}

function makeFallbackProvider(urls) {
  const network = { chainId: CHAIN_ID, name: "mainnet" };
  const nodes = urls.map(u => ({
    url: u,
    p: new ethers.JsonRpcProvider(u, network, { staticNetwork: true, batchMaxCount: 10 }),
    downUntil: 0,
    ok: true,
  }));

  const walletReader = makeWalletReader();
  if (walletReader) {
    nodes.push({
      url: "wallet",
      p: walletReader,
      downUntil: 0,
      ok: true,
    });
  }

  const withTimeout = (ms, work) =>
    Promise.race([
      work(),
      new Promise((_, rej) => setTimeout(() => rej(new Error("timeout")), ms)),
    ]);

  const isInfraErr = (e) => {
    const s = String(e?.message || "");
    return /server response 400\b/i.test(s) ||
      /502|503|504|ECONNRESET|ENETUNREACH|EAI_AGAIN|Failed to fetch/i.test(s) ||
      /failed to detect network|timeout|timed out|ETIMEDOUT/i.test(s);
  };
  const isAuthErr = (e) => /Unauthorized|invalid api key|403|401/i.test(String(e?.message || ""));

  return {
    async call(fn) {
      const now = Date.now();
      let lastErr;
      const candidates = nodes
        .filter(n => n.ok && n.downUntil <= now)
        .concat(nodes.filter(n => n.ok && n.downUntil > now));

      for (const n of candidates) {
        try {
          const res = await withTimeout(3500, () => fn(n.p));
          n.downUntil = 0;
          return res;
        } catch (e) {
          lastErr = e;
          if (isAuthErr(e)) n.ok = false;
          else if (isInfraErr(e)) n.downUntil = Date.now() + 30_000;
        }
      }
      throw lastErr || new Error("All RPCs failed");
    },
  };
}

const quoteRPC = makeFallbackProvider(RPCS);

// ---- Formatting helpers ----
const fmt = (nStr, max = 6) => {
  if (nStr == null) return "--";
  const n = Number(nStr);
  if (!Number.isFinite(n) || Math.abs(n) >= 1e21) {
    const s = String(nStr);
    return s.includes(".")
      ? s.replace(new RegExp(`(\\.\\d{0,${max}}).*$`), "$1").replace(/\.?0+$/, "")
      : s;
  }
  return n.toLocaleString(undefined, { maximumFractionDigits: max });
};
// Format output amounts: thousands separators, smart decimal truncation
const fmtOutput = (nStr) => {
  if (nStr == null) return "--";
  const n = Number(nStr);
  if (!Number.isFinite(n)) return nStr;
  // Adaptive decimals: large numbers get fewer decimals
  let maxDec;
  if (Math.abs(n) >= 10000) maxDec = 2;
  else if (Math.abs(n) >= 100) maxDec = 3;
  else if (Math.abs(n) >= 1) maxDec = 4;
  else maxDec = 6;
  // Use useGrouping:false â€” number inputs reject thousand separators (e.g. "1,234.56")
  return n.toLocaleString('en-US', { useGrouping: false, maximumFractionDigits: maxDec, minimumFractionDigits: 0 });
};

// ---- Allowance cache ----
const _allowTTLms = 10_000;
const _allowCache = new Map();
const _allowKey = (token, owner, spender) =>
  `${token.toLowerCase()}:${owner.toLowerCase()}:${spender.toLowerCase()}`;

function cacheSetAllowance(token, owner, spender, v) {
  _allowCache.set(_allowKey(token, owner, spender), { v, t: Date.now() });
}
function cacheGetAllowance(token, owner, spender) {
  const hit = _allowCache.get(_allowKey(token, owner, spender));
  return hit && Date.now() - hit.t < _allowTTLms ? hit.v : null;
}

// ---- Multicall3 batched reads ----
const MULTICALL3_IFACE = new ethers.Interface([
  "function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])",
  "function getEthBalance(address addr) view returns (uint256 balance)",
]);
const MC_BAL_IFACE = new ethers.Interface([
  "function balanceOf(address) view returns (uint256)",
  "function allowance(address,address) view returns (uint256)",
]);
const _balanceCache = new Map(); // key â†’ { v: bigint, t: number }
const _BAL_TTL = 15_000;

function getCachedBalance(tokenAddress) {
  const key = tokenAddress === ZERO_ADDRESS ? 'ETH' : tokenAddress.toLowerCase();
  const hit = _balanceCache.get(key);
  return (hit && Date.now() - hit.t < _BAL_TTL) ? hit.v : null;
}
function setCachedBalance(tokenAddress, value) {
  const key = tokenAddress === ZERO_ADDRESS ? 'ETH' : tokenAddress.toLowerCase();
  _balanceCache.set(key, { v: value, t: Date.now() });
}

async function multicallRead(calls) {
  if (calls.length === 0) return [];
  const calldata = MULTICALL3_IFACE.encodeFunctionData("aggregate3", [
    calls.map(c => [c.target, c.allowFailure, c.callData])
  ]);
  const rpc = provider || await quoteRPC.call(r => r);
  const raw = await rpc.call({ to: MULTICALL3_ADDRESS, data: calldata });
  return MULTICALL3_IFACE.decodeFunctionResult("aggregate3", raw)[0];
}

// Batch view calls via Multicall3 aggregate3 â€” collapses N sub-calls into 1 eth_call
function mc3ViewBatch(rpc, entries) {
  if (entries.length === 0) return Promise.resolve([]);
  const data = MULTICALL3_IFACE.encodeFunctionData("aggregate3", [
    entries.map(e => [e.target, true, e.data])
  ]);
  return rpc.call({ to: MULTICALL3_ADDRESS, data }).then(raw =>
    MULTICALL3_IFACE.decodeFunctionResult("aggregate3", raw)[0]
  );
}
function mc3Decode(mc3, idx, iface, fn) {
  if (!mc3 || idx < 0 || !mc3[idx]?.success) return null;
  try { return iface.decodeFunctionResult(fn, mc3[idx].returnData); }
  catch { return null; }
}
function mc3AsSettled(mc3, idx, iface, fn) {
  const v = mc3Decode(mc3, idx, iface, fn);
  return v ? { status: 'fulfilled', value: v } : { status: 'rejected' };
}

async function fetchModalBalances() {
  if (!connectedAddress) return;
  const allTokens = Object.values(tokens);
  const calls = [];
  const meta = [];
  const balOfData = MC_BAL_IFACE.encodeFunctionData("balanceOf", [connectedAddress]);

  // ETH balance
  calls.push({ target: MULTICALL3_ADDRESS, allowFailure: true,
    callData: MULTICALL3_IFACE.encodeFunctionData("getEthBalance", [connectedAddress]) });
  meta.push({ type: 'eth' });

  // All ERC-20 balances
  for (const t of allTokens) {
    if (t.address === ZERO_ADDRESS) continue;
    calls.push({ target: t.address, allowFailure: true, callData: balOfData });
    meta.push({ type: 'erc20', address: t.address });
  }

  try {
    const results = await multicallRead(calls);
    for (let i = 0; i < meta.length; i++) {
      const m = meta[i];
      const r = results[i];
      if (!r || !r.success) continue;
      try {
        if (m.type === 'eth') {
          setCachedBalance(ZERO_ADDRESS, MULTICALL3_IFACE.decodeFunctionResult("getEthBalance", r.returnData)[0]);
        } else {
          setCachedBalance(m.address, MC_BAL_IFACE.decodeFunctionResult("balanceOf", r.returnData)[0]);
        }
      } catch {}
    }
    // Re-render to show fetched balances
    const filter = $('tokenSearchInput')?.value || '';
    renderTokenList(filter);
  } catch (e) {
    console.warn("Multicall3 modal balances failed:", e);
  }
}

function safeParseUnits(valStr, decimals) {
  const s = String(valStr).trim();
  if (!s) throw new Error("Empty amount");
  const m = s.match(/^(\d+)(?:\.(\d+))?$/);
  if (!m) throw new Error("Invalid number");
  const frac = m[2] || "";
  if (frac.length > decimals) throw new Error(`Too many decimals (max ${decimals})`);
  return ethers.parseUnits(s, decimals);
}

// ---- Permit config ----
const PERMIT_CONFIG = {
  [USDC_ADDRESS.toLowerCase()]: {
    type: 'eip2612',
    domain: { name: 'USD Coin', version: '2', chainId: 1, verifyingContract: USDC_ADDRESS },
    routerFn: 'permit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
  },
  [DAI_ADDRESS.toLowerCase()]: {
    type: 'dai',
    domain: { name: 'Dai Stablecoin', version: '1', chainId: 1, verifyingContract: DAI_ADDRESS },
    routerFn: 'permitDAI(uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s)',
  },
  [BOLD_ADDRESS.toLowerCase()]: {
    type: 'eip2612',
    domain: { name: 'BOLD Stablecoin', version: '1', chainId: 1, verifyingContract: BOLD_ADDRESS },
    routerFn: 'permit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
  },
};

// ---- Generic EIP-2612 permit detection ----
const _permitCache = new Map(); // address â†’ config | null

const _permitIface = new ethers.Interface([
  'function eip712Domain() view returns (bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)',
  'function nonces(address) view returns (uint256)',
  'function DOMAIN_SEPARATOR() view returns (bytes32)',
  'function name() view returns (string)',
  'function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
]);

async function _staticCall(tokenAddress, data) {
  return await quoteRPC.call(rpc => rpc.call({ to: tokenAddress, data }));
}

async function detectPermitConfig(tokenAddress) {
  const key = tokenAddress.toLowerCase();
  if (PERMIT_CONFIG[key]) return PERMIT_CONFIG[key];
  if (_permitCache.has(key)) return _permitCache.get(key);

  try {
    // Quick check: does it have nonces() and DOMAIN_SEPARATOR()?
    const [nonceRes, dsRes] = await Promise.all([
      _staticCall(tokenAddress, _permitIface.encodeFunctionData('nonces', [ZERO_ADDRESS])),
      _staticCall(tokenAddress, _permitIface.encodeFunctionData('DOMAIN_SEPARATOR')),
    ]);
    // If either reverts, quoteRPC throws or returns 0x
    if (!nonceRes || nonceRes === '0x' || !dsRes || dsRes === '0x') throw new Error('no permit');

    // Try EIP-5267 eip712Domain() first
    let domainName, domainVersion;
    try {
      const domRes = await _staticCall(tokenAddress, _permitIface.encodeFunctionData('eip712Domain'));
      const decoded = _permitIface.decodeFunctionResult('eip712Domain', domRes);
      domainName = decoded[1];
      domainVersion = decoded[2];
    } catch (_) {
      // Fallback: read name() and try version "1"
      const nameRes = await _staticCall(tokenAddress, _permitIface.encodeFunctionData('name'));
      domainName = _permitIface.decodeFunctionResult('name', nameRes)[0];
      domainVersion = '1';
    }

    // Verify by computing the expected DOMAIN_SEPARATOR
    const candidateDomain = { name: domainName, version: domainVersion, chainId: CHAIN_ID, verifyingContract: tokenAddress };
    const computed = ethers.TypedDataEncoder.hashDomain(candidateDomain);
    const onchain = ethers.AbiCoder.defaultAbiCoder().decode(['bytes32'], dsRes)[0];
    if (computed !== onchain) {
      // Try version "2" as fallback
      candidateDomain.version = '2';
      const computed2 = ethers.TypedDataEncoder.hashDomain(candidateDomain);
      if (computed2 !== onchain) {
        _permitCache.set(key, null);
        return null;
      }
    }

    const config = {
      type: 'eip2612',
      domain: candidateDomain,
      routerFn: 'permit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
    };
    _permitCache.set(key, config);
    return config;
  } catch (_) {
    _permitCache.set(key, null);
    return null;
  }
}

async function getPermitConfig(tokenAddress) {
  const key = tokenAddress.toLowerCase();
  if (PERMIT_CONFIG[key]) return PERMIT_CONFIG[key];
  return await detectPermitConfig(tokenAddress);
}

async function signPermit(config, tokenAddress) {
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 3600);
  const owner = connectedAddress;
  const spender = ZROUTER_ADDRESS;

  // Fetch nonce from token contract
  const nonceData = _permitIface.encodeFunctionData('nonces', [owner]);
  const nonceResult = await quoteRPC.call(rpc => rpc.call({ to: tokenAddress, data: nonceData }));
  const nonce = _permitIface.decodeFunctionResult('nonces', nonceResult)[0];

  let types, values;
  if (config.type === 'dai') {
    types = {
      Permit: [
        { name: 'holder', type: 'address' },
        { name: 'spender', type: 'address' },
        { name: 'nonce', type: 'uint256' },
        { name: 'expiry', type: 'uint256' },
        { name: 'allowed', type: 'bool' },
      ],
    };
    values = { holder: owner, spender, nonce, expiry: deadline, allowed: true };
  } else {
    types = {
      Permit: [
        { name: 'owner', type: 'address' },
        { name: 'spender', type: 'address' },
        { name: 'value', type: 'uint256' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' },
      ],
    };
    values = { owner, spender, value: ethers.MaxUint256, nonce, deadline };
  }

  const sig = await signer.signTypedData(config.domain, types, values);
  const { v, r, s } = ethers.Signature.from(sig);
  return { v, r, s, nonce, deadline, config };
}

function decodeMulticallCalls(multicallData) {
  try {
    const decoded = ROUTER_IFACE.decodeFunctionData('multicall', multicallData);
    return Array.from(decoded[0]);
  } catch (e) {
    return [];
  }
}

function buildPermitMulticall(calls, permitData) {
  let permitCall;
  if (permitData.config.type === 'dai') {
    permitCall = ROUTER_IFACE.encodeFunctionData('permitDAI', [permitData.nonce, permitData.deadline, permitData.v, permitData.r, permitData.s]);
  } else {
    permitCall = ROUTER_IFACE.encodeFunctionData('permit', [permitData.config.domain.verifyingContract, ethers.MaxUint256, permitData.deadline, permitData.v, permitData.r, permitData.s]);
  }
  return ROUTER_IFACE.encodeFunctionData('multicall', [[permitCall, ...calls]]);
}

// ---- Permit2 SignatureTransfer support ----
const PERMIT2_DOMAIN = { name: "Permit2", chainId: CHAIN_ID, verifyingContract: PERMIT2_ADDRESS };
const PERMIT2_TYPES = {
  PermitTransferFrom: [
    { name: "permitted", type: "TokenPermissions" },
    { name: "spender", type: "address" },
    { name: "nonce", type: "uint256" },
    { name: "deadline", type: "uint256" },
  ],
  TokenPermissions: [
    { name: "token", type: "address" },
    { name: "amount", type: "uint256" },
  ],
};

async function checkPermit2Allowance(tokenAddress) {
  let a = cacheGetAllowance(tokenAddress, connectedAddress, PERMIT2_ADDRESS);
  if (a != null) return a;
  const r = erc20Read(tokenAddress);
  a = await r.allowance(connectedAddress, PERMIT2_ADDRESS);
  cacheSetAllowance(tokenAddress, connectedAddress, PERMIT2_ADDRESS, a);
  return a;
}

async function signPermit2(tokenAddress, amount) {
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 3600);
  const _nonceBytes = new Uint8Array(8); crypto.getRandomValues(_nonceBytes);
  const nonce = _nonceBytes.reduce((n, b) => (n << 8n) | BigInt(b), 0n);
  const values = {
    permitted: { token: tokenAddress, amount },
    spender: ZROUTER_ADDRESS,
    nonce,
    deadline,
  };
  const sig = await signer.signTypedData(PERMIT2_DOMAIN, PERMIT2_TYPES, values);
  return { signature: sig, nonce, deadline, token: tokenAddress, amount };
}

function buildPermit2Multicall(calls, p2) {
  const p2call = ROUTER_IFACE.encodeFunctionData('permit2TransferFrom', [p2.token, p2.amount, p2.nonce, p2.deadline, p2.signature]);
  return ROUTER_IFACE.encodeFunctionData('multicall', [[p2call, ...calls]]);
}

// ---- ERC20 readers (cached, recreated on provider change) ----
const _erc20Read = new Map();
let _erc20ReadProvider = null;
function erc20Read(address) {
  if (!provider) throw new Error("No provider");
  if (_erc20ReadProvider !== provider) { _erc20Read.clear(); _erc20ReadProvider = provider; }
  const k = address.toLowerCase();
  if (!_erc20Read.has(k)) {
    _erc20Read.set(k, new ethers.Contract(
      address,
      ["function allowance(address,address) view returns (uint256)"],
      provider
    ));
  }
  return _erc20Read.get(k);
}

// ---- Balance updates (Multicall3 batched) ----
async function updateBalances() {
  if (!provider || !connectedAddress) return;

  const seq = ++_balSeq;
  const fromSnap = fromToken, toSnap = toToken;
  const f = tokens[fromSnap], t = tokens[toSnap];
  const fromIsEth = f.address === ZERO_ADDRESS;
  const toIsEth = t.address === ZERO_ADDRESS;

  try {
    const calls = [];
    const meta = [];
    const balOfData = MC_BAL_IFACE.encodeFunctionData("balanceOf", [connectedAddress]);

    // ETH balance via getEthBalance (always â€” needed for PP deposit)
    calls.push({ target: MULTICALL3_ADDRESS, allowFailure: true,
      callData: MULTICALL3_IFACE.encodeFunctionData("getEthBalance", [connectedAddress]) });
    meta.push({ type: 'eth' });

    const _addedErc20 = new Set();
    // From token balance
    if (!fromIsEth) {
      calls.push({ target: f.address, allowFailure: true, callData: balOfData });
      meta.push({ type: 'erc20', key: f.address.toLowerCase() });
      _addedErc20.add(f.address.toLowerCase());
    }
    // To token balance (if different)
    if (!toIsEth) {
      const keyT = t.address.toLowerCase();
      if (!_addedErc20.has(keyT)) {
        calls.push({ target: t.address, allowFailure: true, callData: balOfData });
        meta.push({ type: 'erc20', key: keyT });
        _addedErc20.add(keyT);
      }
    }
    // BOLD balance (always â€” needed for PP deposit; deduped)
    const boldKey = BOLD_ADDRESS.toLowerCase();
    if (!_addedErc20.has(boldKey)) {
      calls.push({ target: BOLD_ADDRESS, allowFailure: true, callData: balOfData });
      meta.push({ type: 'erc20', key: boldKey });
    }
    // Batch allowance reads for from token (saves RPCs during quote/swap)
    if (!fromIsEth) {
      calls.push({ target: f.address, allowFailure: true,
        callData: MC_BAL_IFACE.encodeFunctionData("allowance", [connectedAddress, ZROUTER_ADDRESS]) });
      meta.push({ type: 'allow', token: f.address, spender: ZROUTER_ADDRESS });
      calls.push({ target: f.address, allowFailure: true,
        callData: MC_BAL_IFACE.encodeFunctionData("allowance", [connectedAddress, PERMIT2_ADDRESS]) });
      meta.push({ type: 'allow', token: f.address, spender: PERMIT2_ADDRESS });
    }

    const results = await multicallRead(calls);
    if (seq !== _balSeq || fromSnap !== fromToken || toSnap !== toToken) return;

    const balances = Object.create(null);
    for (let i = 0; i < meta.length; i++) {
      const m = meta[i], r = results[i];
      if (!r || !r.success) continue;
      try {
        if (m.type === 'eth') {
          balances.ETH = MULTICALL3_IFACE.decodeFunctionResult("getEthBalance", r.returnData)[0];
          setCachedBalance(ZERO_ADDRESS, balances.ETH);
        } else if (m.type === 'erc20') {
          balances[m.key] = MC_BAL_IFACE.decodeFunctionResult("balanceOf", r.returnData)[0];
          setCachedBalance(m.key, balances[m.key]);
        } else if (m.type === 'allow') {
          cacheSetAllowance(m.token, connectedAddress, m.spender,
            MC_BAL_IFACE.decodeFunctionResult("allowance", r.returnData)[0]);
        }
      } catch {}
    }

    const fromStr = fromIsEth
      ? `${fmt(ethers.formatEther(balances.ETH ?? 0n))} ETH`
      : `${fmt(ethers.formatUnits(balances[f.address.toLowerCase()] ?? 0n, f.decimals))} ${f.symbol}`;
    const toStr = toIsEth
      ? `${fmt(ethers.formatEther(balances.ETH ?? 0n))} ETH`
      : `${fmt(ethers.formatUnits(balances[t.address.toLowerCase()] ?? 0n, t.decimals))} ${t.symbol}`;

    setText("fromBalance", `Balance: ${fromStr}`);
    setText("toBalance", `Balance: ${toStr}`);
    updatePPBalance();
  } catch (e) {
    console.error("Balance update error:", e);
  }
}

// ---- AMM names ----
const AMM_NAMES = {
  0: "Uniswap V2", 1: "SushiSwap", 2: "zAMM",
  3: "Uniswap V3", 4: "Uniswap V4", 5: "Curve",
  6: "Lido", 7: "WETH Wrap", 8: "V4 Hooked",
};
// Rocket Pool direct deposit (dapp-side quoting via rETH contract)
const ROCKET_DEPOSIT_POOL = "0xCE15294273CFb9D9b628F4D61636623decDF4fdC";
const ROCKET_DEPOSIT_ABI = ["function getMaximumDepositAmount() view returns (uint256)"];
const RETH_RATE_ABI = ["function getRethValue(uint256) view returns (uint256)", "function getEthValue(uint256) view returns (uint256)"];
const ROCKET_DEPOSIT_IFACE = new ethers.Interface(ROCKET_DEPOSIT_ABI);
const RETH_RATE_IFACE = new ethers.Interface(RETH_RATE_ABI);

// ---- Hoisted ABIs / Interfaces (avoid re-parsing per call) ----
const QUOTER_IFACE = new ethers.Interface([
  "function buildBestSwapViaETHMulticall(address to,address refundTo,bool exactOut,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline,uint24 hookPoolFee,int24 hookTickSpacing,address hookAddress) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) a, tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) b, bytes[] calls, bytes multicall, uint256 msgValue)",
  "function buildSplitSwap(address to,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut)[2] legs, bytes multicall, uint256 msgValue)",
  "function getQuotes(bool exactOut,address tokenIn,address tokenOut,uint256 swapAmount) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) best, tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut)[] quotes)",
  "function quoteCurve(bool exactOut,address tokenIn,address tokenOut,uint256 swapAmount,uint256 maxCandidates) view returns (uint256 amountIn,uint256 amountOut,address bestPool,bool usedUnderlying,bool usedStable,uint8 iIndex,uint8 jIndex)",
  "function quoteV4(bool,address,address,uint24,int24,address,uint256) view returns (uint256 amountIn, uint256 amountOut)",
  "function buildSplitSwapHooked(address to,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline,uint24 hookPoolFee,int24 hookTickSpacing,address hookAddress) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut)[2] legs, bytes multicall, uint256 msgValue)",
  "function quoteZAMM(bool exactOut,uint256 feeOrHook,address tokenIn,address tokenOut,uint256 idIn,uint256 idOut,uint256 swapAmount) view returns (uint256 amountIn, uint256 amountOut)",
  "function build3HopMulticall(address to,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) a, tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) b, tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) c, bytes[] calls, bytes multicall, uint256 msgValue)",
  "function buildHybridSplit(address to,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut)[2] legs, bytes multicall, uint256 msgValue)",
  "function quoteLido(bool exactOut,address tokenOut,uint256 swapAmount) view returns (uint256 amountIn, uint256 amountOut)",
]);
const ROUTER_IFACE = new ethers.Interface([
  "function deposit(address,uint256,uint256) payable",
  "function execute(address,uint256,bytes) payable returns (bytes)",
  "function multicall(bytes[]) payable returns (bytes[])",
  "function sweep(address,uint256,uint256,address) payable",
  "function swapVZ(address to,bool exactOut,uint256 feeOrHook,address tokenIn,address tokenOut,uint256 idIn,uint256 idOut,uint256 swapAmount,uint256 amountLimit,uint256 deadline) payable returns (uint256 amountIn, uint256 amountOut)",
  "function swapV4(address to,bool exactOut,uint24 swapFee,int24 tickSpace,address tokenIn,address tokenOut,uint256 swapAmount,uint256 amountLimit,uint256 deadline) payable returns (uint256 amountIn, uint256 amountOut)",
  "function wrap(uint256 amount) payable",
  "function exactETHToSTETH(address to) payable returns (uint256 shares)",
  "function exactETHToWSTETH(address to) payable returns (uint256 wstOut)",
  "function permit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)",
  "function permitDAI(uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s)",
  "function permit2TransferFrom(address token, uint256 amount, uint256 nonce, uint256 deadline, bytes signature)",
]);
const ZORG_BUYSHARES_IFACE = new ethers.Interface([
  "function buyShares(address payToken, uint256 shareAmount, uint256 maxPay)",
  "function approve(address spender, uint256 amount) returns (bool)",
]);
const ZORG_RAGEQUIT_IFACE = new ethers.Interface([
  "function ragequit(address[] tokens, uint256 sharesToBurn, uint256 lootToBurn)",
]);

// ---- Quote refresh timer ----
let _refreshTimer = null;
let _refreshCountdown = 0;

function startQuoteRefresh() {
  stopQuoteRefresh();
  _refreshCountdown = 15;
  setText('quoteCountdown', `Refreshes in ${_refreshCountdown}s`);
  _refreshTimer = setInterval(() => {
    _refreshCountdown--;
    if (_refreshCountdown <= 0) {
      _refreshCountdown = 15;
      handleAmountChange();
    }
    setText('quoteCountdown', `Refreshes in ${_refreshCountdown}s`);
  }, 1000);
}

function stopQuoteRefresh() {
  if (_refreshTimer) { clearInterval(_refreshTimer); _refreshTimer = null; }
  _refreshCountdown = 0;
  setText('quoteCountdown', '');
}

function manualRefresh() {
  handleAmountChange();
  // Timer restarted by handleAmountChange on success
}

// ---- Quoting ----
let _quoteSeq = 0;
let _inputMode = 'exactIn'; // 'exactIn' | 'exactOut'

async function handleAmountChange() {
  const isExactOut = _inputMode === 'exactOut';
  const amtStr = isExactOut ? $("toAmount").value.trim() : $("fromAmount").value.trim();
  const swapBtn = $("swapBtn");
  const dstEl = isExactOut ? $("fromAmount") : $("toAmount");
  const quoteInfoEl = $("quoteInfo");

  if (!connectedAddress) {
    setText(swapBtn, "Connect Wallet");
    setDisabled(swapBtn, false);
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    dstEl.value = "";
    return;
  }

  const amtNum = Number(amtStr);
  if (!amtStr || !Number.isFinite(amtNum) || amtNum <= 0) {
    dstEl.value = "";
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    setText(swapBtn, "Enter an amount");
    setDisabled(swapBtn, true);
    syncSwapURL();
    return;
  }
  syncSwapURL();

  if (fromToken === toToken && !_ppSwapEnabled) {
    dstEl.value = "";
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    setText(swapBtn, "Select different tokens");
    setDisabled(swapBtn, true);
    return;
  }
  if (_ppSwapEnabled && fromToken === 'ETH' && toToken === 'ETH') {
    dstEl.value = amtStr;
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    setText(swapBtn, "Deposit ETH to Privacy Pool");
    setDisabled(swapBtn, !connectedAddress);
    return;
  }
  if (_ppSwapEnabled && fromToken === 'BOLD' && toToken === 'BOLD') {
    dstEl.value = amtStr;
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    setText(swapBtn, "Deposit BOLD to Privacy Pool");
    setDisabled(swapBtn, !connectedAddress);
    return;
  }

  // ETH â†” WETH wrap/unwrap: 1:1, no DEX needed (only when sending to self)
  const _receiverRaw = ($("receiverAddress")?.value || "").trim();
  const _resolvedAddr = getReceiver();
  const _hasCustomReceiver = _receiverRaw && (isReceiverPending() || (_resolvedAddr && _resolvedAddr !== connectedAddress));
  const wrapDir = !_hasCustomReceiver && !_ppSwapEnabled ? isWrapUnwrap(fromToken, toToken) : null;
  if (wrapDir) {
    const fromData = tokens[fromToken];
    try {
      const amountIn = safeParseUnits(amtStr, fromData.decimals);
      // Output equals input (1:1, both 18 decimals)
      dstEl.value = amtStr;
      fitRouteText(wrapDir === 'wrap' ? 'WETH Wrap' : 'WETH Unwrap');
      const _ln = $("routeInfo")?.parentNode?.querySelector('.lido-note');
      if (_ln) _ln.style.display = 'none';
      $("chartLink").style.display = "none";
      setText('impactInfo', '0%');
      setShown('allRoutesWrap', false);
      setShown('impactRow', true);
      setShown('slippageRow', false);
      setShown('refreshRow', false);
      setShown(quoteInfoEl, true);
      updateCalldataLink(null);
      stopQuoteRefresh(); // No refresh needed for 1:1
      setText(swapBtn, wrapDir === 'wrap' ? 'Wrap' : 'Unwrap');
      setDisabled(swapBtn, !connectedAddress);
    } catch (e) {
      dstEl.value = "";
      setShown(quoteInfoEl, false);
      setText(swapBtn, e.message || "Invalid amount");
      setDisabled(swapBtn, true);
    }
    return;
  }

  // WETHâ†’ETH + PP: can't route through quoter, user should unwrap first
  if (_ppSwapEnabled && isWrapUnwrap(fromToken, toToken)) {
    dstEl.value = "";
    setShown(quoteInfoEl, false);
    setText(swapBtn, "Unwrap WETH first");
    setDisabled(swapBtn, true);
    return;
  }

  if (!provider) return;

  const seq = ++_quoteSeq;
  const fromSnap = fromToken, toSnap = toToken;

  // Disable exact-out for special paths (zOrg, ZAMM, ragequit)
  if (isExactOut && isExactOutDisabled(fromSnap, toSnap)) {
    dstEl.value = "";
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    setText(swapBtn, "Exact output not available for this pair");
    setDisabled(swapBtn, true);
    return;
  }

  try {
    setHTML(swapBtn, `<span class="loading"></span> Getting quote...`);
    setDisabled(swapBtn, true);
    dstEl.value = "";
    dstEl.placeholder = "Fetching\u2026";

    const quote = await requestQuote(amtStr, fromSnap, toSnap, isExactOut);

    if (seq !== _quoteSeq || fromSnap !== fromToken || toSnap !== toToken) {
      dstEl.placeholder = "0.0";
      return;
    }

    const toData = tokens[toSnap];
    const fromDataQ = tokens[fromSnap];
    dstEl.placeholder = "0.0";
    let inNum, outNum;
    if (isExactOut) {
      const inRaw = ethers.formatUnits(quote.requiredInput, fromDataQ.decimals);
      const inDisplay = fmtOutput(inRaw);
      if (dstEl.value !== inDisplay) dstEl.value = inDisplay;
      inNum = Number(inRaw);
      outNum = Number(amtStr);
    } else {
      const outRaw = ethers.formatUnits(quote.expectedOutput, toData.decimals);
      const outDisplay = fmtOutput(outRaw);
      if (dstEl.value !== outDisplay) dstEl.value = outDisplay;
      inNum = Number(amtStr);
      outNum = Number(outRaw);
    }

    // Exchange rate line
    const rateEl = $('quoteRate');
    if (rateEl) {
      if (inNum > 0 && Number.isFinite(outNum) && outNum > 0) {
        const rate = outNum / inNum;
        // Adaptive precision: use more decimals for tiny rates (e.g. ZAMM â†’ ETH)
        const rateDec = rate >= 1 ? 2 : rate >= 0.01 ? 4 : rate >= 0.0001 ? 6 : 8;
        rateEl.textContent = `1 ${tokens[fromSnap].symbol} \u2248 ${fmt(rate.toString(), rateDec)} ${toData.symbol}`;
        rateEl.style.display = '';
      } else {
        rateEl.style.display = 'none';
      }
    }

    // Route display
    const isLidoRoute = quote.sourceA === "Lido" && !quote.isSplit && !quote.isTwoHop;
    const isRocketRoute = quote.sourceA === "Rocket Pool" && !quote.isSplit && !quote.isTwoHop;
    const isStakeRoute = isLidoRoute || isRocketRoute;
    const route = quote.isSplit
      ? formatSplitRoute(quote.splitLegs)
      : quote.isTwoHop
        ? `${quote.sourceA} + ${quote.sourceB}`
        : isStakeRoute ? `${quote.sourceA} Stake` : `${quote.sourceA}`;
    fitRouteText(route);
    updateChartLink(quote);
    // Show "Direct stake" note for Lido/Rocket Pool routes
    const routeEl = $("routeInfo");
    if (routeEl) {
      let noteEl = routeEl.parentNode.querySelector('.lido-note');
      if (isStakeRoute) {
        if (!noteEl) {
          noteEl = document.createElement('span');
          noteEl.className = 'lido-note';
          noteEl.style.cssText = 'font-size:11px;color:var(--fg-muted);margin-left:6px';
          routeEl.parentNode.appendChild(noteEl);
        }
        noteEl.textContent = 'Direct stake â€” no DEX fees';
        noteEl.style.display = '';
      } else if (noteEl) {
        noteEl.style.display = 'none';
      }
    }

    // Split/multi-hop slippage note
    const ssn = $('splitSlipNote');
    if (ssn) {
      if (quote.isSplit || quote.isTwoHop) {
        const slippageBps = readSlippage();
        const perLeg = Math.min(Math.max(slippageBps * 3, 150), 500) / 100;
        ssn.textContent = `(${perLeg}% per leg)`;
        ssn.style.display = '';
      } else {
        ssn.style.display = 'none';
      }
    }

    // Price impact
    const impactAmtStr = isExactOut ? ethers.formatUnits(quote.requiredInput, fromDataQ.decimals) : amtStr;
    displayPriceImpact(impactAmtStr, fromSnap, toSnap, quote);

    // All routes
    displayAllRoutes(quote, toSnap, isExactOut, fromSnap);

    // Allowance check
    const fromData = tokens[fromSnap];
    const isDirectStake = isDirectZOrgStake(fromSnap, toSnap);
    const isRagequit = isRagequitPath(fromSnap, toSnap);
    const isDirectPath = isDirectStake || isRagequit;
    const isLidoStake = isStakeRoute;
    const hideSlippage = isDirectPath || isLidoStake;

    // Hide slippage & refresh for 1:1 / Lido / Rocket Pool / ragequit operations
    setShown('slippageRow', !hideSlippage);
    setShown('impactRow', !isLidoStake && !isRagequit);
    setShown('refreshRow', !isDirectPath);
    setShown(quoteInfoEl, true);
    updateCalldataLink(quote.multicall);
    if (isDirectPath) stopQuoteRefresh(); else startQuoteRefresh();
    const isZOrgSell = isZOrgSellPath(fromSnap, toSnap);
    const isZammSell = isZammSellPath(fromSnap, toSnap);
    let btnLabel = isRagequit ? "Ragequit"
      : isDirectStake ? "Stake"
      : isLidoStake ? "Stake"
      : isZOrgSwap(toSnap) ? "Swap & Stake"
      : isZOrgSell ? "Ragequit & Sell"
      : _ppSwapEnabled ? "Swap & Deposit"
      : "Swap";
    if (fromData.address !== ZERO_ADDRESS) {
      const amountIn = isExactOut ? quote.requiredInput : safeParseUnits(amtStr, fromData.decimals);
      if (isDirectStake) {
        // Check allowance against zOrg DAO for direct stake
        let allowance = cacheGetAllowance(fromData.address, connectedAddress, ZORG_DAO);
        if (allowance == null) {
          const r = erc20Read(fromData.address);
          allowance = await r.allowance(connectedAddress, ZORG_DAO);
          cacheSetAllowance(fromData.address, connectedAddress, ZORG_DAO, allowance);
        }
        if (allowance < amountIn) btnLabel = "Approve & " + btnLabel;
      } else if (isRagequit) {
        // No approval needed for ragequit â€” DAO burns msg.sender's shares directly
      } else if (isZOrgSell) {
        // Ragequit doesn't need approval, but second step (ZAMM sell) might
        // Check ZAMM allowance against router for the sell leg
        let allowance = cacheGetAllowance(ZORG_PAY_TOKEN, connectedAddress, ZROUTER_ADDRESS);
        if (allowance == null) {
          const r = erc20Read(ZORG_PAY_TOKEN);
          allowance = await r.allowance(connectedAddress, ZROUTER_ADDRESS);
          cacheSetAllowance(ZORG_PAY_TOKEN, connectedAddress, ZROUTER_ADDRESS, allowance);
        }
        // Don't add "Approve &" prefix â€” handled in-flow during two-step execution
      } else {
        let allowance = cacheGetAllowance(fromData.address, connectedAddress, ZROUTER_ADDRESS);
        if (allowance == null) {
          const r = erc20Read(fromData.address);
          allowance = await r.allowance(connectedAddress, ZROUTER_ADDRESS);
          cacheSetAllowance(fromData.address, connectedAddress, ZROUTER_ADDRESS, allowance);
        }
        if (allowance < amountIn) {
          const [permitCfg, p2Allowance] = await Promise.all([
            getPermitConfig(fromData.address),
            checkPermit2Allowance(fromData.address),
          ]);
          btnLabel = (permitCfg || p2Allowance >= amountIn) ? btnLabel : ("Approve & " + btnLabel);
        }
      }
    }

    setText(swapBtn, btnLabel);
    setDisabled(swapBtn, false);
  } catch (e) {
    console.error("Quote error:", e);
    dstEl.value = "";
    dstEl.placeholder = "0.0";
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    const msg = /Too many decimals|Invalid number|Empty amount/i.test(String(e?.message || ""))
      ? e.message : "Quote failed";
    setText(swapBtn, msg);
    setDisabled(swapBtn, true);
    setTimeout(() => {
      if (seq === _quoteSeq) {
        setText(swapBtn, "Enter an amount");
        setDisabled(swapBtn, true);
      }
    }, 1500);
  }
}

async function setPercentBalance(pct) {
  try {
    if (!provider || !connectedAddress) {
      toggleWallet();
      return;
    }

    const f = tokens[fromToken];
    let raw = getCachedBalance(f.address);

    if (raw == null) {
      if (f.address === ZERO_ADDRESS) {
        raw = await provider.getBalance(connectedAddress);
      } else {
        const c = new ethers.Contract(f.address,
          ["function balanceOf(address) view returns (uint256)"], provider);
        raw = await c.balanceOf(connectedAddress);
      }
      setCachedBalance(f.address, raw);
    }

    // Apply percentage
    raw = (raw * BigInt(pct)) / 100n;

    // Reserve 5% for gas when sending ETH at 100%
    if (f.address === ZERO_ADDRESS && pct === 100) raw = (raw * 95n) / 100n;

    const valStr = ethers.formatUnits(raw, f.decimals);
    const pretty = valStr.includes(".") ? valStr.replace(/\.?0+$/, "") : valStr;

    const input = $("fromAmount");
    input.value = pretty || "0";
    _inputMode = 'exactIn';
    handleAmountChange();
  } catch (e) {
    console.error("Percent balance error:", e);
  }
}

// ---- Slippage ----
const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
function readSlippage(finalize = false) {
  const el = $("slippagePct");
  if (!el) return;
  const raw = el.value;
  let v = parseFloat(raw);
  if (Number.isFinite(v)) {
    v = clamp(v, 0, 20);
    slippageBps = Math.round(v * 100);
    if (finalize) {
      const stepDigits = (String(el.step || "0.1").split(".")[1] || "").length;
      el.value = v.toFixed(stepDigits);
    }
  } else if (finalize) {
    const stepDigits = (String(el.step || "0.1").split(".")[1] || "").length;
    el.value = clamp(slippageBps / 100, 0, 20).toFixed(stepDigits);
  }
  return slippageBps;
}

function initSimpleSlippage() {
  const el = $("slippagePct");
  if (!el || el.dataset.inited === "1") return;
  el.dataset.inited = "1";
  readSlippage(false);

  const reQuote = debounce(() => {
    const amt = _inputMode === 'exactOut' ? $("toAmount")?.value : $("fromAmount")?.value;
    if (amt) handleAmountChange();
  }, 250);

  el.addEventListener("input", () => { readSlippage(false); reQuote(); });
  el.addEventListener("blur", () => { readSlippage(true); reQuote(); });
  el.addEventListener("keydown", (e) => {
    if (e.key !== "ArrowUp" && e.key !== "ArrowDown") return;
    e.preventDefault();
    const step = parseFloat(el.step || "0.01") || 0.01;
    const digits = (String(step).split(".")[1] || "").length;
    const cur = parseFloat(el.value || "0") || 0;
    const dir = e.key === "ArrowUp" ? 1 : -1;
    const next = clamp(cur + dir * step, 0, 20);
    el.value = next.toFixed(digits);
    readSlippage(true);
    reQuote();
  });
}
document.addEventListener("DOMContentLoaded", initSimpleSlippage);

// ---- Receiver name resolution ----
let _resolvedReceiver = null; // { input, address } or null
let _receiverResolveSeq = 0;

function getReceiver() {
  if (!connectedAddress) return null;
  const v = ($("receiverAddress")?.value || "").trim();
  if (!v) return connectedAddress;
  if (ethers.isAddress(v) && v !== ZERO_ADDRESS) return ethers.getAddress(v);
  if (_resolvedReceiver && _resolvedReceiver.input === v && _resolvedReceiver.address) return _resolvedReceiver.address;
  return connectedAddress;
}

function isReceiverPending() {
  const v = ($("receiverAddress")?.value || "").trim();
  if (!v || ethers.isAddress(v)) return false;
  return !_resolvedReceiver || _resolvedReceiver.input !== v || !_resolvedReceiver.address;
}

let _receiverDebounce = null;
function onReceiverInput() {
  clearTimeout(_receiverDebounce);
  const v = ($("receiverAddress")?.value || "").trim();
  const el = $("receiverResolved");

  // Clear state
  _resolvedReceiver = null;

  updateReceiverWarn();
  syncSwapURL();
  // Direct 0x address
  if (!v) { el.style.display = "none"; return; }
  if (ethers.isAddress(v)) {
    el.style.display = "block";
    el.style.color = "var(--fg-muted)";
    el.textContent = ethers.getAddress(v);
    _resolvedReceiver = { input: v, address: ethers.getAddress(v) };
    return;
  }

  // Name resolution (.wei or .eth)
  if (v.endsWith(".wei") || v.endsWith(".eth")) {
    el.style.display = "block";
    el.style.color = "var(--fg-muted)";
    el.textContent = "Resolving " + v + "...";
    _receiverDebounce = setTimeout(() => resolveReceiverName(v), 350);
  } else {
    el.style.display = "block";
    el.style.color = "#c0392b";
    el.textContent = "Enter 0x address, name.wei, or name.eth";
  }
}

async function resolveReceiverName(name) {
  const seq = ++_receiverResolveSeq;
  const el = $("receiverResolved");
  try {
    let resolved = null;
    if (name.endsWith(".wei")) {
      resolved = await quoteRPC.call(async (rpc) => {
        const ns = getWeinsContract(rpc);
        const tokenId = await ns.computeId(name);
        const owner = await ns.ownerOf(tokenId).catch(() => null);
        if (!owner || owner === ZERO_ADDRESS) return null;
        return ethers.getAddress(owner);
      });
    } else if (name.endsWith(".eth")) {
      resolved = await quoteRPC.call(async (rpc) => {
        return await rpc.resolveName(name);
      });
    }
    if (seq !== _receiverResolveSeq) return;
    if (resolved && resolved !== ZERO_ADDRESS) {
      _resolvedReceiver = { input: name, address: resolved };
      el.style.color = "var(--fg-muted)";
      el.textContent = resolved;
      // Re-quote so calldata uses the resolved receiver
      const amt = _inputMode === 'exactOut' ? $("toAmount")?.value : $("fromAmount")?.value;
      if (amt && +amt > 0) handleAmountChange();
    } else {
      _resolvedReceiver = null;
      el.style.color = "#c0392b";
      el.textContent = "Name not found";
    }
  } catch (e) {
    if (seq !== _receiverResolveSeq) return;
    _resolvedReceiver = null;
    el.style.color = "#c0392b";
    el.textContent = "Failed to resolve " + name;
  }
}

// Wire up receiver input listener after DOM ready
document.addEventListener("DOMContentLoaded", () => {
  const ri = $("receiverAddress");
  if (ri) ri.addEventListener("input", onReceiverInput);
});

// Cache contract instances per provider to avoid repeated construction
const _contractCache = new WeakMap();
function _getCached(rpc, addr, abi) {
  let m = _contractCache.get(rpc);
  if (!m) { m = new Map(); _contractCache.set(rpc, m); }
  let c = m.get(addr);
  if (!c) { c = new ethers.Contract(addr, abi, rpc); m.set(addr, c); }
  return c;
}
function getQuoterContract(rpc) { return _getCached(rpc, ZQUOTER_ADDRESS, QUOTER_IFACE); }
function getWeinsContract(rpc) { return _getCached(rpc, WEINS_ADDRESS, WEINS_ABI); }

// ---- zOrg swap+stake helpers ----
function isZOrgSwap(toSym) {
  return tokens[toSym]?._isZOrg === true;
}
function isDirectZOrgStake(fromSym, toSym) {
  return isZOrgSwap(toSym) && tokens[fromSym]?.address?.toLowerCase() === ZORG_PAY_TOKEN.toLowerCase();
}
function isRagequitPath(fromSym, toSym) {
  return tokens[fromSym]?._isZOrg === true && tokens[toSym]?._isZammStake === true;
}
// ZAMM â†’ any non-zOrg token (sell via zAMM pool)
function isZammSellPath(fromSym, toSym) {
  return tokens[fromSym]?._isZammStake === true && !isZOrgSwap(toSym) && !isRagequitPath(fromSym, toSym);
}
// any token â†’ ZAMM (buy via zAMM pool)
function isZammBuyPath(fromSym, toSym) {
  return tokens[toSym]?._isZammStake === true && !tokens[fromSym]?._isZOrg && !tokens[fromSym]?._isZammStake;
}
// zOrg â†’ any token except ZAMM (ragequit 1:1 to ZAMM, then sell ZAMM)
function isZOrgSellPath(fromSym, toSym) {
  return fromSym !== toSym && tokens[fromSym]?._isZOrg === true && !tokens[toSym]?._isZammStake && tokens[toSym] != null;
}
function isExactOutDisabled(fromSym, toSym) {
  return isDirectZOrgStake(fromSym, toSym) || isRagequitPath(fromSym, toSym)
    || isZOrgSwap(toSym) || isZammBuyPath(fromSym, toSym)
    || isZammSellPath(fromSym, toSym) || isZOrgSellPath(fromSym, toSym);
}

// ---- zAMM reverse quote: ZAMM â†’ ETH (client-side AMM math) ----
function getZammAmountOut(amtIn, resIn, resOut, feeBps) {
  if (amtIn === 0n || resIn === 0n || resOut === 0n) return 0n;
  const amtFee = amtIn * (10000n - feeBps);
  return (amtFee * resOut) / (resIn * 10000n + amtFee);
}

function computeZammPoolKey() {
  return ethers.AbiCoder.defaultAbiCoder().encode(
    ["uint256","uint256","address","address","uint256"],
    [0, ZORG_ID, ZERO_ADDRESS, ZORG_TOKEN, 100]
  );
}

const _zammPoolId = BigInt(ethers.keccak256(computeZammPoolKey()));
const _zammPoolsIface = new ethers.Interface(ZAMM_POOLS_ABI);
const _zammPoolsCalldata = _zammPoolsIface.encodeFunctionData("pools", [_zammPoolId]);

async function getZammPoolReserves(rpc) {
  const raw = await rpc.call({ to: MULTICALL3_ADDRESS, data: MULTICALL3_IFACE.encodeFunctionData("aggregate3", [[
    [ZAMM_HOOKED, true, _zammPoolsCalldata],
    [ZAMM_HOOKLESS, true, _zammPoolsCalldata],
  ]]) });
  const results = MULTICALL3_IFACE.decodeFunctionResult("aggregate3", raw)[0];
  const decode = (r) => {
    if (!r.success) return { reserve0: 0n, reserve1: 0n };
    const d = _zammPoolsIface.decodeFunctionResult("pools", r.returnData);
    return { reserve0: BigInt(d[0]), reserve1: BigInt(d[1]) };
  };
  return { hooked: decode(results[0]), hookless: decode(results[1]) };
}

// ZAMM â†’ ETH: sell ERC6909 ZORG for ETH (zeroForOne=false, reserveIn=reserve1, reserveOut=reserve0)
function getZammToEthQuote(amountIn, reserves) {
  const hookedOut = getZammAmountOut(amountIn, reserves.hooked.reserve1, reserves.hooked.reserve0, 100n);
  const hooklessOut = getZammAmountOut(amountIn, reserves.hookless.reserve1, reserves.hookless.reserve0, 100n);
  const useHookless = hooklessOut >= hookedOut;
  return { ethOut: useHookless ? hooklessOut : hookedOut, useHookless };
}

// ---- ETH â†” WETH wrap/unwrap detection ----
const WETH_ABI = ["function deposit() payable", "function withdraw(uint256 wad)"];

function isWrapUnwrap(fromSym, toSym) {
  const from = tokens[fromSym], to = tokens[toSym];
  if (!from || !to) return null;
  const fa = from.address.toLowerCase(), ta = to.address.toLowerCase();
  const weth = WETH_ADDRESS.toLowerCase();
  if (fa === ZERO_ADDRESS && ta === weth) return 'wrap';
  if (fa === weth && ta === ZERO_ADDRESS) return 'unwrap';
  return null;
}

// Direct ZAMM â†’ zOrg stake: no swap needed, call buyShares on the DAO directly
function getDirectZOrgStakeQuote(fromAmountStr, fromSym) {
  const fromData = tokens[fromSym];
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);

  // Direct 1:1 stake â€” no swap, no slippage. shareAmount = maxPay = amountIn.
  const buySharesData = ZORG_BUYSHARES_IFACE.encodeFunctionData('buyShares', [ZORG_PAY_TOKEN, amountIn, amountIn]);

  return {
    expectedOutput: amountIn,
    directDAO: true, // signals executeSwap to call the DAO directly
    daoCalldata: buySharesData,
    multicall: null,
    calls: null,
    msgValue: 0n,
    isTwoHop: false,
    isSplit: false,
    splitLegs: null,
    sourceA: "Direct Stake",
    sourceB: null,
    allQuotes: [{ source: "Direct DAO Stake", sourceId: 2, feeBps: 0n, amountIn, amountOut: amountIn }],
  };
}

// Ragequit zOrg â†’ ZAMM: 1:1 redemption, direct call to DAO
function getRagequitQuote(fromAmountStr, fromSym) {
  const fromData = tokens[fromSym];
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);

  const ragequitData = ZORG_RAGEQUIT_IFACE.encodeFunctionData('ragequit', [
    [ZORG_PAY_TOKEN], amountIn, 0
  ]);

  return {
    expectedOutput: amountIn,
    directDAO: true,
    isRagequit: true,
    daoCalldata: ragequitData,
    multicall: null,
    calls: null,
    msgValue: 0n,
    isTwoHop: false,
    isSplit: false,
    splitLegs: null,
    sourceA: "Ragequit",
    sourceB: null,
    allQuotes: [{ source: "DAO Ragequit", sourceId: 2, feeBps: 0n, amountIn, amountOut: amountIn }],
  };
}

// ZAMM â†’ any token: sell ZAMM via zAMM pool (ZAMMâ†’ETH), then optionally ETHâ†’target via quoter
async function getZammSellQuote(fromAmountStr, fromSym, toSym) {
  const fromData = tokens[fromSym], toData = tokens[toSym];
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);
  readSlippage(true);
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 300);
  const receiver = getReceiver();
  const toIsEth = toData.address === ZERO_ADDRESS;

  return await quoteRPC.call(async (rpc) => {
    const callOpts = { blockTag: "latest" };
    const reserves = await getZammPoolReserves(rpc);
    const { ethOut, useHookless } = getZammToEthQuote(amountIn, reserves);
    const zammDeadline = useHookless ? ethers.MaxUint256 : deadline;
    const zammSource = useHookless ? "zAMMâ‚€" : "zAMM";

    if (toIsEth) {
      // ZAMM â†’ ETH: single zAMM swap via router
      // Router needs ERC6909 input. User holds ERC20 ZAMM.
      // Router deposit() converts ERC20 â†’ ERC6909 for the pool.
      const slipOut = ethOut * (10000n - BigInt(slippageBps)) / 10000n;
      const calls = [];
      // deposit: convert ERC20 ZAMM to ERC6909 inside the router
      calls.push(ROUTER_IFACE.encodeFunctionData('deposit', [ZORG_TOKEN, ZORG_ID, amountIn]));
      // swapVZ: sell ZORG ERC6909 for ETH (zeroForOne=false)
      calls.push(ROUTER_IFACE.encodeFunctionData('swapVZ', [
        receiver, false, 100,
        ZORG_TOKEN, ZERO_ADDRESS, ZORG_ID, 0,
        amountIn, slipOut, zammDeadline
      ]));
      // Sweep ETH to receiver
      calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, receiver]));
      // Safety sweep: remaining ERC20 ZAMM back to user
      calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZORG_PAY_TOKEN, 0, 0, receiver]));
      const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);

      return {
        expectedOutput: ethOut,
        multicall, calls, msgValue: 0n,
        isTwoHop: false, isSplit: false, splitLegs: null,
        sourceA: zammSource, sourceB: null,
        allQuotes: [{ source: zammSource, sourceId: 2, feeBps: 100n, amountIn, amountOut: ethOut }],
      };
    }

    // ZAMM â†’ non-ETH: zAMM (ZAMMâ†’ETH) + quoter (ETHâ†’target)
    const quoter = getQuoterContract(rpc);
    const splitSlip = BigInt(Math.min(Math.max(slippageBps * 3, 150), 500));
    const r = await quoter.buildBestSwapViaETHMulticall(
      receiver, connectedAddress, false,
      ZERO_ADDRESS, toData.address,
      ethOut, splitSlip, deadline, 0, 0, ZERO_ADDRESS, callOpts
    );
    const isTwoHop = r.b.amountOut > 0n;
    const finalOut = isTwoHop ? r.b.amountOut : r.a.amountOut;
    const secondLegSource = AMM_NAMES[isTwoHop ? r.b.source : r.a.source] || "Unknown";

    // Build multicall: deposit + swapVZ (ZAMMâ†’ETH) + second-leg calls (ETHâ†’target) + sweeps
    const slipZamm = ethOut * (10000n - splitSlip) / 10000n;
    const calls = [];
    calls.push(ROUTER_IFACE.encodeFunctionData('deposit', [ZORG_TOKEN, ZORG_ID, amountIn]));
    calls.push(ROUTER_IFACE.encodeFunctionData('swapVZ', [
      ZROUTER_ADDRESS, false, 100,
      ZORG_TOKEN, ZERO_ADDRESS, ZORG_ID, 0,
      amountIn, slipZamm, zammDeadline
    ]));
    // Second leg: ETH â†’ target (calls from quoter operate on transient ETH in router)
    for (const c of Array.from(r.calls)) calls.push(c);
    // Sweep target token and ETH remainder
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [toData.address, 0, 0, receiver]));
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, receiver]));
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZORG_PAY_TOKEN, 0, 0, receiver]));
    const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);

    return {
      expectedOutput: finalOut,
      multicall, calls, msgValue: 0n,
      isTwoHop: true, isSplit: false, splitLegs: null,
      sourceA: zammSource, sourceB: secondLegSource,
      allQuotes: [{ source: `${zammSource} + ${secondLegSource}`, sourceId: 2, feeBps: 100n, amountIn, amountOut: finalOut }],
    };
  });
}

// any token â†’ ZAMM: buy ZAMM via zAMM pool (optionally tokenIn â†’ ETH first, then ETH â†’ ZAMM)
async function getZammBuyQuote(fromAmountStr, fromSym, toSym) {
  const fromData = tokens[fromSym];
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);
  readSlippage(true);
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 300);
  const receiver = getReceiver();
  const ethIn = fromData.address === ZERO_ADDRESS;

  return await quoteRPC.call(async (rpc) => {
    const quoter = getQuoterContract(rpc);
    const callOpts = { blockTag: "latest" };

    let ethForSwap = amountIn;
    let firstLegCalls = null;
    let firstLegSource = null;
    let msgValue = ethIn ? amountIn : 0n;

    // Non-ETH input: route tokenIn â†’ ETH first via quoter (output stays in router)
    if (!ethIn) {
      const r = await quoter.buildBestSwapViaETHMulticall(
        ZROUTER_ADDRESS, connectedAddress, false,
        fromData.address, ZERO_ADDRESS,
        amountIn, BigInt(slippageBps), deadline, 0, 0, ZERO_ADDRESS, callOpts
      );
      const isTwoHop = r.b.amountOut > 0n;
      ethForSwap = isTwoHop ? r.b.amountOut : r.a.amountOut;
      firstLegCalls = Array.from(r.calls);
      firstLegSource = AMM_NAMES[r.a.source] || "Unknown";
      msgValue = 0n;
    }

    // Quote both zAMM pools and pick the better rate
    const reserves = await getZammPoolReserves(rpc);
    // zeroForOne=true â†’ reserveIn=reserve0 (ETH), reserveOut=reserve1 (ZAMM)
    const hookedOut = getZammAmountOut(ethForSwap, reserves.hooked.reserve0, reserves.hooked.reserve1, 100n);
    const hooklessOut = getZammAmountOut(ethForSwap, reserves.hookless.reserve0, reserves.hookless.reserve1, 100n);
    const useHookless = hooklessOut >= hookedOut;
    const zammOut = useHookless ? hooklessOut : hookedOut;
    const zammDeadline = useHookless ? ethers.MaxUint256 : deadline;
    const zammSource = useHookless ? "zAMMâ‚€" : "zAMM";

    const slipOut = zammOut * (10000n - BigInt(slippageBps)) / 10000n;
    const calls = [];

    // If non-ETH: include first leg calls (tokenIn â†’ ETH)
    if (firstLegCalls) {
      for (const c of firstLegCalls) calls.push(c);
    }

    // swapVZ: ETH â†’ ZAMM (zeroForOne=true)
    calls.push(ROUTER_IFACE.encodeFunctionData('swapVZ', [
      ZROUTER_ADDRESS, false, 100,
      ZERO_ADDRESS, ZORG_TOKEN, 0, ZORG_ID,
      ethIn ? 0 : ethForSwap, slipOut, zammDeadline
    ]));

    // Sweep ERC20 ZAMM to receiver
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZORG_PAY_TOKEN, 0, 0, receiver]));
    // Safety sweep: remaining ETH back to user
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, receiver]));
    // Safety sweep: input token back to user (if non-ETH)
    if (!ethIn) {
      calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [fromData.address, 0, 0, receiver]));
    }

    const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);

    return {
      expectedOutput: zammOut,
      multicall, calls, msgValue,
      isTwoHop: !ethIn, isSplit: false, splitLegs: null,
      sourceA: ethIn ? zammSource : firstLegSource,
      sourceB: ethIn ? null : zammSource,
      allQuotes: [{ source: ethIn ? zammSource : `${firstLegSource} + ${zammSource}`, sourceId: 2, feeBps: 100n, amountIn, amountOut: zammOut }],
    };
  });
}

// zOrg â†’ any token (except ZAMM, which is ragequit): ragequit (1:1) then sell ZAMM
// This is a two-step flow: ragequit tx first, then ZAMM sell tx
async function getZOrgSellQuote(fromAmountStr, fromSym, toSym) {
  const fromData = tokens[fromSym];
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);
  // After ragequit, user gets amountIn ZAMM (1:1, both 18 decimals)
  // Then sell that ZAMM to the target
  const zammQuote = await getZammSellQuote(fromAmountStr, "ZAMM", toSym);

  // Encode ragequit calldata for the first tx
  const ragequitData = ZORG_RAGEQUIT_IFACE.encodeFunctionData('ragequit', [
    [ZORG_PAY_TOKEN], amountIn, 0
  ]);

  return {
    expectedOutput: zammQuote.expectedOutput,
    isZOrgSell: true, // signals two-step execution
    ragequitData,
    zammSellQuote: zammQuote, // second step quote
    multicall: zammQuote.multicall,
    calls: zammQuote.calls,
    msgValue: 0n,
    isTwoHop: true, isSplit: false, splitLegs: null,
    sourceA: "Ragequit", sourceB: zammQuote.sourceA + (zammQuote.sourceB ? " + " + zammQuote.sourceB : ""),
    allQuotes: [{ source: `Ragequit + ${zammQuote.sourceA}`, sourceId: 2, feeBps: 100n, amountIn, amountOut: zammQuote.expectedOutput }],
  };
}

async function getZOrgQuote(fromAmountStr, fromSym) {
  const fromData = tokens[fromSym];
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);
  readSlippage(true);
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 300);
  const receiver = getReceiver();
  const ethIn = fromData.address === ZERO_ADDRESS;

  return await quoteRPC.call(async (rpc) => {
    const quoter = getQuoterContract(rpc);
    const callOpts = { blockTag: "latest" };

    let ethForSwap = amountIn;
    let firstLegCalls = null;
    let firstLegSource = null;
    let msgValue = ethIn ? amountIn : 0n;

    // Non-ETH input: route tokenIn â†’ ETH first via quoter (output stays in router)
    if (!ethIn) {
      const r = await quoter.buildBestSwapViaETHMulticall(
        ZROUTER_ADDRESS, connectedAddress, false,
        fromData.address, ZERO_ADDRESS,
        amountIn, BigInt(slippageBps), deadline, 0, 0, ZERO_ADDRESS, callOpts
      );
      const isTwoHop = r.b.amountOut > 0n;
      ethForSwap = isTwoHop ? r.b.amountOut : r.a.amountOut;
      firstLegCalls = Array.from(r.calls);
      firstLegSource = AMM_NAMES[r.a.source] || "Unknown";
      msgValue = 0n;
    }

    // Quote both zAMM pools (hooked & hookless) and pick the better rate
    // zeroForOne=true â†’ reserveIn=reserve0 (ETH), reserveOut=reserve1 (ZAMM)
    const reserves = await getZammPoolReserves(rpc);
    const hookedOut = getZammAmountOut(ethForSwap, reserves.hooked.reserve0, reserves.hooked.reserve1, 100n);
    const hooklessOut = getZammAmountOut(ethForSwap, reserves.hookless.reserve0, reserves.hookless.reserve1, 100n);
    const useHookless = hooklessOut >= hookedOut;
    const zammOut = useHookless ? hooklessOut : hookedOut;
    // deadline=MaxUint256 signals router to use hookless ZAMM_0
    const zammDeadline = useHookless ? ethers.MaxUint256 : deadline;

    // Build multicall
    const slipOut = zammOut * (10000n - BigInt(slippageBps)) / 10000n;
    const calls = [];

    // If non-ETH: include first leg calls (tokenIn â†’ ETH, output stays in router via transient storage)
    if (firstLegCalls) {
      for (const c of firstLegCalls) calls.push(c);
    }

    // swapVZ: input â†’ ERC6909 token, output to zRouter
    // ETH path: tokenIn=address(0), swapAmount=0 uses msg.value
    // Non-ETH path: tokenIn=address(0), explicit swapAmount (covered by transient ETH from first leg)
    calls.push(ROUTER_IFACE.encodeFunctionData('swapVZ', [
      ZROUTER_ADDRESS, false, 100,
      ZERO_ADDRESS, ZORG_TOKEN, 0, ZORG_ID,
      ethIn ? 0 : ethForSwap, slipOut, zammDeadline
    ]));

    // execute: buyShares on the DAO.
    // swapVZ guarantees the router holds â‰¥ slipOut ZAMM. Request slipOut shares (safe minimum),
    // maxPay = zammOut (upper bound). Any excess ZAMM is swept back to user.
    calls.push(ROUTER_IFACE.encodeFunctionData('execute', [
      ZORG_DAO, 0,
      ZORG_BUYSHARES_IFACE.encodeFunctionData('buyShares', [ZORG_PAY_TOKEN, slipOut, zammOut])
    ]));

    // Sweep DAO shares (ERC20) to user
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZORG_DAO_TOKEN, 0, 0, receiver]));

    // Safety sweep: remaining ERC20 pay token back to user
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZORG_PAY_TOKEN, 0, 0, receiver]));

    // Safety sweep: remaining ETH back to user
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, receiver]));

    // Safety sweep: input token back to user (if non-ETH)
    if (!ethIn) {
      calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [fromData.address, 0, 0, receiver]));
    }

    const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);

    return {
      expectedOutput: slipOut,
      multicall,
      calls,
      msgValue,
      isTwoHop: !ethIn,
      isSplit: false,
      splitLegs: null,
      sourceA: ethIn ? (useHookless ? "zAMMâ‚€" : "zAMM") : firstLegSource,
      sourceB: ethIn ? null : (useHookless ? "zAMMâ‚€" : "zAMM"),
      allQuotes: [{ source: (useHookless ? "zAMMâ‚€" : "zAMM") + " â†’ DAO Stake", sourceId: 2, feeBps: 100n, amountIn, amountOut: slipOut }],
    };
  });
}

async function getQuote(fromAmountStr, fromSym, toSym) {
  if (!connectedAddress) throw new Error("Connect wallet to get a quote");
  const fromData = tokens[fromSym], toData = tokens[toSym];
  if (!fromData || !toData) throw new Error("Unknown token");
  if (fromData.address === toData.address) throw new Error("Same token");

  // Direct ZAMM â†’ zOrg stake (no swap needed)
  if (isDirectZOrgStake(fromSym, toSym)) {
    return getDirectZOrgStakeQuote(fromAmountStr, fromSym);
  }

  // zOrg â†’ ZAMM ragequit (burn shares, claim ZAMM)
  if (isRagequitPath(fromSym, toSym)) {
    return getRagequitQuote(fromAmountStr, fromSym);
  }

  // zOrg special path: swap + stake
  if (isZOrgSwap(toSym)) {
    return await getZOrgQuote(fromAmountStr, fromSym);
  }

  // ZAMM buy path: any token â†’ ZAMM via zAMM pool
  if (isZammBuyPath(fromSym, toSym)) {
    return await getZammBuyQuote(fromAmountStr, fromSym, toSym);
  }

  // ZAMM sell path: ZAMM â†’ any token via zAMM pool
  if (isZammSellPath(fromSym, toSym)) {
    return await getZammSellQuote(fromAmountStr, fromSym, toSym);
  }

  // zOrg sell path: ragequit (1:1 â†’ ZAMM) then sell ZAMM
  if (isZOrgSellPath(fromSym, toSym)) {
    return await getZOrgSellQuote(fromAmountStr, fromSym, toSym);
  }

  const receiver = getReceiver();
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);
  readSlippage(true);
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 300);

  return await quoteRPC.call(async (rpc) => {
    const quoter = getQuoterContract(rpc);
    const callOpts = { blockTag: "latest" };

    // Fire all calls in parallel (V4 hooked only for PNKSTR swaps)
    const isPNKSTR = fromData.address.toLowerCase() === PNKSTR_ADDRESS.toLowerCase()
      || toData.address.toLowerCase() === PNKSTR_ADDRESS.toLowerCase();
    // Split/multi-hop routes need wider per-leg slippage to avoid intermittent reverts
    // (each leg has its own amountLimit; first leg moves price affecting the second)
    const splitSlip = BigInt(Math.min(Math.max(slippageBps * 3, 150), 500));
    const hookFee = 0;
    const hookTick = isPNKSTR ? 60 : 0;
    const hookAddr = isPNKSTR ? PNKSTR_HOOK_ADDRESS : ZERO_ADDRESS;
    // Light calls (getQuotes, quoteCurve, Lido, Rocket, spot rate) â†’ single Multicall3 aggregate3
    const mc3Entries = [];
    mc3Entries.push({ target: ZQUOTER_ADDRESS, data: QUOTER_IFACE.encodeFunctionData("getQuotes", [false, fromData.address, toData.address, amountIn]) });
    mc3Entries.push({ target: ZQUOTER_ADDRESS, data: QUOTER_IFACE.encodeFunctionData("quoteCurve", [false, fromData.address, toData.address, amountIn, 8]) });
    // Spot rate: exact-in with small ref amount (piggybacks on same batch)
    const refExp = Math.max(0, fromData.decimals - 2);
    const refAmount = 10n ** BigInt(refExp);
    mc3Entries.push({ target: ZQUOTER_ADDRESS, data: QUOTER_IFACE.encodeFunctionData("getQuotes", [false, fromData.address, toData.address, refAmount]) });
    mc3Entries.push({ target: ZQUOTER_ADDRESS, data: QUOTER_IFACE.encodeFunctionData("quoteCurve", [false, fromData.address, toData.address, refAmount, 8]) });
    // Lido quote for ETH â†’ stETH / wstETH
    const isLidoEligible = fromData.address === ZERO_ADDRESS
      && (toData.address.toLowerCase() === STETH_ADDRESS.toLowerCase()
       || toData.address.toLowerCase() === WSTETH_ADDRESS.toLowerCase());
    let mc3LidoIdx = -1;
    if (isLidoEligible) {
      mc3LidoIdx = mc3Entries.length;
      mc3Entries.push({ target: ZQUOTER_ADDRESS, data: QUOTER_IFACE.encodeFunctionData("quoteLido", [false, toData.address, amountIn]) });
    }
    // Rocket Pool quote for ETH â†’ rETH
    const isRocketEligible = fromData.address === ZERO_ADDRESS
      && toData.address.toLowerCase() === RETH_ADDRESS.toLowerCase();
    let mc3RethIdx = -1, mc3RocketMaxIdx = -1, mc3SpotRocketIdx = -1;
    if (isRocketEligible) {
      mc3RethIdx = mc3Entries.length;
      mc3Entries.push({ target: RETH_ADDRESS, data: RETH_RATE_IFACE.encodeFunctionData("getRethValue", [amountIn]) });
      mc3RocketMaxIdx = mc3Entries.length;
      mc3Entries.push({ target: ROCKET_DEPOSIT_POOL, data: ROCKET_DEPOSIT_IFACE.encodeFunctionData("getMaximumDepositAmount", []) });
      mc3SpotRocketIdx = mc3Entries.length;
      mc3Entries.push({ target: RETH_ADDRESS, data: RETH_RATE_IFACE.encodeFunctionData("getRethValue", [refAmount]) });
    }
    // Heavy calls (complex return types + high gas) stay as separate eth_calls
    const allCalls = [
      quoter.buildBestSwapViaETHMulticall(
        receiver, connectedAddress, false,
        fromData.address, toData.address,
        amountIn, BigInt(slippageBps), deadline,
        hookFee, hookTick, hookAddr, callOpts
      ),
      quoter.buildSplitSwap(
        receiver, fromData.address, toData.address,
        amountIn, splitSlip, deadline, callOpts
      ),
      quoter.build3HopMulticall(
        receiver, fromData.address, toData.address,
        amountIn, splitSlip, deadline, callOpts
      ),
      quoter.buildHybridSplit(
        receiver, fromData.address, toData.address,
        amountIn, splitSlip, deadline, callOpts
      ),
      mc3ViewBatch(rpc, mc3Entries),
    ];
    if (isPNKSTR) {
      allCalls.push(quoter.buildSplitSwapHooked(
        receiver, fromData.address, toData.address,
        amountIn, splitSlip, deadline,
        0, 60, PNKSTR_HOOK_ADDRESS, callOpts
      ));
    }
    const settled = await Promise.allSettled(allCalls);
    const [bestResult, splitResult, threeHopResult, hybridSplitResult, mc3Result] = settled;
    const v4SplitResult = isPNKSTR ? settled[5] : undefined;
    // Decode Multicall3 batch into settled-style objects (post-processing code unchanged)
    const mc3 = mc3Result.status === 'fulfilled' ? mc3Result.value : null;
    const quotesResult = mc3AsSettled(mc3, 0, QUOTER_IFACE, "getQuotes");
    const curveResult = mc3AsSettled(mc3, 1, QUOTER_IFACE, "quoteCurve");
    const lidoQuoteResult = mc3LidoIdx >= 0 ? mc3AsSettled(mc3, mc3LidoIdx, QUOTER_IFACE, "quoteLido") : undefined;
    let rocketQuoteResult;
    if (isRocketEligible) {
      const rethDec = mc3Decode(mc3, mc3RethIdx, RETH_RATE_IFACE, "getRethValue");
      const maxDec = mc3Decode(mc3, mc3RocketMaxIdx, ROCKET_DEPOSIT_IFACE, "getMaximumDepositAmount");
      if (rethDec && maxDec) {
        const rethOut = rethDec[0], maxDeposit = maxDec[0];
        rocketQuoteResult = (amountIn <= maxDeposit && rethOut > 0n)
          ? { status: 'fulfilled', value: { amountIn, amountOut: rethOut } }
          : { status: 'fulfilled', value: { amountIn: 0n, amountOut: 0n } };
      }
    }
    // Spot rate pre-cached from mc3 batch (eliminates second RPC round trip)
    {
      let bestSpotOut = 0n, bestSpotIn = 0n;
      const sq = mc3Decode(mc3, 2, QUOTER_IFACE, "getQuotes");
      if (sq && sq.best.amountOut > bestSpotOut) { bestSpotOut = sq.best.amountOut; bestSpotIn = sq.best.amountIn; }
      const sc = mc3Decode(mc3, 3, QUOTER_IFACE, "quoteCurve");
      if (sc && sc.amountOut > bestSpotOut) { bestSpotOut = sc.amountOut; bestSpotIn = sc.amountIn; }
      if (mc3SpotRocketIdx >= 0) {
        const sr = mc3Decode(mc3, mc3SpotRocketIdx, RETH_RATE_IFACE, "getRethValue");
        if (sr && sr[0] > bestSpotOut) { bestSpotOut = sr[0]; bestSpotIn = refAmount; }
      }
      if (bestSpotOut > 0n && bestSpotIn > 0n) {
        const key = _spotKey(fromData.address, toData.address);
        if (_spotCache.size >= _spotMaxSize) _spotCache.delete(_spotCache.keys().next().value);
        _spotCache.set(key, { rate: { num: bestSpotOut, den: bestSpotIn }, t: Date.now() });
      }
    }

    // bestResult is required
    if (bestResult.status === 'rejected') throw bestResult.reason;
    const r = bestResult.value;

    const isTwoHop = r.b.amountOut > 0n;
    const bestOutput = isTwoHop ? r.b.amountOut : r.a.amountOut;

    let result = {
      expectedOutput: bestOutput,
      multicall: r.multicall,
      calls: r.calls,
      msgValue: r.msgValue ?? 0n,
      isTwoHop,
      isSplit: false,
      splitLegs: null,
      sourceA: AMM_NAMES[r.a.source] || "Unknown",
      sourceB: isTwoHop ? (AMM_NAMES[r.b.source] || "Unknown") : null,
      allQuotes: null,
    };

    // Check if split beats best
    if (splitResult.status === 'fulfilled') {
      const s = splitResult.value;
      const splitTotal = s.legs[0].amountOut + s.legs[1].amountOut;
      if (splitTotal > bestOutput && s.legs[0].amountOut > 0n && s.legs[1].amountOut > 0n) {
        result.expectedOutput = splitTotal;
        result.multicall = s.multicall;
        result.msgValue = s.msgValue ?? 0n;
        result.isSplit = true;
        result.isTwoHop = false;
        result.splitLegs = [
          { source: AMM_NAMES[s.legs[0].source] || "Unknown", amountIn: s.legs[0].amountIn, amountOut: s.legs[0].amountOut, feeBps: s.legs[0].feeBps },
          { source: AMM_NAMES[s.legs[1].source] || "Unknown", amountIn: s.legs[1].amountIn, amountOut: s.legs[1].amountOut, feeBps: s.legs[1].feeBps },
        ];
        // calls not returned by buildSplitSwap; multicall is directly usable
        result.calls = null;
      }
    }

    // Attach all-quotes for display
    if (quotesResult.status === 'fulfilled') {
      const q = quotesResult.value;
      result.allQuotes = q.quotes.map(qt => ({
        source: AMM_NAMES[qt.source] || `AMM #${qt.source}`,
        sourceId: Number(qt.source),
        feeBps: qt.feeBps,
        amountIn: qt.amountIn,
        amountOut: qt.amountOut,
      })).filter(qt => qt.amountOut > 0n);
      // Merge Curve quote if available
      if (curveResult.status === 'fulfilled') {
        const c = curveResult.value;
        if (c.amountOut > 0n) {
          result.allQuotes.push({ source: "Curve", sourceId: 5, feeBps: 0n, amountIn: c.amountIn, amountOut: c.amountOut });
        }
      }
      // Merge Lido quote if available
      if (lidoQuoteResult?.status === 'fulfilled') {
        const l = lidoQuoteResult.value;
        if (l.amountOut > 0n) {
          result.allQuotes.push({ source: "Lido", sourceId: 6, feeBps: 0n, amountIn: l.amountIn, amountOut: l.amountOut });
        }
      }
      // Merge Rocket Pool quote if available
      if (rocketQuoteResult?.status === 'fulfilled') {
        const rp = rocketQuoteResult.value;
        if (rp.amountOut > 0n) {
          result.allQuotes.push({ source: "Rocket Pool", sourceId: -1, feeBps: 0n, amountIn: rp.amountIn, amountOut: rp.amountOut });
        }
      }
    }

    // Check if 3-hop beats current best
    if (threeHopResult?.status === 'fulfilled' && threeHopResult.value) {
      const h3 = threeHopResult.value;
      const h3Output = h3.c.amountOut;
      if (h3Output > result.expectedOutput && h3Output > 0n) {
        result.expectedOutput = h3Output;
        result.multicall = h3.multicall;
        result.calls = h3.calls;
        result.msgValue = h3.msgValue ?? 0n;
        result.isTwoHop = true;
        result.isSplit = false;
        result.splitLegs = null;
        result.sourceA = `${AMM_NAMES[h3.a.source] || "?"} â†’ ${AMM_NAMES[h3.b.source] || "?"}`;
        result.sourceB = AMM_NAMES[h3.c.source] || "?";
      }
    }

    // Check if hybrid split (single-hop + 2-hop) beats current best
    if (hybridSplitResult?.status === 'fulfilled' && hybridSplitResult.value) {
      const hs = hybridSplitResult.value;
      const hsTotal = hs.legs[0].amountOut + hs.legs[1].amountOut;
      const isTrueSplit = hs.legs[0].amountOut > 0n && hs.legs[1].amountOut > 0n;
      if (hsTotal > result.expectedOutput && hsTotal > 0n) {
        result.expectedOutput = hsTotal;
        result.multicall = hs.multicall;
        result.msgValue = hs.msgValue ?? 0n;
        result.calls = null;
        if (isTrueSplit) {
          result.isSplit = true;
          result.isTwoHop = false;
          result.splitLegs = [
            { source: AMM_NAMES[hs.legs[0].source] || "Unknown", amountIn: hs.legs[0].amountIn, amountOut: hs.legs[0].amountOut, feeBps: hs.legs[0].feeBps },
            { source: (AMM_NAMES[hs.legs[1].source] || "Unknown") + " (via hub)", amountIn: hs.legs[1].amountIn, amountOut: hs.legs[1].amountOut, feeBps: hs.legs[1].feeBps },
          ];
          result.sourceA = AMM_NAMES[hs.legs[0].source] || "Unknown";
          result.sourceB = null;
        } else {
          // Single strategy won (100% direct or 100% 2-hop)
          const activeLeg = hs.legs[0].amountOut > 0n ? hs.legs[0] : hs.legs[1];
          result.isSplit = false;
          result.isTwoHop = hs.legs[1].amountOut > 0n;
          result.sourceA = AMM_NAMES[activeLeg.source] || "Unknown";
          result.sourceB = null;
          result.splitLegs = null;
        }
      }
    }

    // Check if V4 hooked split/single (contract-built calldata) beats current best
    if (v4SplitResult?.status === 'fulfilled' && v4SplitResult.value) {
      const hs = v4SplitResult.value;
      const hsTotal = hs.legs[0].amountOut + hs.legs[1].amountOut;
      const isTrueSplit = hs.legs[0].amountOut > 0n && hs.legs[1].amountOut > 0n;
      const activeLeg = hs.legs[0].amountOut > 0n ? hs.legs[0] : hs.legs[1];

      // Add V4 hooked split option to allQuotes if a hooked leg exists
      if (result.allQuotes && isTrueSplit && hsTotal > 0n) {
        const hookedLeg = Number(hs.legs[0].source) === 8 ? hs.legs[0] : (Number(hs.legs[1].source) === 8 ? hs.legs[1] : null);
        if (hookedLeg) {
          result.allQuotes.push({ source: "V4 Hooked (split)", sourceId: 8, feeBps: hookedLeg.feeBps, amountIn, amountOut: hsTotal });
        }
      }

      if (hsTotal > result.expectedOutput && hsTotal > 0n) {
        result.expectedOutput = hsTotal;
        result.multicall = hs.multicall;
        result.msgValue = hs.msgValue ?? 0n;
        result.calls = null;
        if (isTrueSplit) {
          result.isSplit = true;
          result.isTwoHop = false;
          result.sourceA = AMM_NAMES[hs.legs[0].source] || "Unknown";
          result.sourceB = null;
          result.splitLegs = [
            { source: AMM_NAMES[hs.legs[0].source] || "Unknown", amountIn: hs.legs[0].amountIn, amountOut: hs.legs[0].amountOut, feeBps: hs.legs[0].feeBps },
            { source: AMM_NAMES[hs.legs[1].source] || "Unknown", amountIn: hs.legs[1].amountIn, amountOut: hs.legs[1].amountOut, feeBps: hs.legs[1].feeBps },
          ];
        } else {
          result.isSplit = false;
          result.isTwoHop = false;
          result.sourceA = AMM_NAMES[activeLeg.source] || "V4 Hooked";
          result.sourceB = null;
          result.splitLegs = null;
        }
      }
    }

    // Use Lido for ETHâ†’stETH/wstETH only when it gives the best rate
    if (isLidoEligible && lidoQuoteResult?.status === 'fulfilled') {
      const l = lidoQuoteResult.value;
      if (l.amountOut > 0n) {
        if (l.amountOut >= result.expectedOutput) {
          const isStETH = toData.address.toLowerCase() === STETH_ADDRESS.toLowerCase();
          const lidoCall = isStETH
            ? ROUTER_IFACE.encodeFunctionData('exactETHToSTETH', [receiver])
            : ROUTER_IFACE.encodeFunctionData('exactETHToWSTETH', [receiver]);
          const sweepEth = ROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, receiver]);
          const calls = [lidoCall, sweepEth];
          const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);
          result.expectedOutput = l.amountOut;
          result.multicall = multicall;
          result.calls = calls;
          result.msgValue = amountIn;
          result.isTwoHop = false;
          result.isSplit = false;
          result.splitLegs = null;
          result.sourceA = "Lido";
          result.sourceB = null;
        }
      }
    }

    // Use Rocket Pool for ETHâ†’rETH when direct deposit beats DEX rates
    if (isRocketEligible && rocketQuoteResult?.status === 'fulfilled') {
      const rp = rocketQuoteResult.value;
      if (rp.amountOut > 0n && rp.amountOut >= result.expectedOutput) {
        // Build: execute(depositPool.deposit{value: amountIn}) â†’ sweep(rETH, to)
        const depositCalldata = "0xd0e30db0"; // deposit() selector
        const executeCall = ROUTER_IFACE.encodeFunctionData('execute', [ROCKET_DEPOSIT_POOL, amountIn, depositCalldata]);
        const sweepReth = ROUTER_IFACE.encodeFunctionData('sweep', [RETH_ADDRESS, 0, 0, receiver]);
        const calls = [executeCall, sweepReth];
        const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);
        result.expectedOutput = rp.amountOut;
        result.multicall = multicall;
        result.calls = calls;
        result.msgValue = amountIn;
        result.isTwoHop = false;
        result.isSplit = false;
        result.splitLegs = null;
        result.sourceA = "Rocket Pool";
        result.sourceB = null;
      }
    }

    // Curve native-ETH pools: router's swapCurve wraps to WETH but legacy pools
    // need msg.value. Detect and rebuild via execute+sweep, also promote Curve
    // when it beats the current best (like Lido/Rocket Pool overrides).
    if (fromData.address === ZERO_ADDRESS && curveResult?.status === 'fulfilled') {
      const c = curveResult.value;
      if (c.bestPool !== ZERO_ADDRESS && c.amountOut > 0n && !c.usedUnderlying) {
        const curveIsWinner = result.sourceA === "Curve" && !result.isSplit && !result.isTwoHop;
        const curveBeatsBest = c.amountOut > result.expectedOutput;
        if (curveIsWinner || curveBeatsBest) {
          try {
            const poolContract = new ethers.Contract(c.bestPool, ["function coins(uint256) view returns (address)"], rpc);
            const inputCoin = await poolContract.coins(c.iIndex, callOpts);
            if (inputCoin.toLowerCase() === "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee") {
              const exchangeIface = c.usedStable
                ? new ethers.Interface(["function exchange(int128,int128,uint256,uint256) payable"])
                : new ethers.Interface(["function exchange(uint256,uint256,uint256,uint256) payable"]);
              const minOut = c.amountOut * (10000n - BigInt(slippageBps)) / 10000n;
              const exchangeData = exchangeIface.encodeFunctionData('exchange', [c.iIndex, c.jIndex, amountIn, minOut]);
              const executeCall = ROUTER_IFACE.encodeFunctionData('execute', [c.bestPool, amountIn, exchangeData]);
              const sweepOut = ROUTER_IFACE.encodeFunctionData('sweep', [toData.address, 0, 0, receiver]);
              const calls = [executeCall, sweepOut];
              const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);
              result.expectedOutput = c.amountOut;
              result.multicall = multicall;
              result.calls = calls;
              result.msgValue = amountIn;
              result.isTwoHop = false;
              result.isSplit = false;
              result.splitLegs = null;
              result.sourceA = "Curve";
              result.sourceB = null;
            }
          } catch (_) {}
        }
      }
    }

    return result;
  });
}

// ---- Exact-out quoting ----
async function getExactOutQuote(outputAmountStr, fromSym, toSym) {
  if (!connectedAddress) throw new Error("Connect wallet to get a quote");
  const fromData = tokens[fromSym], toData = tokens[toSym];
  if (!fromData || !toData) throw new Error("Unknown token");
  if (fromData.address === toData.address) throw new Error("Same token");

  const receiver = getReceiver();
  const amountOut = safeParseUnits(outputAmountStr, toData.decimals);
  readSlippage(true);
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 300);

  return await quoteRPC.call(async (rpc) => {
    const quoter = getQuoterContract(rpc);
    const callOpts = { blockTag: "latest" };

    const isPNKSTR = fromData.address.toLowerCase() === PNKSTR_ADDRESS.toLowerCase()
      || toData.address.toLowerCase() === PNKSTR_ADDRESS.toLowerCase();
    const hookFee = 0;
    const hookTick = isPNKSTR ? 60 : 0;
    const hookAddr = isPNKSTR ? PNKSTR_HOOK_ADDRESS : ZERO_ADDRESS;
    // Light calls â†’ single Multicall3 aggregate3 (1 eth_call)
    const mc3Entries = [];
    mc3Entries.push({ target: ZQUOTER_ADDRESS, data: QUOTER_IFACE.encodeFunctionData("getQuotes", [true, fromData.address, toData.address, amountOut]) });
    mc3Entries.push({ target: ZQUOTER_ADDRESS, data: QUOTER_IFACE.encodeFunctionData("quoteCurve", [true, fromData.address, toData.address, amountOut, 8]) });
    // Spot rate: exact-in with small ref amount (piggybacks on same batch)
    const refExp = Math.max(0, fromData.decimals - 2);
    const refAmount = 10n ** BigInt(refExp);
    mc3Entries.push({ target: ZQUOTER_ADDRESS, data: QUOTER_IFACE.encodeFunctionData("getQuotes", [false, fromData.address, toData.address, refAmount]) });
    mc3Entries.push({ target: ZQUOTER_ADDRESS, data: QUOTER_IFACE.encodeFunctionData("quoteCurve", [false, fromData.address, toData.address, refAmount, 8]) });
    // Lido exact-out for ETH â†’ stETH/wstETH
    const isLidoEligible = fromData.address === ZERO_ADDRESS
      && (toData.address.toLowerCase() === STETH_ADDRESS.toLowerCase()
       || toData.address.toLowerCase() === WSTETH_ADDRESS.toLowerCase());
    let mc3LidoIdx = -1;
    if (isLidoEligible) {
      mc3LidoIdx = mc3Entries.length;
      mc3Entries.push({ target: ZQUOTER_ADDRESS, data: QUOTER_IFACE.encodeFunctionData("quoteLido", [true, toData.address, amountOut]) });
    }
    // Rocket Pool exact-out for ETH â†’ rETH
    const isRocketEligible = fromData.address === ZERO_ADDRESS
      && toData.address.toLowerCase() === RETH_ADDRESS.toLowerCase();
    let mc3RethIdx = -1, mc3RocketMaxIdx = -1, mc3SpotRocketIdx = -1;
    if (isRocketEligible) {
      mc3RethIdx = mc3Entries.length;
      mc3Entries.push({ target: RETH_ADDRESS, data: RETH_RATE_IFACE.encodeFunctionData("getEthValue", [amountOut]) });
      mc3RocketMaxIdx = mc3Entries.length;
      mc3Entries.push({ target: ROCKET_DEPOSIT_POOL, data: ROCKET_DEPOSIT_IFACE.encodeFunctionData("getMaximumDepositAmount", []) });
      mc3SpotRocketIdx = mc3Entries.length;
      mc3Entries.push({ target: RETH_ADDRESS, data: RETH_RATE_IFACE.encodeFunctionData("getRethValue", [refAmount]) });
    }
    const allCalls = [
      quoter.buildBestSwapViaETHMulticall(
        receiver, connectedAddress, true,
        fromData.address, toData.address,
        amountOut, BigInt(slippageBps), deadline,
        hookFee, hookTick, hookAddr, callOpts
      ),
      mc3ViewBatch(rpc, mc3Entries),
    ];
    const settled = await Promise.allSettled(allCalls);
    const [bestResult, mc3Result] = settled;
    // Decode Multicall3 batch
    const mc3 = mc3Result.status === 'fulfilled' ? mc3Result.value : null;
    const quotesResult = mc3AsSettled(mc3, 0, QUOTER_IFACE, "getQuotes");
    const curveResult = mc3AsSettled(mc3, 1, QUOTER_IFACE, "quoteCurve");
    const lidoQuoteResult = mc3LidoIdx >= 0 ? mc3AsSettled(mc3, mc3LidoIdx, QUOTER_IFACE, "quoteLido") : undefined;
    let rocketQuoteResult;
    if (isRocketEligible) {
      const rethDec = mc3Decode(mc3, mc3RethIdx, RETH_RATE_IFACE, "getEthValue");
      const maxDec = mc3Decode(mc3, mc3RocketMaxIdx, ROCKET_DEPOSIT_IFACE, "getMaximumDepositAmount");
      if (rethDec && maxDec) {
        const ethNeeded = rethDec[0], maxDeposit = maxDec[0];
        rocketQuoteResult = (ethNeeded <= maxDeposit && ethNeeded > 0n)
          ? { status: 'fulfilled', value: { amountIn: ethNeeded, amountOut } }
          : { status: 'fulfilled', value: { amountIn: 0n, amountOut: 0n } };
      }
    }
    // Spot rate pre-cached from mc3 batch
    {
      let bestSpotOut = 0n, bestSpotIn = 0n;
      const sq = mc3Decode(mc3, 2, QUOTER_IFACE, "getQuotes");
      if (sq && sq.best.amountOut > bestSpotOut) { bestSpotOut = sq.best.amountOut; bestSpotIn = sq.best.amountIn; }
      const sc = mc3Decode(mc3, 3, QUOTER_IFACE, "quoteCurve");
      if (sc && sc.amountOut > bestSpotOut) { bestSpotOut = sc.amountOut; bestSpotIn = sc.amountIn; }
      if (mc3SpotRocketIdx >= 0) {
        const sr = mc3Decode(mc3, mc3SpotRocketIdx, RETH_RATE_IFACE, "getRethValue");
        if (sr && sr[0] > bestSpotOut) { bestSpotOut = sr[0]; bestSpotIn = refAmount; }
      }
      if (bestSpotOut > 0n && bestSpotIn > 0n) {
        const key = _spotKey(fromData.address, toData.address);
        if (_spotCache.size >= _spotMaxSize) _spotCache.delete(_spotCache.keys().next().value);
        _spotCache.set(key, { rate: { num: bestSpotOut, den: bestSpotIn }, t: Date.now() });
      }
    }

    if (bestResult.status === 'rejected') throw bestResult.reason;
    const r = bestResult.value;

    const isTwoHop = r.b.amountOut > 0n;
    const requiredInput = r.a.amountIn;

    let result = {
      expectedOutput: isTwoHop ? r.b.amountOut : r.a.amountOut,
      requiredInput,
      multicall: r.multicall,
      calls: r.calls,
      msgValue: r.msgValue ?? 0n,
      isTwoHop,
      isSplit: false,
      splitLegs: null,
      sourceA: AMM_NAMES[r.a.source] || "Unknown",
      sourceB: isTwoHop ? (AMM_NAMES[r.b.source] || "Unknown") : null,
      allQuotes: null,
      exactOut: true,
    };

    // Attach all-quotes for display
    if (quotesResult.status === 'fulfilled') {
      const q = quotesResult.value;
      result.allQuotes = q.quotes.map(qt => ({
        source: AMM_NAMES[qt.source] || `AMM #${qt.source}`,
        sourceId: Number(qt.source),
        feeBps: qt.feeBps,
        amountIn: qt.amountIn,
        amountOut: qt.amountOut,
      })).filter(qt => qt.amountIn > 0n);
      if (curveResult.status === 'fulfilled') {
        const c = curveResult.value;
        if (c.amountIn > 0n) {
          result.allQuotes.push({ source: "Curve", sourceId: 5, feeBps: 0n, amountIn: c.amountIn, amountOut: c.amountOut });
        }
      }
      if (lidoQuoteResult?.status === 'fulfilled') {
        const l = lidoQuoteResult.value;
        if (l.amountIn > 0n) {
          result.allQuotes.push({ source: "Lido", sourceId: 6, feeBps: 0n, amountIn: l.amountIn, amountOut: l.amountOut });
        }
      }
      if (rocketQuoteResult?.status === 'fulfilled') {
        const rp = rocketQuoteResult.value;
        if (rp.amountIn > 0n) {
          result.allQuotes.push({ source: "Rocket Pool", sourceId: -1, feeBps: 0n, amountIn: rp.amountIn, amountOut: rp.amountOut });
        }
      }
    }

    // Use Lido for ETHâ†’stETH/wstETH if it needs less input
    if (isLidoEligible && lidoQuoteResult?.status === 'fulfilled') {
      const l = lidoQuoteResult.value;
      if (l.amountIn > 0n && l.amountIn <= result.requiredInput) {
        const isStETH = toData.address.toLowerCase() === STETH_ADDRESS.toLowerCase();
        const lidoCall = isStETH
          ? ROUTER_IFACE.encodeFunctionData('exactETHToSTETH', [receiver])
          : ROUTER_IFACE.encodeFunctionData('exactETHToWSTETH', [receiver]);
        const sweepEth = ROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, receiver]);
        const calls = [lidoCall, sweepEth];
        const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);
        result.requiredInput = l.amountIn;
        result.expectedOutput = l.amountOut;
        result.multicall = multicall;
        result.calls = calls;
        result.msgValue = l.amountIn;
        result.isTwoHop = false;
        result.isSplit = false;
        result.splitLegs = null;
        result.sourceA = "Lido";
        result.sourceB = null;
      }
    }

    // Use Rocket Pool for ETHâ†’rETH if it needs less input
    if (isRocketEligible && rocketQuoteResult?.status === 'fulfilled') {
      const rp = rocketQuoteResult.value;
      if (rp.amountIn > 0n && rp.amountIn <= result.requiredInput) {
        const depositCalldata = "0xd0e30db0";
        const executeCall = ROUTER_IFACE.encodeFunctionData('execute', [ROCKET_DEPOSIT_POOL, rp.amountIn, depositCalldata]);
        const sweepReth = ROUTER_IFACE.encodeFunctionData('sweep', [RETH_ADDRESS, 0, 0, receiver]);
        const calls = [executeCall, sweepReth];
        const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);
        result.requiredInput = rp.amountIn;
        result.expectedOutput = rp.amountOut;
        result.multicall = multicall;
        result.calls = calls;
        result.msgValue = rp.amountIn;
        result.isTwoHop = false;
        result.isSplit = false;
        result.splitLegs = null;
        result.sourceA = "Rocket Pool";
        result.sourceB = null;
      }
    }

    // Curve native-ETH pools: router's swapCurve wraps to WETH but legacy pools
    // need msg.value. Detect and rebuild via execute+sweep, also promote Curve
    // when it needs less input than the current best.
    if (fromData.address === ZERO_ADDRESS && curveResult?.status === 'fulfilled') {
      const c = curveResult.value;
      if (c.bestPool !== ZERO_ADDRESS && c.amountIn > 0n && !c.usedUnderlying) {
        const curveIsWinner = result.sourceA === "Curve" && !result.isSplit && !result.isTwoHop;
        const curveBeatsBest = c.amountIn < result.requiredInput;
        if (curveIsWinner || curveBeatsBest) {
          try {
            const poolContract = new ethers.Contract(c.bestPool, ["function coins(uint256) view returns (address)"], rpc);
            const inputCoin = await poolContract.coins(c.iIndex, callOpts);
            if (inputCoin.toLowerCase() === "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee") {
              const exchangeIface = c.usedStable
                ? new ethers.Interface(["function exchange(int128,int128,uint256,uint256) payable"])
                : new ethers.Interface(["function exchange(uint256,uint256,uint256,uint256) payable"]);
              // For exact-out: swap c.amountIn input, require at least amountOut output
              const exchangeData = exchangeIface.encodeFunctionData('exchange', [c.iIndex, c.jIndex, c.amountIn, amountOut]);
              const executeCall = ROUTER_IFACE.encodeFunctionData('execute', [c.bestPool, c.amountIn, exchangeData]);
              const sweepOut = ROUTER_IFACE.encodeFunctionData('sweep', [toData.address, 0, 0, receiver]);
              const calls = [executeCall, sweepOut];
              const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);
              result.requiredInput = c.amountIn;
              result.expectedOutput = c.amountOut;
              result.multicall = multicall;
              result.calls = calls;
              result.msgValue = c.amountIn;
              result.isTwoHop = false;
              result.isSplit = false;
              result.splitLegs = null;
              result.sourceA = "Curve";
              result.sourceB = null;
            }
          } catch (_) {}
        }
      }
    }

    return result;
  });
}

// ---- Split route formatting ----
function formatSplitRoute(legs) {
  if (!legs || legs.length < 2) return "Split";
  const total = legs[0].amountIn + legs[1].amountIn;
  if (total === 0n) return `${legs[0].source} + ${legs[1].source}`;
  const pct0 = Number(legs[0].amountIn * 100n / total);
  const pct1 = 100 - pct0;
  return `${pct0}% ${legs[0].source} + ${pct1}% ${legs[1].source}`;
}

// ---- All-routes toggle ----
function toggleAllRoutes() {
  const list = $('allRoutesList');
  const chev = $('routesChevron');
  const open = list.style.display !== 'none';
  list.style.display = open ? 'none' : 'block';
  chev.innerHTML = open ? '&#9654;' : '&#9660;';
}

function displayAllRoutes(quote, toSym, isExactOut = false, fromSym = null) {
  const wrap = $('allRoutesWrap');
  const list = $('allRoutesList');
  if (!quote.allQuotes || quote.allQuotes.length === 0) {
    setShown(wrap, false);
    return;
  }
  if (isExactOut && fromSym) {
    // Exact-out: show required input per source (lower = better)
    const fromData = tokens[fromSym];
    const sorted = [...quote.allQuotes].sort((a, b) => (a.amountIn < b.amountIn ? -1 : a.amountIn > b.amountIn ? 1 : 0));
    const bestAmt = sorted[0].amountIn;
    list.innerHTML = sorted.map(q => {
      const inp = fmt(ethers.formatUnits(q.amountIn, fromData.decimals));
      const badge = q.amountIn === bestAmt ? '<span class="best-badge">best</span>' : '';
      const fee = Number(q.feeBps);
      const feeLabel = fee > 0 ? ` (${fee >= 100 ? (fee / 100) + '%' : fee + 'bp'})` : '';
      return `<div class="routes-list-item"><span>${escText(q.source)}${escText(feeLabel)}</span><span>${inp} ${escText(fromData.symbol)}${badge}</span></div>`;
    }).join('');
  } else {
    const toData = tokens[toSym];
    const sorted = [...quote.allQuotes].sort((a, b) => (b.amountOut > a.amountOut ? 1 : b.amountOut < a.amountOut ? -1 : 0));
    const bestAmt = sorted[0].amountOut;
    list.innerHTML = sorted.map(q => {
      const out = fmt(ethers.formatUnits(q.amountOut, toData.decimals));
      const badge = q.amountOut === bestAmt ? '<span class="best-badge">best</span>' : '';
      const fee = Number(q.feeBps);
      const feeLabel = fee > 0 ? ` (${fee >= 100 ? (fee / 100) + '%' : fee + 'bp'})` : '';
      return `<div class="routes-list-item"><span>${escText(q.source)}${escText(feeLabel)}</span><span>${out} ${escText(toData.symbol)}${badge}</span></div>`;
    }).join('');
  }
  setShown(wrap, true);
}

// ---- Price impact via spot rate ----
const _spotCache = new Map();
const _spotTTL = 60_000;
const _spotMaxSize = 50;

function _spotKey(tokenIn, tokenOut) {
  return `${tokenIn.toLowerCase()}:${tokenOut.toLowerCase()}`;
}

async function getSpotRate(fromSym, toSym) {
  const fromData = tokens[fromSym], toData = tokens[toSym];
  const key = _spotKey(fromData.address, toData.address);
  const cached = _spotCache.get(key);
  if (cached && Date.now() - cached.t < _spotTTL) return cached.rate;

  // zAMM/zOrg special paths: use reserve math (quoter doesn't know these tokens)
  const isFromZamm = fromData._isZammStake || fromData._isZOrg;
  const isToZamm = toData._isZammStake || toData._isZOrg;
  if (isFromZamm || isToZamm) {
    try {
      const spotRate = await quoteRPC.call(async (rpc) => {
        const reserves = await getZammPoolReserves(rpc);
        // Pick best pool
        const h = reserves.hooked, hl = reserves.hookless;
        // Use the pool with more liquidity (higher product)
        const useHookless = hl.reserve0 * hl.reserve1 >= h.reserve0 * h.reserve1;
        const r0 = useHookless ? hl.reserve0 : h.reserve0; // ETH
        const r1 = useHookless ? hl.reserve1 : h.reserve1; // ZAMM/ERC6909
        if (r0 === 0n || r1 === 0n) return null;
        // zOrg â†” ZAMM is 1:1, so zOrg rate = ZAMM rate
        // ZAMM/zOrg â†’ ETH: num=r0 (ETH per unit), den=r1
        // ETH â†’ ZAMM/zOrg: num=r1, den=r0
        if (isFromZamm && !isToZamm) {
          // Selling ZAMM/zOrg â†’ ETH (or via ETH to target)
          if (toData.address === ZERO_ADDRESS) return { num: r0, den: r1 };
          // For non-ETH target, rate = (r0/r1) * ethToTargetRate â€” fall through to generic
          return null;
        }
        if (isToZamm && !isFromZamm) {
          // Buying ZAMM/zOrg: ETH â†’ ZAMM
          if (fromData.address === ZERO_ADDRESS) return { num: r1, den: r0 };
          return null;
        }
        // Both are ZAMM/zOrg: 1:1
        return { num: 1n, den: 1n };
      });
      if (spotRate != null) {
        if (_spotCache.size >= _spotMaxSize) {
          const oldest = _spotCache.keys().next().value;
          _spotCache.delete(oldest);
        }
        _spotCache.set(key, { rate: spotRate, t: Date.now() });
        return spotRate;
      }
    } catch (e) {
      console.warn("zAMM spot rate failed:", e);
    }
  }

  // Use a small reference amount: 10^(decimals-2) or at least 1 unit
  const refExp = Math.max(0, fromData.decimals - 2);
  const refAmount = 10n ** BigInt(refExp);

  try {
    const spotRate = await quoteRPC.call(async (rpc) => {
      const quoter = getQuoterContract(rpc);
      const callOpts = { blockTag: "latest" };
      const spotCalls = [
        quoter.getQuotes(false, fromData.address, toData.address, refAmount, callOpts),
        quoter.quoteCurve(false, fromData.address, toData.address, refAmount, 8, callOpts),
      ];
      // Rocket Pool spot rate for ETHâ†’rETH
      const isRocketSpot = fromData.address === ZERO_ADDRESS
        && toData.address.toLowerCase() === RETH_ADDRESS.toLowerCase();
      if (isRocketSpot) {
        spotCalls.push((async () => {
          const reth = new ethers.Contract(RETH_ADDRESS, RETH_RATE_ABI, rpc);
          const rethOut = await reth.getRethValue(refAmount);
          return { amountIn: refAmount, amountOut: rethOut };
        })());
      }
      const [baseResult, curveResult, rocketSpotResult] = await Promise.allSettled(spotCalls);
      let bestOut = 0n, bestIn = 0n;
      if (baseResult.status === 'fulfilled') {
        const q = baseResult.value;
        if (q.best.amountOut > bestOut) { bestOut = q.best.amountOut; bestIn = q.best.amountIn; }
      }
      if (curveResult.status === 'fulfilled') {
        const c = curveResult.value;
        if (c.amountOut > bestOut) { bestOut = c.amountOut; bestIn = c.amountIn; }
      }
      if (rocketSpotResult?.status === 'fulfilled') {
        const rp = rocketSpotResult.value;
        if (rp.amountOut > bestOut) { bestOut = rp.amountOut; bestIn = rp.amountIn; }
      }
      if (bestOut === 0n || bestIn === 0n) return null;
      // Store raw BigInts to avoid precision loss in Number conversion
      return { num: bestOut, den: bestIn };
    });
    if (spotRate != null) {
      if (_spotCache.size >= _spotMaxSize) {
        const oldest = _spotCache.keys().next().value;
        _spotCache.delete(oldest);
      }
      _spotCache.set(key, { rate: spotRate, t: Date.now() });
    }
    return spotRate;
  } catch (e) {
    console.warn("Spot rate fetch failed:", e);
    return null;
  }
}

async function displayPriceImpact(amtStr, fromSym, toSym, quote) {
  const el = $('impactInfo');
  if (!el) return;
  const seq = _quoteSeq; // capture to detect staleness after await
  try {
    const fromData = tokens[fromSym], toData = tokens[toSym];
    const amountIn = safeParseUnits(amtStr, fromData.decimals);
    if (amountIn === 0n) { el.textContent = '--'; el.className = ''; return; }

    const spotRate = await getSpotRate(fromSym, toSym);
    if (seq !== _quoteSeq) return; // stale â€” newer quote already in flight
    if (spotRate == null || spotRate.den === 0n) {
      el.textContent = '--';
      el.className = '';
      return;
    }

    // impact = (1 - execRate/spotRate) * 100
    // execRate = expectedOutput / amountIn, spotRate = num / den
    // impact = (1 - (expectedOutput * den) / (amountIn * num)) * 100
    const SCALE = 10n ** 18n;
    const ratio = (quote.expectedOutput * spotRate.den * SCALE) / (amountIn * spotRate.num);
    const impact = Number(SCALE - ratio) * 100 / Number(SCALE);
    const displayImpact = Math.max(0, impact);
    el.textContent = displayImpact < 0.01 ? '<0.01%' : displayImpact.toFixed(2) + '%';

    const qBox = $('quoteInfo');
    if (displayImpact > 5) {
      el.className = 'impact-danger';
      if (qBox) qBox.classList.add('impact-high');
    } else if (displayImpact > 2) {
      el.className = 'impact-warn';
      if (qBox) qBox.classList.remove('impact-high');
    } else {
      el.className = '';
      if (qBox) qBox.classList.remove('impact-high');
    }
  } catch (e) {
    el.textContent = '--';
    el.className = '';
    const qBox = $('quoteInfo');
    if (qBox) qBox.classList.remove('impact-high');
  }
}

async function withRetry(task, { tries = 3, base = 120 } = {}) {
  let attempt = 0, lastErr;
  while (attempt < tries) {
    try { return await task(); } catch (e) {
      const s = String(e?.message || "");
      const transient = /missing revert data|CALL_EXCEPTION|timeout|ETIMEDOUT|429|rate/i.test(s);
      if (!transient || attempt === tries - 1) throw e;
      lastErr = e;
      await new Promise(r => setTimeout(r, base * Math.pow(2, attempt)));
      attempt++;
    }
  }
  throw lastErr;
}

let _quoteLock = Promise.resolve();
let _pendingQuoteArgs = null;
let _pendingQuoteSeq = 0;

let _quoteResult = null;
function requestQuote(amtStr, fromSnap, toSnap, exactOut = false) {
  const mySeq = ++_pendingQuoteSeq;
  _pendingQuoteArgs = { amtStr, fromSnap, toSnap, exactOut, seq: mySeq };
  _quoteLock = _quoteLock.catch(() => {}).then(async () => {
    const args = _pendingQuoteArgs;
    if (!args || args.seq !== mySeq) return _quoteResult;
    _pendingQuoteArgs = null;
    _quoteResult = await withRetry(() => args.exactOut
      ? getExactOutQuote(args.amtStr, args.fromSnap, args.toSnap)
      : getQuote(args.amtStr, args.fromSnap, args.toSnap));
    return _quoteResult;
  });
  return _quoteLock;
}

// ---- Swap execution ----
let _swapBusy = false;
let _swapResetTimer = null;

async function executeSwap() {
  if (_swapBusy) return;
  _swapBusy = true;
  if (_swapResetTimer) { clearTimeout(_swapResetTimer); _swapResetTimer = null; }
  stopQuoteRefresh();

  const swapBtn = $("swapBtn");
  try {
    if (!signer || !connectedAddress) {
      toggleWallet();
      return;
    }

    const _isExactOut = _inputMode === 'exactOut';
    const amtStr = _isExactOut ? $("toAmount").value : $("fromAmount").value;
    const amtNum = parseFloat(amtStr);
    if (!amtStr || !Number.isFinite(amtNum) || amtNum <= 0) {
      showStatus("Please enter an amount", "error");
      return;
    }
    if (isReceiverPending()) {
      showStatus("Receiver address is still resolving â€” please wait", "error");
      return;
    }
    if (fromToken === toToken && !_ppSwapEnabled) {
      showStatus("Select different tokens", "error");
      return;
    }
    // Direct deposit (no swap needed â€” from === to for the PP asset)
    if (_ppSwapEnabled && fromToken === toToken && (fromToken === 'ETH' || fromToken === 'BOLD')) {
      _ppSelectedAsset = fromToken;
      ppSyncAssetUI(fromToken);
      $('ppAmount').value = amtStr;
      switchTab('privacy');
      updatePPButton();
      return;
    }
    const receiverRaw = ($("receiverAddress")?.value || "").trim();
    if (receiverRaw && !ethers.isAddress(receiverRaw)) {
      if (isReceiverPending()) {
        showStatus("Receiver name still resolving...", "error");
        return;
      }
      if (!_resolvedReceiver || _resolvedReceiver.input !== receiverRaw || !_resolvedReceiver.address) {
        showStatus("Could not resolve receiver name", "error");
        return;
      }
    }

    // ETH â†” WETH wrap/unwrap: direct contract call, no DEX (only when sending to self)
    const resolvedAddr = getReceiver();
    const hasCustomReceiver = receiverRaw && (isReceiverPending() || (resolvedAddr && resolvedAddr !== connectedAddress));
    const wrapDir = !hasCustomReceiver && !_ppSwapEnabled ? isWrapUnwrap(fromToken, toToken) : null;
    if (wrapDir) {
      const fromData = tokens[fromToken];
      const amountIn = safeParseUnits(amtStr, fromData.decimals);
      const wethContract = new ethers.Contract(WETH_ADDRESS, WETH_ABI, signer);

      if (wrapDir === 'wrap') {
        swapBtn.textContent = "Wrapping...";
        swapBtn.disabled = true;
        const tx = await wcTransaction(
          wethContract.deposit({ value: amountIn }),
          'Confirm wrap in your wallet'
        );
        swapBtn.innerHTML = `Confirming wrap... <a href="https://etherscan.io/tx/${escAttr(tx.hash)}" target="_blank" style="color:inherit;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
        const receipt = await waitForTx(tx);
        if (receipt.status === 0) throw new Error("Wrap transaction failed");
      } else {
        swapBtn.textContent = "Unwrapping...";
        swapBtn.disabled = true;
        const tx = await wcTransaction(
          wethContract.withdraw(amountIn),
          'Confirm unwrap in your wallet'
        );
        swapBtn.innerHTML = `Confirming unwrap... <a href="https://etherscan.io/tx/${escAttr(tx.hash)}" target="_blank" style="color:inherit;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
        const receipt = await waitForTx(tx);
        if (receipt.status === 0) throw new Error("Unwrap transaction failed");
      }

      swapBtn.textContent = wrapDir === 'wrap' ? "Wrap Complete!" : "Unwrap Complete!";
      $("fromAmount").value = "";
      $("toAmount").value = "";
      $("quoteInfo").style.display = "none";
      _swapResetTimer = setTimeout(() => {
        updateBalances();
        swapBtn.textContent = "Enter an amount";
        swapBtn.disabled = true;
      }, 1500);
      return;
    }

    // WETHâ†’ETH + PP: quoter can't route a pure unwrap â€” user should unwrap first
    if (_ppSwapEnabled && isWrapUnwrap(fromToken, toToken)) {
      showStatus("Unwrap WETH to ETH first, then deposit into Privacy Pool", "error");
      return;
    }

    // ---- Direct ZAMM â†’ zOrg stake: approve DAO + call buyShares directly ----
    if (isDirectZOrgStake(fromToken, toToken)) {
      swapBtn.innerHTML = `<span class="loading"></span> Preparing stake...`;
      swapBtn.disabled = true;

      const fromData = tokens[fromToken];
      const amountIn = safeParseUnits(amtStr, fromData.decimals);
      const quote = getDirectZOrgStakeQuote(amtStr, fromToken);

      // Check allowance to zOrg DAO (not the router)
      const zamm = erc20Read(fromData.address);
      swapBtn.textContent = "Checking allowance...";
      let allowance = await zamm.allowance(connectedAddress, ZORG_DAO);

      if (allowance < amountIn) {
        swapBtn.textContent = "Approving ZAMM for DAO...";
        const erc20W = new ethers.Contract(
          fromData.address,
          ["function approve(address,uint256) returns (bool)"],
          signer
        );
        // Reset stale non-zero allowance first (safety for non-standard tokens)
        if (allowance > 0n) {
          const resetTx = await wcTransaction(
            erc20W.approve(ZORG_DAO, 0),
            'Reset allowance in your wallet'
          );
          swapBtn.textContent = "Resetting allowance...";
          const resetRc = await waitForTx(resetTx);
          if (resetRc.status === 0) throw new Error("Allowance reset failed");
        }
        const approveTx = await wcTransaction(
          erc20W.approve(ZORG_DAO, ethers.MaxUint256),
          'Approve ZAMM spending for zOrg DAO in your wallet'
        );
        swapBtn.innerHTML = `Approving... <a href="https://etherscan.io/tx/${escAttr(approveTx.hash)}" target="_blank" style="color:inherit;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
        const rc = await waitForTx(approveTx);
        if (rc.status === 0) throw new Error("Approval transaction failed");
      }

      // Call buyShares directly on the zOrg DAO
      swapBtn.textContent = "Staking...";
      const stakeTx = await wcTransaction(
        signer.sendTransaction({
          to: ZORG_DAO,
          data: quote.daoCalldata,
          value: 0n,
        }),
        'Confirm stake in your wallet'
      );
      swapBtn.innerHTML = `Confirming stake... <a href="https://etherscan.io/tx/${escAttr(stakeTx.hash)}" target="_blank" style="color:inherit;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;

      const receipt = await waitForTx(stakeTx);
      if (receipt.status === 0) throw new Error("Stake transaction failed");

      swapBtn.textContent = "Stake Complete!";
      $("fromAmount").value = "";
      $("toAmount").value = "";
      $("quoteInfo").style.display = "none";
      stopQuoteRefresh();
      _swapResetTimer = setTimeout(() => {
        updateBalances();
        swapBtn.textContent = "Enter an amount";
        swapBtn.disabled = true;
      }, 1500);
      return;
    }

    // ---- zOrg â†’ ZAMM ragequit: burn shares, claim ZAMM directly ----
    if (isRagequitPath(fromToken, toToken)) {
      swapBtn.innerHTML = `<span class="loading"></span> Preparing ragequit...`;
      swapBtn.disabled = true;

      const fromData = tokens[fromToken];
      const amountIn = safeParseUnits(amtStr, fromData.decimals);
      const quote = getRagequitQuote(amtStr, fromToken);

      // No approval needed â€” ragequit burns msg.sender's shares directly
      swapBtn.textContent = "Ragequitting...";
      const rqTx = await wcTransaction(
        signer.sendTransaction({
          to: ZORG_DAO,
          data: quote.daoCalldata,
          value: 0n,
        }),
        'Confirm ragequit in your wallet'
      );
      swapBtn.innerHTML = `Confirming ragequit... <a href="https://etherscan.io/tx/${escAttr(rqTx.hash)}" target="_blank" style="color:inherit;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;

      const receipt = await waitForTx(rqTx);
      if (receipt.status === 0) throw new Error("Ragequit transaction failed");

      swapBtn.textContent = "Ragequit Complete!";
      $("fromAmount").value = "";
      $("toAmount").value = "";
      $("quoteInfo").style.display = "none";
      stopQuoteRefresh();
      _swapResetTimer = setTimeout(() => {
        updateBalances();
        swapBtn.textContent = "Enter an amount";
        swapBtn.disabled = true;
      }, 1500);
      return;
    }

    // ---- zOrg â†’ token sell: two-step (ragequit then ZAMM swap) ----
    if (isZOrgSellPath(fromToken, toToken)) {
      if (_ppSwapEnabled) {
        showStatus("Privacy Pool deposit not supported for zOrg sells â€” sell zOrg first, then deposit the output", "error");
        return;
      }
      swapBtn.innerHTML = `<span class="loading"></span> Preparing sell...`;
      swapBtn.disabled = true;

      const fromSnap = fromToken, toSnap = toToken;
      const fromData = tokens[fromSnap];
      const amountIn = safeParseUnits(amtStr, fromData.decimals);
      const quote = await withRetry(() => getZOrgSellQuote(amtStr, fromSnap, toSnap));

      // Step 1: Ragequit (burns zOrg shares, receive ZAMM 1:1)
      swapBtn.textContent = "Step 1/2: Ragequitting...";
      const rqTx = await wcTransaction(
        signer.sendTransaction({
          to: ZORG_DAO,
          data: quote.ragequitData,
          value: 0n,
        }),
        'Step 1/2: Confirm ragequit in your wallet'
      );
      swapBtn.innerHTML = `Confirming ragequit... <a href="https://etherscan.io/tx/${escAttr(rqTx.hash)}" target="_blank" style="color:inherit;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
      const rqReceipt = await waitForTx(rqTx);
      if (rqReceipt.status === 0) throw new Error("Ragequit transaction failed");

      // Step 2: Sell ZAMM via router (re-quote to get fresh reserves)
      // If step 2 fails, user now holds ZAMM (ragequit already succeeded)
      try {
        swapBtn.textContent = "Step 2/2: Preparing swap...";
        const zammAmtStr = ethers.formatUnits(amountIn, 18);
        const freshQuote = await withRetry(() => getZammSellQuote(zammAmtStr, "ZAMM", toSnap));

        // Handle ERC20 approval for ZAMM â†’ router
        let txData = freshQuote.multicall;
        const zammAddr = ZORG_PAY_TOKEN;
        const r = erc20Read(zammAddr);
        let allowance = await r.allowance(connectedAddress, ZROUTER_ADDRESS);
        cacheSetAllowance(zammAddr, connectedAddress, ZROUTER_ADDRESS, allowance);

        if (allowance < amountIn) {
          let approved = false;
          // Try Permit2
          let p2Allowance = cacheGetAllowance(zammAddr, connectedAddress, PERMIT2_ADDRESS);
          if (p2Allowance == null) {
            p2Allowance = await r.allowance(connectedAddress, PERMIT2_ADDRESS);
            cacheSetAllowance(zammAddr, connectedAddress, PERMIT2_ADDRESS, p2Allowance);
          }
          if (p2Allowance >= amountIn) {
            try {
              swapBtn.textContent = "Sign Permit2...";
              const permit2Data = await signPermit2(zammAddr, amountIn);
              const innerCalls = freshQuote.calls || decodeMulticallCalls(freshQuote.multicall);
              txData = buildPermit2Multicall(innerCalls, permit2Data);
              approved = true;
            } catch (p2Err) {
              const msg = String(p2Err?.message || '');
              if (/user rejected|user denied|user cancelled/i.test(msg)) throw p2Err;
              txData = freshQuote.multicall;
            }
          }
          if (!approved) {
            swapBtn.textContent = "Approving ZAMM...";
            const erc20W = new ethers.Contract(zammAddr, ["function approve(address,uint256) returns (bool)"], signer);
            if (allowance > 0n) {
              const resetTx = await wcTransaction(erc20W.approve(ZROUTER_ADDRESS, 0), 'Reset allowance');
              await waitForTx(resetTx);
            }
            const approveTx = await wcTransaction(erc20W.approve(ZROUTER_ADDRESS, ethers.MaxUint256), 'Approve ZAMM for swap');
            swapBtn.innerHTML = `Approving... <a href="https://etherscan.io/tx/${escAttr(approveTx.hash)}" target="_blank" style="color:inherit;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
            const rc = await waitForTx(approveTx);
            if (rc.status === 0) throw new Error("Approval failed");
            cacheSetAllowance(zammAddr, connectedAddress, ZROUTER_ADDRESS, ethers.MaxUint256);
          }
        }

        swapBtn.textContent = "Step 2/2: Swapping...";
        const swapTx = await wcTransaction(
          signer.sendTransaction({
            to: ZROUTER_ADDRESS,
            data: txData,
            value: 0n,
          }),
          'Step 2/2: Confirm swap in your wallet'
        );
        swapBtn.innerHTML = `Confirming swap... <a href="https://etherscan.io/tx/${escAttr(swapTx.hash)}" target="_blank" style="color:inherit;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
        const swapReceipt = await waitForTx(swapTx);
        if (swapReceipt.status === 0) throw new Error("Swap transaction failed");
      } catch (step2Err) {
        // Ragequit already succeeded â€” user now holds ZAMM tokens
        const s = String(step2Err?.message || '');
        if (/user rejected|user denied|user cancelled/i.test(s)) {
          showStatus("Ragequit succeeded. You now hold ZAMM. Swap cancelled.", "error");
        } else {
          showStatus("Ragequit succeeded but swap failed. You now hold ZAMM â€” sell it separately.", "error");
        }
        swapBtn.textContent = "Ragequit done, swap failed";
        $("fromAmount").value = "";
        $("toAmount").value = "";
        $("quoteInfo").style.display = "none";
        stopQuoteRefresh();
        _swapResetTimer = setTimeout(() => {
          updateBalances();
          swapBtn.textContent = "Enter an amount";
          swapBtn.disabled = true;
        }, 3000);
        return;
      }

      swapBtn.textContent = "Sell Complete!";
      $("fromAmount").value = "";
      $("toAmount").value = "";
      $("quoteInfo").style.display = "none";
      stopQuoteRefresh();
      _swapResetTimer = setTimeout(() => {
        updateBalances();
        swapBtn.textContent = "Enter an amount";
        swapBtn.disabled = true;
      }, 1500);
      return;
    }

    swapBtn.innerHTML = `<span class="loading"></span> Getting quote...`;
    swapBtn.disabled = true;

    const fromSnap = fromToken, toSnap = toToken;
    const quote = await withRetry(() => _isExactOut
      ? getExactOutQuote(amtStr, fromSnap, toSnap)
      : getQuote(amtStr, fromSnap, toSnap));
    const fromData = tokens[fromSnap];
    const amountIn = _isExactOut ? quote.requiredInput : safeParseUnits(amtStr, fromData.decimals);

    let txData = quote.multicall;

    // ERC20 approval
    if (fromData.address !== ZERO_ADDRESS) {
      const r = erc20Read(fromData.address);
      swapBtn.textContent = "Checking allowance...";
      let allowance = await r.allowance(connectedAddress, ZROUTER_ADDRESS);
      cacheSetAllowance(fromData.address, connectedAddress, ZROUTER_ADDRESS, allowance);

      if (allowance < amountIn) {
        let approved = false;

        // --- Try 1: EIP-2612 Permit (single tx) ---
        const permitCfg = await getPermitConfig(fromData.address);
        if (permitCfg) {
          try {
            swapBtn.textContent = "Sign permit...";
            const permitData = await signPermit(permitCfg, fromData.address);
            const innerCalls = quote.calls || decodeMulticallCalls(quote.multicall);
            const permitTxData = buildPermitMulticall(innerCalls, permitData);
            // Pre-flight: catch on-chain permit failures (e.g. InvalidShortString)
            await provider.estimateGas({
              from: connectedAddress,
              to: ZROUTER_ADDRESS,
              data: permitTxData,
              value: quote.msgValue ?? 0n,
            });
            txData = permitTxData;
            approved = true;
          } catch (permitErr) {
            const msg = String(permitErr?.message || '');
            if (/user rejected|user denied|user cancelled/i.test(msg)) throw permitErr;
            console.warn("Permit failed, falling back:", permitErr);
            _permitCache.set(fromData.address.toLowerCase(), null);
            txData = quote.multicall;
          }
        }

        // --- Try 2: Permit2 (single tx, sign-only) ---
        if (!approved) {
          let p2Allowance = cacheGetAllowance(fromData.address, connectedAddress, PERMIT2_ADDRESS);
          if (p2Allowance == null) {
            swapBtn.textContent = "Checking Permit2...";
            const r2 = erc20Read(fromData.address);
            p2Allowance = await r2.allowance(connectedAddress, PERMIT2_ADDRESS);
            cacheSetAllowance(fromData.address, connectedAddress, PERMIT2_ADDRESS, p2Allowance);
          }
          if (p2Allowance >= amountIn) {
            try {
              swapBtn.textContent = "Sign Permit2...";
              const permit2Data = await signPermit2(fromData.address, amountIn);
              const innerCalls = quote.calls || decodeMulticallCalls(quote.multicall);
              txData = buildPermit2Multicall(innerCalls, permit2Data);
              approved = true;
            } catch (p2Err) {
              const msg = String(p2Err?.message || '');
              if (/user rejected|user denied|user cancelled/i.test(msg)) throw p2Err;
              console.warn("Permit2 failed, falling back:", p2Err);
              txData = quote.multicall;
            }
          }
        }

        // --- Try 3: Approve (two tx, traditional fallback) ---
        if (!approved) {
          swapBtn.textContent = "Approving token...";
          const erc20W = new ethers.Contract(
            fromData.address,
            ["function approve(address,uint256) returns (bool)"],
            signer
          );
          // WBTC/USDT revert on approve(spender, newVal) when current != 0
          // Reset to zero first if there's a stale non-zero allowance
          if (allowance > 0n) {
            const resetTx = await wcTransaction(
              erc20W.approve(ZROUTER_ADDRESS, 0),
              'Reset allowance in your wallet'
            );
            swapBtn.textContent = "Resetting allowance...";
            const resetRc = await waitForTx(resetTx);
            if (resetRc.status === 0) throw new Error("Allowance reset failed");
          }
          const approveTx = await wcTransaction(
            erc20W.approve(ZROUTER_ADDRESS, ethers.MaxUint256),
            'Approve token spending in your wallet'
          );
          swapBtn.innerHTML = `Approving... <a href="https://etherscan.io/tx/${escAttr(approveTx.hash)}" target="_blank" style="color:inherit;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
          const rc = await waitForTx(approveTx);
          if (rc.status === 0) throw new Error("Approval transaction failed");
          const fresh = _isExactOut ? await getExactOutQuote(amtStr, fromSnap, toSnap) : await getQuote(amtStr, fromSnap, toSnap);
          txData = fresh.multicall;
          quote.msgValue = fresh.msgValue;
          cacheSetAllowance(fromData.address, connectedAddress, ZROUTER_ADDRESS, ethers.MaxUint256);
        }
      }
    }

    if (_ppSwapEnabled && (toSnap === 'ETH' || toSnap === 'BOLD')) {
      const ppAsset = toSnap; // 'ETH' or 'BOLD'
      const ppIsBOLD = ppAsset === 'BOLD';
      const ppCfg = ppIsBOLD ? _ppConfigBold : _ppConfig;
      swapBtn.textContent = "Preparing privacy deposit...";

      // Re-quote with to=ZROUTER so output stays in router
      const _ppTokenOut = ppIsBOLD ? BOLD_ADDRESS : ZERO_ADDRESS;
      const ppQuote = await withRetry(() => quoteRPC.call(async (rpc) => {
        const quoter = getQuoterContract(rpc);
        const deadline = BigInt(Math.trunc(Date.now() / 1000) + 300);
        if (_isExactOut) {
          // Exact-out: swap to get exactly the desired output, routed to router
          const toData = tokens[toSnap];
          const exactOutputAmt = safeParseUnits(amtStr, toData.decimals);
          return quoter.buildBestSwapViaETHMulticall(
            ZROUTER_ADDRESS, connectedAddress, true,
            fromData.address, _ppTokenOut,
            exactOutputAmt, BigInt(slippageBps), deadline,
            0, 0, ZERO_ADDRESS, { blockTag: "latest" }
          );
        }
        return quoter.buildBestSwapViaETHMulticall(
          ZROUTER_ADDRESS, connectedAddress, false,
          fromData.address, _ppTokenOut,
          amountIn, BigInt(slippageBps), deadline,
          0, 0, ZERO_ADDRESS, { blockTag: "latest" }
        );
      }));

      // For exact-out, the swap guarantees the output amount; for exact-in, use slippage-safe minimum
      let depositAmount;
      if (_isExactOut) {
        const toData = tokens[toSnap];
        depositAmount = safeParseUnits(amtStr, toData.decimals);
      } else {
        // R-1: Use slippage-safe minimum, not raw quoted output.
        // On-chain swap enforces SlippageLib.limit() independently; actual output may be lower than quoted.
        const _rawOut = ppQuote.b.amountOut > 0n ? ppQuote.b.amountOut : ppQuote.a.amountOut;
        if (_rawOut === 0n) throw new Error("PP swap quote returned zero output â€” try a different amount or pair");
        depositAmount = _rawOut * (10000n - BigInt(slippageBps)) / 10000n;
      }

      if (ppCfg && depositAmount < ppCfg.minimumDepositAmount) {
        showStatus(`Output below PP minimum deposit of ${ethers.formatEther(ppCfg.minimumDepositAmount)} ${ppAsset}`, "error");
        return;
      }

      swapBtn.textContent = "Deriving keys...";
      const { masterNullifier, masterSecret } = await ppEnsureMasterKeys();
      const _ppScope = ppComputeScope(ppAsset);
      const _ppDepositIdx = await ppFindUnusedDepositIndex(masterNullifier, masterSecret, _ppScope, ppGetDepositIndex(connectedAddress, _ppScope));
      const { nullifier, secret, precommitment } = ppDeriveDepositKeys(masterNullifier, masterSecret, _ppScope, _ppDepositIdx);

      // Build multicall: [permit?] + swap calls + execute(PP deposit) + sweep excess
      const swapCalls = ppQuote.calls ? Array.from(ppQuote.calls) : decodeMulticallCalls(ppQuote.multicall);
      if (swapCalls.length === 0) throw new Error("PP swap routing failed â€” no swap calls generated");
      let depositCalldata, executeCall, sweepCalls;
      if (ppIsBOLD) {
        // R-3: Preflight check â€” router must have BOLD allowance to PP entrypoint
        const rpcPF = await quoteRPC.call(r => r);
        const boldPF = new ethers.Contract(BOLD_ADDRESS, ['function allowance(address,address) view returns (uint256)'], rpcPF);
        const routerToEPAllow = await boldPF.allowance(ZROUTER_ADDRESS, PP_ENTRYPOINT);
        if (routerToEPAllow < depositAmount) {
          showStatus('Router lacks BOLD allowance to Privacy Pool entrypoint. Contact the zFi team to configure router approval.', 'error');
          return;
        }
        // ERC20 deposit: deposit(address asset, uint256 value, uint256 precommitment), value=0 (no ETH)
        depositCalldata = PP_DEPOSIT_IFACE.encodeFunctionData('deposit(address,uint256,uint256)', [BOLD_ADDRESS, depositAmount, precommitment]);
        executeCall = ROUTER_IFACE.encodeFunctionData('execute', [PP_ENTRYPOINT, 0, depositCalldata]);
        // Sweep excess BOLD + ETH remainder (ETH dust possible when input is ETHâ†’BOLD two-hop)
        sweepCalls = [
          ROUTER_IFACE.encodeFunctionData('sweep', [BOLD_ADDRESS, 0, 0, connectedAddress]),
          ROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, connectedAddress]),
        ];
      } else {
        // ETH deposit: deposit(uint256 precommitment) payable, value=depositAmount
        depositCalldata = PP_DEPOSIT_IFACE.encodeFunctionData('deposit(uint256)', [precommitment]);
        executeCall = ROUTER_IFACE.encodeFunctionData('execute', [PP_ENTRYPOINT, depositAmount, depositCalldata]);
        sweepCalls = [ROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, connectedAddress])];
      }

      // If the approval flow embedded a permit/permit2 call in txData, extract it
      // and prepend to the PP multicall (permit was signed for this tx, must be included)
      const _permitSelectors = new Set([
        ROUTER_IFACE.getFunction('permit').selector,
        ROUTER_IFACE.getFunction('permitDAI').selector,
        ROUTER_IFACE.getFunction('permit2TransferFrom').selector,
      ]);
      let permitPrefix = [];
      if (txData !== quote.multicall) {
        const modCalls = decodeMulticallCalls(txData);
        if (modCalls.length > 0 && _permitSelectors.has(modCalls[0].slice(0, 10))) {
          permitPrefix = [modCalls[0]];
        }
      }
      const ppMulticall = ROUTER_IFACE.encodeFunctionData('multicall', [[...permitPrefix, ...swapCalls, executeCall, ...sweepCalls]]);

      swapBtn.textContent = "Confirm in wallet...";
      const ppTxValue = ppQuote.msgValue ?? (fromData.address === ZERO_ADDRESS ? amountIn : 0n);

      const swapTx = await wcTransaction(
        signer.sendTransaction({
          to: ZROUTER_ADDRESS,
          data: ppMulticall,
          value: ppTxValue,
        }),
        `Confirm swap & ${ppAsset} privacy deposit`
      );
      // Increment index immediately after tx submitted to prevent reuse if tab closes
      ppSetDepositIndex(connectedAddress, _ppScope, _ppDepositIdx + 1);

      // Show partial note immediately (nullifier+secret)
      const partialNote = buildPPNote(nullifier, secret, null, ppAsset);
      $('ppSwapNoteText').value = partialNote;
      setShown('ppSwapNoteBox', true);

      // Save partial note to localStorage
      let noteIdx;
      try {
        const saved = JSON.parse(localStorage.getItem('pp_notes') || '[]');
        noteIdx = saved.length;
        saved.push({ note: partialNote, amount: depositAmount.toString(), asset: ppAsset, timestamp: Date.now(), txHash: swapTx.hash });
        localStorage.setItem('pp_notes', JSON.stringify(saved));
        renderPPNotes();
      } catch (_lsErr) {
        noteIdx = -1;
        alert("CRITICAL: Could not save note to browser storage. Copy your note NOW from the text area â€” you need it to withdraw.");
      }

      swapBtn.innerHTML = `Confirming deposit... <a href="https://etherscan.io/tx/${escAttr(swapTx.hash)}" target="_blank" style="color:inherit;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
      const receipt = await waitForTx(swapTx);

      if (!receipt || receipt.status === 0) throw new Error("Swap & deposit transaction failed");

      // Parse deposit events to get value, label, leafIndex, commitment
      const depositInfo = parsePPDepositReceipt(receipt);
      const fullNote = buildPPNote(nullifier, secret, depositInfo, ppAsset);
      $('ppSwapNoteText').value = fullNote;
      // Update localStorage with full note
      try {
        const updSaved = JSON.parse(localStorage.getItem('pp_notes') || '[]');
        if (noteIdx >= 0 && updSaved[noteIdx]) { updSaved[noteIdx].note = fullNote; localStorage.setItem('pp_notes', JSON.stringify(updSaved)); renderPPNotes(); }
      } catch (_) {}

      swapBtn.textContent = "Deposit Complete! Save your note.";
      $("fromAmount").value = "";
      $("toAmount").value = "";
      $("quoteInfo").style.display = "none";
      stopQuoteRefresh();
      _swapResetTimer = setTimeout(() => {
        updateBalances();
        swapBtn.textContent = "Enter an amount";
        swapBtn.disabled = true;
      }, 3000);
      return;
    }

    const isLidoExec = (quote.sourceA === "Lido" || quote.sourceA === "Rocket Pool") && !quote.isSplit && !quote.isTwoHop;
    const actionLabel = isLidoExec ? "Staking" : isZOrgSwap(toSnap) ? "Swapping & Staking" : "Swapping";
    swapBtn.textContent = actionLabel + "...";
    const txValue = quote.msgValue ?? 0n;

    const swapTx = await wcTransaction(
      signer.sendTransaction({
        to: ZROUTER_ADDRESS,
        data: txData,
        value: txValue,
      }),
      isLidoExec ? 'Confirm stake in your wallet' : 'Confirm swap in your wallet'
    );
    swapBtn.innerHTML = `Confirming ${actionLabel.toLowerCase()}... <a href="https://etherscan.io/tx/${escAttr(swapTx.hash)}" target="_blank" style="color:inherit;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;

    const receipt = await waitForTx(swapTx);
    if (receipt.status === 0) throw new Error(isLidoExec ? "Stake transaction failed" : "Swap transaction failed");

    swapBtn.textContent = (isLidoExec ? "Stake" : isZOrgSwap(toSnap) ? "Swap & Stake" : "Swap") + " Complete!";
    $("fromAmount").value = "";
    $("toAmount").value = "";
    $("quoteInfo").style.display = "none";
    stopQuoteRefresh();
    _swapResetTimer = setTimeout(() => {
      updateBalances();
      swapBtn.textContent = "Enter an amount";
      swapBtn.disabled = true;
    }, 1500);
  } catch (e) {
    console.error("Swap error:", e);
    let msg = "Swap failed";
    const s = String(e?.data || e?.message || e?.reason || "");
    if (e.code === 4001 || /user rejected|denied/i.test(s)) msg = "Transaction cancelled";
    else if (/insufficient funds/i.test(s) || /INSUFFICIENT_FUNDS/i.test(s)) msg = "Insufficient balance";
    else if (/7939f424/.test(s)) msg = `Insufficient ${fromToken} balance or approval`;
    else if (/Too many decimals|Invalid number/i.test(s)) msg = s;
    else if (/PrecommitmentAlreadyUsed/i.test(s)) msg = "Precommitment already used. Try again.";
    else if (/InsufficientAllowance/i.test(s)) msg = "Insufficient token allowance.";
    else if (/InsufficientBalance/i.test(s)) msg = "Insufficient balance for deposit.";

    swapBtn.textContent = msg;
    swapBtn.disabled = false;
    _swapResetTimer = setTimeout(() => { handleAmountChange(); }, 2000);
  } finally {
    _swapBusy = false;
  }
}

// ---- Token swap direction ----
function swapTokens() {
  if (fromToken === toToken) return;
  if (_ppSwapEnabled) { showStatus(`Output locked to ${_ppSelectedAsset} for Privacy Pool deposit`, "error"); return; }
  const prevFrom = fromToken, prevTo = toToken;
  const fAmt = $("fromAmount").value;
  const tAmt = $("toAmount").value;

  fromToken = prevTo;
  toToken = prevFrom;
  // Copy the user-typed amount to fromAmount, clear toAmount, reset to exact-in
  $("fromAmount").value = tAmt;
  $("toAmount").value = "";
  _inputMode = 'exactIn';
  updateTokenDisplay();
  _quoteSeq++;
  updateBalances();
  if (tAmt) handleAmountChange();
}

function fitRouteText(route) {
  const el = $("routeInfo");
  el.textContent = route;
  el.title = route;
  el.removeAttribute("data-size");
  const len = route.length;
  if (len > 48) el.setAttribute("data-size", "xs");
  else if (len > 32) el.setAttribute("data-size", "sm");
}

function computeZammPoolId(addr0, addr1, id0, id1, fee) {
  const [sortedA, sortedB] = addr0.toLowerCase() < addr1.toLowerCase() ? [addr0, addr1] : [addr1, addr0];
  const [sortedId0, sortedId1] = addr0.toLowerCase() < addr1.toLowerCase() ? [id0, id1] : [id1, id0];
  const poolKey = ethers.AbiCoder.defaultAbiCoder().encode(
    ["uint256","uint256","address","address","uint256"],
    [sortedId0, sortedId1, sortedA, sortedB, fee]
  );
  return BigInt(ethers.keccak256(poolKey));
}

const COINGECKO_SLUGS = {
  ETH: "ethereum", WETH: "weth", BOLD: "liquity-bold", LUSD: "liquity-usd",
  DAI: "dai", USDC: "usdc", USDT: "tether", WBTC: "wrapped-bitcoin",
  stETH: "lido-staked-ether", wstETH: "wrapped-steth", rETH: "rocket-pool-eth",
  PNKSTR: "kleros",
};

function updateChartLink(quote) {
  const link = $("chartLink");
  const zammRe = /zAMM|V4 Hooked/;
  const hasZamm = zammRe.test(quote.sourceA || "") || zammRe.test(quote.sourceB || "")
    || (quote.splitLegs && quote.splitLegs.some(l => zammRe.test(l.source || "")));
  if (hasZamm) {
    // Determine pool ID: for zOrg route use ZORG_ID; otherwise standard ERC20 pool
    const fromAddr = tokens[fromToken].address;
    const toAddr = tokens[toToken].address;
    const isZorg = !!(tokens[fromToken]._isZOrg || tokens[toToken]._isZOrg || tokens[fromToken]._isZammStake || tokens[toToken]._isZammStake);
    let poolId;
    if (isZorg) {
      poolId = computeZammPoolId(ZERO_ADDRESS, ZORG_TOKEN, 0n, ZORG_ID, 100n);
    } else {
      poolId = computeZammPoolId(fromAddr, toAddr, 0n, 0n, 100n);
    }
    link.href = "./chart/#/" + poolId.toString();
    link.style.display = "inline-flex";
    return;
  }
  // Non-zAMM: link to CoinGecko for the to-token (or from-token if to is ETH)
  const slug = COINGECKO_SLUGS[toToken] || COINGECKO_SLUGS[fromToken];
  if (slug) {
    link.href = "https://www.coingecko.com/en/coins/" + slug;
    link.style.display = "inline-flex";
  } else {
    link.style.display = "none";
  }
}

// ---- Quick-pick popular tokens ----
const QUICK_TOKENS = ["BOLD", "DAI", "stETH", "rETH"];

function renderQuickTokens() {
  const el = $('quickTokens');
  if (!el) return;
  el.innerHTML = '';
  for (const sym of QUICK_TOKENS) {
    if (!tokens[sym] || sym === toToken || sym === fromToken) continue;
    const btn = document.createElement('button');
    btn.className = 'quick-token';
    btn.setAttribute('aria-label', sym);
    btn.innerHTML = `<span class="qi">${iconForSymbol(sym)}</span>`;
    // Make inner icon fill the container
    const svgOrImg = btn.querySelector('.qi > *');
    if (svgOrImg) { svgOrImg.style.width = '100%'; svgOrImg.style.height = '100%'; }
    btn.onclick = () => {
      toToken = sym;
      updateTokenDisplay();
      updateBalances();
      const amt = _inputMode === 'exactOut' ? $("toAmount") : $("fromAmount");
      if (amt && amt.value) reQuoteDebounced();
    };
    el.appendChild(btn);
  }
}

// Sync URL bar so users can copy/share the current swap
let _activeTab = 'swap';
function syncSwapURL() {
  if (_activeTab !== 'swap') return; // privacy tab syncs its own URL
  const _sp = new URLSearchParams();
  _sp.set('from', fromToken.toLowerCase()); _sp.set('to', toToken.toLowerCase());
  if (_inputMode === 'exactOut') {
    const _ta = $("toAmount");
    if (_ta && _ta.value && +_ta.value > 0) _sp.set('outamt', _ta.value);
  } else {
    const _fa = $("fromAmount");
    if (_fa && _fa.value && +_fa.value > 0) _sp.set('amt', _fa.value);
  }
  const _rv = ($("receiverAddress")?.value || "").trim();
  if (_rv) _sp.set('recv', _rv);
  if (_ppSwapEnabled) _sp.set('pp', _ppSelectedAsset.toLowerCase());
  history.replaceState(null, '', '?' + _sp.toString());
}
function syncPrivacyURL() {
  const _sp = new URLSearchParams();
  _sp.set('pp', _ppSelectedAsset.toLowerCase());
  const _pa = $('ppAmount');
  if (_pa && _pa.value && +_pa.value > 0) _sp.set('amt', _pa.value);
  history.replaceState(null, '', '?' + _sp.toString() + '#privacy');
}

function updateCalldataLink(multicall) {
  const el = $("calldataLink");
  if (!el) return;
  if (!multicall) { el.style.display = 'none'; return; }
  el.href = `https://calldata.swiss-knife.xyz/decoder?calldata=${multicall}&chainId=1&address=${ZROUTER_ADDRESS}`;
  el.style.display = '';
}

function updateReceiverWarn() {
  const el = $("receiverWarn");
  if (!el) return;
  const recv = ($("receiverAddress")?.value || "").trim();
  if (!recv) { el.style.display = 'none'; return; }
  const isDirect = isDirectZOrgStake(fromToken, toToken) || isRagequitPath(fromToken, toToken);
  if (isDirect) {
    el.textContent = "Custom receiver not supported for direct DAO stake/ragequit â€” output goes to your wallet";
    el.style.display = 'block';
  } else {
    el.style.display = 'none';
  }
}

// ---- Token display ----
function updateTokenDisplay() {
  const fSym = fromToken, tSym = toToken;
  setHTML("fromTokenIcon", iconForSymbol(fSym));
  setText("fromTokenSymbol", tokens[fSym].symbol);
  setHTML("toTokenIcon", iconForSymbol(tSym));
  setText("toTokenSymbol", tokens[tSym].symbol);
  renderQuickTokens();
  updateReceiverWarn();
  syncSwapURL();
}

// ---- Token modal ----
function initTokenListClick() {
  const list = $("tokenList");
  if (!list || list.dataset.inited === "1") return;
  list.dataset.inited = "1";
  list.addEventListener("click", (e) => {
    // Handle .wei list remove button
    const removeBtn = e.target.closest('.wei-list-remove');
    if (removeBtn) {
      const listName = removeBtn.getAttribute('data-list');
      if (listName) {
        removeWeiList(listName);
        renderTokenList($('tokenSearchInput')?.value || '');
      }
      return;
    }
    const row = e.target.closest(".token-list-item");
    if (!row) return;
    const symbol = row.getAttribute("data-symbol");
    if (symbol) selectToken(symbol);
  });
}

function openTokenModal(side) {
  currentModal = side;
  const searchInput = $('tokenSearchInput');
  if (searchInput) searchInput.value = '';
  const statusEl = $('weiListStatus');
  if (statusEl) { statusEl.textContent = ''; statusEl.className = 'token-search-status'; }
  renderTokenList('');
  $("tokenModal").classList.add('active');
  document.body.classList.add('modal-open');
  if (searchInput) searchInput.focus();
  // Batch-fetch all token balances via Multicall3 (single RPC)
  if (connectedAddress) fetchModalBalances();
}

function closeTokenModal() {
  $("tokenModal").classList.remove('active');
  document.body.classList.remove('modal-open');
  $("customTokenAddress").value = "";
  const searchInput = $('tokenSearchInput');
  if (searchInput) searchInput.value = '';
  const statusEl = $('weiListStatus');
  if (statusEl) { statusEl.textContent = ''; statusEl.className = 'token-search-status'; }
}

const reQuoteDebounced = debounce(handleAmountChange, 600);

function selectToken(symbol) {
  if (currentModal === "from") {
    if (symbol === toToken) toToken = fromToken;
    fromToken = symbol;
    // If PP swap is on and new from matches PP deposit asset, flip to the other
    if (_ppSwapEnabled && (fromToken === 'ETH' || fromToken === 'BOLD') && fromToken === _ppSelectedAsset) {
      const alt = fromToken === 'ETH' ? 'BOLD' : 'ETH';
      _ppSelectedAsset = alt;
      toToken = alt;
      ppSyncAssetUI(alt);
    }
  } else {
    if (_ppSwapEnabled) { closeTokenModal(); showStatus(`Output locked to ${_ppSelectedAsset} for Privacy Pool deposit`, "error"); return; }
    if (symbol === fromToken) fromToken = toToken;
    toToken = symbol;
  }
  updateTokenDisplay();
  updateBalances();
  closeTokenModal();
  currentModal = null;
  const _srcField = _inputMode === 'exactOut' ? $("toAmount") : $("fromAmount");
  if (_srcField) _srcField.focus();
  if (_srcField && _srcField.value) reQuoteDebounced();
}

function setupDirectZammStake() {
  fromToken = "ZAMM";
  toToken = "zOrg";
  updateTokenDisplay();
  updateBalances();
  const amt = $("fromAmount");
  if (amt) amt.focus();
  if (amt && amt.value) reQuoteDebounced();
}

function setupRagequit() {
  fromToken = "zOrg";
  toToken = "ZAMM";
  updateTokenDisplay();
  updateBalances();
  const amt = $("fromAmount");
  if (amt) amt.focus();
  if (amt && amt.value) reQuoteDebounced();
}

async function addCustomToken() {
  let address = $("customTokenAddress").value.trim();
  if (!ethers.isAddress(address)) { showStatus("Invalid address", "error"); return; }
  address = ethers.getAddress(address);
  if (address === ZERO_ADDRESS) { showStatus("Zero address is not a valid ERC-20", "error"); return; }

  try {
    const rpc = provider || new ethers.JsonRpcProvider("https://eth.llamarpc.com");
    try {
      const code = await rpc.getCode(address);
      if (!code || code === "0x") { showStatus("That address has no contract code on Ethereum", "error"); return; }
    } catch (_) {}

    const erc20 = new ethers.Contract(address, [
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
    ], rpc);
    const [rawSymbol, rawDecimals] = await Promise.all([erc20.symbol(), erc20.decimals()]);

    const symbol = String(rawSymbol || "").trim().slice(0, 24) || "TKN";
    const rawDec = Number(rawDecimals);
    const decimals = Number.isInteger(rawDec) && rawDec >= 0 && rawDec <= 36 ? rawDec : 18;

    const existing = tokens[symbol];
    if (existing && existing.address.toLowerCase() !== address.toLowerCase()) {
      showStatus(`A different token with symbol ${symbol} is already listed`, "error");
      return;
    }

    tokens[symbol] = { address, symbol, decimals };
    saveCustomTokens();
    selectToken(symbol);
  } catch (e) {
    console.error("Error adding token:", e);
    showStatus("Failed to add token. Ensure it's a valid ERC-20 on Ethereum", "error");
  }
}

// ---- Keyboard shortcuts ----
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    closeTokenModal();
    closeWalletModal();
  }
});

// ---- Init ----
document.addEventListener("DOMContentLoaded", () => {
  // Deeplink: ?from=eth&to=bold&amt=1.5 (lowercase â€” wei.is gateway mangles mixed-case params)
  const _urlp = new URLSearchParams(window.location.search);
  const _findToken = (s) => { const u = (s||'').toUpperCase(); return Object.keys(tokens).find(k => k.toUpperCase() === u); };
  const _dlFrom = _findToken(_urlp.get('from'));
  const _dlTo = _findToken(_urlp.get('to'));
  if (_dlFrom) fromToken = _dlFrom;
  if (_dlTo) toToken = _dlTo;
  if (fromToken === toToken) toToken = fromToken === 'ETH' ? 'zOrg' : 'ETH';
  const _dlAmt = _urlp.get('amt');
  const _dlOutAmt = _urlp.get('outamt');
  // Deeplink: ?pp=eth or ?pp=bold â€” Privacy Pool deposit
  // Direct deposit: ?pp=eth&amt=1 (no from â†’ go straight to privacy tab)
  // Swap+deposit: ?from=eth&pp=bold&amt=1.5 (explicit from â†’ swap into pp asset)
  // Exact-out: ?from=usdc&to=eth&outamt=1 (exact output mode)
  const _dlPP = (_urlp.get('pp') || '').toUpperCase();
  const _ppIsDirect = (_dlPP === 'ETH' || _dlPP === 'BOLD') && !_dlFrom;
  if (!_ppIsDirect && _dlOutAmt && !isNaN(+_dlOutAmt) && +_dlOutAmt > 0) {
    _inputMode = 'exactOut';
    const ta = $("toAmount");
    if (ta) { ta.value = _dlOutAmt; setTimeout(() => handleAmountChange(), 50); }
  } else if (!_ppIsDirect && _dlAmt && !isNaN(+_dlAmt) && +_dlAmt > 0) {
    _inputMode = 'exactIn';
    const fa = $("fromAmount");
    if (fa) { fa.value = _dlAmt; setTimeout(() => handleAmountChange(), 50); }
  }
  const _dlRecv = (_urlp.get('recv') || '').trim();
  if (_dlRecv) {
    const ri = $("receiverAddress");
    if (ri) { ri.value = _dlRecv; setTimeout(() => onReceiverInput(), 50); }
    // Expand the receiver accordion
    const rw = $("receiverWrap");
    if (rw) { rw.style.maxHeight = '80px'; rw.style.opacity = '1'; }
    const chev = document.querySelector('.receiver-toggle .chevron');
    if (chev) chev.textContent = '\u25BC';
  }
  if (_dlPP === 'ETH' || _dlPP === 'BOLD') {
    _ppSelectedAsset = _dlPP;
    if (_ppIsDirect) {
      // Direct deposit â€” skip swap panel, go straight to privacy tab
      ppSyncAssetUI(_dlPP);
      if (_dlAmt && !isNaN(+_dlAmt) && +_dlAmt > 0) $('ppAmount').value = _dlAmt;
      switchTab('privacy');
    } else {
      // Swap + deposit into PP
      _ppSwapEnabled = true;
      const cb = $('ppSwapToggle');
      if (cb) cb.checked = true;
      setShown('ppSwapAssetWrap', true);
      ppSyncAssetUI(_dlPP);
      if (toToken !== _dlPP) { _ppSavedToToken = toToken; toToken = _dlPP; }
      if (!_ppConfig) setTimeout(() => loadPPConfig(), 100);
    }
  }
  updateTokenDisplay();
  initTokenListClick();
  initTokenSearch();
  const fromEl = $("fromAmount");
  if (fromEl) fromEl.addEventListener("input", debounce(() => { _inputMode = 'exactIn'; handleAmountChange(); }, 400));
  const toEl = $("toAmount");
  if (toEl) toEl.addEventListener("input", debounce(() => { _inputMode = 'exactOut'; handleAmountChange(); }, 400));
  // Defer heavy localStorage parsing until after first render
  (window.requestIdleCallback || setTimeout)(() => loadWeiLists());
});

// Swap button click
$("swapBtn").addEventListener("click", () => {
  if (!connectedAddress) { showWalletModal(); return; }
  executeSwap();
});

// ---- Auto-reconnect (non-blocking) ----
window.addEventListener("load", () => {
  const savedWallet = localStorage.getItem('zswap_wallet');
  if (!savedWallet) return;
  setText('walletBtn', '...');
  // Fire-and-forget: don't block page interactivity
  setTimeout(async () => {
    try {
      window.dispatchEvent(new Event('eip6963:requestProvider'));
      await new Promise(r => setTimeout(r, 300));
      await connectWithWallet(savedWallet);
    } catch (e) {
      console.error("Auto-reconnect failed:", e);
      setText('walletBtn', 'connect');
    }
  }, 100);
});

const PP_ENTRYPOINT = "0x6818809eefce719e480a7526d76bd3e561526b46";
const PP_ENTRYPOINT_ABI = [
  "function deposit(uint256) payable returns (uint256)",
  "function deposit(address,uint256,uint256) returns (uint256)",
  "function assetConfig(address) view returns (address pool, uint256 minimumDepositAmount, uint256 vettingFeeBPS, uint256 maxRelayFeeBPS)",
  "function latestRoot() view returns (uint256)",
  "function usedPrecommitments(uint256) view returns (bool)"
];
const PP_POOL_EVENTS = new ethers.Interface([
  "event Deposited(address indexed _depositor, uint256 _commitment, uint256 _label, uint256 _value, uint256 _precommitmentHash)",
  "event LeafInserted(uint256 _index, uint256 _leaf, uint256 _root)"
]);
const SNARK_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;

let _ppMasterKeys = null; // { masterNullifier, masterSecret, address }

async function ppDeriveWalletSeed(signer, address) {
  const domain = { name: 'Privacy Pools', version: '1' };
  const types = {
    DeriveSeed: [
      { name: 'action', type: 'string' },
      { name: 'context', type: 'string' },
      { name: 'addressHash', type: 'bytes32' },
    ]
  };
  const message = {
    action: 'Derive Account Seed',
    context: 'privacy-pools/wallet-seed:v2',
    addressHash: ethers.keccak256(address),
  };
  const sig = await signer.signTypedData(domain, types, message);
  const sigBytes = ethers.getBytes(sig);
  const r = sigBytes.slice(0, 32);

  // HKDF-SHA256: IKM=r, salt=address bytes, info="privacy-pools/wallet-seed:v2", len=32
  const ikm = await crypto.subtle.importKey('raw', r, 'HKDF', false, ['deriveBits']);
  const hkdfBits = await crypto.subtle.deriveBits(
    { name: 'HKDF', hash: 'SHA-256', salt: ethers.getBytes(address), info: new TextEncoder().encode('privacy-pools/wallet-seed:v2') },
    ikm, 256
  );
  return ethers.Mnemonic.fromEntropy(new Uint8Array(hkdfBits));
}

function ppDeriveMasterKeys(mnemonic) {
  const key1 = ethers.HDNodeWallet.fromMnemonic(mnemonic, "m/44'/60'/0'/0/0").privateKey;
  const key2 = ethers.HDNodeWallet.fromMnemonic(mnemonic, "m/44'/60'/1'/0/0").privateKey;
  const masterNullifier = poseidon1([BigInt(Number(BigInt(key1)))]);
  const masterSecret = poseidon1([BigInt(Number(BigInt(key2)))]);
  return { masterNullifier, masterSecret };
}

function ppDeriveDepositKeys(masterNullifier, masterSecret, scope, index) {
  const nullifier = poseidon3([masterNullifier, scope, BigInt(index)]);
  const secret = poseidon3([masterSecret, scope, BigInt(index)]);
  const precommitment = poseidon2([nullifier, secret]);
  return { nullifier, secret, precommitment };
}

async function ppFindUnusedDepositIndex(masterNullifier, masterSecret, scope, startIndex) {
  const rpc = await quoteRPC.call(r => r);
  const ep = new ethers.Contract(PP_ENTRYPOINT, PP_ENTRYPOINT_ABI, rpc);
  let idx = startIndex;
  for (let i = 0; i < 20; i++) {
    const keys = ppDeriveDepositKeys(masterNullifier, masterSecret, scope, idx);
    const used = await ep.usedPrecommitments(keys.precommitment);
    if (!used) return idx;
    idx++;
  }
  throw new Error('Could not find unused deposit index after 20 attempts');
}

// H-4: Label-based withdrawal key derivation (SDK-compatible for change commitments)
function ppDeriveWithdrawalKeys(masterNullifier, masterSecret, label, withdrawalIndex) {
  const nullifier = poseidon3([masterNullifier, label, BigInt(withdrawalIndex)]);
  const secret = poseidon3([masterSecret, label, BigInt(withdrawalIndex)]);
  const precommitment = poseidon2([nullifier, secret]);
  return { nullifier, secret, precommitment };
}

function ppGetWithdrawalIndex(address, label) {
  const key = `pp_withdraw_idx_${address.toLowerCase()}_${label}`;
  return parseInt(localStorage.getItem(key) || '0', 10);
}

function ppSetWithdrawalIndex(address, label, index) {
  const key = `pp_withdraw_idx_${address.toLowerCase()}_${label}`;
  localStorage.setItem(key, index.toString());
}

async function ppEnsureMasterKeys() {
  if (_ppMasterKeys && _ppMasterKeys.address === connectedAddress) return _ppMasterKeys;
  const mnemonic = await ppDeriveWalletSeed(signer, connectedAddress);
  const keys = ppDeriveMasterKeys(mnemonic);
  _ppMasterKeys = { ...keys, address: connectedAddress };
  return _ppMasterKeys;
}

function ppGetDepositIndex(address, scope) {
  const key = `pp_deposit_idx_${address.toLowerCase()}_${scope}`;
  return parseInt(localStorage.getItem(key) || '0', 10);
}

function ppSetDepositIndex(address, scope, index) {
  const key = `pp_deposit_idx_${address.toLowerCase()}_${scope}`;
  localStorage.setItem(key, index.toString());
}

const PP_ETH_POOL = '0xF241d57C6DebAe225c0F2e6eA1529373C9A9C9fB';
const PP_ETH_ASSET = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
const PP_BOLD_POOL = '0xb4b5Fd38Fd4788071d7287e3cB52948e0d10b23E';

function ppComputeScope(asset) {
  const isETH = (!asset || asset === 'ETH');
  const poolAddress = isETH ? (_ppConfig?.pool || PP_ETH_POOL) : (_ppConfigBold?.pool || PP_BOLD_POOL);
  const assetAddress = isETH ? PP_ETH_ASSET : BOLD_ADDRESS;
  return BigInt(ethers.keccak256('0x' +
    poolAddress.slice(2).toLowerCase() +
    '0000000000000000000000000000000000000000000000000000000000000001' +
    assetAddress.slice(2).toLowerCase()
  )) % SNARK_FIELD;
}

let _ppConfig = null; // { pool, minimumDepositAmount, vettingFeeBPS }
let _ppConfigBold = null; // { pool, minimumDepositAmount, vettingFeeBPS }
let _ppSelectedAsset = 'ETH'; // 'ETH' or 'BOLD'
let _ppSwapEnabled = false;
let _ppSavedToToken = null; // saved toToken before PP lock

const PP_DEPOSIT_IFACE = new ethers.Interface([
  "function deposit(uint256) payable returns (uint256)",
  "function deposit(address,uint256,uint256) returns (uint256)"
]);

function parsePPDepositReceipt(receipt) {
  let value, label, commitment, leafIndex, root;
  for (const log of receipt.logs) {
    try {
      const parsed = PP_POOL_EVENTS.parseLog({ topics: log.topics, data: log.data });
      if (parsed.name === 'Deposited') {
        commitment = parsed.args._commitment;
        label = parsed.args._label;
        value = parsed.args._value;
      } else if (parsed.name === 'LeafInserted') {
        leafIndex = parsed.args._index;
        root = parsed.args._root;
      }
    } catch {}
  }
  return { value, label, commitment, leafIndex, root };
}

// Build the full note JSON with all fields needed for withdrawal
function buildPPNote(nullifier, secret, depositInfo, asset) {
  const note = {
    nullifier: '0x' + nullifier.toString(16).padStart(64, '0'),
    secret: '0x' + secret.toString(16).padStart(64, '0'),
  };
  if (asset && asset !== 'ETH') note.asset = asset;
  if (depositInfo) {
    if (depositInfo.value != null) note.value = depositInfo.value.toString();
    if (depositInfo.label != null) note.label = '0x' + BigInt(depositInfo.label).toString(16).padStart(64, '0');
    if (depositInfo.leafIndex != null) note.leafIndex = Number(depositInfo.leafIndex);
    if (depositInfo.commitment != null) note.commitment = '0x' + BigInt(depositInfo.commitment).toString(16).padStart(64, '0');
    if (depositInfo.root != null) note.root = '0x' + BigInt(depositInfo.root).toString(16).padStart(64, '0');
  }
  return JSON.stringify(note);
}

function ppSyncAssetUI(asset) {
  // Privacy tab buttons
  const ethBtn = $('ppAssetETH'), boldBtn = $('ppAssetBOLD');
  if (ethBtn) { ethBtn.style.background = asset === 'ETH' ? 'var(--btn-bg)' : 'var(--surface)'; ethBtn.style.color = asset === 'ETH' ? 'var(--btn-fg)' : 'var(--fg-muted)'; ethBtn.style.borderColor = asset === 'ETH' ? 'var(--btn-bg)' : 'transparent'; }
  if (boldBtn) { boldBtn.style.background = asset === 'BOLD' ? 'var(--btn-bg)' : 'var(--surface)'; boldBtn.style.color = asset === 'BOLD' ? 'var(--btn-fg)' : 'var(--fg-muted)'; boldBtn.style.borderColor = asset === 'BOLD' ? 'var(--btn-bg)' : 'transparent'; }
  // Swap tab buttons â€” disable the one matching fromToken (same-token swap+deposit is just a direct deposit)
  const sEth = $('ppSwapAssetETH'), sBold = $('ppSwapAssetBOLD');
  const ethDisabled = fromToken === 'ETH';
  const boldDisabled = fromToken === 'BOLD';
  if (sEth) {
    sEth.disabled = ethDisabled;
    sEth.style.background = asset === 'ETH' ? 'var(--btn-bg)' : 'var(--surface)';
    sEth.style.color = ethDisabled ? 'var(--fg-dim)' : (asset === 'ETH' ? 'var(--btn-fg)' : 'var(--fg-muted)');
    sEth.style.borderColor = asset === 'ETH' ? 'var(--btn-bg)' : 'transparent';
    sEth.style.opacity = ethDisabled ? '0.4' : '1';
    sEth.style.cursor = ethDisabled ? 'not-allowed' : 'pointer';
  }
  if (sBold) {
    sBold.disabled = boldDisabled;
    sBold.style.background = asset === 'BOLD' ? 'var(--btn-bg)' : 'var(--surface)';
    sBold.style.color = boldDisabled ? 'var(--fg-dim)' : (asset === 'BOLD' ? 'var(--btn-fg)' : 'var(--fg-muted)');
    sBold.style.borderColor = asset === 'BOLD' ? 'var(--btn-bg)' : 'transparent';
    sBold.style.opacity = boldDisabled ? '0.4' : '1';
    sBold.style.cursor = boldDisabled ? 'not-allowed' : 'pointer';
  }
  setText('ppAmountLabel', `Amount (${asset})`);
  setText('ppMinUnit', asset);
}

function ppSelectAsset(asset) {
  _ppSelectedAsset = asset;
  ppSyncAssetUI(asset);
  loadPPConfig();
  updatePPBalance();
  updatePPButton();
  syncPrivacyURL();
  if (_ppSwapEnabled) {
    if (toToken !== asset) { toToken = asset; updateTokenDisplay(); }
    handleAmountChange();
  }
}

function ppSwapSelectAsset(asset) {
  if (asset === fromToken) return;
  _ppSelectedAsset = asset;
  ppSyncAssetUI(asset);
  if (toToken !== asset) { toToken = asset; updateTokenDisplay(); }
  handleAmountChange();
  if (!_ppConfig) loadPPConfig();
}

function togglePPSwap() {
  const w = $('ppSwapWrap');
  const open = w.style.maxHeight === '0px';
  w.style.maxHeight = open ? '120px' : '0px';
  w.style.opacity = open ? '1' : '0';
  $('ppSwapChevron').textContent = open ? '\u25BC' : '\u25B6';
}

function onPPSwapToggle() {
  _ppSwapEnabled = $('ppSwapToggle').checked;
  setShown('ppSwapAssetWrap', _ppSwapEnabled);
  if (_ppSwapEnabled) {
    // Pick a PP deposit asset that differs from fromToken
    let target;
    if (toToken === 'ETH' || toToken === 'BOLD') {
      target = toToken;
    } else {
      target = _ppSelectedAsset;
    }
    if (target === fromToken) target = (fromToken === 'ETH') ? 'BOLD' : 'ETH';
    _ppSelectedAsset = target;
    ppSyncAssetUI(target);
    if (toToken !== target) { _ppSavedToToken = toToken; toToken = target; updateTokenDisplay(); }
    handleAmountChange();
    if (!_ppConfig) loadPPConfig();
  } else {
    // Restore previous token
    if (_ppSavedToToken && _ppSavedToToken !== toToken) { toToken = _ppSavedToToken; updateTokenDisplay(); }
    _ppSavedToToken = null;
    handleAmountChange();
  }
}

function ppSwapDownloadNote() {
  const note = $('ppSwapNoteText').value;
  if (!note) return;
  const blob = new Blob([note], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `privacy-pool-note-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
}

function randomFieldElement() {
  const bytes = new Uint8Array(32);
  crypto.getRandomValues(bytes);
  let n = 0n;
  for (let i = 0; i < 32; i++) n = (n << 8n) | BigInt(bytes[i]);
  return n % SNARK_FIELD;
}

function switchTab(tab) {
  _activeTab = tab;
  document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  $('swapTab').style.display = tab === 'swap' ? '' : 'none';
  $('privacyTab').style.display = tab === 'privacy' ? '' : 'none';
  if (tab === 'privacy') {
    syncPrivacyURL();
    loadPPConfig();
    updatePPBalance();
    renderPPNotes();
    updatePPButton();
  } else {
    syncSwapURL();
  }
}

async function loadPPConfig() {
  try {
    const rpc = await quoteRPC.call(r => r);
    const ep = new ethers.Contract(PP_ENTRYPOINT, PP_ENTRYPOINT_ABI, rpc);
    const [ethConfig, boldConfig] = await Promise.all([
      ep.assetConfig(PP_ETH_ASSET),
      ep.assetConfig(BOLD_ADDRESS)
    ]);
    _ppConfig = { pool: ethConfig.pool, minimumDepositAmount: ethConfig.minimumDepositAmount, vettingFeeBPS: ethConfig.vettingFeeBPS };
    _ppConfigBold = { pool: boldConfig.pool, minimumDepositAmount: boldConfig.minimumDepositAmount, vettingFeeBPS: boldConfig.vettingFeeBPS };
    const cfg = _ppSelectedAsset === 'BOLD' ? _ppConfigBold : _ppConfig;
    setText('ppFeeBps', cfg.vettingFeeBPS.toString());
    setText('ppMinDeposit', ethers.formatEther(cfg.minimumDepositAmount));
    setText('ppMinUnit', _ppSelectedAsset);
    setShown('ppFeeInfo', true);
  } catch (e) {
    console.warn("Failed to load PP config:", e);
  }
}

let _ppBalanceRaw = null;

function updatePPBalance() {
  if (!connectedAddress) { setText('ppBalance', ''); _ppBalanceRaw = null; return; }
  const asset = _ppSelectedAsset;
  const tokenAddr = asset === 'BOLD' ? BOLD_ADDRESS : ZERO_ADDRESS;
  const cached = getCachedBalance(tokenAddr);
  if (cached != null) {
    _ppBalanceRaw = cached;
    setText('ppBalance', `Balance: ${fmt(ethers.formatEther(cached))} ${asset}`);
  } else {
    _ppBalanceRaw = null;
    setText('ppBalance', 'Balance: ...');
  }
}

function setPPPercentBalance(pct) {
  if (!connectedAddress) { showWalletModal(); return; }
  if (_ppBalanceRaw == null) return;
  const amount = _ppBalanceRaw * BigInt(pct) / 100n;
  $('ppAmount').value = ethers.formatEther(amount);
  $('ppAmount').dispatchEvent(new Event('input'));
}

function updatePPButton() {
  const btn = $('ppDepositBtn');
  if (!btn) return;
  if (!connectedAddress) {
    setText(btn, 'Connect Wallet');
    setDisabled(btn, false);
    btn.onclick = () => showWalletModal();
    return;
  }
  const amt = $('ppAmount')?.value;
  if (!amt || isNaN(+amt) || +amt <= 0) {
    setText(btn, 'Enter an amount');
    setDisabled(btn, true);
    btn.onclick = null;
    return;
  }
  try {
    const wei = ethers.parseEther(amt);
    const cfg = _ppSelectedAsset === 'BOLD' ? _ppConfigBold : _ppConfig;
    if (cfg && wei < cfg.minimumDepositAmount) {
      setText(btn, `Min ${ethers.formatEther(cfg.minimumDepositAmount)} ${_ppSelectedAsset}`);
      setDisabled(btn, true);
      btn.onclick = null;
      return;
    }
  } catch {
    setText(btn, 'Invalid amount');
    setDisabled(btn, true);
    btn.onclick = null;
    return;
  }
  setText(btn, 'Deposit');
  setDisabled(btn, false);
  btn.onclick = ppDeposit;
}

async function ppDeposit() {
  const btn = $('ppDepositBtn');
  try {
    const amtStr = $('ppAmount').value;
    if (!amtStr || +amtStr <= 0) { showStatus("Enter an amount", "error"); return; }
    const amount = ethers.parseEther(amtStr);

    const isBOLD = _ppSelectedAsset === 'BOLD';
    const cfg = isBOLD ? _ppConfigBold : _ppConfig;
    if (cfg && amount < cfg.minimumDepositAmount) {
      showStatus(`Minimum deposit is ${ethers.formatEther(cfg.minimumDepositAmount)} ${_ppSelectedAsset}`, "error");
      return;
    }

    if (!signer) { showWalletModal(); return; }

    setText(btn, 'Deriving keys...');
    setDisabled(btn, true);

    const { masterNullifier, masterSecret } = await ppEnsureMasterKeys();
    const scope = ppComputeScope(_ppSelectedAsset);
    const depositIdx = await ppFindUnusedDepositIndex(masterNullifier, masterSecret, scope, ppGetDepositIndex(connectedAddress, scope));
    const { nullifier, secret, precommitment } = ppDeriveDepositKeys(masterNullifier, masterSecret, scope, depositIdx);

    let tx;
    if (isBOLD) {
      // BOLD: use zRouter multicall for single-tx atomic deposit
      // permit(BOLD) â†’ router.deposit(BOLD,0,amt) â†’ execute(PP, deposit(BOLD,amt,precom))
      const ppDepositData = PP_DEPOSIT_IFACE.encodeFunctionData('deposit(address,uint256,uint256)', [BOLD_ADDRESS, amount, precommitment]);
      const routerPull = ROUTER_IFACE.encodeFunctionData('deposit', [BOLD_ADDRESS, 0, amount]);
      const executeCall = ROUTER_IFACE.encodeFunctionData('execute', [PP_ENTRYPOINT, 0, ppDepositData]);
      const sweepCall = ROUTER_IFACE.encodeFunctionData('sweep', [BOLD_ADDRESS, 0, 0, connectedAddress]);

      let permitPrefix = [];
      let approved = false;

      // Check existing router allowance
      const rpc = await quoteRPC.call(r => r);
      const boldRead = new ethers.Contract(BOLD_ADDRESS, ['function allowance(address,address) view returns (uint256)'], rpc);
      const routerAllowance = await boldRead.allowance(connectedAddress, ZROUTER_ADDRESS);
      if (routerAllowance >= amount) approved = true;

      // Try EIP-2612 permit (gasless signature, single tx)
      if (!approved) {
        const permitCfg = await getPermitConfig(BOLD_ADDRESS);
        if (permitCfg) {
          try {
            setText(btn, 'Sign permit...');
            const permitData = await signPermit(permitCfg, BOLD_ADDRESS);
            const permitCall = ROUTER_IFACE.encodeFunctionData('permit', [BOLD_ADDRESS, ethers.MaxUint256, permitData.deadline, permitData.v, permitData.r, permitData.s]);
            permitPrefix = [permitCall];
            approved = true;
          } catch (e) {
            if (/user rejected|user denied|user cancelled/i.test(String(e?.message))) throw e;
            console.warn("BOLD permit failed, falling back to approve:", e);
          }
        }
      }

      // Fallback: traditional approve (separate tx)
      if (!approved) {
        setText(btn, 'Approve BOLD...');
        const boldW = new ethers.Contract(BOLD_ADDRESS, ['function approve(address,uint256) returns (bool)'], signer);
        const approveTx = await wcTransaction(boldW.approve(ZROUTER_ADDRESS, ethers.MaxUint256), 'Approve BOLD spending');
        await waitForTx(approveTx);
      }

      // M-6: Preflight check â€” router must have BOLD allowance to PP entrypoint
      const rpcPreflight = await quoteRPC.call(r => r);
      const boldPreflight = new ethers.Contract(BOLD_ADDRESS, ['function allowance(address,address) view returns (uint256)'], rpcPreflight);
      const routerToEPAllowance = await boldPreflight.allowance(ZROUTER_ADDRESS, PP_ENTRYPOINT);
      if (routerToEPAllowance < amount) {
        showStatus('Router lacks BOLD allowance to Privacy Pool entrypoint. Contact the zFi team to configure router approval.', 'error');
        return;
      }

      setText(btn, 'Confirm in wallet...');
      const ppMulticall = ROUTER_IFACE.encodeFunctionData('multicall', [[...permitPrefix, routerPull, executeCall, sweepCall]]);
      tx = await wcTransaction(
        signer.sendTransaction({ to: ZROUTER_ADDRESS, data: ppMulticall, value: 0n }),
        'Confirm BOLD Privacy Pool deposit'
      );
    } else {
      const ep = new ethers.Contract(PP_ENTRYPOINT, PP_ENTRYPOINT_ABI, signer);
      setText(btn, 'Confirm in wallet...');
      tx = await wcTransaction(
        ep['deposit(uint256)'](precommitment, { value: amount }),
        'Confirm Privacy Pool deposit'
      );
    }
    // Increment index immediately after tx submitted (before confirmation) to prevent reuse if tab closes
    ppSetDepositIndex(connectedAddress, scope, depositIdx + 1);

    // Show partial note immediately (nullifier+secret) â€” user must save before anything else
    const partialNote = buildPPNote(nullifier, secret, null, _ppSelectedAsset);
    $('ppNote').value = partialNote;
    setShown('ppNoteBox', true);

    // Save partial note to localStorage
    let noteIdx;
    try {
      const saved = JSON.parse(localStorage.getItem('pp_notes') || '[]');
      noteIdx = saved.length;
      saved.push({ note: partialNote, amount: amount.toString(), asset: _ppSelectedAsset, timestamp: Date.now(), txHash: tx.hash });
      localStorage.setItem('pp_notes', JSON.stringify(saved));
      renderPPNotes();
    } catch (_lsErr) {
      noteIdx = -1;
      alert("CRITICAL: Could not save note to browser storage. Copy your note NOW from the text area â€” you need it to withdraw.");
    }

    btn.innerHTML = `Confirming deposit... <a href="https://etherscan.io/tx/${escAttr(tx.hash)}" target="_blank" style="color:inherit;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
    const receipt = await waitForTx(tx);

    if (receipt && receipt.status === 1) {
      // Parse deposit events to get value, label, leafIndex, commitment
      const depositInfo = parsePPDepositReceipt(receipt);
      const fullNote = buildPPNote(nullifier, secret, depositInfo, _ppSelectedAsset);
      $('ppNote').value = fullNote;
      // Update localStorage with full note
      try {
        const updSaved = JSON.parse(localStorage.getItem('pp_notes') || '[]');
        if (noteIdx >= 0 && updSaved[noteIdx]) { updSaved[noteIdx].note = fullNote; localStorage.setItem('pp_notes', JSON.stringify(updSaved)); renderPPNotes(); }
      } catch (_) {}
      showStatus('Deposit confirmed! Save your note to withdraw later.', 'success');
    } else {
      showStatus('Transaction may have failed. Check Etherscan. Your note has been saved.', 'error');
    }
    updatePPBalance();
  } catch (e) {
    console.error('ppDeposit error:', e);
    const errStr = String(e?.data || e?.message || e?.reason || e || '');
    const ppDepositErrors = {
      'INSUFFICIENT_FUNDS': `Insufficient ${_ppSelectedAsset} balance for this deposit.`,
      'insufficient funds': `Insufficient ${_ppSelectedAsset} balance for this deposit.`,
      'PrecommitmentAlreadyUsed': 'This precommitment has already been used. Try a new deposit.',
      'InsufficientAllowance': 'Insufficient token allowance. Please approve spending first.',
      'InsufficientBalance': 'Insufficient balance for this deposit amount.',
    };
    let decoded = false;
    for (const [key, msg] of Object.entries(ppDepositErrors)) {
      if (errStr.includes(key)) { showStatus(msg, 'error'); decoded = true; break; }
    }
    if (!decoded) handleError(e);
  } finally {
    updatePPButton();
  }
}

function downloadNote() {
  const note = $('ppNote').value;
  if (!note) return;
  const blob = new Blob([note], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `privacy-pool-note-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
}

function renderPPNotes() {
  const saved = JSON.parse(localStorage.getItem('pp_notes') || '[]');
  setText('ppNoteCount', saved.length.toString());
  const list = $('ppNotesList');
  if (!list) return;
  if (saved.length === 0) {
    list.innerHTML = '<div style="color:var(--fg-muted);padding:8px 0">No saved notes</div>';
    return;
  }
  list.innerHTML = saved.map((entry, i) => {
    const date = new Date(entry.timestamp).toLocaleDateString();
    const unit = escText(entry.asset || 'ETH');
    const amtStr = entry.amount ? escText(fmt(ethers.formatEther(BigInt(entry.amount)))) + ` ${unit}` : '?';
    const typeLabel = entry.isChange ? '<span style="color:orange;font-weight:600">CHANGE</span> ' : '';
    const txLink = entry.txHash ? `<a href="https://etherscan.io/tx/${escAttr(entry.txHash)}" target="_blank" rel="noopener" style="font-size:11px">tx</a>` : '';
    return `<div style="padding:6px 0;border-bottom:1px solid var(--border-muted);display:flex;align-items:center;justify-content:space-between;gap:8px">
      <div style="min-width:0">
        <div style="font-size:11px;color:var(--fg-muted)">${typeLabel}${escText(date)} &middot; ${amtStr} ${txLink}</div>
        <div style="font-family:monospace;font-size:10px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:260px;opacity:0.6">${escText(entry.note)}</div>
      </div>
      <div style="display:flex;gap:4px;flex-shrink:0">
        <button onclick="navigator.clipboard.writeText(ppGetNote(${i}))" style="font-size:10px;padding:2px 6px;cursor:pointer;background:var(--btn-bg);color:var(--btn-fg);border:1px solid var(--border);border-radius:0">Copy</button>
        <button onclick="ppDeleteNote(${i})" style="font-size:10px;padding:2px 6px;cursor:pointer;background:none;color:var(--remove-fg);border:1px solid var(--border-muted);border-radius:0">Del</button>
      </div>
    </div>`;
  }).join('');
}

function ppGetNote(index) {
  const saved = JSON.parse(localStorage.getItem('pp_notes') || '[]');
  return saved[index]?.note || '';
}

function ppDeleteNote(index) {
  try {
    const saved = JSON.parse(localStorage.getItem('pp_notes') || '[]');
    saved.splice(index, 1);
    localStorage.setItem('pp_notes', JSON.stringify(saved));
  } catch (_) { /* storage unavailable */ }
  renderPPNotes();
}

// Wire up ppAmount input
document.addEventListener("DOMContentLoaded", () => {
  const ppAmtEl = $("ppAmount");
  if (ppAmtEl) ppAmtEl.addEventListener("input", () => { updatePPButton(); syncPrivacyURL(); });

  // Populate PP asset selector icons
  document.querySelectorAll('.pp-icon-16[data-icon]').forEach(el => {
    const icon = ICONS[el.dataset.icon];
    if (icon) el.innerHTML = icon;
  });
  document.querySelectorAll('.pp-icon-18[data-icon]').forEach(el => {
    const icon = ICONS[el.dataset.icon];
    if (icon) el.innerHTML = icon;
  });

  // Restore saved Etherscan API key
  const _savedEsKey = localStorage.getItem('pp_etherscan_key');
  if (_savedEsKey && $('ppwEtherscanKey')) $('ppwEtherscanKey').value = _savedEsKey;

  // Deeplink: ?tab=privacy or #privacy
  const _urlp2 = new URLSearchParams(window.location.search);
  if (_urlp2.get('tab') === 'privacy' || window.location.hash === '#privacy') switchTab('privacy');

  // Init saved notes count
  renderPPNotes();
});

const PP_POOL_ABI = [
  "function withdraw(tuple(address,bytes),tuple(uint256[2],uint256[2][2],uint256[2],uint256[8]))",
  "function SCOPE() view returns (uint256)",
  "function currentRoot() view returns (uint256)",
  "event LeafInserted(uint256 _index, uint256 _leaf, uint256 _root)",
  "event Deposited(address indexed _depositor, uint256 _commitment, uint256 _label, uint256 _value, uint256 _precommitmentHash)"
];
const PP_POOL_DEPLOY_BLOCK = 22100000; // before first pool deposit (pool creation may predate entrypoint)
const PP_MAX_TREE_DEPTH = 32;
const PP_WITHDRAW_WASM = "https://privacypools.com/artifacts/withdraw.wasm";
const PP_WITHDRAW_ZKEY = "https://privacypools.com/artifacts/withdraw.zkey";

let _ppwNote = null;

// LeanIMT: build tree from ordered leaves using poseidon2
function leanIMTBuild(leaves) {
  if (leaves.length === 0) return { levels: [[]], depth: 0, root: 0n };
  const levels = [leaves.map(l => BigInt(l))];
  while (levels[levels.length - 1].length > 1) {
    const curr = levels[levels.length - 1];
    const next = [];
    for (let i = 0; i < curr.length; i += 2) {
      if (i + 1 < curr.length) next.push(poseidon2([curr[i], curr[i + 1]]));
      else next.push(curr[i]);
    }
    levels.push(next);
  }
  return { levels, depth: levels.length - 1, root: levels[levels.length - 1][0] };
}

// LeanIMT: Merkle proof for leaf at index, padded to PP_MAX_TREE_DEPTH
function leanIMTProof(levels, leafIndex) {
  const siblings = [];
  let idx = leafIndex;
  for (let d = 0; d < levels.length - 1; d++) {
    const sib = idx ^ 1;
    siblings.push(sib < levels[d].length ? levels[d][sib] : 0n);
    idx = idx >> 1;
  }
  while (siblings.length < PP_MAX_TREE_DEPTH) siblings.push(0n);
  return siblings;
}

function ppwParseNote() {
  const raw = $('ppwNote').value.trim();
  if (!raw) { showStatus('Paste a note JSON', 'error'); _ppwNote = null; setDisabled('ppwWithdrawBtn', true); return; }
  let note;
  try { note = JSON.parse(raw); } catch { showStatus('Invalid JSON', 'error'); _ppwNote = null; setDisabled('ppwWithdrawBtn', true); return; }
  if (!note.nullifier || !note.secret) { showStatus('Note must have nullifier and secret', 'error'); _ppwNote = null; setDisabled('ppwWithdrawBtn', true); return; }

  const nullifier = BigInt(note.nullifier);
  const secret = BigInt(note.secret);
  const precommitment = poseidon2([nullifier, secret]);

  // R-6: Normalize and validate asset to canonical ETH/BOLD
  const rawAsset = (note.asset || 'ETH').toUpperCase().trim();
  const noteAsset = (rawAsset === 'BOLD') ? 'BOLD' : 'ETH';
  if (note.asset && rawAsset !== 'ETH' && rawAsset !== 'BOLD') {
    showStatus('Unrecognized note asset "' + escText(note.asset) + '", defaulting to ETH.', 'error');
  }
  _ppwNote = { nullifier, secret, precommitment, asset: noteAsset };

  setText('ppwNullifier', note.nullifier);
  setText('ppwSecret', note.secret);
  setText('ppwPrecommitment', '0x' + precommitment.toString(16).padStart(64, '0'));

  if (note.leafIndex != null) $('ppwLeafIndex').value = note.leafIndex;
  if (note.value != null) $('ppwValue').value = note.value;
  if (note.label != null) $('ppwLabel').value = note.label;
  if (note.commitment != null) $('ppwCommitment').value = note.commitment;

  setShown('ppwParsed', true);
  setDisabled('ppwWithdrawBtn', false);
}

function ppwUploadNote(event) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = e => { $('ppwNote').value = e.target.result; ppwParseNote(); };
  reader.readAsText(file);
}

async function ppwWithdraw() {
  const statusEl = $('ppwVerifyStatus');
  const statusBox = $('ppwVerify');
  const btn = $('ppwWithdrawBtn');

  function log(msg) { setShown(statusBox, true); statusEl.innerHTML += msg + '<br>'; }
  function logReplace(msg) { setShown(statusBox, true); statusEl.innerHTML = msg; }

  try {
    setDisabled(btn, true);
    setText(btn, 'Working...');
    statusEl.innerHTML = '';

    // Validate inputs
    if (!_ppwNote) { showStatus('Parse a note first', 'error'); return; }
    const leafIndex = parseInt($('ppwLeafIndex').value);
    const value = BigInt($('ppwValue').value || '0');
    const label = BigInt($('ppwLabel').value || '0');
    if (isNaN(leafIndex)) { showStatus('Leaf index required', 'error'); return; }
    if (value === 0n) { showStatus('Value (wei) required', 'error'); return; }
    if (label === 0n) { showStatus('Label required', 'error'); return; }
    const withdrawAmtRaw = $('ppwWithdrawAmt').value.trim();
    const withdrawnValue = withdrawAmtRaw ? BigInt(withdrawAmtRaw) : value;
    if (withdrawnValue > value) { showStatus('Withdraw amount exceeds deposit value', 'error'); return; }
    if (withdrawnValue === 0n) { showStatus('Withdraw amount must be > 0', 'error'); return; }

    const customRecipient = $('ppwRecipient').value.trim();
    // Direct pool.withdraw requires msg.sender == processooor (InvalidProcessooor revert).
    // Custom recipients need relay mode which is not yet supported â€” force self-withdrawal.
    if (customRecipient && customRecipient.toLowerCase() !== connectedAddress?.toLowerCase()) {
      showStatus('Direct withdrawal requires recipient = connected wallet. Custom recipients require relay mode (not yet supported).', 'error');
      return;
    }
    const recipient = connectedAddress;
    if (!recipient) { showStatus('Connect wallet first', 'error'); return; }
    if (!signer) { showWalletModal(); return; }

    log('Validating inputs...');

    // Resolve pool and scope from note asset (H-2: support BOLD withdrawal)
    const wAsset = _ppwNote.asset || 'ETH';
    const wIsBOLD = wAsset === 'BOLD';
    const poolAddress = wIsBOLD ? (_ppConfigBold?.pool || PP_BOLD_POOL) : (_ppConfig?.pool || PP_ETH_POOL);
    const SCOPE = ppComputeScope(wAsset);
    log('Asset: ' + wAsset + ' Pool: ' + poolAddress.slice(0, 10) + '... SCOPE: ' + SCOPE.toString().slice(0, 16) + '...');

    // Fetch state tree + ASP leaves from 0xbow API (primary), Etherscan fallback for state tree
    log('Fetching tree data from 0xbow API...');
    let treeLeaves, aspLeaves;
    let aspFromAPI = false;
    try {
      const aspResp = await fetch('https://api.0xbow.io/1/public/mt-leaves', {
        headers: { 'X-Pool-Scope': SCOPE.toString() }
      });
      if (!aspResp.ok) throw new Error('HTTP ' + aspResp.status);
      const aspData = await aspResp.json();
      if (!aspData.aspLeaves || !Array.isArray(aspData.aspLeaves) || aspData.aspLeaves.length === 0) {
        throw new Error('No ASP leaves returned');
      }
      aspLeaves = aspData.aspLeaves.map(l => BigInt(l));
      // Use stateTreeLeaves from the same API response if available
      if (aspData.stateTreeLeaves && Array.isArray(aspData.stateTreeLeaves) && aspData.stateTreeLeaves.length > 0) {
        treeLeaves = aspData.stateTreeLeaves.map(l => BigInt(l));
        aspFromAPI = true;
        log('Fetched ' + treeLeaves.length + ' state leaves + ' + aspLeaves.length + ' ASP leaves from 0xbow API.');
      } else {
        log('Fetched ' + aspLeaves.length + ' ASP leaves (no state tree in API response â€” falling back to Etherscan).');
      }
    } catch (aspErr) {
      showStatus('Failed to fetch data from 0xbow API: ' + aspErr.message + '. The API may be unavailable.', 'error');
      return;
    }

    // Etherscan fallback: only if API didn't provide state tree leaves
    let esShifted = false;
    if (!treeLeaves) {
      const esKey = ($('ppwEtherscanKey')?.value || '').trim() || localStorage.getItem('pp_etherscan_key') || '';
      if (!esKey) { showStatus('Etherscan API key required for state tree fallback â€” expand the field above and paste your free key from etherscan.io/myapikey', 'error'); return; }
      log('Fetching state tree leaves via Etherscan (fallback)...');
      const leaves = [];
      let lastEventRoot = null;
      const LEAF_TOPIC = '0xcb249c8292372bd11f567786635483fca9e635030baafca55ff1a8940141d221';
      let esFrom = PP_POOL_DEPLOY_BLOCK;
      let batch = 0;

      const ES_MAX_BATCHES = 200; // safety cap (~200k leaves)
      while (batch < ES_MAX_BATCHES) {
        batch++;
        const url = 'https://api.etherscan.io/v2/api?chainid=1&module=logs&action=getLogs' +
          '&address=' + poolAddress +
          '&topic0=' + LEAF_TOPIC +
          '&fromBlock=' + esFrom + '&toBlock=latest' +
          '&page=1&offset=1000' +
          '&apikey=' + esKey;
        let json;
        for (let attempt = 0; attempt < 10; attempt++) {
          logReplace('Fetching leaves batch ' + batch + (attempt ? ' (retry ' + attempt + ')' : '') +
            '... (' + leaves.length + ' so far, from block ' + esFrom + ')');
          try {
            const resp = await fetch(url);
            json = await resp.json();
          } catch (fetchErr) {
            log('Network error, retrying in 8s... (' + fetchErr.message + ')');
            await new Promise(r => setTimeout(r, 8000));
            continue;
          }
          if (json.status === '1' && Array.isArray(json.result)) break;
          const errMsg = typeof json.result === 'string' ? json.result : json.message || 'unknown error';
          log('Etherscan: ' + errMsg + ', retrying in 8s...');
          json = null;
          await new Promise(r => setTimeout(r, 8000));
        }
        if (!json || json.status !== '1' || !Array.isArray(json.result) || json.result.length === 0) break;
        for (const entry of json.result) {
          const d = entry.data.slice(2);
          leaves[parseInt(d.slice(0, 64), 16)] = BigInt('0x' + d.slice(64, 128));
          lastEventRoot = BigInt('0x' + d.slice(128, 192));
        }
        if (json.result.length < 1000) break;
        const lastBlockHex = json.result[json.result.length - 1].blockNumber;
        esFrom = parseInt(lastBlockHex, 16) + 1;
        await new Promise(r => setTimeout(r, 5500));
      }
      if (leaves.length === 0) { showStatus('Failed to fetch leaves from Etherscan. Check your API key and try again.', 'error'); return; }
      // Check for gaps in sparse array
      for (let i = 0; i < leaves.length; i++) {
        if (leaves[i] === undefined) leaves[i] = 0n;
      }
      // If only gap is index 0, the contract may 1-index events
      if (leaves[0] === 0n && leaves.length > 1 && leaves[1] !== 0n) {
        const leavesShifted = leaves.slice(1);
        const treeShifted = leanIMTBuild(leavesShifted);
        if (lastEventRoot && treeShifted.root === lastEventRoot) {
          log('Contract uses 1-based leaf indexing. Adjusting (index ' + leafIndex + ' â†’ position ' + (leafIndex - 1) + ').');
          treeLeaves = leavesShifted;
          esShifted = true;
        }
      }
      if (!treeLeaves) treeLeaves = leaves;
      log('Fetched ' + treeLeaves.length + ' state leaves via Etherscan (fallback).');
    }

    // API-sourced leaves are 0-indexed dense arrays â€” leafIndex maps directly.
    // Etherscan-sourced may have been shifted above if contract uses 1-based indexing.
    let adjustedLeafIndex = leafIndex;
    if (typeof esShifted !== 'undefined' && esShifted) {
      adjustedLeafIndex = leafIndex - 1;
    }

    if (adjustedLeafIndex < 0 || adjustedLeafIndex >= treeLeaves.length) {
      showStatus('Leaf index ' + leafIndex + ' out of range (tree has ' + treeLeaves.length + ' leaves)', 'error');
      return;
    }

    // L-10: Always check tree leaf at position is non-empty; always verify commitment
    const treeLeaf = treeLeaves[adjustedLeafIndex];
    if (treeLeaf == null || treeLeaf === 0n) {
      showStatus('Tree leaf at position ' + adjustedLeafIndex + ' is empty. Verify your leaf index.', 'error');
      return;
    }
    // commitment = poseidon3([value, label, precommitment]) per protocol circuit
    const expectedCommitment = poseidon3([value, label, _ppwNote.precommitment]);
    if (treeLeaf !== expectedCommitment) {
      showStatus('Commitment mismatch at tree position ' + adjustedLeafIndex + ': expected 0x' + expectedCommitment.toString(16).slice(0, 16) + '... but tree has 0x' + treeLeaf.toString(16).slice(0, 16) + '... â€” check note data and leaf index.', 'error');
      return;
    }
    log('Commitment verified at tree position ' + adjustedLeafIndex + '.');

    // Build state Merkle tree
    log('Building state Merkle tree...');
    const stateTree = leanIMTBuild(treeLeaves);
    const stateSiblings = leanIMTProof(stateTree.levels, adjustedLeafIndex);
    log('State tree depth=' + stateTree.depth + ' root=0x' + stateTree.root.toString(16).slice(0, 16) + '...');

    // M-5: Validate reconstructed state root against on-chain pool.currentRoot()
    try {
      const rpc = await quoteRPC.call(r => r);
      const poolRO = new ethers.Contract(poolAddress, PP_POOL_ABI, rpc);
      const onChainStateRoot = await poolRO.currentRoot();
      if (stateTree.root !== onChainStateRoot) {
        // R-4: Protocol accepts a window of recent roots, not only currentRoot().
        // Warn but allow proceed â€” the on-chain verifier will reject if truly invalid.
        log('<b>Warning:</b> State tree root differs from on-chain currentRoot (local 0x' + stateTree.root.toString(16).slice(0, 16) + '... vs on-chain 0x' + onChainStateRoot.toString(16).slice(0, 16) + '...). This may still be accepted if within the recent root window.');
        showStatus('State root differs from latest on-chain root. Proceeding â€” withdrawal may still succeed if root is within accepted window. If it fails, retry in a few minutes.', 'error');
      } else {
        log('State root verified against on-chain pool.currentRoot().');
      }
    } catch (stateRootErr) {
      log('<b>Warning:</b> Could not verify state root on-chain (' + escText(stateRootErr.message) + '). Proceeding â€” tx may revert if state is stale.');
      showStatus('Could not verify state root on-chain (RPC issue). Withdrawal will proceed but may revert. Consider retrying if it fails.', 'error');
    }

    // Find our label in ASP leaves
    const aspIndex = aspLeaves.indexOf(label);
    if (aspIndex === -1) {
      showStatus('Your deposit label is not yet in the ASP association set. This can take up to 7 days after deposit. Try again later.', 'error');
      return;
    }
    log('Label found in ASP set at index ' + aspIndex + '.');

    // Build ASP Merkle tree
    const aspTree = leanIMTBuild(aspLeaves);
    const aspSiblings = leanIMTProof(aspTree.levels, aspIndex);
    log('ASP tree depth=' + aspTree.depth + ' root=0x' + aspTree.root.toString(16).slice(0, 16) + '...');

    // H-3: Verify ASP root matches on-chain latestRoot before proving
    log('Verifying ASP root against on-chain latestRoot...');
    try {
      const rpc = await quoteRPC.call(r => r);
      const ep = new ethers.Contract(PP_ENTRYPOINT, PP_ENTRYPOINT_ABI, rpc);
      const onChainASPRoot = await ep.latestRoot();
      if (aspTree.root !== onChainASPRoot) {
        showStatus('ASP root mismatch: local 0x' + aspTree.root.toString(16).slice(0, 16) + '... vs on-chain 0x' + onChainASPRoot.toString(16).slice(0, 16) + '... â€” API data is stale. Retry in a few minutes.', 'error');
        return;
      }
      log('ASP root verified against on-chain.');
    } catch (aspRootErr) {
      log('<b>Warning:</b> Could not verify ASP root on-chain (' + escText(aspRootErr.message) + '). Proceeding â€” tx may revert if root is stale.');
      showStatus('Could not verify ASP root on-chain (RPC issue). Withdrawal will proceed but may revert. Consider retrying if it fails.', 'error');
    }

    // Prepare circuit inputs
    log('Preparing circuit inputs...');
    const isPartial = withdrawnValue < value;
    const changeValue = value - withdrawnValue;
    let newNullifier, newSecret;
    if (isPartial && signer && connectedAddress) {
      // H-4: Use label-based derivation for change commitments (SDK-compatible)
      const mk = await ppEnsureMasterKeys();
      const changeIdx = ppGetWithdrawalIndex(connectedAddress, label.toString());
      const changeKeys = ppDeriveWithdrawalKeys(mk.masterNullifier, mk.masterSecret, label, changeIdx);
      newNullifier = changeKeys.nullifier;
      newSecret = changeKeys.secret;
    } else {
      newNullifier = randomFieldElement();
      newSecret = randomFieldElement();
    }
    const assetUnit = wAsset;
    if (isPartial) {
      log('Partial withdrawal: ' + ethers.formatEther(withdrawnValue) + ' ' + assetUnit + ' (change: ' + ethers.formatEther(changeValue) + ' ' + assetUnit + ')');
    }

    // context = keccak256(abi.encode(Withdrawal{processooor,data}, SCOPE)) % SNARK_FIELD
    const withdrawalData = '0x';
    const encoded = ethers.AbiCoder.defaultAbiCoder().encode(
      ['tuple(address,bytes)', 'uint256'],
      [[recipient, withdrawalData], SCOPE]
    );
    const context = BigInt(ethers.keccak256(encoded)) % SNARK_FIELD;

    const circuitInputs = {
      withdrawnValue: withdrawnValue.toString(),
      stateRoot: stateTree.root.toString(),
      stateTreeDepth: stateTree.depth.toString(),
      ASPRoot: aspTree.root.toString(),
      ASPTreeDepth: aspTree.depth.toString(),
      context: context.toString(),
      label: label.toString(),
      existingValue: value.toString(),
      existingNullifier: _ppwNote.nullifier.toString(),
      existingSecret: _ppwNote.secret.toString(),
      newNullifier: newNullifier.toString(),
      newSecret: newSecret.toString(),
      stateSiblings: stateSiblings.map(s => s.toString()),
      stateIndex: adjustedLeafIndex.toString(),
      ASPSiblings: aspSiblings.map(s => s.toString()),
      ASPIndex: aspIndex.toString()
    };

    // Lazy-load snarkjs
    if (typeof snarkjs === 'undefined') {
      log('Loading snarkjs...');
      await new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://unpkg.com/snarkjs@0.7.5/build/snarkjs.min.js';
        s.integrity = 'sha384-5C3lIE3PUFoPsYZ/bNSvfCiuptqUGqsf0RKUh9iAW3S7c62I3SUONh+JcJ7Bfcir';
        s.crossOrigin = 'anonymous';
        s.onload = resolve;
        s.onerror = () => reject(new Error('Failed to load snarkjs (integrity check may have failed)'));
        document.head.appendChild(s);
      });
    }

    // M-9: Download, verify artifact integrity, then pass Blob URLs to snarkjs
    log('Downloading & verifying proving artifacts...');
    const PP_EXPECTED_HASHES = {
      wasm: '36cda22791def3d520a55c0fc808369cd5849532a75fab65686e666ed3d55c10',
      zkey: '2a893b42174c813566e5c40c715a8b90cd49fc4ecf384e3a6024158c3d6de677'
    };
    async function fetchAndVerify(url, expectedHash, label) {
      const resp = await fetch(url);
      if (!resp.ok) throw new Error(label + ': HTTP ' + resp.status);
      const buf = await resp.arrayBuffer();
      const hashBuf = await crypto.subtle.digest('SHA-256', buf);
      const hash = Array.from(new Uint8Array(hashBuf)).map(b => b.toString(16).padStart(2, '0')).join('');
      if (hash !== expectedHash) throw new Error(label + ' integrity check failed: expected ' + expectedHash.slice(0, 16) + '... got ' + hash.slice(0, 16) + '...');
      // snarkjs expects URL strings â€” create Blob URL from verified buffer
      return URL.createObjectURL(new Blob([buf]));
    }
    const [wasmUrl, zkeyUrl] = await Promise.all([
      fetchAndVerify(PP_WITHDRAW_WASM, PP_EXPECTED_HASHES.wasm, 'withdraw.wasm'),
      fetchAndVerify(PP_WITHDRAW_ZKEY, PP_EXPECTED_HASHES.zkey, 'withdraw.zkey')
    ]);
    log('Artifacts verified.');

    // Generate ZK proof
    log('Generating ZK proof (30\u2013120s proving)...');
    let proof, publicSignals;
    try {
      ({ proof, publicSignals } = await snarkjs.groth16.fullProve(circuitInputs, wasmUrl, zkeyUrl));
    } finally {
      URL.revokeObjectURL(wasmUrl);
      URL.revokeObjectURL(zkeyUrl);
    }
    log('Proof generated!');

    // Convert snarkjs proof to Solidity format (pB components reversed for BN128)
    const pA = [BigInt(proof.pi_a[0]), BigInt(proof.pi_a[1])];
    const pB = [
      [BigInt(proof.pi_b[0][1]), BigInt(proof.pi_b[0][0])],
      [BigInt(proof.pi_b[1][1]), BigInt(proof.pi_b[1][0])]
    ];
    const pC = [BigInt(proof.pi_c[0]), BigInt(proof.pi_c[1])];
    const pubSigs = publicSignals.map(s => BigInt(s));

    // Submit withdrawal to pool contract
    log('Submitting withdrawal transaction...');
    const poolSigner = new ethers.Contract(poolAddress, PP_POOL_ABI, signer);
    const tx = await wcTransaction(
      poolSigner.withdraw([recipient, withdrawalData], [pA, pB, pC, pubSigs]),
      'Confirm Privacy Pool withdrawal'
    );
    log('Transaction submitted: ' + tx.hash);
    setText(btn, 'Waiting for confirmation...');

    const receipt = await waitForTx(tx);
    if (receipt && receipt.status === 1) {
      log('<b>Withdrawal confirmed!</b> ' + ethers.formatEther(withdrawnValue) + ' ' + assetUnit + ' sent to ' + recipient.slice(0, 10) + '...');

      // For partial withdrawals, save the change note
      if (isPartial) {
        // Parse LeafInserted event from receipt to get the new leaf index
        let changeLeafIndex, changeCommitment;
        for (const rlog of receipt.logs) {
          try {
            const parsed = PP_POOL_EVENTS.parseLog({ topics: rlog.topics, data: rlog.data });
            if (parsed.name === 'LeafInserted') {
              changeLeafIndex = Number(parsed.args._index);
              changeCommitment = '0x' + BigInt(parsed.args._leaf).toString(16).padStart(64, '0');
            }
          } catch {}
        }
        const changeNote = {
          nullifier: '0x' + newNullifier.toString(16).padStart(64, '0'),
          secret: '0x' + newSecret.toString(16).padStart(64, '0'),
          value: changeValue.toString(),
          label: '0x' + label.toString(16).padStart(64, '0'),
          leafIndex: changeLeafIndex,
          commitment: changeCommitment,
          asset: wAsset !== 'ETH' ? wAsset : undefined
        };
        const changeNoteJson = JSON.stringify(changeNote);
        // Save to localStorage
        let _changeSaved = false;
        try {
          const saved = JSON.parse(localStorage.getItem('pp_notes') || '[]');
          saved.push({ note: changeNoteJson, timestamp: Date.now(), amount: changeValue.toString(), asset: wAsset, txHash: tx.hash, isChange: true });
          localStorage.setItem('pp_notes', JSON.stringify(saved));
          _changeSaved = true;
        } catch (_) {
          alert("CRITICAL: Could not save change note to browser storage. Copy it NOW â€” you need it to withdraw remaining funds.");
        }
        // H-4/M-7: Use withdrawal-specific index counter keyed by label
        if (connectedAddress) ppSetWithdrawalIndex(connectedAddress, label.toString(), ppGetWithdrawalIndex(connectedAddress, label.toString()) + 1);
        renderPPNotes();
        log('<b style="color:orange">CHANGE NOTE SAVED</b> â€” ' + ethers.formatEther(changeValue) + ' ' + assetUnit + ' remaining. The change note has been saved to your browser. <b>Copy and back it up now</b> â€” losing it means losing the remaining funds.');
        // Also show in result textarea for easy copying
        setShown('ppwResult', true);
        $('ppwResultText').value = JSON.stringify({ changeNote, txHash: tx.hash, proof, publicSignals }, null, 2);
      } else {
        setShown('ppwResult', true);
        $('ppwResultText').value = JSON.stringify({ txHash: tx.hash, proof, publicSignals }, null, 2);
      }
      showStatus('Withdrawal successful!', 'success');
    } else {
      log('<b>Transaction may have failed.</b> Check Etherscan.');
      showStatus('Transaction may have failed', 'error');
      setShown('ppwResult', true);
      $('ppwResultText').value = JSON.stringify({ txHash: tx.hash, proof, publicSignals }, null, 2);
    }

  } catch (e) {
    console.error('ppwWithdraw error:', e);
    const errStr = String(e?.data || e?.message || e?.reason || e || '');
    const ppErrors = {
      'PrecommitmentAlreadyUsed': 'This deposit has already been used. The precommitment was already spent.',
      'InvalidProcessooor': 'Direct withdrawal requires msg.sender = recipient. Use the connected wallet as recipient.',
      'IncorrectASPRoot': 'ASP root is stale or incorrect. Wait a few minutes and retry.',
      'NullifierAlreadySpent': 'This deposit has already been withdrawn (nullifier spent).',
      'InvalidProof': 'ZK proof verification failed. Note data or tree state may be incorrect.',
      'InsufficientBalance': 'Pool has insufficient balance for this withdrawal amount.'
    };
    let decoded = false;
    for (const [key, msg] of Object.entries(ppErrors)) {
      if (errStr.includes(key)) { log('<b>Error:</b> ' + msg); decoded = true; break; }
    }
    if (!decoded) log('<b>Error:</b> ' + escText(e.shortMessage || e.message || e));
    handleError(e);
  } finally {
    setText(btn, 'Verify & Prepare Withdrawal');
    setDisabled(btn, !_ppwNote);
  }
}

</script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"8510b592df8f4a69b87bbf8e840f200c","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>
