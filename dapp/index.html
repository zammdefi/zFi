<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>SWAP</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><rect width='16' height='16' fill='%230a0a0a'/><rect x='3' y='1' width='1' height='1' fill='%23e8e8e0'/><rect x='5' y='2' width='1' height='1' fill='%23e8e8e0'/><rect x='10' y='2' width='1' height='1' fill='%23e8e8e0'/><rect x='12' y='1' width='1' height='1' fill='%23e8e8e0'/><rect x='4' y='4' width='8' height='1' fill='%23e8e8e0'/><rect x='3' y='5' width='10' height='1' fill='%23e8e8e0'/><rect x='2' y='6' width='12' height='3' fill='%23e8e8e0'/><rect x='3' y='9' width='10' height='1' fill='%23e8e8e0'/><rect x='4' y='10' width='8' height='1' fill='%23e8e8e0'/><rect x='3' y='6' width='3' height='2' fill='%230a0a0a'/><rect x='10' y='6' width='3' height='2' fill='%230a0a0a'/><rect x='5' y='11' width='2' height='1' fill='%23e8e8e0'/><rect x='9' y='11' width='2' height='1' fill='%23e8e8e0'/><rect x='2' y='12' width='3' height='1' fill='%23e8e8e0'/><rect x='7' y='12' width='2' height='1' fill='%23e8e8e0'/><rect x='11' y='12' width='3' height='1' fill='%23e8e8e0'/><rect x='1' y='13' width='2' height='1' fill='%23e8e8e0'/><rect x='13' y='13' width='2' height='1' fill='%23e8e8e0'/></svg>" type="image/svg+xml">
<script>
// Prevent dark-mode FOUC: apply class before first paint
(function(){var d=localStorage.getItem('dark');if(d==='1'||(d===null&&matchMedia('(prefers-color-scheme:dark)').matches))document.documentElement.classList.add('dark')})();
</script>
<style>
:root {
  --bg:#fff;--fg:#000;--fg-muted:#666;--fg-dim:#999;
  --border:#000;--border-muted:#ddd;--input-ph:#aaa;
  --surface:#f9f9f9;--surface-hover:#f5f5f5;--list-hover:#f0f0f0;
  --btn-bg:#000;--btn-fg:#fff;--btn-hover:#333;
  --btn-dis-bg:transparent;--btn-dis-border:#ccc;--btn-dis-fg:#999;
  --sec-bg:#fff;--sec-border:#000;
  --card-border:#ccc;--card-shadow:none;
  --modal-overlay:rgba(0,0,0,0.8);--modal-bg:#fff;--modal-border:#000;
  --status-error:#fff0f0;--status-success:#f0fff0;
  --slip-border:rgba(0,0,0,0.25);--slip-hover:rgba(0,0,0,0.45);--slip-focus:#000;
  --refresh-color:#bbb;--refresh-hover:#888;--countdown:#bbb;
  --info-border:#999;--info-hover:#000;
  --info-tip-bg:#fff;--info-tip-border:#ddd;--info-tip-fg:#333;--info-tip-shadow:0 2px 8px rgba(0,0,0,0.08);
  --toggle-bg:#eee;--toggle-fg:#000;
  --loading-border:#666;--loading-top:#fff;
  --token-bal:#888;--group-border:#eee;
  --routes-fg:#666;--routes-hover:#000;--routes-list:#444;
  --badge-bg:#000;--badge-fg:#fff;
  --link-fg:inherit;--remove-fg:#999;
}
.dark {
  --bg:#0a0a0a;--fg:#e8e8e0;--fg-muted:#888;--fg-dim:#666;
  --border:#333;--border-muted:#333;--input-ph:#555;
  --surface:#111;--surface-hover:#151515;--list-hover:#1a1a1a;
  --btn-bg:#e8e8e0;--btn-fg:#0a0a0a;--btn-hover:#ccc;
  --btn-dis-bg:transparent;--btn-dis-border:#444;--btn-dis-fg:#666;
  --sec-bg:#0a0a0a;--sec-border:#333;
  --card-border:#333;--card-shadow:none;
  --modal-overlay:rgba(0,0,0,0.85);--modal-bg:#111;--modal-border:#333;
  --status-error:#1a0000;--status-success:#001a00;
  --slip-border:rgba(255,255,255,0.15);--slip-hover:rgba(255,255,255,0.3);--slip-focus:#e8e8e0;
  --refresh-color:#555;--refresh-hover:#999;--countdown:#555;
  --info-border:#555;--info-hover:#e8e8e0;
  --info-tip-bg:#111;--info-tip-border:#333;--info-tip-fg:#aaa;--info-tip-shadow:0 2px 8px rgba(0,0,0,0.3);
  --toggle-bg:#e8e8e0;--toggle-fg:#000;
  --loading-border:#444;--loading-top:#0a0a0a;
  --token-bal:#666;--group-border:#222;
  --routes-fg:#666;--routes-hover:#e8e8e0;--routes-list:#999;
  --badge-bg:#e8e8e0;--badge-fg:#0a0a0a;
  --link-fg:#e8e8e0;--remove-fg:#555;
}
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
body {
  font-family: Helvetica, Arial, sans-serif;
  background: var(--bg);
  color: var(--fg);
  min-height: 100vh;
  padding: 60px 20px 20px;
  max-width: 480px;
  margin: 0 auto;
  overflow-x: hidden;
}
a { color: var(--link-fg); }
h1 {
  font-size: 14px;
  font-weight: 400;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  margin-bottom: 24px;
}
.section {
  margin-bottom: 16px;
}
label {
  display: block;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 8px;
  color: var(--fg-muted);
}
input[type="number"], input[type="text"], .amount-input {
  width: 100%;
  padding: 8px 0;
  font-size: 24px;
  font-family: inherit;
  border: none;
  border-bottom: 1.5px solid var(--border);
  outline: none;
  background: transparent;
  color: var(--fg);
}
input::placeholder { color: var(--input-ph); }
input:focus { border-bottom-width: 2.5px; margin-bottom: -1px; }
button {
  display: inline-block;
  padding: 12px 24px;
  font-size: 12px;
  font-family: inherit;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  background: var(--btn-bg);
  color: var(--btn-fg);
  border: 1px solid var(--btn-bg);
  cursor: pointer;
  margin-right: 8px;
  margin-top: 8px;
  transition: background 0.2s, border-color 0.2s, color 0.2s;
}
button:hover { background: var(--btn-hover); }
button:disabled { background: var(--btn-dis-bg); border-color: var(--btn-dis-border); color: var(--btn-dis-fg); cursor: not-allowed; }
button.secondary {
  background: var(--sec-bg);
  color: var(--fg);
  border-color: var(--sec-border);
}
button.secondary:hover { background: var(--surface-hover); }

.wallet {
  position: fixed;
  top: max(20px, env(safe-area-inset-top, 0px));
  right: max(20px, env(safe-area-inset-right, 0px));
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  z-index: 100;
}
.wallet button { margin: 0; padding: 8px 16px; text-transform: none; }


.token-select {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: transparent;
  border: none;
  padding: 4px 2px;
  cursor: pointer;
  transition: opacity 0.15s;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}
.token-select:hover { opacity: 0.6; }
.token-icon { width: 24px; height: 24px; display: inline-flex; align-items: center; }
.token-symbol { font-weight: 600; color: var(--fg); }
.token-chevron { font-size: 10px; color: var(--fg-dim); margin-left: -2px; }

/* Quick-pick token row */
.quick-tokens {
  display: flex;
  align-items: center;
  gap: 6px;
}
.quick-token {
  width: 26px; height: 26px;
  border-radius: 50%;
  border: 1.5px solid transparent;
  background: transparent;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  transition: transform 0.15s ease, border-color 0.15s ease, filter 0.15s ease, opacity 0.15s ease;
  position: relative;
  filter: grayscale(0.6);
  opacity: 0.55;
}
.quick-token:hover {
  transform: scale(1.15);
  filter: grayscale(0);
  opacity: 1;
}
.quick-token .qi { width: 22px; height: 22px; border-radius: 50%; pointer-events: none; }
.quick-token[aria-label]::after {
  content: attr(aria-label);
  position: absolute;
  bottom: calc(100% + 4px);
  left: 50%;
  transform: translateX(-50%);
  font-size: 10px;
  letter-spacing: 0.03em;
  padding: 2px 5px;
  border-radius: 3px;
  background: var(--info-tip-bg);
  border: 1px solid var(--info-tip-border);
  color: var(--info-tip-fg);
  box-shadow: var(--info-tip-shadow);
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.12s ease;
}
.quick-token:hover::after { opacity: 1; }

/* Token input sections */
.token-section {
  margin-bottom: 12px;
}
.token-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  gap: 8px;
  min-width: 0;
}
.amount-input { font-weight: 400; }
.balance {
  font-size: 12px;
  color: var(--fg-muted);
  margin-top: 6px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.max-btn {
  padding: 2px 4px;
  border: none;
  background: none;
  color: var(--fg-dim);
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.03em;
  text-transform: uppercase;
  cursor: pointer;
  transition: color 0.15s, background 0.15s;
  margin: 0;
  border-radius: 3px;
}
.max-btn:hover { color: var(--fg); background: var(--surface-hover); }
.max-btn:disabled { opacity: 0.4; cursor: not-allowed; background: none; }

/* Swap arrow */
.swap-arrow {
  display: flex;
  justify-content: center;
  margin: 2px 0 8px;
}
.arrow-btn {
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 0;
  width: 32px;
  height: 32px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  transition: transform 0.3s ease, background 0.2s, border-color 0.2s;
  margin: 0;
}
.arrow-btn:hover { transform: rotate(180deg); background: var(--btn-bg); border-color: var(--btn-bg); }
.arrow-btn:hover svg { stroke: var(--btn-fg); }
.arrow-btn svg { stroke: var(--fg); transition: stroke 0.2s; }

/* Swap button */
.swap-btn {
  background: var(--btn-bg);
  color: var(--btn-fg);
  border: 1px solid var(--btn-bg);
  padding: 14px 24px;
  font-size: 13px;
  font-weight: 600;
  text-transform: none;
  letter-spacing: 0.02em;
  cursor: pointer;
  width: 100%;
  margin-top: 12px;
  transition: all 0.2s;
}
.swap-btn:hover:not(:disabled) { background: var(--btn-hover); }
.swap-btn:disabled { background: var(--btn-dis-bg); border-color: var(--btn-dis-border); color: var(--btn-dis-fg); cursor: not-allowed; }

/* Quote info */
.quote-info {
  padding: 12px;
  background: var(--surface);
  margin-top: 16px;
  font-size: 13px;
  color: var(--fg);
  overflow: hidden;
}
.quote-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 3px 0;
}
.quote-rate {
  font-size: 12px;
  color: var(--fg-muted);
  padding: 6px 0 2px;
  border-top: 1px solid var(--card-border);
  margin-top: 4px;
}
.quote-row > :nth-child(2) {
  margin-left: auto;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  text-align: right;
}
#routeInfo {
  max-width: 65%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
#routeInfo[data-size="sm"] { font-size: 12px; }
#routeInfo[data-size="xs"] { font-size: 11px; }

/* Slippage inline */
.slip-inline {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  cursor: text;
}
.slip-unit {
  color: var(--fg-muted);
  font-weight: 600;
  pointer-events: none;
}
.slip-num {
  -webkit-appearance: none;
  appearance: textfield;
  background: transparent;
  border: 0;
  border-bottom: 1px solid var(--slip-border);
  border-radius: 0;
  padding: 2px 0;
  width: 4.5ch;
  min-width: 3.5ch;
  text-align: right;
  font-size: 13px;
  color: var(--fg);
  outline: none;
  transition: border-color 0.15s ease;
}
.slip-num:hover { border-bottom-color: var(--slip-hover); }
.slip-num:focus { border-bottom-color: var(--slip-focus); }
.slip-num::-webkit-outer-spin-button,
.slip-num::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
.slip-num[type="number"] { -moz-appearance: textfield; }

/* Refresh button & countdown */
.refresh-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: none;
  border: none;
  cursor: pointer;
  padding: 2px;
  margin: 0;
  color: var(--refresh-color);
  transition: color 0.15s;
  opacity: 0.7;
}
.refresh-btn:hover { color: var(--refresh-hover); opacity: 1; }
.refresh-btn svg { display: block; }
.quote-countdown { color: var(--countdown); font-size: 11px; opacity: 0.7; }

/* Price impact */
.impact-warn { color: #e67e22; }
.impact-danger { color: #e74c3c; font-weight: 600; }
.quote-info.impact-high { background: rgba(231,76,60,0.06); }
.dark .quote-info.impact-high { background: rgba(231,76,60,0.1); }

/* All routes collapsible */
.routes-toggle {
  display: flex;
  align-items: center;
  gap: 4px;
  cursor: pointer;
  user-select: none;
  color: var(--routes-fg);
  font-size: 12px;
  margin-top: 6px;
}
.routes-toggle:hover { color: var(--routes-hover); }
.routes-list {
  margin-top: 4px;
  font-size: 12px;
  color: var(--routes-list);
}
.routes-list-item {
  display: flex;
  justify-content: space-between;
  padding: 3px 0;
}
.routes-list-item .best-badge {
  background: var(--badge-bg);
  color: var(--badge-fg);
  font-size: 10px;
  padding: 1px 5px;
  margin-left: 6px;
  letter-spacing: 0.03em;
}

/* Loading spinner */
.loading {
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid var(--loading-border);
  border-top: 2px solid var(--loading-top);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  vertical-align: middle;
}
@keyframes spin { 0% { transform: rotate(0); } 100% { transform: rotate(360deg); } }

/* Token modal */
.modal-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--modal-overlay);
  backdrop-filter: blur(4px);
  z-index: 2000;
  justify-content: center;
  align-items: center;
  padding: 20px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.modal-overlay.active { display: flex; }
body.modal-open { overflow: hidden; }
.modal {
  background: var(--modal-bg);
  border: 2px solid var(--modal-border);
  padding: 20px;
  width: 100%;
  max-width: 360px;
  max-height: calc(100vh - 40px);
  max-height: calc(100dvh - 40px);
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}
.modal-title {
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}
.modal-close {
  background: none;
  border: none;
  color: var(--fg);
  font-size: 24px;
  cursor: pointer;
  line-height: 1;
  padding: 0;
  margin: 0;
}
.modal-close:hover { opacity: 0.5; }

/* Wallet modal options */
.wallet-option {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: var(--modal-bg);
  border: 1px solid var(--border);
  color: var(--fg);
  cursor: pointer;
  margin-bottom: 8px;
  transition: background 0.15s, color 0.15s;
}
.wallet-option:hover { background: var(--btn-bg); color: var(--btn-fg); }
.wallet-option-icon { font-size: 1.5rem; }
.wallet-option-name { font-weight: 600; }
.wallet-option.disconnect {
  border-color: #f00;
  color: #f00;
  justify-content: center;
}
.wallet-option.disconnect:hover { background: #f00; color: #fff; }

/* Token list in modal */
.token-list-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  cursor: pointer;
  transition: background 0.2s;
}
.token-list-item:hover { background: var(--list-hover); }
.token-list-item.highlight {
  background: var(--surface);
  outline: 1px solid var(--border);
  outline-offset: -1px;
}
.token-balance { margin-left: auto; font-size: 12px; color: var(--token-bal); font-variant-numeric: tabular-nums; }

/* Custom token input */
.custom-token-input, .token-search {
  width: 100%;
  padding: 8px 0;
  border: none;
  border-bottom: 1px solid var(--border);
  font-size: 14px;
  font-family: inherit;
  outline: none;
  background: transparent;
  color: var(--fg);
}
.custom-token-input { margin-top: 8px; }
.custom-token-input:focus, .token-search:focus { border-bottom-width: 2px; }
.token-search-status {
  font-size: 11px;
  color: var(--fg-dim);
  margin: 4px 0 8px;
  min-height: 14px;
}
.token-search-status.error { color: #e74c3c; }
.token-group-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--fg-dim);
  padding: 8px 12px 4px;
  border-top: 1px solid var(--group-border);
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.wei-list-remove {
  background: none;
  border: none;
  color: var(--remove-fg);
  font-size: 14px;
  cursor: pointer;
  padding: 0 4px;
  margin: 0;
  line-height: 1;
}
.wei-list-remove:hover { color: #e74c3c; }

/* Status */
.status {
  font-size: 13px;
  margin-top: 16px;
  padding: 12px;
  background: var(--surface);
  color: var(--fg);
  display: none;
}
.status.show { display: block; }
.status.error { background: var(--status-error); }
.status.success { background: var(--status-success); }

/* Footer */
.site-footer {
  position: relative;
  text-align: center;
  padding: 48px 20px;
  font-size: 11px;
  opacity: 0.35;
  letter-spacing: 0.5px;
  font-weight: 300;
}
.site-footer a {
  color: inherit;
  text-decoration: underline;
  margin: 0 2px;
}
.site-footer a:hover { opacity: 0.7; }

/* Responsive */
@media (max-width: 700px) {
  body { padding: 80px 16px 20px; }
  .wallet { top: 16px; right: 16px; }
  .wallet button { padding: 10px 14px; font-size: 11px; }
  h1 { margin-bottom: 30px; font-size: 13px; }
  input[type="number"], input[type="text"] { font-size: 20px; padding: 8px 0; }
  .amount-input { font-size: 20px; }
  .swap-btn { padding: 12px 20px; }
  .modal { max-width: 100%; margin: 0 10px; max-height: calc(100vh - 40px); overflow-y: auto; }
  .dark-toggle { top: 18px; left: 16px; }
  .swap-card { padding: 20px 16px; }
  .quick-token { min-width: 26px; min-height: 26px; padding: 4px; }
}
@media (max-width: 380px) {
  body { padding: 70px 12px 20px; }
  input[type="number"], input[type="text"] { font-size: 18px; }
  .amount-input { font-size: 18px; }
  h1 { font-size: 12px; }
  .swap-card { padding: 16px 12px; }
  .token-select { padding: 4px 2px; gap: 4px; font-size: 11px; }
  .token-icon { width: 20px; height: 20px; }
  .quick-tokens { gap: 4px; }
  .quick-token { width: 24px; height: 24px; }
  .quick-token .qi { width: 20px; height: 20px; }
  .quote-info { padding: 10px 8px; font-size: 12px; }
  .balance { font-size: 11px; gap: 4px; flex-wrap: wrap; }
  .max-btn { font-size: 9px; padding: 2px 3px; }
}

/* Info tooltip */
.info-tip {
  position: relative;
  display: inline-flex;
}
.info-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  border: 1px solid var(--info-border);
  font-size: 11px;
  font-style: italic;
  font-family: Georgia, serif;
  color: var(--info-border);
  cursor: help;
  line-height: 1;
  padding-right: 1px;
}
.info-icon:hover { border-color: var(--info-hover); color: var(--info-hover); }
.info-tooltip {
  display: none;
  position: absolute;
  top: 28px;
  left: 0;
  width: 280px;
  padding: 14px 16px;
  background: var(--info-tip-bg);
  border: 1px solid var(--info-tip-border);
  font-size: 12px;
  font-weight: 400;
  line-height: 1.6;
  letter-spacing: 0;
  text-transform: none;
  color: var(--info-tip-fg);
  z-index: 200;
  box-shadow: var(--info-tip-shadow);
}
.info-tip.open .info-tooltip { display: block; }

/* Dark mode toggle */
.dark-toggle {
  position: fixed;
  top: max(22px, env(safe-area-inset-top, 0px));
  left: max(20px, env(safe-area-inset-left, 0px));
  border: none;
  cursor: pointer;
  font-size: 14px;
  padding: 0 0 1px 0;
  margin: 0;
  opacity: 0.7;
  transition: opacity 0.2s;
  z-index: 100;
  line-height: 1;
  color: var(--toggle-fg);
  background: var(--toggle-bg);
  border-radius: 50%;
  width: 28px;
  height: 28px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}
.dark-toggle:hover { opacity: 1; }

/* Swap card container */
.swap-card {
  border: 1px solid var(--card-border);
  border-radius: 0;
  padding: 24px;
  background: var(--bg);
}

/* Receiver accordion */
.receiver-toggle {
  display: flex;
  align-items: center;
  gap: 6px;
  cursor: pointer;
  user-select: none;
  padding: 8px 0;
  margin-top: 4px;
  border-top: 1px solid var(--card-border);
}
.receiver-toggle label {
  cursor: pointer;
  pointer-events: none;
  margin: 0;
}
</style>
</head>
<body>

<button class="dark-toggle" onclick="toggleDark()" title="Toggle dark mode">&#9789;</button>

<!-- Wallet button (fixed top-right) -->
<div class="wallet">
  <button id="walletBtn" onclick="toggleWallet()">connect</button>
</div>

<h1 style="display:flex;align-items:center;gap:8px">Swap <span class="info-tip"><span class="info-icon" onclick="this.parentElement.classList.toggle('open');event.stopPropagation()">i</span><span class="info-tooltip"><a href="https://github.com/zammdefi/zrouter" target="_blank" rel="noopener" style="color:inherit;font-weight:600">zRouter</a> is a fully on-chain DEX aggregator. Routes are discovered and optimized by zQuoter directly on the blockchain â€” no off-chain APIs, no solvers, no servers.<br><br>Aggregates Uniswap V2/V3/V4, SushiSwap, Curve, zAMM, and Lido with atomic multi-hop execution, split routing, and per-leg slippage protection.<br><br>Zero protocol fees. No intermediaries. Your trade goes directly from your wallet to the liquidity pools.</span></span></h1>

<!-- Swap card -->
<div class="swap-card">

<!-- From token section -->
<div class="section token-section">
  <div class="token-header">
    <label style="margin:0">From</label>
    <div class="token-select" onclick="openTokenModal('from')">
      <span id="fromTokenIcon" class="token-icon"></span>
      <span id="fromTokenSymbol" class="token-symbol">ETH</span>
      <span class="token-chevron">&#9662;</span>
    </div>
  </div>
  <input type="number" id="fromAmount" class="amount-input" placeholder="0.0" step="any">
  <div class="balance"><span id="fromBalance">Balance: --</span> <span style="color:var(--fg-dim)">&middot;</span> <button class="max-btn" type="button" onclick="setPercentBalance(25)">25%</button> <button class="max-btn" type="button" onclick="setPercentBalance(50)">50%</button> <button class="max-btn" type="button" onclick="setPercentBalance(75)">75%</button> <button class="max-btn" type="button" onclick="setPercentBalance(100)">100%</button></div>
</div>

<!-- Swap direction arrow -->
<div class="swap-arrow">
  <button class="arrow-btn" onclick="swapTokens()">
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke-width="2.5"><path d="M7 10L12 15L17 10"/></svg>
  </button>
</div>

<!-- To token section -->
<div class="section token-section">
  <div class="token-header">
    <label style="margin:0">To</label>
    <div style="display:flex;align-items:center;gap:10px">
      <div id="quickTokens" class="quick-tokens"></div>
      <div class="token-select" onclick="openTokenModal('to')">
        <span id="toTokenIcon" class="token-icon"></span>
        <span id="toTokenSymbol" class="token-symbol">zOrg</span>
        <span class="token-chevron">&#9662;</span>
      </div>
    </div>
  </div>
  <input type="text" id="toAmount" class="amount-input" placeholder="0.0" readonly>
  <div id="toBalance" class="balance">Balance: --</div>
</div>

<!-- Quote info -->
<div id="quoteInfo" class="quote-info" style="display:none">
  <div class="quote-row">
    <span>Route:</span><span id="routeInfo">--</span><a id="chartLink" href="#" target="_blank" rel="noopener" title="View pool chart" style="display:none;margin-left:4px;opacity:0.5;transition:opacity 0.15s;line-height:1" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.5'"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg></a>
  </div>
  <div class="quote-row" id="impactRow">
    <span>Impact:</span><span id="impactInfo">--</span>
  </div>
  <div class="quote-row" id="slippageRow">
    <span>Slippage:</span>
    <span class="slip-inline">
      <input id="slippagePct" class="slip-num" type="number" inputmode="decimal" min="0" max="20" step="0.1" value="0.5" aria-label="Slippage (%)">
      <span class="slip-unit">%</span>
      <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" style="opacity:0.35;margin-left:-2px"><path d="M17 3a2.83 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg>
      <span id="splitSlipNote" style="display:none;font-size:11px;color:var(--fg-muted);margin-left:6px"></span>
    </span>
  </div>
  <div class="quote-row" id="refreshRow">
    <span class="quote-countdown" id="quoteCountdown"></span>
    <span>
      <button class="refresh-btn" onclick="manualRefresh()" title="Refresh quote">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 2v6h-6"/><path d="M3 12a9 9 0 0 1 15-6.7L21 8"/><path d="M3 22v-6h6"/><path d="M21 12a9 9 0 0 1-15 6.7L3 16"/></svg>
      </button>
    </span>
  </div>
  <div id="quoteRate" class="quote-rate" style="display:none"></div>
  <div id="allRoutesWrap" style="display:none">
    <div class="routes-toggle" onclick="toggleAllRoutes()">
      <span class="chevron" id="routesChevron" style="font-size:9px">&#9654;</span>
      <span>All routes</span>
    </div>
    <div id="allRoutesList" class="routes-list" style="display:none"></div>
  </div>
</div>

<!-- Receiver (optional) -->
<div style="min-height:46px">
  <div class="receiver-toggle" onclick="const w=document.getElementById('receiverWrap');const open=w.style.display!=='none';w.style.display=open?'none':'block';this.querySelector('.chevron').textContent=open?'\u25B6':'\u25BC'">
    <span class="chevron" style="font-size:9px;color:var(--fg-muted)">&#9654;</span>
    <label style="margin:0;cursor:pointer;pointer-events:none">Receiver</label>
  </div>
  <div id="receiverWrap" style="display:none;margin-top:8px">
    <input type="text" id="receiverAddress" placeholder="0x address, name.wei, or name.eth" style="font-size:14px;padding:8px 0">
    <div id="receiverResolved" style="display:none;font-size:12px;margin-top:4px;color:var(--fg-muted);word-break:break-all"></div>
  </div>
</div>

<!-- Swap button -->
<button id="swapBtn" class="swap-btn" disabled>Connect Wallet</button>

</div><!-- end swap-card -->

<!-- Direct ZAMM stake / ragequit links -->
<div id="directStakeLink" style="text-align:center;margin-top:10px;font-size:13px;opacity:0.7">
  <a href="#" onclick="setupDirectZammStake();return false" style="color:var(--link-fg);text-decoration:underline;cursor:pointer">Stake ZAMM directly to zOrg</a>
  <span style="color:var(--fg-dim)">&middot;</span>
  <a href="#" onclick="setupRagequit();return false" style="color:var(--link-fg);text-decoration:underline;cursor:pointer">Ragequit zOrg to ZAMM</a>
</div>

<!-- Status -->
<div id="status" class="status"></div>

<!-- Wallet Modal -->
<div class="modal-overlay" id="walletModal" onclick="if(event.target===this)closeWalletModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Connect Wallet</div>
      <button class="modal-close" onclick="closeWalletModal()">&times;</button>
    </div>
    <div class="modal-body" id="walletOptions"></div>
  </div>
</div>

<!-- Token Modal -->
<div class="modal-overlay" id="tokenModal" onclick="if(event.target===this)closeTokenModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Select Token</div>
      <button class="modal-close" onclick="closeTokenModal()">&times;</button>
    </div>
    <input type="text" id="tokenSearchInput" class="token-search" placeholder="Search or enter name.wei" autocomplete="off">
    <div id="weiListStatus" class="token-search-status"></div>
    <div id="tokenList" style="max-height:280px;overflow-y:auto"></div>
    <input type="text" id="customTokenAddress" class="custom-token-input" placeholder="Enter token address">
    <button style="margin-top:12px;width:100%" onclick="addCustomToken()">Add Custom Token</button>
  </div>
</div>

<!-- Footer web ring -->
<div class="site-footer">
  <a href="./domains/">Domains</a> &middot; <a href="./dao/">DAO</a> &middot; <a href="./ico/">ICO</a> &middot; built by <a href="https://opensea.io/collection/zorgz" target="_blank" rel="noopener"><svg width="14" height="14" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin:0 2px;image-rendering:pixelated"><rect width="16" height="16" fill="#0a0a0a"/><rect x="3" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="5" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="10" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="12" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="4" y="4" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="5" width="10" height="1" fill="#e8e8e0"/><rect x="2" y="6" width="12" height="3" fill="#e8e8e0"/><rect x="3" y="9" width="10" height="1" fill="#e8e8e0"/><rect x="4" y="10" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="10" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="5" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="9" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="2" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="7" y="12" width="2" height="1" fill="#e8e8e0"/><rect x="11" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="1" y="13" width="2" height="1" fill="#e8e8e0"/><rect x="13" y="13" width="2" height="1" fill="#e8e8e0"/></svg></a><a href="./dao/#/dao/1/0x5E58BA0e06ED0F5558f83bE732a4b899a674053E">zOrg</a> &middot; <a href="https://x.com/z_fi_" target="_blank" rel="noopener" title="X"><svg width="14" height="14" viewBox="0 0 300 300.251" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;fill:currentColor"><path d="M178.57 127.15 290.27 0h-26.46l-97.03 110.38L89.34 0H0l117.13 166.93L0 300.25h26.46l102.4-116.59 81.8 116.59h89.34M36.01 19.54H76.66l187.13 262.13h-40.66"/></svg></a>
  <div style="margin-top:8px;letter-spacing:1px"><a href="https://github.com/z-fi/zFi" target="_blank" rel="noopener" style="text-decoration:none;color:inherit">zfi.wei</a></div>
</div>

<script src="./ethers.min.js"></script>
<script src="./walletconnect.min.js"></script>
<script>
// ---- Dark mode ----
function toggleDark() {
  const on = document.documentElement.classList.toggle('dark');
  document.querySelector('.dark-toggle').textContent = on ? '\u2600' : '\u263D';
  localStorage.setItem('dark', on ? '1' : '0');
}
(function() {
  // Class already applied in <head> for FOUC prevention; just sync the toggle icon
  if (document.documentElement.classList.contains('dark')) {
    document.querySelector('.dark-toggle').textContent = '\u2600';
  }
})();
document.addEventListener('click', () => document.querySelectorAll('.info-tip.open').forEach(t => t.classList.remove('open')));

// ---- Constants ----
const CHAIN_ID = 1;
const ZQUOTER_ADDRESS = "0x305e175e80d7edaed2498e8b2d6526619feb16e7";
const ZROUTER_ADDRESS = "0x000000000000FB114709235f1ccBFfb925F600e4";
const USDC_ADDRESS = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
const USDT_ADDRESS = "0xdAC17F958D2ee523a2206206994597C13D831ec7";
const WBTC_ADDRESS = "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599";
const WETH_ADDRESS = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";
const STETH_ADDRESS = "0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84";
const WSTETH_ADDRESS = "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0";
const RETH_ADDRESS = "0xae78736Cd615f374D3085123A210448E74Fc6393";
const DAI_ADDRESS = "0x6B175474E89094C44Da98b954EedeAC495271d0F";
const PNKSTR_ADDRESS = "0xc50673EDb3A7b94E8CAD8a7d4E0cD68864E33eDF";
const PERMIT2_ADDRESS = "0x000000000022D473030F116dDEE9F6B43aC78BA3";
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
const WEINS_ADDRESS = "0x0000000000696760E15f265e828DB644A0c242EB";
const PNKSTR_HOOK_ADDRESS = "0xfAaad5B731F52cDc9746F2414c823eca9B06E844";
const V4_ROUTER_ADDRESS = "0x00000000000044a361Ae3cAc094c9D1b14Eece97";
// V4 USDC/PNKSTR hookless pool params (fee=10000, tickSpacing=200)
const MULTICALL3_ADDRESS = "0xcA11bde05977b3631167028862bE2a173976CA11";
const ZAMM_HOOKED = "0x000000000000040470635EB91b7CE4D132D616eD";
const ZAMM_HOOKLESS = "0x00000000000008882D72EfA6cCE4B6a40b24C860";
const ZAMM_POOLS_ABI = ["function pools(uint256) view returns (uint112, uint112, uint32, uint256, uint256, uint256, uint256)"];
const ZORG_TOKEN = "0x0000000000009710cd229bf635c4500029651ee8";
const ZORG_ID = 1334160193485309697971829933264346612480800613613n;
const ZORG_PAY_TOKEN = "0xe9b1cfea55baa219e34301f2f31b9fd0921664ed"; // ERC20 equivalent of the ERC6909 swap output
const ZORG_DAO = "0x5E58BA0e06ED0F5558f83bE732a4b899a674053E";
const ZORG_DAO_TOKEN = "0x00a6bA94BBb5474725515De88fE04F854f2dCb12";
const WEINS_ABI = ["function computeId(string) pure returns (uint256)", "function text(uint256,string) view returns (string)", "function contenthash(uint256) view returns (bytes)", "function reverseResolve(address) view returns (string)", "function ownerOf(uint256) view returns (address)"];
const IPFS_GATEWAYS = ["https://content.wrappr.wtf/ipfs/", "https://dweb.link/ipfs/"];
const BUILTIN_ADDRS = new Set([ZERO_ADDRESS, WETH_ADDRESS, USDC_ADDRESS, USDT_ADDRESS, WBTC_ADDRESS, STETH_ADDRESS, WSTETH_ADDRESS, RETH_ADDRESS, DAI_ADDRESS, PNKSTR_ADDRESS, ZORG_DAO_TOKEN, ZORG_PAY_TOKEN].map(a => a.toLowerCase()));

// ---- DOM helpers ----
const $ = id => document.getElementById(id);

function setText(id, s) {
  const el = typeof id === 'string' ? $(id) : id;
  if (!el) return;
  if (el.textContent !== s) el.textContent = s;
}
let _htmlCache = new WeakMap();
function setHTML(id, s) {
  const el = typeof id === 'string' ? $(id) : id;
  if (!el) return;
  if (_htmlCache.get(el) === s) return;
  el.innerHTML = s;
  _htmlCache.set(el, s);
}
function setShown(id, shown) {
  const el = typeof id === 'string' ? $(id) : id;
  if (!el) return;
  const want = shown ? '' : 'none';
  if (el.style.display !== want) el.style.display = want;
}
function setDisabled(btn, disabled) {
  const el = typeof btn === 'string' ? $(btn) : btn;
  if (!el) return;
  if (!!el.disabled !== !!disabled) el.disabled = !!disabled;
}
const _escTextMap = { '&': '&amp;', '<': '&lt;', '>': '&gt;' };
function escText(s) {
  return String(s).replace(/[&<>]/g, m => _escTextMap[m]);
}
function escAttr(s) {
  return escText(s).replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}
function debounce(fn, wait) {
  let t;
  return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), wait); };
}

// ---- Wallet state ----
let provider = null;
let signer = null;
let connectedAddress = null;
let connectedWalletProvider = null;
let walletConnectProvider = null;
let isConnecting = false;
let walletEventHandlers = null;
let isWalletConnect = false;
let wcDeepLink = null;

const eip6963Providers = new Map();

window.addEventListener('eip6963:announceProvider', (event) => {
  try {
    const { info, provider } = event.detail || {};
    if (info?.uuid && provider) {
      eip6963Providers.set(info.uuid, { info, provider });
    }
  } catch (e) {}
});
window.dispatchEvent(new Event('eip6963:requestProvider'));

// ---- Wallet helpers ----
function findProvider(checkFn) {
  if (window.ethereum?.providers?.length) {
    for (const p of window.ethereum.providers) {
      if (checkFn(p)) return p;
    }
  }
  if (window.ethereum && checkFn(window.ethereum)) return window.ethereum;
  return null;
}

const WALLET_CONFIG = {
  metamask: { name: 'MetaMask', icon: 'ðŸ¦Š', detect: () => findProvider(p => p.isMetaMask), getProvider: () => findProvider(p => p.isMetaMask) },
  coinbase: { name: 'Coinbase', icon: 'ðŸ”µ', detect: () => findProvider(p => p.isCoinbaseWallet), getProvider: () => findProvider(p => p.isCoinbaseWallet) },
  rabby: { name: 'Rabby', icon: 'ðŸ°', detect: () => findProvider(p => p.isRabby), getProvider: () => findProvider(p => p.isRabby) },
  rainbow: { name: 'Rainbow', icon: 'ðŸŒˆ', detect: () => findProvider(p => p.isRainbow), getProvider: () => findProvider(p => p.isRainbow) },
  walletconnect: { name: 'WalletConnect', icon: 'ðŸ“±' }
};

function detectWallets() {
  const detected = [];
  const seenNames = new Set();

  // 1. EIP-6963 providers first
  for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
    const name = info?.name || 'Unknown';
    if (!seenNames.has(name.toLowerCase())) {
      const iconUrl = info.icon && (info.icon.startsWith('data:image/') || info.icon.startsWith('https://')) ? info.icon : null;
      const safeIconUrl = iconUrl ? iconUrl.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c])) : null;
      detected.push({
        key: `eip6963_${uuid}`,
        name: name,
        icon: safeIconUrl ? `<img src="${safeIconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : 'ðŸ”Œ',
        getProvider: () => provider
      });
      seenNames.add(name.toLowerCase());
    }
  }

  // 2. Check window.ethereum.providers array
  if (window.ethereum?.providers?.length) {
    for (let i = 0; i < window.ethereum.providers.length; i++) {
      const p = window.ethereum.providers[i];
      const name = p.isMetaMask ? 'MetaMask' : p.isCoinbaseWallet ? 'Coinbase' : p.isRabby ? 'Rabby' : p.isRainbow ? 'Rainbow' : null;
      if (name && !seenNames.has(name.toLowerCase())) {
        detected.push({ key: `provider_${i}`, name, icon: 'ðŸ”—', getProvider: () => p });
        seenNames.add(name.toLowerCase());
      }
    }
  }

  // 3. Legacy WALLET_CONFIG detection
  for (const [key, config] of Object.entries(WALLET_CONFIG)) {
    if (key === 'walletconnect') continue;
    try {
      if (config.detect && config.detect() && !seenNames.has(config.name.toLowerCase())) {
        detected.push({ key, ...config });
        seenNames.add(config.name.toLowerCase());
      }
    } catch (e) {}
  }

  // 4. Fallback: if nothing detected but window.ethereum exists
  if (detected.length === 0 && window.ethereum) {
    detected.push({ key: 'injected', name: 'Browser Wallet', icon: 'ðŸ”—', getProvider: () => window.ethereum });
  }

  // 5. WalletConnect
  const wcModule = globalThis['@walletconnect/ethereum-provider'];
  if (wcModule?.EthereumProvider) {
    detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: 'ðŸ“±' });
  }

  return detected;
}

function showWalletModal() {
  $('walletModal').classList.add('active');
  document.body.classList.add('modal-open');
  $('walletOptions').innerHTML = '<div style="padding:12px;text-align:center;">Detecting wallets...</div>';

  window.dispatchEvent(new Event('eip6963:requestProvider'));

  const doDetect = (attempt = 1) => {
    const wallets = detectWallets();
    const hasBrowserWallet = wallets.some(w => w.key !== 'walletconnect');
    if (!hasBrowserWallet && attempt < 2) {
      setTimeout(() => doDetect(attempt + 1), 250);
    } else {
      renderWalletModal(wallets);
    }
  };

  setTimeout(() => doDetect(), 150);
}

function renderWalletModal(wallets) {
  const container = $('walletOptions');

  if (connectedAddress) {
    const displayName = $('walletBtn').textContent;
    const showName = displayName && displayName !== 'connect' && !displayName.startsWith('0x');
    container.innerHTML = `
      <div style="padding: 12px; border: 1px solid currentColor; margin-bottom: 12px;">
        <div style="font-weight: 600; margin-bottom: 6px;">Connected</div>
        ${showName ? `<div style="font-size: 16px; margin-bottom: 4px;">${escText(displayName)}</div>` : ''}
        <div style="font-size: 12px; word-break: break-all; opacity: 0.6;">${escText(connectedAddress)}</div>
      </div>
      <div class="wallet-option disconnect" onclick="disconnectWallet()">
        <span class="wallet-option-name">Disconnect</span>
      </div>
    `;
  } else {
    container.innerHTML = wallets.length > 0 ? wallets.map(w => `
      <div class="wallet-option" data-wallet-key="${escAttr(w.key)}">
        <span class="wallet-option-icon">${w.icon}</span>
        <span class="wallet-option-name">${escText(w.name)}</span>
      </div>
    `).join('') : '<div style="padding:12px;text-align:center;">No wallets detected.</div>';
    container.querySelectorAll('[data-wallet-key]').forEach(el => {
      el.addEventListener('click', () => connectWithWallet(el.dataset.walletKey));
    });
  }
}

function closeWalletModal() {
  $('walletModal').classList.remove('active');
  document.body.classList.remove('modal-open');
}

function toggleWallet() { showWalletModal(); }

// ---- WalletConnect transaction helper ----
async function wcTransaction(txPromise, message = 'Confirm in your wallet app') {
  if (!isWalletConnect) return txPromise;

  const notif = document.createElement('div');
  notif.id = 'wcNotif';
  notif.innerHTML = `
    <div style="position:fixed;top:0;left:0;right:0;background:#1a1a2e;color:#fff;padding:16px;text-align:center;z-index:10000;font-size:14px;">
      <div style="margin-bottom:8px;">ðŸ“± ${escText(message)}</div>
      <div style="font-size:12px;opacity:0.7;">Open your wallet app to approve the transaction</div>
      ${wcDeepLink && /^https?:\/\//i.test(wcDeepLink) ? `<a href="${escAttr(wcDeepLink)}" style="display:inline-block;margin-top:8px;padding:8px 16px;background:#fff;color:#000;border-radius:4px;text-decoration:none;">Open Wallet</a>` : ''}
    </div>
  `;
  document.body.appendChild(notif);

  try {
    const result = await txPromise;
    return result;
  } finally {
    notif.remove();
  }
}

// ---- waitForTx - robust tx confirmation ----
async function waitForTx(tx, timeoutMs = 90000) {
  const txHash = tx.hash;

  async function pollReceipt(maxAttempts = 45) {
    const p = quoteRPC ? await quoteRPC.call(rpc => rpc) : provider;
    for (let i = 0; i < maxAttempts; i++) {
      try {
        const receipt = await p.getTransactionReceipt(txHash);
        if (receipt) {
          if (receipt.status === 0) throw new Error('Transaction reverted');
          return receipt;
        }
      } catch (rpcErr) {
        if (i === maxAttempts - 1) throw rpcErr;
      }
      await new Promise(r => setTimeout(r, 2000));
    }
    return null;
  }

  // For WalletConnect, always use polling
  if (isWalletConnect) {
    const receipt = await pollReceipt();
    if (receipt) return receipt;
    throw new Error('Transaction confirmation timeout');
  }

  // Race tx.wait() against timeout
  let receipt = null;
  let waitError = null;

  try {
    receipt = await Promise.race([
      tx.wait(),
      new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeoutMs))
    ]);
  } catch (e) {
    waitError = e;
    const msg = (e.message || '').toLowerCase();
    const shouldPoll = msg.includes('timeout') ||
                       msg.includes('index') ||
                       msg.includes('invalid_argument') ||
                       msg.includes('invalid argument') ||
                       msg.includes('could not coalesce') ||
                       msg.includes('missing response');

    if (shouldPoll && txHash) {
      receipt = await pollReceipt();
    }
  }

  if (receipt) return receipt;
  throw waitError || new Error('Transaction confirmation timeout');
}

// ---- Connect with wallet ----
async function connectWithWallet(walletKey) {
  if (isConnecting) return;
  isConnecting = true;

  try {
    closeWalletModal();
    let walletProvider;

    if (walletKey === 'walletconnect') {
      const wcModule = globalThis['@walletconnect/ethereum-provider'];
      const WCProvider = wcModule?.EthereumProvider;

      if (!WCProvider?.init) throw new Error('WalletConnect not available');

      if (walletConnectProvider) {
        try { await walletConnectProvider.disconnect?.(); } catch (e) {}
        walletConnectProvider = null;
      }

      walletConnectProvider = await WCProvider.init({
        projectId: '1e8390ef1c1d8a185e035912a1409749',
        chains: [1],
        showQrModal: true,
        rpcMap: { 1: 'https://1rpc.io/eth' },
        metadata: {
          name: 'ETH Swap by zAMM',
          description: 'Onchain DEX aggregator',
          url: window.location.origin,
          icons: []
        }
      });

      walletConnectProvider.on('display_uri', (uri) => {
        try {
          const session = walletConnectProvider.session;
          const peerMeta = session?.peer?.metadata;
          if (peerMeta?.redirect?.native && /^https?:\/\//i.test(peerMeta.redirect.native)) wcDeepLink = peerMeta.redirect.native;
          else if (peerMeta?.redirect?.universal && /^https?:\/\//i.test(peerMeta.redirect.universal)) wcDeepLink = peerMeta.redirect.universal;
        } catch (e) {}
      });

      await walletConnectProvider.enable();
      walletProvider = walletConnectProvider;
      isWalletConnect = true;

      try {
        const session = walletConnectProvider.session;
        const peerMeta = session?.peer?.metadata;
        if (peerMeta?.redirect?.native && /^https?:\/\//i.test(peerMeta.redirect.native)) wcDeepLink = peerMeta.redirect.native;
        else if (peerMeta?.redirect?.universal && /^https?:\/\//i.test(peerMeta.redirect.universal)) wcDeepLink = peerMeta.redirect.universal;
      } catch (e) {}
    } else if (walletKey.startsWith('eip6963_')) {
      const uuid = walletKey.replace('eip6963_', '');
      walletProvider = eip6963Providers.get(uuid)?.provider;
      if (!walletProvider) {
        const savedName = localStorage.getItem('zswap_wallet_name')?.toLowerCase();
        if (savedName) {
          for (const [, { info, provider }] of eip6963Providers) {
            if (info?.name?.toLowerCase() === savedName) {
              walletProvider = provider;
              break;
            }
          }
        }
      }
      isWalletConnect = false;
      wcDeepLink = null;
    } else {
      walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
      isWalletConnect = false;
      wcDeepLink = null;
    }

    if (!walletProvider) throw new Error('Wallet not found');

    if (walletKey !== 'walletconnect') {
      await walletProvider.request({ method: 'eth_requestAccounts' });
    }

    // Check/switch chain
    const chainId = await walletProvider.request({ method: 'eth_chainId' });
    if (BigInt(chainId) !== 1n) {
      try {
        await walletProvider.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: '0x1' }]
        });
        const newChainId = await walletProvider.request({ method: 'eth_chainId' });
        if (BigInt(newChainId) !== 1n) throw new Error('Chain switch failed');
      } catch (switchErr) {
        showStatus('Please switch to Ethereum Mainnet', 'error');
        if (walletKey === 'walletconnect') {
          try { walletConnectProvider?.disconnect(); } catch (e) {}
          walletConnectProvider = null;
        }
        isWalletConnect = false;
        wcDeepLink = null;
        return;
      }
    }

    // Initialize globals
    provider = new ethers.BrowserProvider(walletProvider);
    signer = await provider.getSigner();
    connectedAddress = await signer.getAddress();
    const oldWalletProvider = connectedWalletProvider;
    connectedWalletProvider = walletProvider;
    updateWalletDisplay();

    if (oldWalletProvider && walletEventHandlers) {
      try {
        oldWalletProvider.removeListener('accountsChanged', walletEventHandlers.accountsChanged);
        oldWalletProvider.removeListener('chainChanged', walletEventHandlers.chainChanged);
      } catch (e) {}
    }
    walletEventHandlers = {
      accountsChanged: () => window.location.reload(),
      chainChanged: () => window.location.reload()
    };
    walletProvider.on('accountsChanged', walletEventHandlers.accountsChanged);
    walletProvider.on('chainChanged', walletEventHandlers.chainChanged);

    try {
      localStorage.setItem('zswap_wallet', walletKey);
      if (walletKey.startsWith('eip6963_')) {
        const uuid = walletKey.replace('eip6963_', '');
        const name = eip6963Providers.get(uuid)?.info?.name;
        if (name) localStorage.setItem('zswap_wallet_name', name);
      }
    } catch (e) {}

    // Clear caches (provider changed)
    _erc20Read.clear();
    _balanceCache.clear();
    _allowCache.clear();

    // Update swap UI
    setText('swapBtn', 'Enter an amount');
    setDisabled('swapBtn', true);
    updateBalances();
    updateWcBanner();

    const preAmt = $('fromAmount')?.value?.trim();
    if (preAmt) handleAmountChange();

  } catch (error) {
    handleError(error);
  } finally {
    isConnecting = false;
  }
}

function updateWcBanner() {
  const existing = $('wcBanner');
  if (existing) existing.remove();

  if (isWalletConnect && connectedAddress) {
    const banner = document.createElement('div');
    banner.id = 'wcBanner';
    banner.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#1a1a2e;color:#fff;padding:10px 16px;display:flex;justify-content:space-between;align-items:center;z-index:9000;font-size:13px;';
    banner.innerHTML = `
      <span>ðŸ“± Connected via WalletConnect</span>
      <button onclick="disconnectWallet()" style="background:#fff;color:#000;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;font-size:12px;">Disconnect</button>
    `;
    document.body.prepend(banner);
    document.body.style.paddingTop = '44px';
  } else {
    document.body.style.paddingTop = '';
  }
}

function updateWalletDisplay() {
  if (!connectedAddress) {
    $('walletBtn').textContent = 'connect';
    updateWcBanner();
    return;
  }
  $('walletBtn').textContent = connectedAddress.slice(0, 6) + '...' + connectedAddress.slice(-4);
  updateWcBanner();
  // Resolve .wei name in background
  const _capturedAddr = connectedAddress;
  quoteRPC.call(async (rpc) => {
    const ns = getWeinsContract(rpc);
    const name = await ns.reverseResolve(_capturedAddr);
    if (name && connectedAddress === _capturedAddr) $('walletBtn').textContent = name.toLowerCase();
  }).catch(() => {});
}

function disconnectWallet() {
  if (connectedWalletProvider && walletEventHandlers) {
    try {
      connectedWalletProvider.removeListener('accountsChanged', walletEventHandlers.accountsChanged);
      connectedWalletProvider.removeListener('chainChanged', walletEventHandlers.chainChanged);
    } catch (e) {}
  }
  walletEventHandlers = null;

  if (walletConnectProvider) {
    try { walletConnectProvider.disconnect(); } catch (e) {}
    walletConnectProvider = null;
  }
  provider = null;
  signer = null;
  connectedAddress = null;
  connectedWalletProvider = null;
  isWalletConnect = false;
  wcDeepLink = null;
  $('walletBtn').textContent = 'connect';
  updateWcBanner();
  closeWalletModal();
  try { localStorage.removeItem('zswap_wallet'); localStorage.removeItem('zswap_wallet_name'); } catch (e) {}

  // Reset swap UI
  setText('swapBtn', 'Connect Wallet');
  setDisabled('swapBtn', false);
  setText('fromBalance', 'Balance: --');
  setText('toBalance', 'Balance: --');
  setShown('quoteInfo', false);
  stopQuoteRefresh();
  $('toAmount').value = '';
  _erc20Read.clear();
  _balanceCache.clear();
  _allowCache.clear();
}

function showStatus(msg, type) {
  const el = $('status');
  if (!el) return;
  el.textContent = msg;
  el.className = 'status show' + (type ? ' ' + type : '');
  setTimeout(() => { el.className = 'status'; }, type === 'error' ? 8000 : 5000);
}

function handleError(e) {
  const msg = (e.message || e.reason || String(e)).toLowerCase();
  if (msg.includes('user rejected') || msg.includes('user denied') || msg.includes('user cancelled')) return;
  showStatus(e.message || 'An error occurred', 'error');
}

// ---- Token data ----
let currentModal = null;
const tokens = {
  ETH: { address: ZERO_ADDRESS, symbol: "ETH", decimals: 18 },
  WETH: { address: WETH_ADDRESS, symbol: "WETH", decimals: 18 },
  zOrg: { address: ZORG_DAO_TOKEN, symbol: "zOrg", decimals: 18, _isZOrg: true },
  ZAMM: { address: ZORG_PAY_TOKEN, symbol: "ZAMM", decimals: 18, _isZammStake: true },
  USDC: { address: USDC_ADDRESS, symbol: "USDC", decimals: 6 },
  USDT: { address: USDT_ADDRESS, symbol: "USDT", decimals: 6 },
  DAI: { address: DAI_ADDRESS, symbol: "DAI", decimals: 18 },
  WBTC: { address: WBTC_ADDRESS, symbol: "WBTC", decimals: 8 },
  stETH: { address: STETH_ADDRESS, symbol: "stETH", decimals: 18 },
  wstETH: { address: WSTETH_ADDRESS, symbol: "wstETH", decimals: 18 },
  rETH: { address: RETH_ADDRESS, symbol: "rETH", decimals: 18 },
  PNKSTR: { address: PNKSTR_ADDRESS, symbol: "PNKSTR", decimals: 18 },
};

// Load custom tokens from localStorage
try {
  const saved = JSON.parse(localStorage.getItem('zswap_custom_tokens') || '[]');
  for (const t of saved) {
    if (t.address && t.symbol && t.decimals != null && !tokens[t.symbol]) {
      tokens[t.symbol] = { address: t.address, symbol: t.symbol, decimals: t.decimals };
    }
  }
} catch (_) {}

function saveCustomTokens() {
  try {
    const custom = Object.values(tokens).filter(t => !BUILTIN_ADDRS.has(t.address.toLowerCase()) && !weiListTokenSource.has(t.symbol));
    localStorage.setItem('zswap_custom_tokens', JSON.stringify(custom));
  } catch (_) {}
}

// ---- .wei token list state ----
const weiLists = new Map();       // name â†’ { tokens: [...], loadedAt }
const weiListTokenSource = new Map(); // symbol â†’ listName
let _tokenListAutoLoaded = false;  // true once auto-load of token-list.wei attempted

function saveWeiLists() {
  try {
    const obj = {};
    for (const [name, data] of weiLists) obj[name] = data;
    localStorage.setItem('zswap_wei_lists', JSON.stringify(obj));
  } catch (_) {}
}

function loadWeiLists() {
  try {
    const raw = JSON.parse(localStorage.getItem('zswap_wei_lists') || '{}');
    for (const [name, data] of Object.entries(raw)) {
      if (data && Array.isArray(data.tokens)) {
        weiLists.set(name, data);
        mergeWeiListTokens(name, data.tokens);
      }
    }
  } catch (_) {}
}

function validateTokenList(rawArray) {
  if (!Array.isArray(rawArray)) return [];
  const seen = new Set();
  const result = [];
  for (const entry of rawArray) {
    if (!entry || typeof entry !== 'object') continue;
    const { address, symbol, decimals } = entry;
    if (!address || !symbol || decimals == null) continue;
    const addrClean = String(address).trim().toLowerCase();
    if (!ethers.isAddress(addrClean)) continue;
    const checksummed = ethers.getAddress(addrClean);
    if (checksummed === ZERO_ADDRESS) continue;
    const addrLower = checksummed.toLowerCase();
    if (seen.has(addrLower)) continue;
    const sym = String(symbol).trim();
    if (!sym || sym.length > 24 || !/^[A-Za-z0-9.$_-]+$/.test(sym)) continue;
    const dec = Number(decimals);
    if (!Number.isInteger(dec) || dec < 0 || dec > 36) continue;
    seen.add(addrLower);
    const item = { address: checksummed, symbol: sym, decimals: dec };
    if (entry.icon && typeof entry.icon === 'string') {
      const url = entry.icon.trim();
      if (url.startsWith('https://') || url.startsWith('data:image/')) item.icon = url;
    }
    result.push(item);
  }
  return result;
}

function mergeWeiListTokens(listName, validated) {
  const builtInAddrs = BUILTIN_ADDRS;
  for (const t of validated) {
    if (builtInAddrs.has(t.address.toLowerCase())) continue;
    let sym = t.symbol;
    // Handle symbol collision with different address
    if (tokens[sym] && tokens[sym].address.toLowerCase() !== t.address.toLowerCase()) {
      sym = sym + '.' + listName.replace(/\.wei$/, '');
    }
    if (!tokens[sym]) {
      tokens[sym] = { address: t.address, symbol: sym, decimals: t.decimals };
      if (t.icon) tokens[sym].icon = t.icon;
    }
    weiListTokenSource.set(sym, listName);
  }
}

// ---- ENSIP-7 contenthash â†’ IPFS CID decoder ----
const BASE32_ALPHA = 'abcdefghijklmnopqrstuvwxyz234567';
function bytesToBase32(bytes) {
  let bits = 0, value = 0, out = '';
  for (const b of bytes) {
    value = (value << 8) | b;
    bits += 8;
    while (bits >= 5) { bits -= 5; out += BASE32_ALPHA[(value >> bits) & 31]; }
  }
  if (bits > 0) out += BASE32_ALPHA[(value << (5 - bits)) & 31];
  return out;
}

function decodeContenthash(hex) {
  try {
    const bytes = ethers.getBytes(hex);
    if (bytes.length < 3) return null;
    let proto = 0, shift = 0, offset = 0;
    for (; offset < bytes.length; offset++) {
      proto |= (bytes[offset] & 0x7f) << shift;
      shift += 7;
      if (!(bytes[offset] & 0x80)) { offset++; break; }
    }
    if (proto !== 0xe3) return null; // IPFS only
    const cidBytes = bytes.slice(offset);
    if (cidBytes[0] === 0x01) return 'b' + bytesToBase32(cidBytes); // CIDv1
    return null;
  } catch { return null; }
}

async function fetchIPFS(cid) {
  let lastErr;
  for (const gw of IPFS_GATEWAYS) {
    try {
      const resp = await fetch(gw + cid);
      if (!resp.ok) throw new Error(resp.status);
      return await resp.text();
    } catch (e) { lastErr = e; }
  }
  throw new Error('All IPFS gateways failed: ' + lastErr?.message);
}

let _weiResolveSeq = 0;
let _weiResolving = false;

async function resolveWeiList(nameInput) {
  let name = nameInput.toLowerCase().trim();
  if (name.endsWith('.wei')) name = name.slice(0, -4);
  if (!name) return;
  const fullName = name + '.wei';

  if (weiLists.has(fullName)) {
    setHTML('weiListStatus', escText(fullName) + ' already loaded');
    return;
  }

  const seq = ++_weiResolveSeq;
  _weiResolving = true;
  const statusEl = $('weiListStatus');
  statusEl.className = 'token-search-status';
  statusEl.textContent = 'Loading ' + fullName + '...';

  try {
    // Read both contenthash and text record in parallel
    const { ch, txt } = await quoteRPC.call(async (rpc) => {
      const ns = getWeinsContract(rpc);
      const tokenId = await ns.computeId(fullName);
      const [ch, txt] = await Promise.all([
        ns.contenthash(tokenId).catch(() => '0x'),
        ns.text(tokenId, 'tokens').catch(() => ''),
      ]);
      return { ch, txt };
    });

    if (seq !== _weiResolveSeq) { _weiResolving = false; return; }

    let raw = null;

    // Try contenthash first (IPFS)
    if (ch && ch !== '0x' && ch.length > 2) {
      const cid = decodeContenthash(ch);
      if (cid) {
        statusEl.textContent = 'Fetching from IPFS...';
        raw = await fetchIPFS(cid);
        if (seq !== _weiResolveSeq) { _weiResolving = false; return; }
      }
    }

    // Fall back to text record
    if (!raw || !raw.trim()) {
      raw = txt;
    }

    if (!raw || !raw.trim()) {
      statusEl.className = 'token-search-status error';
      statusEl.textContent = 'No token list found on ' + fullName;
      _weiResolving = false;
      return;
    }

    let parsed;
    try { parsed = JSON.parse(raw); } catch (e) {
      statusEl.className = 'token-search-status error';
      statusEl.textContent = 'Invalid JSON from ' + fullName;
      _weiResolving = false;
      return;
    }

    const validated = validateTokenList(parsed);
    if (validated.length === 0) {
      statusEl.className = 'token-search-status error';
      statusEl.textContent = 'No valid tokens in ' + fullName;
      _weiResolving = false;
      return;
    }

    weiLists.set(fullName, { tokens: validated, loadedAt: Date.now() });
    mergeWeiListTokens(fullName, validated);
    saveWeiLists();
    statusEl.className = 'token-search-status';
    statusEl.textContent = 'Loaded ' + validated.length + ' tokens from ' + fullName;

    _weiResolving = false;
    const filter = $('tokenSearchInput')?.value || '';
    renderTokenList(filter);
  } catch (e) {
    _weiResolving = false;
    if (seq !== _weiResolveSeq) return;
    statusEl.className = 'token-search-status error';
    statusEl.textContent = 'Failed to resolve ' + fullName;
    console.error('.wei resolve error:', e);
    renderTokenList($('tokenSearchInput')?.value || '');
  }
}

function removeWeiList(listName) {
  const entry = weiLists.get(listName);
  if (!entry) return;
  // Collect symbols to remove (avoid mutating map during iteration)
  const toRemove = [];
  for (const [sym, src] of weiListTokenSource) {
    if (src !== listName) continue;
    // Don't remove if currently selected
    if (sym === fromToken || sym === toToken) continue;
    toRemove.push(sym);
  }
  for (const sym of toRemove) {
    delete tokens[sym];
    weiListTokenSource.delete(sym);
  }
  weiLists.delete(listName);
  saveWeiLists();
  if (listName === 'token-list.wei') _tokenListAutoLoaded = false;
}

function renderTokenList(filter) {
  const list = $('tokenList');
  if (!list) return;
  list.textContent = '';
  const frag = document.createDocumentFragment();
  const q = (filter || '').toLowerCase().trim();

  const builtInAddrs = BUILTIN_ADDRS;

  function matchesFilter(sym, addr) {
    if (!q) return true;
    return sym.toLowerCase().includes(q) || addr.toLowerCase().includes(q);
  }

  function makeRow(symbol) {
    const t = tokens[symbol];
    const row = document.createElement('div');
    row.className = 'token-list-item';
    row.setAttribute('data-symbol', symbol);
    const iconSpan = document.createElement('span');
    iconSpan.className = 'token-icon';
    iconSpan.innerHTML = iconForSymbol(symbol);
    const nameSpan = document.createElement('span');
    nameSpan.className = 'token-symbol';
    nameSpan.textContent = symbol;
    const balSpan = document.createElement('span');
    balSpan.className = 'token-balance';
    if (connectedAddress && t) {
      const cached = getCachedBalance(t.address);
      if (cached != null && cached > 0n) {
        const formatted = t.address === ZERO_ADDRESS
          ? ethers.formatEther(cached) : ethers.formatUnits(cached, t.decimals);
        balSpan.textContent = fmt(formatted);
      }
    }
    row.append(iconSpan, nameSpan, balSpan);
    return row;
  }

  // Built-in tokens
  let hasAny = false;
  for (const sym of Object.keys(tokens)) {
    if (!builtInAddrs.has(tokens[sym].address.toLowerCase())) continue;
    if (!matchesFilter(sym, tokens[sym].address)) continue;
    frag.appendChild(makeRow(sym));
    hasAny = true;
  }

  // Pre-index weiListTokenSource by list name (O(n) instead of O(n*m))
  const _weiByList = new Map();
  for (const [sym, src] of weiListTokenSource) {
    if (!tokens[sym]) continue;
    if (!_weiByList.has(src)) _weiByList.set(src, []);
    _weiByList.get(src).push(sym);
  }

  // Per-.wei-list groups
  for (const [listName] of weiLists) {
    const srcTokens = _weiByList.get(listName) || [];
    const listTokens = [];
    for (const sym of srcTokens) {
      if (!matchesFilter(sym, tokens[sym].address)) continue;
      listTokens.push(sym);
    }
    if (listTokens.length === 0) continue;
    const label = document.createElement('div');
    label.className = 'token-group-label';
    label.innerHTML = escText(listName) + ' <button class="wei-list-remove" data-list="' + escAttr(listName) + '" title="Remove list">&times;</button>';
    frag.appendChild(label);
    for (const sym of listTokens) frag.appendChild(makeRow(sym));
    hasAny = true;
  }

  // Custom tokens (not built-in, not from .wei lists)
  const customTokens = [];
  for (const sym of Object.keys(tokens)) {
    if (tokens[sym]._isZammStake) continue; // ZAMM is in built-in section, skip here
    if (builtInAddrs.has(tokens[sym].address.toLowerCase())) continue;
    if (weiListTokenSource.has(sym)) continue;
    if (!matchesFilter(sym, tokens[sym].address)) continue;
    customTokens.push(sym);
  }
  if (customTokens.length > 0) {
    const label = document.createElement('div');
    label.className = 'token-group-label';
    label.textContent = 'Custom';
    frag.appendChild(label);
    for (const sym of customTokens) frag.appendChild(makeRow(sym));
    hasAny = true;
  }

  if (!hasAny) {
    const empty = document.createElement('div');
    empty.style.cssText = 'padding:16px 12px;color:#999;font-size:13px;text-align:center';
    if (q && !_tokenListAutoLoaded && !weiLists.has('token-list.wei') && !q.endsWith('.wei')) {
      _tokenListAutoLoaded = true;
      empty.textContent = 'Searching extended token list\u2026';
      frag.appendChild(empty);
      resolveWeiList('token-list.wei');
    } else if (q && _weiResolving) {
      empty.textContent = 'Searching extended token list\u2026';
      frag.appendChild(empty);
    } else {
      empty.textContent = q ? 'No tokens match \u201c' + q + '\u201d' : 'No tokens';
      frag.appendChild(empty);
    }
  }

  list.appendChild(frag);

  // Highlight best match when searching
  if (q && q.length >= 2) {
    const rows = list.querySelectorAll('.token-list-item');
    let bestRow = null;
    for (const row of rows) {
      const sym = (row.getAttribute('data-symbol') || '').toLowerCase();
      const t = tokens[row.getAttribute('data-symbol')];
      // Exact symbol or address match gets priority
      if (sym === q || (t && t.address.toLowerCase() === q)) {
        bestRow = row;
        break;
      }
      // First partial match as fallback
      if (!bestRow && (sym.includes(q) || (t && t.address.toLowerCase().includes(q)))) {
        bestRow = row;
      }
    }
    if (bestRow) {
      bestRow.classList.add('highlight');
      bestRow.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }
  }
}

let _weiDebounceTimer = null;

function initTokenSearch() {
  const input = $('tokenSearchInput');
  if (!input) return;

  const debouncedRender = debounce((val) => renderTokenList(val), 150);
  input.addEventListener('input', () => {
    const val = input.value.trim();
    debouncedRender(val);
    clearTimeout(_weiDebounceTimer);
    if (val.endsWith('.wei') && val.length > 4) {
      _weiDebounceTimer = setTimeout(() => resolveWeiList(val), 800);
    }
  });

  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      const val = input.value.trim();
      if (val.endsWith('.wei') && val.length > 4) {
        clearTimeout(_weiDebounceTimer);
        resolveWeiList(val);
      }
    }
  });

}

let fromToken = "ETH";
let toToken = "zOrg";
let _balSeq = 0;
let slippageBps = 50;

// ---- Token Icons ----
const ETH_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><polygon fill="#80D8FF" points="7.62,18.83 16.01,30.5 16.01,24.1"/><polygon fill="#42A5F5" points="16.01,30.5 24.38,18.78 16.01,24.1"/><polygon fill="#FFF176" points="16.01,1.5 7.62,16.23 16.01,12.3"/><polygon fill="#FF8A80" points="24.38,16.18 16.01,1.5 16.01,12.3"/><polygon fill="#C1AEE1" points="16.01,21.5 24.38,16.18 16.01,12.3"/><polygon fill="#55FB9B" points="16.01,12.3 7.62,16.23 16.01,21.5"/></svg>`;
const WETH_ICON = `<svg width="24" height="24" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg"><circle cx="18" cy="18" r="17" fill="none" stroke="#90CAF9" stroke-width="1.5" stroke-dasharray="4 2.5"/><g transform="translate(2,2)"><polygon fill="#80D8FF" points="7.62,18.83 16.01,30.5 16.01,24.1"/><polygon fill="#42A5F5" points="16.01,30.5 24.38,18.78 16.01,24.1"/><polygon fill="#FFF176" points="16.01,1.5 7.62,16.23 16.01,12.3"/><polygon fill="#FF8A80" points="24.38,16.18 16.01,1.5 16.01,12.3"/><polygon fill="#C1AEE1" points="16.01,21.5 24.38,16.18 16.01,12.3"/><polygon fill="#55FB9B" points="16.01,12.3 7.62,16.23 16.01,21.5"/></g></svg>`;
const USDC_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#2775CA" cx="16" cy="16" r="16"/><g fill="#FFF"><path d="M20.022 18.124c0-2.124-1.28-2.852-3.84-3.156-1.828-.243-2.193-.728-2.193-1.578 0-.85.61-1.396 1.828-1.396 1.097 0 1.707.364 2.011 1.275a.458.458 0 00.427.303h.975a.416.416 0 00.427-.425v-.06a3.04 3.04 0 00-2.743-2.489V9.142c0-.243-.183-.425-.487-.486h-.915c-.243 0-.426.182-.487.486v1.396c-1.829.242-2.986 1.456-2.986 2.974 0 2.002 1.218 2.791 3.778 3.095 1.707.303 2.255.668 2.255 1.639 0 .97-.853 1.638-2.011 1.638-1.585 0-2.133-.667-2.316-1.578-.06-.242-.244-.364-.427-.364h-1.036a.416.416 0 00-.426.425v.06c.243 1.518 1.219 2.61 3.23 2.914v1.457c0 .242.183.425.487.485h.915c.243 0 .426-.182.487-.485V21.34c1.829-.303 3.047-1.578 3.047-3.217z"/><path d="M12.892 24.497c-4.754-1.7-7.192-6.98-5.424-11.653.914-2.55 2.925-4.491 5.424-5.402.244-.121.365-.303.365-.607v-.85c0-.242-.121-.424-.365-.485-.061 0-.183 0-.244.06a10.895 10.895 0 00-7.13 13.717c1.096 3.4 3.717 6.01 7.13 7.102.244.121.488 0 .548-.243.061-.06.061-.122.061-.243v-.85c0-.182-.182-.424-.365-.546zm6.46-18.936c-.244-.122-.488 0-.548.242-.061.061-.061.122-.061.243v.85c0 .243.182.485.365.607 4.754 1.7 7.192 6.98 5.424 11.653-.914 2.55-2.925 4.491-5.424 5.402-.244.121-.365.303-.365.607v.85c0 .242.121.424.365.485.061 0 .183 0 .244-.06a10.895 10.895 0 007.13-13.717c-1.096-3.46-3.778-6.07-7.13-7.162z"/></g></g></svg>`;
const USDT_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle cx="16" cy="16" r="16" fill="#26A17B"/><path fill="#FFF" d="M17.922 17.383v-.002c-.11.008-.677.042-1.942.042-1.01 0-1.721-.03-1.971-.042v.003c-3.888-.171-6.79-.848-6.79-1.658 0-.809 2.902-1.486 6.79-1.66v2.644c.254.018.982.061 1.988.061 1.207 0 1.812-.05 1.925-.06v-2.643c3.88.173 6.775.85 6.775 1.658 0 .81-2.895 1.485-6.775 1.657m0-3.59v-2.366h5.414V7.819H8.595v3.608h5.414v2.365c-4.4.202-7.709 1.074-7.709 2.118 0 1.044 3.309 1.915 7.709 2.118v7.582h3.913v-7.584c4.393-.202 7.694-1.073 7.694-2.116 0-1.043-3.301-1.914-7.694-2.117"/></g></svg>`;
const WBTC_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle cx="16" cy="16" r="16" fill="#F7931A"/><path fill="#FFF" fill-rule="nonzero" d="M23.189 14.02c.314-2.096-1.283-3.223-3.465-3.975l.708-2.84-1.728-.43-.69 2.765c-.454-.114-.92-.22-1.385-.326l.695-2.783L15.596 6l-.708 2.839c-.376-.086-.746-.17-1.104-.26l.002-.009-2.384-.595-.46 1.846s1.283.294 1.256.312c.7.175.826.638.805 1.006l-.806 3.235c.048.012.11.03.18.057l-.183-.045-1.13 4.532c-.086.212-.303.531-.793.41.018.025-1.256-.313-1.256-.313l-.858 1.978 2.25.561c.418.105.828.215 1.231.318l-.715 2.872 1.727.43.708-2.84c.472.127.93.245 1.378.357l-.706 2.828 1.728.43.715-2.866c2.948.558 5.164.333 6.097-2.333.752-2.146-.037-3.385-1.588-4.192 1.13-.26 1.98-1.003 2.207-2.538zm-3.95 5.538c-.533 2.147-4.148.986-5.32.695l.95-3.805c1.172.293 4.929.872 4.37 3.11zm.535-5.569c-.487 1.953-3.495.96-4.47.717l.86-3.45c.975.243 4.118.696 3.61 2.733z"/></g></svg>`;
const STETH_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#00A3FF" cx="16" cy="16" r="16"/><path d="M16.005 4.805l-5.655 8.668 5.655-3.233V4.805z" fill="#FFF"/><path opacity=".6" d="M16.004 10.238l5.658 3.23-5.658-8.674v5.444z" fill="#FFF"/><path opacity=".6" d="M16.005 10.239l-5.655 3.229 5.655 3.23v-6.46z" fill="#FFF"/><path opacity=".2" d="M16.004 10.239v6.459l5.654-3.23-5.654-3.229z" fill="#FFF"/><path d="M10.35 14.864c-2.048 3.097-1.603 7.253 1.034 9.824 1.561 1.521 3.622 2.353 5.683 2.353 2.061 0 4.122-.832 5.683-2.353 2.637-2.571 3.082-6.727 1.034-9.824L16.067 18.611 10.35 14.864z" fill="#FFF" opacity=".6"/></g></svg>`;
const WSTETH_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#00A3FF" cx="16" cy="16" r="16"/><path d="M9.437 14.864l-.181.275c-2.048 3.097-1.603 7.253 1.034 9.824 1.561 1.521 3.622 2.353 5.683 2.353 0 0 0 0-6.536-12.452z" fill="#FFF"/><path opacity=".6" d="M15.997 18.611l-6.56-3.747c6.56 12.452 6.56 12.452 6.56 12.452 0-2.683 0-5.623 0-8.705z" fill="#FFF"/><path opacity=".6" d="M22.563 14.864l.181.275c2.048 3.097 1.603 7.253-1.034 9.824-1.561 1.521-3.622 2.353-5.683 2.353 0 0 0 0 6.536-12.452z" fill="#FFF"/><path opacity=".2" d="M16.003 18.611l6.56-3.747c-6.56 12.452-6.56 12.452-6.56 12.452 0-2.683 0-5.623 0-8.705z" fill="#FFF"/><path opacity=".2" d="M16.004 10.239v6.459l5.654-3.23-5.654-3.229z" fill="#FFF"/><path opacity=".6" d="M16.005 10.239l-5.655 3.229 5.655 3.23v-6.46z" fill="#FFF"/><path d="M16.005 4.805l-5.655 8.668 5.655-3.233V4.805z" fill="#FFF"/><path opacity=".6" d="M16.004 10.238l5.658 3.23-5.658-8.674v5.444z" fill="#FFF"/></g></svg>`;
const RETH_ICON = `<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="bgGradient" x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" style="stop-color:#FFAA6B;stop-opacity:1"/><stop offset="100%" style="stop-color:#FF8A5B;stop-opacity:1"/></linearGradient></defs><circle cx="100" cy="100" r="95" fill="#FFC93D"/><circle cx="100" cy="100" r="88" fill="#FF6B6B"/><circle cx="100" cy="100" r="82" fill="url(#bgGradient)"/><g transform="translate(100, 100) rotate(45)"><path d="M -8 -25 C -8 -30, -5 -35, 0 -35 C 5 -35, 8 -30, 8 -25 L 8 -5 L 18 5 L 18 15 L 8 10 L 8 20 L 0 25 L -8 20 L -8 10 L -18 15 L -18 5 L -8 -5 Z" fill="white"/><circle cx="0" cy="-20" r="4" fill="#FF8A5B"/><path d="M -6 20 L -9 35 L -3 30 L 0 38 L 3 30 L 9 35 L 6 20 Z" fill="white"/></g></svg>`;
const DAI_ICON = `<svg width="24" height="24" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle fill="#F4B731" fill-rule="nonzero" cx="16" cy="16" r="16"/><path d="M9.277 8h6.552c3.985 0 7.006 2.116 8.13 5.194H26v1.861h-1.611c.031.294.047.594.047.898v.046c0 .342-.02.68-.06 1.01H26v1.86h-2.08C22.767 21.905 19.77 24 15.83 24H9.277v-5.131H7v-1.86h2.277v-1.954H7v-1.86h2.277V8zm1.831 10.869v3.462h4.72c2.914 0 5.078-1.387 6.085-3.462H11.108zm11.366-1.86H11.108v-1.954h11.37c.041.307.063.622.063.944v.045c0 .329-.023.65-.067.964zM15.83 9.665c2.926 0 5.097 1.424 6.098 3.528h-10.82V9.666h4.72z" fill="#FFF"/></g></svg>`;
// PNKSTR animated SVG is large (~4KB); lazy-loaded on first use
let _pnkstrIcon = null;
function getPNKSTRIcon() {
  if (_pnkstrIcon) return _pnkstrIcon;
  _pnkstrIcon = `<svg width="24" height="24" viewBox="0 0 296 296" xmlns="http://www.w3.org/2000/svg" shape-rendering="geometricPrecision" text-rendering="geometricPrecision"><style>#em3zDC0HIkr3{animation:em3zDC0HIkr3__rd 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr3__rd{0%{rx:93.77px;ry:93.77px}3.125%{rx:93.77px;ry:93.77px}18.75%{rx:93.77px;ry:93.77px}34.375%{rx:93.77px;ry:93.77px}56.25%{rx:0px;ry:0px}93.75%{rx:0px;ry:0px}100%{rx:0px;ry:0px}}#em3zDC0HIkr3_to{animation:em3zDC0HIkr3_to__to 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr3_to__to{0%{transform:translate(180.943141px,95.15235px)}3.125%{transform:translate(180.943141px,95.15235px)}18.75%{transform:translate(180.122px,95.152354px)}34.375%{transform:translate(148.075px,148.655006px)}56.25%{transform:translate(148.5px,148.655005px)}71.875%{transform:translate(180.122px,120.865004px)}84.375%{transform:translate(180.122px,95.152352px)}93.75%{transform:translate(180.122px,95.152351px)}100%{transform:translate(180.122px,95.152351px)}}#em3zDC0HIkr3_tr{animation:em3zDC0HIkr3_tr__tr 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr3_tr__tr{0%{transform:rotate(0deg)}34.375%{transform:rotate(0deg)}42.5%{transform:rotate(90deg)}100%{transform:rotate(90deg)}}#em3zDC0HIkr3_ts{animation:em3zDC0HIkr3_ts__ts 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr3_ts__ts{0%{transform:scale(0,0)}3.125%{transform:scale(0,0)}18.75%{transform:scale(0.8,0.8)}34.375%{transform:scale(1.319281,1.320365)}56.25%{transform:scale(1,1)}71.875%{transform:scale(0.697529,0.658712)}93.75%{transform:scale(0,0)}100%{transform:scale(0,0)}}#em3zDC0HIkr12_tr{animation:em3zDC0HIkr12_tr__tr 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr12_tr__tr{0%{transform:translate(135.33781px,207.03926px) rotate(720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}24.0625%{transform:translate(135.33781px,207.03926px) rotate(0deg);animation-timing-function:step-end}31.25%{transform:translate(135.33781px,207.03926px) rotate(720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}55.3125%{transform:translate(135.33781px,207.03926px) rotate(0deg);animation-timing-function:step-end}62.5%{transform:translate(135.33781px,207.03926px) rotate(720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}86.5625%{transform:translate(135.33781px,207.03926px) rotate(0deg);animation-timing-function:step-end}93.75%{transform:translate(135.33781px,207.03926px) rotate(720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}100%{transform:translate(135.33781px,207.03926px) rotate(532.987013deg)}}#em3zDC0HIkr12{animation:em3zDC0HIkr12_f_p 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr12_f_p{0%{fill:#d2dbed}24.0625%{fill:#d2dbec}31.25%{fill:#d2dbed}55.3125%{fill:#d2dbec}62.5%{fill:#d2dbed}86.5625%{fill:#d2dbec}93.75%{fill:#d2dbed}100%{fill:#d2dbed}}#em3zDC0HIkr13_tr{animation:em3zDC0HIkr13_tr__tr 32000ms linear infinite normal forwards}@keyframes em3zDC0HIkr13_tr__tr{0%{transform:translate(11.12px,29.9px) rotate(-720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}24.0625%{transform:translate(11.12px,29.9px) rotate(0deg);animation-timing-function:step-end}31.25%{transform:translate(11.12px,29.9px) rotate(-720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}55.3125%{transform:translate(11.12px,29.9px) rotate(0deg);animation-timing-function:step-end}62.5%{transform:translate(11.12px,29.9px) rotate(-720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}86.5625%{transform:translate(11.12px,29.9px) rotate(0deg);animation-timing-function:step-end}93.75%{transform:translate(11.12px,29.9px) rotate(-720deg);animation-timing-function:cubic-bezier(0.415,0.08,0.115,0.955)}100%{transform:translate(11.12px,29.9px) rotate(-532.987013deg)}}</style><circle r="148" transform="translate(148 148)" fill="#0d0d0d"/><g id="em3zDC0HIkr3_to" transform="translate(180.943141,95.15235)"><g id="em3zDC0HIkr3_tr" transform="rotate(0)"><g id="em3zDC0HIkr3_ts" transform="scale(0,0)"><rect id="em3zDC0HIkr3" width="187.538" height="187.538" rx="93.77" ry="93.77" transform="translate(-93.769,-93.769005)" fill="#f2f2f2"/></g></g></g><g style="mix-blend-mode:difference"><path d="M141.692,120.865v-43.1014h11.213v43.1014h-11.213ZM125.299,78.8923v-9.4526h43.857v9.4526h-43.857Zm53.228,41.9727L164.05,69.4397h11.425l9.51,39.2913h-.923l10.007-39.2913h10.716l9.864,39.2913h-.852l9.581-39.2913h11.567L220.184,120.865h-12.135l-9.084-36.0472h.994l-9.155,36.0472h-12.277Z" fill="#fff"/></g></svg>`;
  return _pnkstrIcon;
}
const ZORG_ICON = `<svg width="24" height="24" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><circle cx="100" cy="100" r="99" fill="#000"/><circle cx="100" cy="100" r="93" fill="none" stroke="#fff" stroke-width="1.2"/><path d="M 69 65 L 96 64 L 97 65 L 98 64 L 120 64 L 121 65 L 122 64 L 130 64 L 130 70 L 117 85 L 118 86 L 104 100 L 105 101 L 91 115 L 92 116 L 78 130 L 96 130 L 97 131 L 98 130 L 120 130 L 121 131 L 122 130 L 132 131 L 120 136 L 119 135 L 118 136 L 96 136 L 95 135 L 94 136 L 71 136 L 71 130 L 84 115 L 83 114 L 97 100 L 96 99 L 110 85 L 109 84 L 123 70 L 105 70 L 104 69 L 103 70 L 83 70 L 82 69 L 81 70 L 69 69 Z" fill="#fff"/></svg>`;
const ZAMM_ICON = `<svg width="24" height="24" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><circle cx="100" cy="100" r="99" fill="#fff"/><circle cx="100" cy="100" r="93" fill="none" stroke="#000" stroke-width="1.2"/><path d="M 69 65 L 96 64 L 97 65 L 98 64 L 120 64 L 121 65 L 122 64 L 130 64 L 130 70 L 117 85 L 118 86 L 104 100 L 105 101 L 91 115 L 92 116 L 78 130 L 96 130 L 97 131 L 98 130 L 120 130 L 121 131 L 122 130 L 132 131 L 120 136 L 119 135 L 118 136 L 96 136 L 95 135 L 94 136 L 71 136 L 71 130 L 84 115 L 83 114 L 97 100 L 96 99 L 110 85 L 109 84 L 123 70 L 105 70 L 104 69 L 103 70 L 83 70 L 82 69 L 81 70 L 69 69 Z" fill="#000"/></svg>`;
const DEFAULT_ICON = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/><text x="12" y="16" text-anchor="middle" fill="currentColor" font-size="12" font-weight="bold">?</text></svg>`;

const ICONS = {
  ETH: ETH_ICON, WETH: WETH_ICON, USDC: USDC_ICON, USDT: USDT_ICON, WBTC: WBTC_ICON,
  stETH: STETH_ICON, wstETH: WSTETH_ICON, rETH: RETH_ICON, DAI: DAI_ICON, zOrg: ZORG_ICON, ZAMM: ZAMM_ICON,
};

const _letterIconCache = new Map();
function iconForSymbol(sym) {
  const s = String(sym);
  if (ICONS[s]) return ICONS[s];
  if (s === 'PNKSTR') return getPNKSTRIcon();
  const t = tokens[s];
  if (t?.icon) {
    const img = document.createElement('img');
    img.src = t.icon;
    img.width = 24;
    img.height = 24;
    img.style.borderRadius = '50%';
    img.alt = s;
    img.onerror = function() { this.outerHTML = makeLetterIcon(s); };
    return img.outerHTML;
  }
  if (_letterIconCache.has(s)) return _letterIconCache.get(s);
  const svg = makeLetterIcon(s);
  _letterIconCache.set(s, svg);
  return svg;
}

function makeLetterIcon(sym) {
  try {
    const full = String(sym ?? '').trim();
    // Preserve original casing (stETH, crvUSD, frxETH, etc.)
    const clean = full.replace(/[^A-Za-z0-9]/g, '') || '?';
    const show = clean.length <= 7 ? clean : clean.slice(0, 6) + '\u2026';
    const L = show.length;
    const fontSize = L <= 1 ? 10 : L === 2 ? 8.5 : L === 3 ? 7.2 : L === 4 ? 6 : L === 5 ? 5.2 : L === 6 ? 4.6 : 4;
    // Deterministic hue from full symbol (case-sensitive for better spread)
    let hash = 0;
    for (let i = 0; i < clean.length; i++) hash = ((hash << 5) - hash + clean.charCodeAt(i)) | 0;
    const hue = ((hash % 360) + 360) % 360;
    // textLength compresses longer symbols to fit within the circle
    const tl = L >= 5 ? ` textLength="${L >= 7 ? 19 : 18}" lengthAdjust="spacingAndGlyphs"` : '';
    return `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-label="${escAttr(full)}">` +
      `<title>${escText(full)}</title>` +
      `<circle cx="12" cy="12" r="11" fill="hsl(${hue},50%,50%)" stroke="hsl(${hue},35%,38%)" stroke-width="1"/>` +
      `<text x="12" y="12.3" text-anchor="middle" dominant-baseline="middle"` +
      ` font-family="Helvetica,Arial,sans-serif"` +
      ` font-size="${fontSize}" font-weight="700" fill="#fff"${tl}>${escText(show)}</text>` +
      `</svg>`;
  } catch (e) {
    return DEFAULT_ICON;
  }
}

// ---- RPC fallback system ----
const RPCS = [
  "https://eth.llamarpc.com",
  "https://ethereum.publicnode.com",
  "https://1rpc.io/eth",
  "https://rpc.ankr.com/eth",
];

function makeWalletReader() {
  try {
    if (!window.ethereum) return null;
    const bp = new ethers.BrowserProvider(window.ethereum, CHAIN_ID);
    return bp;
  } catch { return null; }
}

function makeFallbackProvider(urls) {
  const network = { chainId: CHAIN_ID, name: "mainnet" };
  const nodes = urls.map(u => ({
    url: u,
    p: new ethers.JsonRpcProvider(u, network, { batchMaxCount: 10 }),
    downUntil: 0,
    warmed: false,
    ok: true,
  }));

  const walletReader = makeWalletReader();
  if (walletReader) {
    nodes.push({
      url: "wallet",
      p: walletReader,
      downUntil: 0,
      warmed: true,
      ok: true,
    });
  }

  const withTimeout = (ms, work) =>
    Promise.race([
      work(),
      new Promise((_, rej) => setTimeout(() => rej(new Error("timeout")), ms)),
    ]);

  const isInfraErr = (e) => {
    const s = String(e?.message || "");
    return /server response 400\b/i.test(s) ||
      /502|503|504|ECONNRESET|ENETUNREACH|EAI_AGAIN|Failed to fetch/i.test(s) ||
      /failed to detect network|timeout|timed out|ETIMEDOUT/i.test(s);
  };
  const isAuthErr = (e) => /Unauthorized|invalid api key|403|401/i.test(String(e?.message || ""));

  return {
    async call(fn) {
      const now = Date.now();
      let lastErr;
      const candidates = nodes
        .filter(n => n.ok && n.downUntil <= now)
        .concat(nodes.filter(n => n.ok && n.downUntil > now));

      for (const n of candidates) {
        try {
          if (!n.warmed && n.url !== "wallet") {
            await withTimeout(1200, () => n.p.getNetwork());
            n.warmed = true;
          }
          const res = await withTimeout(3500, () => fn(n.p));
          n.downUntil = 0;
          return res;
        } catch (e) {
          lastErr = e;
          if (isAuthErr(e)) n.ok = false;
          else if (isInfraErr(e)) n.downUntil = Date.now() + 30_000;
        }
      }
      throw lastErr || new Error("All RPCs failed");
    },
  };
}

const quoteRPC = makeFallbackProvider(RPCS);

// ---- Formatting helpers ----
const fmt = (nStr, max = 6) => {
  if (nStr == null) return "--";
  const n = Number(nStr);
  if (!Number.isFinite(n) || Math.abs(n) >= 1e21) {
    const s = String(nStr);
    return s.includes(".")
      ? s.replace(new RegExp(`(\\.\\d{0,${max}}).*$`), "$1").replace(/\.?0+$/, "")
      : s;
  }
  return n.toLocaleString(undefined, { maximumFractionDigits: max });
};
// Format output amounts: thousands separators, smart decimal truncation
const fmtOutput = (nStr) => {
  if (nStr == null) return "--";
  const n = Number(nStr);
  if (!Number.isFinite(n)) return nStr;
  // Adaptive decimals: large numbers get fewer decimals
  let maxDec;
  if (Math.abs(n) >= 10000) maxDec = 2;
  else if (Math.abs(n) >= 100) maxDec = 3;
  else if (Math.abs(n) >= 1) maxDec = 4;
  else maxDec = 6;
  return n.toLocaleString(undefined, { maximumFractionDigits: maxDec, minimumFractionDigits: 0 });
};

// ---- Allowance cache ----
const _allowTTLms = 10_000;
const _allowCache = new Map();
const _allowKey = (token, owner, spender) =>
  `${token.toLowerCase()}:${owner.toLowerCase()}:${spender.toLowerCase()}`;

function cacheSetAllowance(token, owner, spender, v) {
  _allowCache.set(_allowKey(token, owner, spender), { v, t: Date.now() });
}
function cacheGetAllowance(token, owner, spender) {
  const hit = _allowCache.get(_allowKey(token, owner, spender));
  return hit && Date.now() - hit.t < _allowTTLms ? hit.v : null;
}

// ---- Multicall3 batched reads ----
const MULTICALL3_IFACE = new ethers.Interface([
  "function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])",
  "function getEthBalance(address addr) view returns (uint256 balance)",
]);
const MC_BAL_IFACE = new ethers.Interface([
  "function balanceOf(address) view returns (uint256)",
  "function allowance(address,address) view returns (uint256)",
]);
const _balanceCache = new Map(); // key â†’ { v: bigint, t: number }
const _BAL_TTL = 15_000;

function getCachedBalance(tokenAddress) {
  const key = tokenAddress === ZERO_ADDRESS ? 'ETH' : tokenAddress.toLowerCase();
  const hit = _balanceCache.get(key);
  return (hit && Date.now() - hit.t < _BAL_TTL) ? hit.v : null;
}
function setCachedBalance(tokenAddress, value) {
  const key = tokenAddress === ZERO_ADDRESS ? 'ETH' : tokenAddress.toLowerCase();
  _balanceCache.set(key, { v: value, t: Date.now() });
}

async function multicallRead(calls) {
  if (calls.length === 0) return [];
  const calldata = MULTICALL3_IFACE.encodeFunctionData("aggregate3", [
    calls.map(c => [c.target, c.allowFailure, c.callData])
  ]);
  const rpc = provider || await quoteRPC.call(r => r);
  const raw = await rpc.call({ to: MULTICALL3_ADDRESS, data: calldata });
  return MULTICALL3_IFACE.decodeFunctionResult("aggregate3", raw)[0];
}

async function fetchModalBalances() {
  if (!connectedAddress) return;
  const allTokens = Object.values(tokens);
  const calls = [];
  const meta = [];
  const balOfData = MC_BAL_IFACE.encodeFunctionData("balanceOf", [connectedAddress]);

  // ETH balance
  calls.push({ target: MULTICALL3_ADDRESS, allowFailure: true,
    callData: MULTICALL3_IFACE.encodeFunctionData("getEthBalance", [connectedAddress]) });
  meta.push({ type: 'eth' });

  // All ERC-20 balances
  for (const t of allTokens) {
    if (t.address === ZERO_ADDRESS) continue;
    calls.push({ target: t.address, allowFailure: true, callData: balOfData });
    meta.push({ type: 'erc20', address: t.address });
  }

  try {
    const results = await multicallRead(calls);
    for (let i = 0; i < meta.length; i++) {
      const m = meta[i];
      const r = results[i];
      if (!r || !r.success) continue;
      try {
        if (m.type === 'eth') {
          setCachedBalance(ZERO_ADDRESS, MULTICALL3_IFACE.decodeFunctionResult("getEthBalance", r.returnData)[0]);
        } else {
          setCachedBalance(m.address, MC_BAL_IFACE.decodeFunctionResult("balanceOf", r.returnData)[0]);
        }
      } catch {}
    }
    // Re-render to show fetched balances
    const filter = $('tokenSearchInput')?.value || '';
    renderTokenList(filter);
  } catch (e) {
    console.warn("Multicall3 modal balances failed:", e);
  }
}

function safeParseUnits(valStr, decimals) {
  const s = String(valStr).trim();
  if (!s) throw new Error("Empty amount");
  const m = s.match(/^(\d+)(?:\.(\d+))?$/);
  if (!m) throw new Error("Invalid number");
  const frac = m[2] || "";
  if (frac.length > decimals) throw new Error(`Too many decimals (max ${decimals})`);
  return ethers.parseUnits(s, decimals);
}

// ---- Permit config ----
const PERMIT_CONFIG = {
  [USDC_ADDRESS.toLowerCase()]: {
    type: 'eip2612',
    domain: { name: 'USD Coin', version: '2', chainId: 1, verifyingContract: USDC_ADDRESS },
    routerFn: 'permit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
  },
  [DAI_ADDRESS.toLowerCase()]: {
    type: 'dai',
    domain: { name: 'Dai Stablecoin', version: '1', chainId: 1, verifyingContract: DAI_ADDRESS },
    routerFn: 'permitDAI(uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s)',
  },
};

// ---- Generic EIP-2612 permit detection ----
const _permitCache = new Map(); // address â†’ config | null

const _permitIface = new ethers.Interface([
  'function eip712Domain() view returns (bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)',
  'function nonces(address) view returns (uint256)',
  'function DOMAIN_SEPARATOR() view returns (bytes32)',
  'function name() view returns (string)',
  'function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
]);

async function _staticCall(tokenAddress, data) {
  return await quoteRPC.call(rpc => rpc.call({ to: tokenAddress, data }));
}

async function detectPermitConfig(tokenAddress) {
  const key = tokenAddress.toLowerCase();
  if (PERMIT_CONFIG[key]) return PERMIT_CONFIG[key];
  if (_permitCache.has(key)) return _permitCache.get(key);

  try {
    // Quick check: does it have nonces() and DOMAIN_SEPARATOR()?
    const [nonceRes, dsRes] = await Promise.all([
      _staticCall(tokenAddress, _permitIface.encodeFunctionData('nonces', [ZERO_ADDRESS])),
      _staticCall(tokenAddress, _permitIface.encodeFunctionData('DOMAIN_SEPARATOR')),
    ]);
    // If either reverts, quoteRPC throws or returns 0x
    if (!nonceRes || nonceRes === '0x' || !dsRes || dsRes === '0x') throw new Error('no permit');

    // Try EIP-5267 eip712Domain() first
    let domainName, domainVersion;
    try {
      const domRes = await _staticCall(tokenAddress, _permitIface.encodeFunctionData('eip712Domain'));
      const decoded = _permitIface.decodeFunctionResult('eip712Domain', domRes);
      domainName = decoded[1];
      domainVersion = decoded[2];
    } catch (_) {
      // Fallback: read name() and try version "1"
      const nameRes = await _staticCall(tokenAddress, _permitIface.encodeFunctionData('name'));
      domainName = _permitIface.decodeFunctionResult('name', nameRes)[0];
      domainVersion = '1';
    }

    // Verify by computing the expected DOMAIN_SEPARATOR
    const candidateDomain = { name: domainName, version: domainVersion, chainId: CHAIN_ID, verifyingContract: tokenAddress };
    const computed = ethers.TypedDataEncoder.hashDomain(candidateDomain);
    const onchain = ethers.AbiCoder.defaultAbiCoder().decode(['bytes32'], dsRes)[0];
    if (computed !== onchain) {
      // Try version "2" as fallback
      candidateDomain.version = '2';
      const computed2 = ethers.TypedDataEncoder.hashDomain(candidateDomain);
      if (computed2 !== onchain) {
        _permitCache.set(key, null);
        return null;
      }
    }

    const config = {
      type: 'eip2612',
      domain: candidateDomain,
      routerFn: 'permit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)',
    };
    _permitCache.set(key, config);
    return config;
  } catch (_) {
    _permitCache.set(key, null);
    return null;
  }
}

async function getPermitConfig(tokenAddress) {
  const key = tokenAddress.toLowerCase();
  if (PERMIT_CONFIG[key]) return PERMIT_CONFIG[key];
  return await detectPermitConfig(tokenAddress);
}

async function signPermit(config, tokenAddress) {
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 3600);
  const owner = connectedAddress;
  const spender = ZROUTER_ADDRESS;

  // Fetch nonce from token contract
  const nonceData = _permitIface.encodeFunctionData('nonces', [owner]);
  const nonceResult = await quoteRPC.call(rpc => rpc.call({ to: tokenAddress, data: nonceData }));
  const nonce = _permitIface.decodeFunctionResult('nonces', nonceResult)[0];

  let types, values;
  if (config.type === 'dai') {
    types = {
      Permit: [
        { name: 'holder', type: 'address' },
        { name: 'spender', type: 'address' },
        { name: 'nonce', type: 'uint256' },
        { name: 'expiry', type: 'uint256' },
        { name: 'allowed', type: 'bool' },
      ],
    };
    values = { holder: owner, spender, nonce, expiry: deadline, allowed: true };
  } else {
    types = {
      Permit: [
        { name: 'owner', type: 'address' },
        { name: 'spender', type: 'address' },
        { name: 'value', type: 'uint256' },
        { name: 'nonce', type: 'uint256' },
        { name: 'deadline', type: 'uint256' },
      ],
    };
    values = { owner, spender, value: ethers.MaxUint256, nonce, deadline };
  }

  const sig = await signer.signTypedData(config.domain, types, values);
  const { v, r, s } = ethers.Signature.from(sig);
  return { v, r, s, nonce, deadline, config };
}

function decodeMulticallCalls(multicallData) {
  try {
    const decoded = ROUTER_IFACE.decodeFunctionData('multicall', multicallData);
    return Array.from(decoded[0]);
  } catch (e) {
    return [];
  }
}

function buildPermitMulticall(calls, permitData) {
  let permitCall;
  if (permitData.config.type === 'dai') {
    permitCall = ROUTER_IFACE.encodeFunctionData('permitDAI', [permitData.nonce, permitData.deadline, permitData.v, permitData.r, permitData.s]);
  } else {
    permitCall = ROUTER_IFACE.encodeFunctionData('permit', [permitData.config.domain.verifyingContract, ethers.MaxUint256, permitData.deadline, permitData.v, permitData.r, permitData.s]);
  }
  return ROUTER_IFACE.encodeFunctionData('multicall', [[permitCall, ...calls]]);
}

// ---- Permit2 SignatureTransfer support ----
const PERMIT2_DOMAIN = { name: "Permit2", chainId: CHAIN_ID, verifyingContract: PERMIT2_ADDRESS };
const PERMIT2_TYPES = {
  PermitTransferFrom: [
    { name: "permitted", type: "TokenPermissions" },
    { name: "spender", type: "address" },
    { name: "nonce", type: "uint256" },
    { name: "deadline", type: "uint256" },
  ],
  TokenPermissions: [
    { name: "token", type: "address" },
    { name: "amount", type: "uint256" },
  ],
};

async function checkPermit2Allowance(tokenAddress) {
  let a = cacheGetAllowance(tokenAddress, connectedAddress, PERMIT2_ADDRESS);
  if (a != null) return a;
  const r = erc20Read(tokenAddress);
  a = await r.allowance(connectedAddress, PERMIT2_ADDRESS);
  cacheSetAllowance(tokenAddress, connectedAddress, PERMIT2_ADDRESS, a);
  return a;
}

async function signPermit2(tokenAddress, amount) {
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 3600);
  const _nonceBytes = new Uint8Array(8); crypto.getRandomValues(_nonceBytes);
  const nonce = _nonceBytes.reduce((n, b) => (n << 8n) | BigInt(b), 0n);
  const values = {
    permitted: { token: tokenAddress, amount },
    spender: ZROUTER_ADDRESS,
    nonce,
    deadline,
  };
  const sig = await signer.signTypedData(PERMIT2_DOMAIN, PERMIT2_TYPES, values);
  return { signature: sig, nonce, deadline, token: tokenAddress, amount };
}

function buildPermit2Multicall(calls, p2) {
  const p2call = ROUTER_IFACE.encodeFunctionData('permit2TransferFrom', [p2.token, p2.amount, p2.nonce, p2.deadline, p2.signature]);
  return ROUTER_IFACE.encodeFunctionData('multicall', [[p2call, ...calls]]);
}

// ---- ERC20 readers (cached, recreated on provider change) ----
const _erc20Read = new Map();
let _erc20ReadProvider = null;
function erc20Read(address) {
  if (!provider) throw new Error("No provider");
  if (_erc20ReadProvider !== provider) { _erc20Read.clear(); _erc20ReadProvider = provider; }
  const k = address.toLowerCase();
  if (!_erc20Read.has(k)) {
    _erc20Read.set(k, new ethers.Contract(
      address,
      ["function allowance(address,address) view returns (uint256)"],
      provider
    ));
  }
  return _erc20Read.get(k);
}

// ---- Balance updates (Multicall3 batched) ----
async function updateBalances() {
  if (!provider || !connectedAddress) return;

  const seq = ++_balSeq;
  const fromSnap = fromToken, toSnap = toToken;
  const f = tokens[fromSnap], t = tokens[toSnap];
  const fromIsEth = f.address === ZERO_ADDRESS;
  const toIsEth = t.address === ZERO_ADDRESS;

  try {
    const calls = [];
    const meta = [];
    const balOfData = MC_BAL_IFACE.encodeFunctionData("balanceOf", [connectedAddress]);

    // ETH balance via getEthBalance
    if (fromIsEth || toIsEth) {
      calls.push({ target: MULTICALL3_ADDRESS, allowFailure: true,
        callData: MULTICALL3_IFACE.encodeFunctionData("getEthBalance", [connectedAddress]) });
      meta.push({ type: 'eth' });
    }
    // From token balance
    if (!fromIsEth) {
      calls.push({ target: f.address, allowFailure: true, callData: balOfData });
      meta.push({ type: 'erc20', key: f.address.toLowerCase() });
    }
    // To token balance (if different)
    if (!toIsEth) {
      const keyT = t.address.toLowerCase();
      if (fromIsEth || keyT !== f.address.toLowerCase()) {
        calls.push({ target: t.address, allowFailure: true, callData: balOfData });
        meta.push({ type: 'erc20', key: keyT });
      }
    }
    // Batch allowance reads for from token (saves RPCs during quote/swap)
    if (!fromIsEth) {
      calls.push({ target: f.address, allowFailure: true,
        callData: MC_BAL_IFACE.encodeFunctionData("allowance", [connectedAddress, ZROUTER_ADDRESS]) });
      meta.push({ type: 'allow', token: f.address, spender: ZROUTER_ADDRESS });
      calls.push({ target: f.address, allowFailure: true,
        callData: MC_BAL_IFACE.encodeFunctionData("allowance", [connectedAddress, PERMIT2_ADDRESS]) });
      meta.push({ type: 'allow', token: f.address, spender: PERMIT2_ADDRESS });
    }

    const results = await multicallRead(calls);
    if (seq !== _balSeq || fromSnap !== fromToken || toSnap !== toToken) return;

    const balances = Object.create(null);
    for (let i = 0; i < meta.length; i++) {
      const m = meta[i], r = results[i];
      if (!r || !r.success) continue;
      try {
        if (m.type === 'eth') {
          balances.ETH = MULTICALL3_IFACE.decodeFunctionResult("getEthBalance", r.returnData)[0];
          setCachedBalance(ZERO_ADDRESS, balances.ETH);
        } else if (m.type === 'erc20') {
          balances[m.key] = MC_BAL_IFACE.decodeFunctionResult("balanceOf", r.returnData)[0];
          setCachedBalance(m.key, balances[m.key]);
        } else if (m.type === 'allow') {
          cacheSetAllowance(m.token, connectedAddress, m.spender,
            MC_BAL_IFACE.decodeFunctionResult("allowance", r.returnData)[0]);
        }
      } catch {}
    }

    const fromStr = fromIsEth
      ? `${fmt(ethers.formatEther(balances.ETH ?? 0n))} ETH`
      : `${fmt(ethers.formatUnits(balances[f.address.toLowerCase()] ?? 0n, f.decimals))} ${f.symbol}`;
    const toStr = toIsEth
      ? `${fmt(ethers.formatEther(balances.ETH ?? 0n))} ETH`
      : `${fmt(ethers.formatUnits(balances[t.address.toLowerCase()] ?? 0n, t.decimals))} ${t.symbol}`;

    setText("fromBalance", `Balance: ${fromStr}`);
    setText("toBalance", `Balance: ${toStr}`);
  } catch (e) {
    console.error("Balance update error:", e);
  }
}

// ---- AMM names ----
const AMM_NAMES = {
  0: "Uniswap V2", 1: "SushiSwap", 2: "zAMM",
  3: "Uniswap V3", 4: "Uniswap V4", 5: "Curve",
  6: "Lido", 7: "WETH Wrap", 8: "V4 Hooked",
};

// ---- Hoisted ABIs / Interfaces (avoid re-parsing per call) ----
const QUOTER_IFACE = new ethers.Interface([
  "function buildBestSwapViaETHMulticall(address to,address refundTo,bool exactOut,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline,uint24 hookPoolFee,int24 hookTickSpacing,address hookAddress) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) a, tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) b, bytes[] calls, bytes multicall, uint256 msgValue)",
  "function buildSplitSwap(address to,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut)[2] legs, bytes multicall, uint256 msgValue)",
  "function getQuotes(bool exactOut,address tokenIn,address tokenOut,uint256 swapAmount) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) best, tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut)[] quotes)",
  "function quoteCurve(bool exactOut,address tokenIn,address tokenOut,uint256 swapAmount,uint256 maxCandidates) view returns (uint256 amountIn,uint256 amountOut,address bestPool,bool usedUnderlying,bool usedStable,uint8 iIndex,uint8 jIndex)",
  "function quoteV4(bool,address,address,uint24,int24,address,uint256) view returns (uint256 amountIn, uint256 amountOut)",
  "function buildSplitSwapHooked(address to,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline,uint24 hookPoolFee,int24 hookTickSpacing,address hookAddress) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut)[2] legs, bytes multicall, uint256 msgValue)",
  "function quoteZAMM(bool exactOut,uint256 feeOrHook,address tokenIn,address tokenOut,uint256 idIn,uint256 idOut,uint256 swapAmount) view returns (uint256 amountIn, uint256 amountOut)",
  "function build3HopMulticall(address to,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) a, tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) b, tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut) c, bytes[] calls, bytes multicall, uint256 msgValue)",
  "function buildHybridSplit(address to,address tokenIn,address tokenOut,uint256 swapAmount,uint256 slippageBps,uint256 deadline) view returns (tuple(uint8 source,uint256 feeBps,uint256 amountIn,uint256 amountOut)[2] legs, bytes multicall, uint256 msgValue)",
  "function quoteLido(bool exactOut,address tokenOut,uint256 swapAmount) view returns (uint256 amountIn, uint256 amountOut)",
]);
const ROUTER_IFACE = new ethers.Interface([
  "function deposit(address,uint256,uint256) payable",
  "function execute(address,uint256,bytes) payable returns (bytes)",
  "function multicall(bytes[]) payable returns (bytes[])",
  "function sweep(address,uint256,uint256,address) payable",
  "function swapVZ(address to,bool exactOut,uint256 feeOrHook,address tokenIn,address tokenOut,uint256 idIn,uint256 idOut,uint256 swapAmount,uint256 amountLimit,uint256 deadline) payable returns (uint256 amountIn, uint256 amountOut)",
  "function swapV4(address to,bool exactOut,uint24 swapFee,int24 tickSpace,address tokenIn,address tokenOut,uint256 swapAmount,uint256 amountLimit,uint256 deadline) payable returns (uint256 amountIn, uint256 amountOut)",
  "function wrap(uint256 amount) payable",
  "function exactETHToSTETH(address to) payable returns (uint256 shares)",
  "function exactETHToWSTETH(address to) payable returns (uint256 wstOut)",
  "function permit(address token, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)",
  "function permitDAI(uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s)",
  "function permit2TransferFrom(address token, uint256 amount, uint256 nonce, uint256 deadline, bytes signature)",
]);
const ZORG_BUYSHARES_IFACE = new ethers.Interface([
  "function buyShares(address payToken, uint256 shareAmount, uint256 maxPay)",
  "function approve(address spender, uint256 amount) returns (bool)",
]);
const ZORG_RAGEQUIT_IFACE = new ethers.Interface([
  "function ragequit(address[] tokens, uint256 sharesToBurn, uint256 lootToBurn)",
]);

// ---- Quote refresh timer ----
let _refreshTimer = null;
let _refreshCountdown = 0;

function startQuoteRefresh() {
  stopQuoteRefresh();
  _refreshCountdown = 15;
  setText('quoteCountdown', `Refreshes in ${_refreshCountdown}s`);
  _refreshTimer = setInterval(() => {
    _refreshCountdown--;
    if (_refreshCountdown <= 0) {
      _refreshCountdown = 15;
      handleAmountChange();
    }
    setText('quoteCountdown', `Refreshes in ${_refreshCountdown}s`);
  }, 1000);
}

function stopQuoteRefresh() {
  if (_refreshTimer) { clearInterval(_refreshTimer); _refreshTimer = null; }
  _refreshCountdown = 0;
  setText('quoteCountdown', '');
}

function manualRefresh() {
  handleAmountChange();
  // Timer restarted by handleAmountChange on success
}

// ---- Quoting ----
let _quoteSeq = 0;

async function handleAmountChange() {
  const amtStr = $("fromAmount").value.trim();
  const swapBtn = $("swapBtn");
  const toAmountEl = $("toAmount");
  const quoteInfoEl = $("quoteInfo");

  if (!connectedAddress) {
    setText(swapBtn, "Connect Wallet");
    setDisabled(swapBtn, false);
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    toAmountEl.value = "";
    return;
  }

  const amtNum = Number(amtStr);
  if (!amtStr || !Number.isFinite(amtNum) || amtNum <= 0) {
    toAmountEl.value = "";
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    setText(swapBtn, "Enter an amount");
    setDisabled(swapBtn, true);
    return;
  }

  if (fromToken === toToken) {
    toAmountEl.value = "";
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    setText(swapBtn, "Select different tokens");
    setDisabled(swapBtn, true);
    return;
  }

  // ZAMM cannot be purchased directly â€” use the zOrg stake path instead
  if (tokens[toToken]?._isZammStake && !isDirectZOrgStake(fromToken, toToken) && !isRagequitPath(fromToken, toToken)) {
    toAmountEl.value = "";
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    setText(swapBtn, "Swap to zOrg instead (includes ZAMM)");
    setDisabled(swapBtn, true);
    return;
  }

  // ETH â†” WETH wrap/unwrap: 1:1, no DEX needed (only when sending to self)
  const _receiverRaw = ($("receiverAddress")?.value || "").trim();
  const _resolvedAddr = getReceiver();
  const _hasCustomReceiver = _receiverRaw && (isReceiverPending() || (_resolvedAddr && _resolvedAddr !== connectedAddress));
  const wrapDir = !_hasCustomReceiver ? isWrapUnwrap(fromToken, toToken) : null;
  if (wrapDir) {
    const fromData = tokens[fromToken];
    try {
      const amountIn = safeParseUnits(amtStr, fromData.decimals);
      // Output equals input (1:1, both 18 decimals)
      toAmountEl.value = amtStr;
      fitRouteText(wrapDir === 'wrap' ? 'WETH Wrap' : 'WETH Unwrap');
      const _ln = $("routeInfo")?.parentNode?.querySelector('.lido-note');
      if (_ln) _ln.style.display = 'none';
      $("chartLink").style.display = "none";
      setText('impactInfo', '0%');
      setShown('allRoutesWrap', false);
      setShown('impactRow', true);
      setShown('slippageRow', false);
      setShown('refreshRow', false);
      setShown(quoteInfoEl, true);
      stopQuoteRefresh(); // No refresh needed for 1:1
      setText(swapBtn, wrapDir === 'wrap' ? 'Wrap' : 'Unwrap');
      setDisabled(swapBtn, !connectedAddress);
    } catch (e) {
      toAmountEl.value = "";
      setShown(quoteInfoEl, false);
      setText(swapBtn, e.message || "Invalid amount");
      setDisabled(swapBtn, true);
    }
    return;
  }

  if (!provider) return;

  const seq = ++_quoteSeq;
  const fromSnap = fromToken, toSnap = toToken;

  try {
    setHTML(swapBtn, `<span class="loading"></span> Getting quote...`);
    setDisabled(swapBtn, true);
    toAmountEl.value = "";
    toAmountEl.placeholder = "Fetching\u2026";

    const quote = await requestQuote(amtStr, fromSnap, toSnap);

    if (seq !== _quoteSeq || fromSnap !== fromToken || toSnap !== toToken) return;

    const toData = tokens[toSnap];
    toAmountEl.placeholder = "0.0";
    const outRaw = ethers.formatUnits(quote.expectedOutput, toData.decimals);
    const outDisplay = fmtOutput(outRaw);
    if (toAmountEl.value !== outDisplay) toAmountEl.value = outDisplay;

    // Exchange rate line
    const rateEl = $('quoteRate');
    if (rateEl) {
      const inNum = Number(amtStr);
      const outNum = Number(outRaw);
      if (inNum > 0 && Number.isFinite(outNum) && outNum > 0) {
        const rate = outNum / inNum;
        // Adaptive precision: use more decimals for tiny rates (e.g. ZAMM â†’ ETH)
        const rateDec = rate >= 1 ? 2 : rate >= 0.01 ? 4 : rate >= 0.0001 ? 6 : 8;
        rateEl.textContent = `1 ${tokens[fromSnap].symbol} \u2248 ${fmt(rate.toString(), rateDec)} ${toData.symbol}`;
        rateEl.style.display = '';
      } else {
        rateEl.style.display = 'none';
      }
    }

    // Route display
    const isLidoRoute = quote.sourceA === "Lido" && !quote.isSplit && !quote.isTwoHop;
    const route = quote.isSplit
      ? formatSplitRoute(quote.splitLegs)
      : quote.isTwoHop
        ? `${quote.sourceA} + ${quote.sourceB}`
        : isLidoRoute ? "Lido Stake" : `${quote.sourceA}`;
    fitRouteText(route);
    updateChartLink(quote);
    // Show "Direct stake" note for Lido routes
    const routeEl = $("routeInfo");
    if (routeEl) {
      let noteEl = routeEl.parentNode.querySelector('.lido-note');
      if (isLidoRoute) {
        if (!noteEl) {
          noteEl = document.createElement('span');
          noteEl.className = 'lido-note';
          noteEl.style.cssText = 'font-size:11px;color:var(--fg-muted);margin-left:6px';
          routeEl.parentNode.appendChild(noteEl);
        }
        noteEl.textContent = 'Direct stake â€” no DEX fees';
        noteEl.style.display = '';
      } else if (noteEl) {
        noteEl.style.display = 'none';
      }
    }

    // Split/multi-hop slippage note
    const ssn = $('splitSlipNote');
    if (ssn) {
      if (quote.isSplit || quote.isTwoHop) {
        const slippageBps = readSlippage();
        const perLeg = Math.min(Math.max(slippageBps * 3, 150), 500) / 100;
        ssn.textContent = `(${perLeg}% per leg)`;
        ssn.style.display = '';
      } else {
        ssn.style.display = 'none';
      }
    }

    // Price impact
    displayPriceImpact(amtStr, fromSnap, toSnap, quote);

    // All routes
    displayAllRoutes(quote, toSnap);

    // Allowance check
    const fromData = tokens[fromSnap];
    const isDirectStake = isDirectZOrgStake(fromSnap, toSnap);
    const isRagequit = isRagequitPath(fromSnap, toSnap);
    const isDirectPath = isDirectStake || isRagequit;
    const isLidoStake = isLidoRoute;
    const hideSlippage = isDirectPath || isLidoStake;

    // Hide slippage & refresh for 1:1 / Lido / ragequit operations
    setShown('slippageRow', !hideSlippage);
    setShown('impactRow', !isLidoStake && !isRagequit);
    setShown('refreshRow', !isDirectPath);
    setShown(quoteInfoEl, true);
    if (isDirectPath) stopQuoteRefresh(); else startQuoteRefresh();
    const isZOrgSell = isZOrgSellPath(fromSnap, toSnap);
    const isZammSell = isZammSellPath(fromSnap, toSnap);
    let btnLabel = isRagequit ? "Ragequit"
      : isDirectStake ? "Stake"
      : isLidoStake ? "Stake"
      : isZOrgSwap(toSnap) ? "Swap & Stake"
      : isZOrgSell ? "Ragequit & Sell"
      : "Swap";
    if (fromData.address !== ZERO_ADDRESS) {
      const amountIn = safeParseUnits(amtStr, fromData.decimals);
      if (isDirectStake) {
        // Check allowance against zOrg DAO for direct stake
        const r = erc20Read(fromData.address);
        const allowance = await r.allowance(connectedAddress, ZORG_DAO);
        if (allowance < amountIn) btnLabel = "Approve & " + btnLabel;
      } else if (isRagequit) {
        // No approval needed for ragequit â€” DAO burns msg.sender's shares directly
      } else if (isZOrgSell) {
        // Ragequit doesn't need approval, but second step (ZAMM sell) might
        // Check ZAMM allowance against router for the sell leg
        let allowance = cacheGetAllowance(ZORG_PAY_TOKEN, connectedAddress, ZROUTER_ADDRESS);
        if (allowance == null) {
          const r = erc20Read(ZORG_PAY_TOKEN);
          allowance = await r.allowance(connectedAddress, ZROUTER_ADDRESS);
          cacheSetAllowance(ZORG_PAY_TOKEN, connectedAddress, ZROUTER_ADDRESS, allowance);
        }
        // Don't add "Approve &" prefix â€” handled in-flow during two-step execution
      } else {
        let allowance = cacheGetAllowance(fromData.address, connectedAddress, ZROUTER_ADDRESS);
        if (allowance == null) {
          const r = erc20Read(fromData.address);
          allowance = await r.allowance(connectedAddress, ZROUTER_ADDRESS);
          cacheSetAllowance(fromData.address, connectedAddress, ZROUTER_ADDRESS, allowance);
        }
        if (allowance < amountIn) {
          const [permitCfg, p2Allowance] = await Promise.all([
            getPermitConfig(fromData.address),
            checkPermit2Allowance(fromData.address),
          ]);
          btnLabel = (permitCfg || p2Allowance >= amountIn) ? btnLabel : ("Approve & " + btnLabel);
        }
      }
    }

    setText(swapBtn, btnLabel);
    setDisabled(swapBtn, false);
  } catch (e) {
    console.error("Quote error:", e);
    toAmountEl.value = "";
    toAmountEl.placeholder = "0.0";
    setShown(quoteInfoEl, false);
    stopQuoteRefresh();
    const msg = /Too many decimals|Invalid number|Empty amount/i.test(String(e?.message || ""))
      ? e.message : "Quote failed";
    setText(swapBtn, msg);
    setDisabled(swapBtn, true);
    setTimeout(() => {
      if (seq === _quoteSeq) {
        setText(swapBtn, "Enter an amount");
        setDisabled(swapBtn, true);
      }
    }, 1500);
  }
}

async function setPercentBalance(pct) {
  try {
    if (!provider || !connectedAddress) {
      toggleWallet();
      return;
    }

    const f = tokens[fromToken];
    let raw = getCachedBalance(f.address);

    if (raw == null) {
      if (f.address === ZERO_ADDRESS) {
        raw = await provider.getBalance(connectedAddress);
      } else {
        const c = new ethers.Contract(f.address,
          ["function balanceOf(address) view returns (uint256)"], provider);
        raw = await c.balanceOf(connectedAddress);
      }
      setCachedBalance(f.address, raw);
    }

    // Apply percentage
    raw = (raw * BigInt(pct)) / 100n;

    // Reserve 5% for gas when sending ETH at 100%
    if (f.address === ZERO_ADDRESS && pct === 100) raw = (raw * 95n) / 100n;

    const valStr = ethers.formatUnits(raw, f.decimals);
    const pretty = valStr.includes(".") ? valStr.replace(/\.?0+$/, "") : valStr;

    const input = $("fromAmount");
    input.value = pretty || "0";
    handleAmountChange();
  } catch (e) {
    console.error("Percent balance error:", e);
  }
}

// ---- Slippage ----
const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
function readSlippage(finalize = false) {
  const el = $("slippagePct");
  if (!el) return;
  const raw = el.value;
  let v = parseFloat(raw);
  if (Number.isFinite(v)) {
    v = clamp(v, 0, 20);
    slippageBps = Math.round(v * 100);
    if (finalize) {
      const stepDigits = (String(el.step || "0.1").split(".")[1] || "").length;
      el.value = v.toFixed(stepDigits);
    }
  } else if (finalize) {
    const stepDigits = (String(el.step || "0.1").split(".")[1] || "").length;
    el.value = clamp(slippageBps / 100, 0, 20).toFixed(stepDigits);
  }
  return slippageBps;
}

function initSimpleSlippage() {
  const el = $("slippagePct");
  if (!el || el.dataset.inited === "1") return;
  el.dataset.inited = "1";
  readSlippage(false);

  const reQuote = debounce(() => {
    const amt = $("fromAmount")?.value;
    if (amt) handleAmountChange();
  }, 250);

  el.addEventListener("input", () => { readSlippage(false); reQuote(); });
  el.addEventListener("blur", () => { readSlippage(true); reQuote(); });
  el.addEventListener("keydown", (e) => {
    if (e.key !== "ArrowUp" && e.key !== "ArrowDown") return;
    e.preventDefault();
    const step = parseFloat(el.step || "0.01") || 0.01;
    const digits = (String(step).split(".")[1] || "").length;
    const cur = parseFloat(el.value || "0") || 0;
    const dir = e.key === "ArrowUp" ? 1 : -1;
    const next = clamp(cur + dir * step, 0, 20);
    el.value = next.toFixed(digits);
    readSlippage(true);
    reQuote();
  });
}
document.addEventListener("DOMContentLoaded", initSimpleSlippage);

// ---- Receiver name resolution ----
let _resolvedReceiver = null; // { input, address } or null
let _receiverResolveSeq = 0;

function getReceiver() {
  if (!connectedAddress) return null;
  const v = ($("receiverAddress")?.value || "").trim();
  if (!v) return connectedAddress;
  if (ethers.isAddress(v) && v !== ZERO_ADDRESS) return ethers.getAddress(v);
  if (_resolvedReceiver && _resolvedReceiver.input === v && _resolvedReceiver.address) return _resolvedReceiver.address;
  return connectedAddress;
}

function isReceiverPending() {
  const v = ($("receiverAddress")?.value || "").trim();
  if (!v || ethers.isAddress(v)) return false;
  return !_resolvedReceiver || _resolvedReceiver.input !== v || !_resolvedReceiver.address;
}

let _receiverDebounce = null;
function onReceiverInput() {
  clearTimeout(_receiverDebounce);
  const v = ($("receiverAddress")?.value || "").trim();
  const el = $("receiverResolved");

  // Clear state
  _resolvedReceiver = null;

  // Direct 0x address
  if (!v) { el.style.display = "none"; return; }
  if (ethers.isAddress(v)) {
    el.style.display = "block";
    el.style.color = "var(--fg-muted)";
    el.textContent = ethers.getAddress(v);
    _resolvedReceiver = { input: v, address: ethers.getAddress(v) };
    return;
  }

  // Name resolution (.wei or .eth)
  if (v.endsWith(".wei") || v.endsWith(".eth")) {
    el.style.display = "block";
    el.style.color = "var(--fg-muted)";
    el.textContent = "Resolving " + v + "...";
    _receiverDebounce = setTimeout(() => resolveReceiverName(v), 350);
  } else {
    el.style.display = "block";
    el.style.color = "#c0392b";
    el.textContent = "Enter 0x address, name.wei, or name.eth";
  }
}

async function resolveReceiverName(name) {
  const seq = ++_receiverResolveSeq;
  const el = $("receiverResolved");
  try {
    let resolved = null;
    if (name.endsWith(".wei")) {
      resolved = await quoteRPC.call(async (rpc) => {
        const ns = getWeinsContract(rpc);
        const tokenId = await ns.computeId(name);
        const owner = await ns.ownerOf(tokenId).catch(() => null);
        if (!owner || owner === ZERO_ADDRESS) return null;
        return ethers.getAddress(owner);
      });
    } else if (name.endsWith(".eth")) {
      resolved = await quoteRPC.call(async (rpc) => {
        return await rpc.resolveName(name);
      });
    }
    if (seq !== _receiverResolveSeq) return;
    if (resolved && resolved !== ZERO_ADDRESS) {
      _resolvedReceiver = { input: name, address: resolved };
      el.style.color = "var(--fg-muted)";
      el.textContent = resolved;
    } else {
      _resolvedReceiver = null;
      el.style.color = "#c0392b";
      el.textContent = "Name not found";
    }
  } catch (e) {
    if (seq !== _receiverResolveSeq) return;
    _resolvedReceiver = null;
    el.style.color = "#c0392b";
    el.textContent = "Failed to resolve " + name;
  }
}

// Wire up receiver input listener after DOM ready
document.addEventListener("DOMContentLoaded", () => {
  const ri = $("receiverAddress");
  if (ri) ri.addEventListener("input", onReceiverInput);
});

// Cache contract instances per provider to avoid repeated construction
const _contractCache = new WeakMap();
function _getCached(rpc, addr, abi) {
  let m = _contractCache.get(rpc);
  if (!m) { m = new Map(); _contractCache.set(rpc, m); }
  let c = m.get(addr);
  if (!c) { c = new ethers.Contract(addr, abi, rpc); m.set(addr, c); }
  return c;
}
function getQuoterContract(rpc) { return _getCached(rpc, ZQUOTER_ADDRESS, QUOTER_IFACE); }
function getWeinsContract(rpc) { return _getCached(rpc, WEINS_ADDRESS, WEINS_ABI); }

// ---- zOrg swap+stake helpers ----
function isZOrgSwap(toSym) {
  return tokens[toSym]?._isZOrg === true;
}
function isDirectZOrgStake(fromSym, toSym) {
  return isZOrgSwap(toSym) && tokens[fromSym]?.address?.toLowerCase() === ZORG_PAY_TOKEN.toLowerCase();
}
function isRagequitPath(fromSym, toSym) {
  return tokens[fromSym]?._isZOrg === true && tokens[toSym]?._isZammStake === true;
}
// ZAMM â†’ any non-zOrg token (sell via zAMM pool)
function isZammSellPath(fromSym, toSym) {
  return tokens[fromSym]?._isZammStake === true && !isZOrgSwap(toSym) && !isRagequitPath(fromSym, toSym);
}
// zOrg â†’ any token except ZAMM (ragequit 1:1 to ZAMM, then sell ZAMM)
function isZOrgSellPath(fromSym, toSym) {
  return fromSym !== toSym && tokens[fromSym]?._isZOrg === true && !tokens[toSym]?._isZammStake && tokens[toSym] != null;
}

// ---- zAMM reverse quote: ZAMM â†’ ETH (client-side AMM math) ----
function getZammAmountOut(amtIn, resIn, resOut, feeBps) {
  if (amtIn === 0n || resIn === 0n || resOut === 0n) return 0n;
  const amtFee = amtIn * (10000n - feeBps);
  return (amtFee * resOut) / (resIn * 10000n + amtFee);
}

function computeZammPoolKey() {
  return ethers.AbiCoder.defaultAbiCoder().encode(
    ["uint256","uint256","address","address","uint256"],
    [0, ZORG_ID, ZERO_ADDRESS, ZORG_TOKEN, 100]
  );
}

async function getZammPoolReserves(rpc) {
  const poolId = BigInt(ethers.keccak256(computeZammPoolKey()));
  const zammHooked = new ethers.Contract(ZAMM_HOOKED, ZAMM_POOLS_ABI, rpc);
  const zammHookless = new ethers.Contract(ZAMM_HOOKLESS, ZAMM_POOLS_ABI, rpc);
  const callOpts = { blockTag: "latest" };
  const [hookedRes, hooklessRes] = await Promise.all([
    zammHooked.pools(poolId, callOpts).catch(() => [0n, 0n]),
    zammHookless.pools(poolId, callOpts).catch(() => [0n, 0n]),
  ]);
  return {
    hooked: { reserve0: BigInt(hookedRes[0]), reserve1: BigInt(hookedRes[1]) },
    hookless: { reserve0: BigInt(hooklessRes[0]), reserve1: BigInt(hooklessRes[1]) },
  };
}

// ZAMM â†’ ETH: sell ERC6909 ZORG for ETH (zeroForOne=false, reserveIn=reserve1, reserveOut=reserve0)
function getZammToEthQuote(amountIn, reserves) {
  const hookedOut = getZammAmountOut(amountIn, reserves.hooked.reserve1, reserves.hooked.reserve0, 100n);
  const hooklessOut = getZammAmountOut(amountIn, reserves.hookless.reserve1, reserves.hookless.reserve0, 100n);
  const useHookless = hooklessOut >= hookedOut;
  return { ethOut: useHookless ? hooklessOut : hookedOut, useHookless };
}

// ---- ETH â†” WETH wrap/unwrap detection ----
const WETH_ABI = ["function deposit() payable", "function withdraw(uint256 wad)"];

function isWrapUnwrap(fromSym, toSym) {
  const from = tokens[fromSym], to = tokens[toSym];
  if (!from || !to) return null;
  const fa = from.address.toLowerCase(), ta = to.address.toLowerCase();
  const weth = WETH_ADDRESS.toLowerCase();
  if (fa === ZERO_ADDRESS && ta === weth) return 'wrap';
  if (fa === weth && ta === ZERO_ADDRESS) return 'unwrap';
  return null;
}

// Direct ZAMM â†’ zOrg stake: no swap needed, call buyShares on the DAO directly
function getDirectZOrgStakeQuote(fromAmountStr, fromSym) {
  const fromData = tokens[fromSym];
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);
  readSlippage(true);
  const slipOut = amountIn * (10000n - BigInt(slippageBps)) / 10000n;

  // Encode the direct buyShares call on the DAO
  const buySharesData = ZORG_BUYSHARES_IFACE.encodeFunctionData('buyShares', [ZORG_PAY_TOKEN, slipOut, amountIn]);

  return {
    expectedOutput: amountIn,
    directDAO: true, // signals executeSwap to call the DAO directly
    daoCalldata: buySharesData,
    multicall: null,
    calls: null,
    msgValue: 0n,
    isTwoHop: false,
    isSplit: false,
    splitLegs: null,
    sourceA: "Direct Stake",
    sourceB: null,
    allQuotes: [{ source: "Direct DAO Stake", sourceId: 2, feeBps: 0n, amountIn, amountOut: amountIn }],
  };
}

// Ragequit zOrg â†’ ZAMM: 1:1 redemption, direct call to DAO
function getRagequitQuote(fromAmountStr, fromSym) {
  const fromData = tokens[fromSym];
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);

  const ragequitData = ZORG_RAGEQUIT_IFACE.encodeFunctionData('ragequit', [
    [ZORG_PAY_TOKEN], amountIn, 0
  ]);

  return {
    expectedOutput: amountIn,
    directDAO: true,
    isRagequit: true,
    daoCalldata: ragequitData,
    multicall: null,
    calls: null,
    msgValue: 0n,
    isTwoHop: false,
    isSplit: false,
    splitLegs: null,
    sourceA: "Ragequit",
    sourceB: null,
    allQuotes: [{ source: "DAO Ragequit", sourceId: 2, feeBps: 0n, amountIn, amountOut: amountIn }],
  };
}

// ZAMM â†’ any token: sell ZAMM via zAMM pool (ZAMMâ†’ETH), then optionally ETHâ†’target via quoter
async function getZammSellQuote(fromAmountStr, fromSym, toSym) {
  const fromData = tokens[fromSym], toData = tokens[toSym];
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);
  readSlippage(true);
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 300);
  const receiver = getReceiver();
  const toIsEth = toData.address === ZERO_ADDRESS;

  return await quoteRPC.call(async (rpc) => {
    const callOpts = { blockTag: "latest" };
    const reserves = await getZammPoolReserves(rpc);
    const { ethOut, useHookless } = getZammToEthQuote(amountIn, reserves);
    const zammDeadline = useHookless ? ethers.MaxUint256 : deadline;
    const zammSource = useHookless ? "zAMMâ‚€" : "zAMM";

    if (toIsEth) {
      // ZAMM â†’ ETH: single zAMM swap via router
      // Router needs ERC6909 input. User holds ERC20 ZAMM.
      // Router deposit() converts ERC20 â†’ ERC6909 for the pool.
      const slipOut = ethOut * (10000n - BigInt(slippageBps)) / 10000n;
      const calls = [];
      // deposit: convert ERC20 ZAMM to ERC6909 inside the router
      calls.push(ROUTER_IFACE.encodeFunctionData('deposit', [ZORG_TOKEN, ZORG_ID, amountIn]));
      // swapVZ: sell ZORG ERC6909 for ETH (zeroForOne=false)
      calls.push(ROUTER_IFACE.encodeFunctionData('swapVZ', [
        receiver, false, 100,
        ZORG_TOKEN, ZERO_ADDRESS, ZORG_ID, 0,
        amountIn, slipOut, zammDeadline
      ]));
      // Sweep ETH to receiver
      calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, receiver]));
      // Safety sweep: remaining ERC20 ZAMM back to user
      calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZORG_PAY_TOKEN, 0, 0, receiver]));
      const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);

      return {
        expectedOutput: ethOut,
        multicall, calls, msgValue: 0n,
        isTwoHop: false, isSplit: false, splitLegs: null,
        sourceA: zammSource, sourceB: null,
        allQuotes: [{ source: zammSource, sourceId: 2, feeBps: 100n, amountIn, amountOut: ethOut }],
      };
    }

    // ZAMM â†’ non-ETH: zAMM (ZAMMâ†’ETH) + quoter (ETHâ†’target)
    const quoter = getQuoterContract(rpc);
    const splitSlip = BigInt(Math.min(Math.max(slippageBps * 3, 150), 500));
    const r = await quoter.buildBestSwapViaETHMulticall(
      receiver, connectedAddress, false,
      ZERO_ADDRESS, toData.address,
      ethOut, splitSlip, deadline, 0, 0, ZERO_ADDRESS, callOpts
    );
    const isTwoHop = r.b.amountOut > 0n;
    const finalOut = isTwoHop ? r.b.amountOut : r.a.amountOut;
    const secondLegSource = AMM_NAMES[r.a.source] || "Unknown";

    // Build multicall: deposit + swapVZ (ZAMMâ†’ETH) + second-leg calls (ETHâ†’target) + sweeps
    const slipZamm = ethOut * (10000n - splitSlip) / 10000n;
    const calls = [];
    calls.push(ROUTER_IFACE.encodeFunctionData('deposit', [ZORG_TOKEN, ZORG_ID, amountIn]));
    calls.push(ROUTER_IFACE.encodeFunctionData('swapVZ', [
      ZROUTER_ADDRESS, false, 100,
      ZORG_TOKEN, ZERO_ADDRESS, ZORG_ID, 0,
      amountIn, slipZamm, zammDeadline
    ]));
    // Second leg: ETH â†’ target (calls from quoter operate on transient ETH in router)
    for (const c of Array.from(r.calls)) calls.push(c);
    // Sweep target token and ETH remainder
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [toData.address, 0, 0, receiver]));
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, receiver]));
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZORG_PAY_TOKEN, 0, 0, receiver]));
    const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);

    return {
      expectedOutput: finalOut,
      multicall, calls, msgValue: 0n,
      isTwoHop: true, isSplit: false, splitLegs: null,
      sourceA: zammSource, sourceB: secondLegSource,
      allQuotes: [{ source: `${zammSource} + ${secondLegSource}`, sourceId: 2, feeBps: 100n, amountIn, amountOut: finalOut }],
    };
  });
}

// zOrg â†’ any token (except ZAMM, which is ragequit): ragequit (1:1) then sell ZAMM
// This is a two-step flow: ragequit tx first, then ZAMM sell tx
async function getZOrgSellQuote(fromAmountStr, fromSym, toSym) {
  const fromData = tokens[fromSym];
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);
  // After ragequit, user gets amountIn ZAMM (1:1, both 18 decimals)
  // Then sell that ZAMM to the target
  const zammQuote = await getZammSellQuote(fromAmountStr, "ZAMM", toSym);

  // Encode ragequit calldata for the first tx
  const ragequitData = ZORG_RAGEQUIT_IFACE.encodeFunctionData('ragequit', [
    [ZORG_PAY_TOKEN], amountIn, 0
  ]);

  return {
    expectedOutput: zammQuote.expectedOutput,
    isZOrgSell: true, // signals two-step execution
    ragequitData,
    zammSellQuote: zammQuote, // second step quote
    multicall: zammQuote.multicall,
    calls: zammQuote.calls,
    msgValue: 0n,
    isTwoHop: true, isSplit: false, splitLegs: null,
    sourceA: "Ragequit", sourceB: zammQuote.sourceA + (zammQuote.sourceB ? " + " + zammQuote.sourceB : ""),
    allQuotes: [{ source: `Ragequit + ${zammQuote.sourceA}`, sourceId: 2, feeBps: 100n, amountIn, amountOut: zammQuote.expectedOutput }],
  };
}

async function getZOrgQuote(fromAmountStr, fromSym) {
  const fromData = tokens[fromSym];
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);
  readSlippage(true);
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 300);
  const receiver = getReceiver();
  const ethIn = fromData.address === ZERO_ADDRESS;

  return await quoteRPC.call(async (rpc) => {
    const quoter = getQuoterContract(rpc);
    const callOpts = { blockTag: "latest" };

    let ethForSwap = amountIn;
    let firstLegCalls = null;
    let firstLegSource = null;
    let msgValue = ethIn ? amountIn : 0n;

    // Non-ETH input: route tokenIn â†’ ETH first via quoter (output stays in router)
    if (!ethIn) {
      const r = await quoter.buildBestSwapViaETHMulticall(
        ZROUTER_ADDRESS, connectedAddress, false,
        fromData.address, ZERO_ADDRESS,
        amountIn, BigInt(slippageBps), deadline, 0, 0, ZERO_ADDRESS, callOpts
      );
      const isTwoHop = r.b.amountOut > 0n;
      ethForSwap = isTwoHop ? r.b.amountOut : r.a.amountOut;
      firstLegCalls = Array.from(r.calls);
      firstLegSource = AMM_NAMES[r.a.source] || "Unknown";
      msgValue = 0n;
    }

    // Quote both zAMM pools (hooked & hookless) and pick the better rate
    // PoolKey: (id0=0, id1=ZORG_ID, token0=ZERO_ADDRESS, token1=ZORG_TOKEN, feeOrHook=100)
    // sorted: address(0) < ZORG_TOKEN, so zeroForOne=true (ETH in, ZORG out)
    const poolKey = ethers.AbiCoder.defaultAbiCoder().encode(
      ["uint256","uint256","address","address","uint256"],
      [0, ZORG_ID, ZERO_ADDRESS, ZORG_TOKEN, 100]
    );
    const poolId = BigInt(ethers.keccak256(poolKey));
    const zammHooked = new ethers.Contract(ZAMM_HOOKED, ZAMM_POOLS_ABI, rpc);
    const zammHookless = new ethers.Contract(ZAMM_HOOKLESS, ZAMM_POOLS_ABI, rpc);
    const [hookedRes, hooklessRes] = await Promise.all([
      zammHooked.pools(poolId, callOpts).catch(() => [0n, 0n]),
      zammHookless.pools(poolId, callOpts).catch(() => [0n, 0n]),
    ]);
    // zeroForOne=true â†’ reserveIn=reserve0, reserveOut=reserve1
    function getAmountOut(amtIn, resIn, resOut, feeBps) {
      if (amtIn === 0n || resIn === 0n || resOut === 0n) return 0n;
      const amtFee = amtIn * (10000n - feeBps);
      return (amtFee * resOut) / (resIn * 10000n + amtFee);
    }
    const hookedOut = getAmountOut(ethForSwap, BigInt(hookedRes[0]), BigInt(hookedRes[1]), 100n);
    const hooklessOut = getAmountOut(ethForSwap, BigInt(hooklessRes[0]), BigInt(hooklessRes[1]), 100n);
    const useHookless = hooklessOut >= hookedOut;
    const zammOut = useHookless ? hooklessOut : hookedOut;
    // deadline=MaxUint256 signals router to use hookless ZAMM_0
    const zammDeadline = useHookless ? ethers.MaxUint256 : deadline;

    // Build multicall
    const slipOut = zammOut * (10000n - BigInt(slippageBps)) / 10000n;
    const calls = [];

    // If non-ETH: include first leg calls (tokenIn â†’ ETH, output stays in router via transient storage)
    if (firstLegCalls) {
      for (const c of firstLegCalls) calls.push(c);
    }

    // swapVZ: input â†’ ERC6909 token, output to zRouter
    // ETH path: tokenIn=address(0), swapAmount=0 uses msg.value
    // Non-ETH path: tokenIn=address(0), explicit swapAmount (covered by transient ETH from first leg)
    calls.push(ROUTER_IFACE.encodeFunctionData('swapVZ', [
      ZROUTER_ADDRESS, false, 100,
      ZERO_ADDRESS, ZORG_TOKEN, 0, ZORG_ID,
      ethIn ? 0 : ethForSwap, slipOut, zammDeadline
    ]));

    // execute: buyShares on the DAO (payToken = ERC20 equivalent, shareAmount = slipOut, maxPay = full swap output)
    calls.push(ROUTER_IFACE.encodeFunctionData('execute', [
      ZORG_DAO, 0,
      ZORG_BUYSHARES_IFACE.encodeFunctionData('buyShares', [ZORG_PAY_TOKEN, slipOut, zammOut])
    ]));

    // Sweep DAO shares (ERC20) to user
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZORG_DAO_TOKEN, 0, 0, receiver]));

    // Safety sweep: remaining ERC20 pay token back to user
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZORG_PAY_TOKEN, 0, 0, receiver]));

    // Safety sweep: remaining ETH back to user
    calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, receiver]));

    // Safety sweep: input token back to user (if non-ETH)
    if (!ethIn) {
      calls.push(ROUTER_IFACE.encodeFunctionData('sweep', [fromData.address, 0, 0, receiver]));
    }

    const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);

    return {
      expectedOutput: zammOut,
      multicall,
      calls,
      msgValue,
      isTwoHop: !ethIn,
      isSplit: false,
      splitLegs: null,
      sourceA: ethIn ? (useHookless ? "zAMMâ‚€" : "zAMM") : firstLegSource,
      sourceB: ethIn ? null : (useHookless ? "zAMMâ‚€" : "zAMM"),
      allQuotes: [{ source: (useHookless ? "zAMMâ‚€" : "zAMM") + " â†’ DAO Stake", sourceId: 2, feeBps: 100n, amountIn, amountOut: zammOut }],
    };
  });
}

async function getQuote(fromAmountStr, fromSym, toSym) {
  if (!connectedAddress) throw new Error("Connect wallet to get a quote");
  const fromData = tokens[fromSym], toData = tokens[toSym];
  if (!fromData || !toData) throw new Error("Unknown token");
  if (fromData.address === toData.address) throw new Error("Same token");

  // Direct ZAMM â†’ zOrg stake (no swap needed)
  if (isDirectZOrgStake(fromSym, toSym)) {
    return getDirectZOrgStakeQuote(fromAmountStr, fromSym);
  }

  // zOrg â†’ ZAMM ragequit (burn shares, claim ZAMM)
  if (isRagequitPath(fromSym, toSym)) {
    return getRagequitQuote(fromAmountStr, fromSym);
  }

  // zOrg special path: swap + stake
  if (isZOrgSwap(toSym)) {
    return await getZOrgQuote(fromAmountStr, fromSym);
  }

  // ZAMM sell path: ZAMM â†’ any token via zAMM pool
  if (isZammSellPath(fromSym, toSym)) {
    return await getZammSellQuote(fromAmountStr, fromSym, toSym);
  }

  // zOrg sell path: ragequit (1:1 â†’ ZAMM) then sell ZAMM
  if (isZOrgSellPath(fromSym, toSym)) {
    return await getZOrgSellQuote(fromAmountStr, fromSym, toSym);
  }

  const receiver = getReceiver();
  const amountIn = safeParseUnits(fromAmountStr, fromData.decimals);
  readSlippage(true);
  const deadline = BigInt(Math.trunc(Date.now() / 1000) + 300);

  return await quoteRPC.call(async (rpc) => {
    const quoter = getQuoterContract(rpc);
    const callOpts = { blockTag: "latest" };

    // Fire all calls in parallel (V4 hooked only for PNKSTR swaps)
    const isPNKSTR = fromData.address.toLowerCase() === PNKSTR_ADDRESS.toLowerCase()
      || toData.address.toLowerCase() === PNKSTR_ADDRESS.toLowerCase();
    // Split/multi-hop routes need wider per-leg slippage to avoid intermittent reverts
    // (each leg has its own amountLimit; first leg moves price affecting the second)
    const splitSlip = BigInt(Math.min(Math.max(slippageBps * 3, 150), 500));
    const hookFee = 0;
    const hookTick = isPNKSTR ? 60 : 0;
    const hookAddr = isPNKSTR ? PNKSTR_HOOK_ADDRESS : ZERO_ADDRESS;
    const allCalls = [
      quoter.buildBestSwapViaETHMulticall(
        receiver, connectedAddress, false,
        fromData.address, toData.address,
        amountIn, BigInt(slippageBps), deadline,
        hookFee, hookTick, hookAddr, callOpts
      ),
      quoter.buildSplitSwap(
        receiver, fromData.address, toData.address,
        amountIn, splitSlip, deadline, callOpts
      ),
      quoter.getQuotes(false, fromData.address, toData.address, amountIn, callOpts),
      quoter.quoteCurve(false, fromData.address, toData.address, amountIn, 8, callOpts),
      quoter.build3HopMulticall(
        receiver, fromData.address, toData.address,
        amountIn, splitSlip, deadline, callOpts
      ),
      quoter.buildHybridSplit(
        receiver, fromData.address, toData.address,
        amountIn, splitSlip, deadline, callOpts
      ),
    ];
    if (isPNKSTR) {
      allCalls.push(quoter.buildSplitSwapHooked(
        receiver, fromData.address, toData.address,
        amountIn, splitSlip, deadline,
        0, 60, PNKSTR_HOOK_ADDRESS, callOpts
      ));
    }
    // Lido quote for ETH â†’ stETH / wstETH
    const isLidoEligible = fromData.address === ZERO_ADDRESS
      && (toData.address.toLowerCase() === STETH_ADDRESS.toLowerCase()
       || toData.address.toLowerCase() === WSTETH_ADDRESS.toLowerCase());
    let lidoQuoteIdx = -1;
    if (isLidoEligible) {
      lidoQuoteIdx = allCalls.length;
      allCalls.push(quoter.quoteLido(false, toData.address, amountIn, callOpts));
    }
    const settled = await Promise.allSettled(allCalls);
    const [bestResult, splitResult, quotesResult, curveResult, threeHopResult, hybridSplitResult] = settled;
    const v4SplitResult = isPNKSTR ? settled[6] : undefined;
    const lidoQuoteResult = lidoQuoteIdx >= 0 ? settled[lidoQuoteIdx] : undefined;

    // bestResult is required
    if (bestResult.status === 'rejected') throw bestResult.reason;
    const r = bestResult.value;

    const isTwoHop = r.b.amountOut > 0n;
    const bestOutput = isTwoHop ? r.b.amountOut : r.a.amountOut;

    let result = {
      expectedOutput: bestOutput,
      multicall: r.multicall,
      calls: r.calls,
      msgValue: r.msgValue ?? 0n,
      isTwoHop,
      isSplit: false,
      splitLegs: null,
      sourceA: AMM_NAMES[r.a.source] || "Unknown",
      sourceB: isTwoHop ? (AMM_NAMES[r.b.source] || "Unknown") : null,
      allQuotes: null,
    };

    // Check if split beats best
    if (splitResult.status === 'fulfilled') {
      const s = splitResult.value;
      const splitTotal = s.legs[0].amountOut + s.legs[1].amountOut;
      if (splitTotal > bestOutput && s.legs[0].amountOut > 0n && s.legs[1].amountOut > 0n) {
        result.expectedOutput = splitTotal;
        result.multicall = s.multicall;
        result.msgValue = s.msgValue ?? 0n;
        result.isSplit = true;
        result.isTwoHop = false;
        result.splitLegs = [
          { source: AMM_NAMES[s.legs[0].source] || "Unknown", amountIn: s.legs[0].amountIn, amountOut: s.legs[0].amountOut, feeBps: s.legs[0].feeBps },
          { source: AMM_NAMES[s.legs[1].source] || "Unknown", amountIn: s.legs[1].amountIn, amountOut: s.legs[1].amountOut, feeBps: s.legs[1].feeBps },
        ];
        // calls not returned by buildSplitSwap; multicall is directly usable
        result.calls = null;
      }
    }

    // Attach all-quotes for display
    if (quotesResult.status === 'fulfilled') {
      const q = quotesResult.value;
      result.allQuotes = q.quotes.map(qt => ({
        source: AMM_NAMES[qt.source] || `AMM #${qt.source}`,
        sourceId: Number(qt.source),
        feeBps: qt.feeBps,
        amountIn: qt.amountIn,
        amountOut: qt.amountOut,
      })).filter(qt => qt.amountOut > 0n);
      // Merge Curve quote if available
      if (curveResult.status === 'fulfilled') {
        const c = curveResult.value;
        if (c.amountOut > 0n) {
          result.allQuotes.push({ source: "Curve", sourceId: 5, feeBps: 0n, amountIn: c.amountIn, amountOut: c.amountOut });
        }
      }
      // Merge Lido quote if available
      if (lidoQuoteResult?.status === 'fulfilled') {
        const l = lidoQuoteResult.value;
        if (l.amountOut > 0n) {
          result.allQuotes.push({ source: "Lido", sourceId: 6, feeBps: 0n, amountIn: l.amountIn, amountOut: l.amountOut });
        }
      }
    }

    // Check if 3-hop beats current best
    if (threeHopResult?.status === 'fulfilled' && threeHopResult.value) {
      const h3 = threeHopResult.value;
      const h3Output = h3.c.amountOut;
      if (h3Output > result.expectedOutput && h3Output > 0n) {
        result.expectedOutput = h3Output;
        result.multicall = h3.multicall;
        result.calls = h3.calls;
        result.msgValue = h3.msgValue ?? 0n;
        result.isTwoHop = true;
        result.isSplit = false;
        result.splitLegs = null;
        result.sourceA = `${AMM_NAMES[h3.a.source] || "?"} â†’ ${AMM_NAMES[h3.b.source] || "?"}`;
        result.sourceB = AMM_NAMES[h3.c.source] || "?";
      }
    }

    // Check if hybrid split (single-hop + 2-hop) beats current best
    if (hybridSplitResult?.status === 'fulfilled' && hybridSplitResult.value) {
      const hs = hybridSplitResult.value;
      const hsTotal = hs.legs[0].amountOut + hs.legs[1].amountOut;
      const isTrueSplit = hs.legs[0].amountOut > 0n && hs.legs[1].amountOut > 0n;
      if (hsTotal > result.expectedOutput && hsTotal > 0n) {
        result.expectedOutput = hsTotal;
        result.multicall = hs.multicall;
        result.msgValue = hs.msgValue ?? 0n;
        result.calls = null;
        if (isTrueSplit) {
          result.isSplit = true;
          result.isTwoHop = false;
          result.splitLegs = [
            { source: AMM_NAMES[hs.legs[0].source] || "Unknown", amountIn: hs.legs[0].amountIn, amountOut: hs.legs[0].amountOut, feeBps: hs.legs[0].feeBps },
            { source: (AMM_NAMES[hs.legs[1].source] || "Unknown") + " (via hub)", amountIn: hs.legs[1].amountIn, amountOut: hs.legs[1].amountOut, feeBps: hs.legs[1].feeBps },
          ];
          result.sourceA = AMM_NAMES[hs.legs[0].source] || "Unknown";
          result.sourceB = null;
        } else {
          // Single strategy won (100% direct or 100% 2-hop)
          const activeLeg = hs.legs[0].amountOut > 0n ? hs.legs[0] : hs.legs[1];
          result.isSplit = false;
          result.isTwoHop = hs.legs[1].amountOut > 0n;
          result.sourceA = AMM_NAMES[activeLeg.source] || "Unknown";
          result.sourceB = null;
          result.splitLegs = null;
        }
      }
    }

    // Check if V4 hooked split/single (contract-built calldata) beats current best
    if (v4SplitResult?.status === 'fulfilled' && v4SplitResult.value) {
      const hs = v4SplitResult.value;
      const hsTotal = hs.legs[0].amountOut + hs.legs[1].amountOut;
      const isTrueSplit = hs.legs[0].amountOut > 0n && hs.legs[1].amountOut > 0n;
      const activeLeg = hs.legs[0].amountOut > 0n ? hs.legs[0] : hs.legs[1];

      // Add V4 hooked split option to allQuotes if a hooked leg exists
      if (result.allQuotes && isTrueSplit && hsTotal > 0n) {
        const hookedLeg = Number(hs.legs[0].source) === 8 ? hs.legs[0] : (Number(hs.legs[1].source) === 8 ? hs.legs[1] : null);
        if (hookedLeg) {
          result.allQuotes.push({ source: "V4 Hooked (split)", sourceId: 8, feeBps: hookedLeg.feeBps, amountIn, amountOut: hsTotal });
        }
      }

      if (hsTotal > result.expectedOutput && hsTotal > 0n) {
        result.expectedOutput = hsTotal;
        result.multicall = hs.multicall;
        result.msgValue = hs.msgValue ?? 0n;
        result.calls = null;
        if (isTrueSplit) {
          result.isSplit = true;
          result.isTwoHop = false;
          result.sourceA = AMM_NAMES[hs.legs[0].source] || "Unknown";
          result.sourceB = null;
          result.splitLegs = [
            { source: AMM_NAMES[hs.legs[0].source] || "Unknown", amountIn: hs.legs[0].amountIn, amountOut: hs.legs[0].amountOut, feeBps: hs.legs[0].feeBps },
            { source: AMM_NAMES[hs.legs[1].source] || "Unknown", amountIn: hs.legs[1].amountIn, amountOut: hs.legs[1].amountOut, feeBps: hs.legs[1].feeBps },
          ];
        } else {
          result.isSplit = false;
          result.isTwoHop = false;
          result.sourceA = AMM_NAMES[activeLeg.source] || "V4 Hooked";
          result.sourceB = null;
          result.splitLegs = null;
        }
      }
    }

    // Prefer Lido for ETHâ†’stETH/wstETH when competitive (guaranteed execution, no pool risk)
    if (isLidoEligible && lidoQuoteResult?.status === 'fulfilled') {
      const l = lidoQuoteResult.value;
      if (l.amountOut > 0n) {
        // Use Lido if within 0.5% of best, or if Lido actually beats best
        const threshold = result.expectedOutput * 9950n / 10000n;
        if (l.amountOut >= threshold) {
          const isStETH = toData.address.toLowerCase() === STETH_ADDRESS.toLowerCase();
          const lidoCall = isStETH
            ? ROUTER_IFACE.encodeFunctionData('exactETHToSTETH', [receiver])
            : ROUTER_IFACE.encodeFunctionData('exactETHToWSTETH', [receiver]);
          const sweepEth = ROUTER_IFACE.encodeFunctionData('sweep', [ZERO_ADDRESS, 0, 0, connectedAddress]);
          const calls = [lidoCall, sweepEth];
          const multicall = ROUTER_IFACE.encodeFunctionData('multicall', [calls]);
          result.expectedOutput = l.amountOut;
          result.multicall = multicall;
          result.calls = calls;
          result.msgValue = amountIn;
          result.isTwoHop = false;
          result.isSplit = false;
          result.splitLegs = null;
          result.sourceA = "Lido";
          result.sourceB = null;
        }
      }
    }

    return result;
  });
}

// ---- Split route formatting ----
function formatSplitRoute(legs) {
  if (!legs || legs.length < 2) return "Split";
  const total = legs[0].amountIn + legs[1].amountIn;
  if (total === 0n) return `${legs[0].source} + ${legs[1].source}`;
  const pct0 = Number(legs[0].amountIn * 100n / total);
  const pct1 = 100 - pct0;
  return `${pct0}% ${legs[0].source} + ${pct1}% ${legs[1].source}`;
}

// ---- All-routes toggle ----
function toggleAllRoutes() {
  const list = $('allRoutesList');
  const chev = $('routesChevron');
  const open = list.style.display !== 'none';
  list.style.display = open ? 'none' : 'block';
  chev.innerHTML = open ? '&#9654;' : '&#9660;';
}

function displayAllRoutes(quote, toSym) {
  const wrap = $('allRoutesWrap');
  const list = $('allRoutesList');
  if (!quote.allQuotes || quote.allQuotes.length === 0) {
    setShown(wrap, false);
    return;
  }
  const toData = tokens[toSym];
  const sorted = [...quote.allQuotes].sort((a, b) => (b.amountOut > a.amountOut ? 1 : b.amountOut < a.amountOut ? -1 : 0));
  const bestAmt = sorted[0].amountOut;
  list.innerHTML = sorted.map(q => {
    const out = fmt(ethers.formatUnits(q.amountOut, toData.decimals));
    const badge = q.amountOut === bestAmt ? '<span class="best-badge">best</span>' : '';
    const fee = Number(q.feeBps);
    const feeLabel = fee > 0 ? ` (${fee >= 100 ? (fee / 100) + '%' : fee + 'bp'})` : '';
    return `<div class="routes-list-item"><span>${escText(q.source)}${escText(feeLabel)}</span><span>${out} ${escText(toData.symbol)}${badge}</span></div>`;
  }).join('');
  setShown(wrap, true);
}

// ---- Price impact via spot rate ----
const _spotCache = new Map();
const _spotTTL = 60_000;
const _spotMaxSize = 50;

function _spotKey(tokenIn, tokenOut) {
  return `${tokenIn.toLowerCase()}:${tokenOut.toLowerCase()}`;
}

async function getSpotRate(fromSym, toSym) {
  const fromData = tokens[fromSym], toData = tokens[toSym];
  const key = _spotKey(fromData.address, toData.address);
  const cached = _spotCache.get(key);
  if (cached && Date.now() - cached.t < _spotTTL) return cached.rate;

  // zAMM/zOrg special paths: use reserve math (quoter doesn't know these tokens)
  const isFromZamm = fromData._isZammStake || fromData._isZOrg;
  const isToZamm = toData._isZammStake || toData._isZOrg;
  if (isFromZamm || isToZamm) {
    try {
      const spotRate = await quoteRPC.call(async (rpc) => {
        const reserves = await getZammPoolReserves(rpc);
        // Pick best pool
        const h = reserves.hooked, hl = reserves.hookless;
        // Use the pool with more liquidity (higher product)
        const useHookless = hl.reserve0 * hl.reserve1 >= h.reserve0 * h.reserve1;
        const r0 = useHookless ? hl.reserve0 : h.reserve0; // ETH
        const r1 = useHookless ? hl.reserve1 : h.reserve1; // ZAMM/ERC6909
        if (r0 === 0n || r1 === 0n) return null;
        // zOrg â†” ZAMM is 1:1, so zOrg rate = ZAMM rate
        // ZAMM/zOrg â†’ ETH: num=r0 (ETH per unit), den=r1
        // ETH â†’ ZAMM/zOrg: num=r1, den=r0
        if (isFromZamm && !isToZamm) {
          // Selling ZAMM/zOrg â†’ ETH (or via ETH to target)
          if (toData.address === ZERO_ADDRESS) return { num: r0, den: r1 };
          // For non-ETH target, rate = (r0/r1) * ethToTargetRate â€” fall through to generic
          return null;
        }
        if (isToZamm && !isFromZamm) {
          // Buying ZAMM/zOrg: ETH â†’ ZAMM
          if (fromData.address === ZERO_ADDRESS) return { num: r1, den: r0 };
          return null;
        }
        // Both are ZAMM/zOrg: 1:1
        return { num: 1n, den: 1n };
      });
      if (spotRate != null) {
        if (_spotCache.size >= _spotMaxSize) {
          const oldest = _spotCache.keys().next().value;
          _spotCache.delete(oldest);
        }
        _spotCache.set(key, { rate: spotRate, t: Date.now() });
        return spotRate;
      }
    } catch (e) {
      console.warn("zAMM spot rate failed:", e);
    }
  }

  // Use a small reference amount: 10^(decimals-2) or at least 1 unit
  const refExp = Math.max(0, fromData.decimals - 2);
  const refAmount = 10n ** BigInt(refExp);

  try {
    const spotRate = await quoteRPC.call(async (rpc) => {
      const quoter = getQuoterContract(rpc);
      const callOpts = { blockTag: "latest" };
      const [baseResult, curveResult] = await Promise.allSettled([
        quoter.getQuotes(false, fromData.address, toData.address, refAmount, callOpts),
        quoter.quoteCurve(false, fromData.address, toData.address, refAmount, 8, callOpts),
      ]);
      let bestOut = 0n, bestIn = 0n;
      if (baseResult.status === 'fulfilled') {
        const q = baseResult.value;
        if (q.best.amountOut > bestOut) { bestOut = q.best.amountOut; bestIn = q.best.amountIn; }
      }
      if (curveResult.status === 'fulfilled') {
        const c = curveResult.value;
        if (c.amountOut > bestOut) { bestOut = c.amountOut; bestIn = c.amountIn; }
      }
      if (bestOut === 0n || bestIn === 0n) return null;
      // Store raw BigInts to avoid precision loss in Number conversion
      return { num: bestOut, den: bestIn };
    });
    if (spotRate != null) {
      if (_spotCache.size >= _spotMaxSize) {
        const oldest = _spotCache.keys().next().value;
        _spotCache.delete(oldest);
      }
      _spotCache.set(key, { rate: spotRate, t: Date.now() });
    }
    return spotRate;
  } catch (e) {
    console.warn("Spot rate fetch failed:", e);
    return null;
  }
}

async function displayPriceImpact(amtStr, fromSym, toSym, quote) {
  const el = $('impactInfo');
  if (!el) return;
  const seq = _quoteSeq; // capture to detect staleness after await
  try {
    const fromData = tokens[fromSym], toData = tokens[toSym];
    const amountIn = safeParseUnits(amtStr, fromData.decimals);

    const spotRate = await getSpotRate(fromSym, toSym);
    if (seq !== _quoteSeq) return; // stale â€” newer quote already in flight
    if (spotRate == null || spotRate.den === 0n) {
      el.textContent = '--';
      el.className = '';
      return;
    }

    // impact = (1 - execRate/spotRate) * 100
    // execRate = expectedOutput / amountIn, spotRate = num / den
    // impact = (1 - (expectedOutput * den) / (amountIn * num)) * 100
    const SCALE = 10n ** 18n;
    const ratio = (quote.expectedOutput * spotRate.den * SCALE) / (amountIn * spotRate.num);
    const impact = Number(SCALE - ratio) * 100 / Number(SCALE);
    const displayImpact = Math.max(0, impact);
    el.textContent = displayImpact < 0.01 ? '<0.01%' : displayImpact.toFixed(2) + '%';

    const qBox = $('quoteInfo');
    if (displayImpact > 5) {
      el.className = 'impact-danger';
      if (qBox) qBox.classList.add('impact-high');
    } else if (displayImpact > 2) {
      el.className = 'impact-warn';
      if (qBox) qBox.classList.remove('impact-high');
    } else {
      el.className = '';
      if (qBox) qBox.classList.remove('impact-high');
    }
  } catch (e) {
    el.textContent = '--';
    el.className = '';
    const qBox = $('quoteInfo');
    if (qBox) qBox.classList.remove('impact-high');
  }
}

async function withRetry(task, { tries = 3, base = 120 } = {}) {
  let attempt = 0, lastErr;
  while (attempt < tries) {
    try { return await task(); } catch (e) {
      const s = String(e?.message || "");
      const transient = /missing revert data|CALL_EXCEPTION|timeout|ETIMEDOUT|429|rate/i.test(s);
      if (!transient || attempt === tries - 1) throw e;
      lastErr = e;
      await new Promise(r => setTimeout(r, base * Math.pow(2, attempt)));
      attempt++;
    }
  }
  throw lastErr;
}

let _quoteLock = Promise.resolve();
let _pendingQuoteArgs = null;
let _pendingQuoteSeq = 0;

let _quoteResult = null;
function requestQuote(amtStr, fromSnap, toSnap) {
  const mySeq = ++_pendingQuoteSeq;
  _pendingQuoteArgs = { amtStr, fromSnap, toSnap, seq: mySeq };
  _quoteLock = _quoteLock.catch(() => {}).then(async () => {
    const args = _pendingQuoteArgs;
    if (!args || args.seq !== mySeq) return _quoteResult;
    _pendingQuoteArgs = null;
    _quoteResult = await withRetry(() => getQuote(args.amtStr, args.fromSnap, args.toSnap));
    return _quoteResult;
  });
  return _quoteLock;
}

// ---- Swap execution ----
let _swapBusy = false;

async function executeSwap() {
  if (_swapBusy) return;
  _swapBusy = true;
  stopQuoteRefresh();

  const swapBtn = $("swapBtn");
  try {
    if (!signer || !connectedAddress) {
      toggleWallet();
      return;
    }

    const amtStr = $("fromAmount").value;
    const amtNum = parseFloat(amtStr);
    if (!amtStr || !Number.isFinite(amtNum) || amtNum <= 0) {
      showStatus("Please enter an amount", "error");
      return;
    }
    if (fromToken === toToken) {
      showStatus("Select different tokens", "error");
      return;
    }
    const receiverRaw = ($("receiverAddress")?.value || "").trim();
    if (receiverRaw && !ethers.isAddress(receiverRaw)) {
      if (isReceiverPending()) {
        showStatus("Receiver name still resolving...", "error");
        return;
      }
      if (!_resolvedReceiver || _resolvedReceiver.input !== receiverRaw || !_resolvedReceiver.address) {
        showStatus("Could not resolve receiver name", "error");
        return;
      }
    }

    // ETH â†” WETH wrap/unwrap: direct contract call, no DEX (only when sending to self)
    const resolvedAddr = getReceiver();
    const hasCustomReceiver = receiverRaw && (isReceiverPending() || (resolvedAddr && resolvedAddr !== connectedAddress));
    const wrapDir = !hasCustomReceiver ? isWrapUnwrap(fromToken, toToken) : null;
    if (wrapDir) {
      const fromData = tokens[fromToken];
      const amountIn = safeParseUnits(amtStr, fromData.decimals);
      const wethContract = new ethers.Contract(WETH_ADDRESS, WETH_ABI, signer);

      if (wrapDir === 'wrap') {
        swapBtn.textContent = "Wrapping...";
        swapBtn.disabled = true;
        const tx = await wcTransaction(
          wethContract.deposit({ value: amountIn }),
          'Confirm wrap in your wallet'
        );
        swapBtn.innerHTML = `Confirming wrap... <a href="https://etherscan.io/tx/${escAttr(tx.hash)}" target="_blank" style="color:white;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
        const receipt = await waitForTx(tx);
        if (receipt.status === 0) throw new Error("Wrap transaction failed");
      } else {
        swapBtn.textContent = "Unwrapping...";
        swapBtn.disabled = true;
        const tx = await wcTransaction(
          wethContract.withdraw(amountIn),
          'Confirm unwrap in your wallet'
        );
        swapBtn.innerHTML = `Confirming unwrap... <a href="https://etherscan.io/tx/${escAttr(tx.hash)}" target="_blank" style="color:white;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
        const receipt = await waitForTx(tx);
        if (receipt.status === 0) throw new Error("Unwrap transaction failed");
      }

      swapBtn.textContent = wrapDir === 'wrap' ? "Wrap Complete!" : "Unwrap Complete!";
      $("fromAmount").value = "";
      $("toAmount").value = "";
      $("quoteInfo").style.display = "none";
      setTimeout(() => {
        updateBalances();
        swapBtn.textContent = "Enter an amount";
        swapBtn.disabled = true;
      }, 1500);
      return;
    }

    // ---- Direct ZAMM â†’ zOrg stake: approve DAO + call buyShares directly ----
    if (isDirectZOrgStake(fromToken, toToken)) {
      swapBtn.innerHTML = `<span class="loading"></span> Preparing stake...`;
      swapBtn.disabled = true;

      const fromData = tokens[fromToken];
      const amountIn = safeParseUnits(amtStr, fromData.decimals);
      const quote = getDirectZOrgStakeQuote(amtStr, fromToken);

      // Check allowance to zOrg DAO (not the router)
      const zamm = erc20Read(fromData.address);
      swapBtn.textContent = "Checking allowance...";
      let allowance = await zamm.allowance(connectedAddress, ZORG_DAO);

      if (allowance < amountIn) {
        swapBtn.textContent = "Approving ZAMM for DAO...";
        const erc20W = new ethers.Contract(
          fromData.address,
          ["function approve(address,uint256) returns (bool)"],
          signer
        );
        // Reset stale non-zero allowance first (safety for non-standard tokens)
        if (allowance > 0n) {
          const resetTx = await wcTransaction(
            erc20W.approve(ZORG_DAO, 0),
            'Reset allowance in your wallet'
          );
          swapBtn.textContent = "Resetting allowance...";
          const resetRc = await waitForTx(resetTx);
          if (resetRc.status === 0) throw new Error("Allowance reset failed");
        }
        const approveTx = await wcTransaction(
          erc20W.approve(ZORG_DAO, ethers.MaxUint256),
          'Approve ZAMM spending for zOrg DAO in your wallet'
        );
        swapBtn.innerHTML = `Approving... <a href="https://etherscan.io/tx/${escAttr(approveTx.hash)}" target="_blank" style="color:white;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
        const rc = await waitForTx(approveTx);
        if (rc.status === 0) throw new Error("Approval transaction failed");
      }

      // Call buyShares directly on the zOrg DAO
      swapBtn.textContent = "Staking...";
      const stakeTx = await wcTransaction(
        signer.sendTransaction({
          to: ZORG_DAO,
          data: quote.daoCalldata,
          value: 0n,
        }),
        'Confirm stake in your wallet'
      );
      swapBtn.innerHTML = `Confirming stake... <a href="https://etherscan.io/tx/${escAttr(stakeTx.hash)}" target="_blank" style="color:white;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;

      const receipt = await waitForTx(stakeTx);
      if (receipt.status === 0) throw new Error("Stake transaction failed");

      swapBtn.textContent = "Stake Complete!";
      $("fromAmount").value = "";
      $("toAmount").value = "";
      $("quoteInfo").style.display = "none";
      stopQuoteRefresh();
      setTimeout(() => {
        updateBalances();
        swapBtn.textContent = "Enter an amount";
        swapBtn.disabled = true;
      }, 1500);
      return;
    }

    // ---- zOrg â†’ ZAMM ragequit: burn shares, claim ZAMM directly ----
    if (isRagequitPath(fromToken, toToken)) {
      swapBtn.innerHTML = `<span class="loading"></span> Preparing ragequit...`;
      swapBtn.disabled = true;

      const fromData = tokens[fromToken];
      const amountIn = safeParseUnits(amtStr, fromData.decimals);
      const quote = getRagequitQuote(amtStr, fromToken);

      // No approval needed â€” ragequit burns msg.sender's shares directly
      swapBtn.textContent = "Ragequitting...";
      const rqTx = await wcTransaction(
        signer.sendTransaction({
          to: ZORG_DAO,
          data: quote.daoCalldata,
          value: 0n,
        }),
        'Confirm ragequit in your wallet'
      );
      swapBtn.innerHTML = `Confirming ragequit... <a href="https://etherscan.io/tx/${escAttr(rqTx.hash)}" target="_blank" style="color:white;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;

      const receipt = await waitForTx(rqTx);
      if (receipt.status === 0) throw new Error("Ragequit transaction failed");

      swapBtn.textContent = "Ragequit Complete!";
      $("fromAmount").value = "";
      $("toAmount").value = "";
      $("quoteInfo").style.display = "none";
      stopQuoteRefresh();
      setTimeout(() => {
        updateBalances();
        swapBtn.textContent = "Enter an amount";
        swapBtn.disabled = true;
      }, 1500);
      return;
    }

    // ---- zOrg â†’ token sell: two-step (ragequit then ZAMM swap) ----
    if (isZOrgSellPath(fromToken, toToken)) {
      swapBtn.innerHTML = `<span class="loading"></span> Preparing sell...`;
      swapBtn.disabled = true;

      const fromSnap = fromToken, toSnap = toToken;
      const fromData = tokens[fromSnap];
      const amountIn = safeParseUnits(amtStr, fromData.decimals);
      const quote = await withRetry(() => getZOrgSellQuote(amtStr, fromSnap, toSnap));

      // Step 1: Ragequit (burns zOrg shares, receive ZAMM 1:1)
      swapBtn.textContent = "Step 1/2: Ragequitting...";
      const rqTx = await wcTransaction(
        signer.sendTransaction({
          to: ZORG_DAO,
          data: quote.ragequitData,
          value: 0n,
        }),
        'Step 1/2: Confirm ragequit in your wallet'
      );
      swapBtn.innerHTML = `Confirming ragequit... <a href="https://etherscan.io/tx/${escAttr(rqTx.hash)}" target="_blank" style="color:white;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
      const rqReceipt = await waitForTx(rqTx);
      if (rqReceipt.status === 0) throw new Error("Ragequit transaction failed");

      // Step 2: Sell ZAMM via router (re-quote to get fresh reserves)
      // If step 2 fails, user now holds ZAMM (ragequit already succeeded)
      try {
        swapBtn.textContent = "Step 2/2: Preparing swap...";
        const zammAmtStr = ethers.formatUnits(amountIn, 18);
        const freshQuote = await withRetry(() => getZammSellQuote(zammAmtStr, "ZAMM", toSnap));

        // Handle ERC20 approval for ZAMM â†’ router
        let txData = freshQuote.multicall;
        const zammAddr = ZORG_PAY_TOKEN;
        const r = erc20Read(zammAddr);
        let allowance = await r.allowance(connectedAddress, ZROUTER_ADDRESS);
        cacheSetAllowance(zammAddr, connectedAddress, ZROUTER_ADDRESS, allowance);

        if (allowance < amountIn) {
          let approved = false;
          // Try Permit2
          let p2Allowance = cacheGetAllowance(zammAddr, connectedAddress, PERMIT2_ADDRESS);
          if (p2Allowance == null) {
            p2Allowance = await r.allowance(connectedAddress, PERMIT2_ADDRESS);
            cacheSetAllowance(zammAddr, connectedAddress, PERMIT2_ADDRESS, p2Allowance);
          }
          if (p2Allowance >= amountIn) {
            try {
              swapBtn.textContent = "Sign Permit2...";
              const permit2Data = await signPermit2(zammAddr, amountIn);
              const innerCalls = freshQuote.calls || decodeMulticallCalls(freshQuote.multicall);
              txData = buildPermit2Multicall(innerCalls, permit2Data);
              approved = true;
            } catch (p2Err) {
              const msg = String(p2Err?.message || '');
              if (/user rejected|user denied|user cancelled/i.test(msg)) throw p2Err;
              txData = freshQuote.multicall;
            }
          }
          if (!approved) {
            swapBtn.textContent = "Approving ZAMM...";
            const erc20W = new ethers.Contract(zammAddr, ["function approve(address,uint256) returns (bool)"], signer);
            if (allowance > 0n) {
              const resetTx = await wcTransaction(erc20W.approve(ZROUTER_ADDRESS, 0), 'Reset allowance');
              await waitForTx(resetTx);
            }
            const approveTx = await wcTransaction(erc20W.approve(ZROUTER_ADDRESS, ethers.MaxUint256), 'Approve ZAMM for swap');
            swapBtn.innerHTML = `Approving... <a href="https://etherscan.io/tx/${escAttr(approveTx.hash)}" target="_blank" style="color:white;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
            const rc = await waitForTx(approveTx);
            if (rc.status === 0) throw new Error("Approval failed");
            cacheSetAllowance(zammAddr, connectedAddress, ZROUTER_ADDRESS, ethers.MaxUint256);
          }
        }

        swapBtn.textContent = "Step 2/2: Swapping...";
        const swapTx = await wcTransaction(
          signer.sendTransaction({
            to: ZROUTER_ADDRESS,
            data: txData,
            value: 0n,
          }),
          'Step 2/2: Confirm swap in your wallet'
        );
        swapBtn.innerHTML = `Confirming swap... <a href="https://etherscan.io/tx/${escAttr(swapTx.hash)}" target="_blank" style="color:white;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
        const swapReceipt = await waitForTx(swapTx);
        if (swapReceipt.status === 0) throw new Error("Swap transaction failed");
      } catch (step2Err) {
        // Ragequit already succeeded â€” user now holds ZAMM tokens
        const s = String(step2Err?.message || '');
        if (/user rejected|user denied|user cancelled/i.test(s)) {
          showStatus("Ragequit succeeded. You now hold ZAMM. Swap cancelled.", "error");
        } else {
          showStatus("Ragequit succeeded but swap failed. You now hold ZAMM â€” sell it separately.", "error");
        }
        swapBtn.textContent = "Ragequit done, swap failed";
        $("fromAmount").value = "";
        $("toAmount").value = "";
        $("quoteInfo").style.display = "none";
        stopQuoteRefresh();
        setTimeout(() => {
          updateBalances();
          swapBtn.textContent = "Enter an amount";
          swapBtn.disabled = true;
        }, 3000);
        return;
      }

      swapBtn.textContent = "Sell Complete!";
      $("fromAmount").value = "";
      $("toAmount").value = "";
      $("quoteInfo").style.display = "none";
      stopQuoteRefresh();
      setTimeout(() => {
        updateBalances();
        swapBtn.textContent = "Enter an amount";
        swapBtn.disabled = true;
      }, 1500);
      return;
    }

    swapBtn.innerHTML = `<span class="loading"></span> Getting quote...`;
    swapBtn.disabled = true;

    const fromSnap = fromToken, toSnap = toToken;
    const quote = await withRetry(() => getQuote(amtStr, fromSnap, toSnap));
    const fromData = tokens[fromSnap];
    const amountIn = safeParseUnits(amtStr, fromData.decimals);

    let txData = quote.multicall;

    // ERC20 approval
    if (fromData.address !== ZERO_ADDRESS) {
      const r = erc20Read(fromData.address);
      swapBtn.textContent = "Checking allowance...";
      let allowance = await r.allowance(connectedAddress, ZROUTER_ADDRESS);
      cacheSetAllowance(fromData.address, connectedAddress, ZROUTER_ADDRESS, allowance);

      if (allowance < amountIn) {
        let approved = false;

        // --- Try 1: EIP-2612 Permit (single tx) ---
        const permitCfg = await getPermitConfig(fromData.address);
        if (permitCfg) {
          try {
            swapBtn.textContent = "Sign permit...";
            const permitData = await signPermit(permitCfg, fromData.address);
            const innerCalls = quote.calls || decodeMulticallCalls(quote.multicall);
            const permitTxData = buildPermitMulticall(innerCalls, permitData);
            // Pre-flight: catch on-chain permit failures (e.g. InvalidShortString)
            await provider.estimateGas({
              from: connectedAddress,
              to: ZROUTER_ADDRESS,
              data: permitTxData,
              value: quote.msgValue ?? 0n,
            });
            txData = permitTxData;
            approved = true;
          } catch (permitErr) {
            const msg = String(permitErr?.message || '');
            if (/user rejected|user denied|user cancelled/i.test(msg)) throw permitErr;
            console.warn("Permit failed, falling back:", permitErr);
            _permitCache.set(fromData.address.toLowerCase(), null);
            txData = quote.multicall;
          }
        }

        // --- Try 2: Permit2 (single tx, sign-only) ---
        if (!approved) {
          let p2Allowance = cacheGetAllowance(fromData.address, connectedAddress, PERMIT2_ADDRESS);
          if (p2Allowance == null) {
            swapBtn.textContent = "Checking Permit2...";
            const r2 = erc20Read(fromData.address);
            p2Allowance = await r2.allowance(connectedAddress, PERMIT2_ADDRESS);
            cacheSetAllowance(fromData.address, connectedAddress, PERMIT2_ADDRESS, p2Allowance);
          }
          if (p2Allowance >= amountIn) {
            try {
              swapBtn.textContent = "Sign Permit2...";
              const permit2Data = await signPermit2(fromData.address, amountIn);
              const innerCalls = quote.calls || decodeMulticallCalls(quote.multicall);
              txData = buildPermit2Multicall(innerCalls, permit2Data);
              approved = true;
            } catch (p2Err) {
              const msg = String(p2Err?.message || '');
              if (/user rejected|user denied|user cancelled/i.test(msg)) throw p2Err;
              console.warn("Permit2 failed, falling back:", p2Err);
              txData = quote.multicall;
            }
          }
        }

        // --- Try 3: Approve (two tx, traditional fallback) ---
        if (!approved) {
          swapBtn.textContent = "Approving token...";
          const erc20W = new ethers.Contract(
            fromData.address,
            ["function approve(address,uint256) returns (bool)"],
            signer
          );
          // WBTC/USDT revert on approve(spender, newVal) when current != 0
          // Reset to zero first if there's a stale non-zero allowance
          if (allowance > 0n) {
            const resetTx = await wcTransaction(
              erc20W.approve(ZROUTER_ADDRESS, 0),
              'Reset allowance in your wallet'
            );
            swapBtn.textContent = "Resetting allowance...";
            const resetRc = await waitForTx(resetTx);
            if (resetRc.status === 0) throw new Error("Allowance reset failed");
          }
          const approveTx = await wcTransaction(
            erc20W.approve(ZROUTER_ADDRESS, ethers.MaxUint256),
            'Approve token spending in your wallet'
          );
          swapBtn.innerHTML = `Approving... <a href="https://etherscan.io/tx/${escAttr(approveTx.hash)}" target="_blank" style="color:white;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;
          const rc = await waitForTx(approveTx);
          if (rc.status === 0) throw new Error("Approval transaction failed");
          const fresh = await getQuote(amtStr, fromSnap, toSnap);
          txData = fresh.multicall;
          quote.msgValue = fresh.msgValue;
          cacheSetAllowance(fromData.address, connectedAddress, ZROUTER_ADDRESS, ethers.MaxUint256);
        }
      }
    }

    const isLidoExec = quote.sourceA === "Lido" && !quote.isSplit && !quote.isTwoHop;
    const actionLabel = isLidoExec ? "Staking" : isZOrgSwap(toSnap) ? "Swapping & Staking" : "Swapping";
    swapBtn.textContent = actionLabel + "...";
    const txValue = quote.msgValue ?? 0n;

    const swapTx = await wcTransaction(
      signer.sendTransaction({
        to: ZROUTER_ADDRESS,
        data: txData,
        value: txValue,
      }),
      isLidoExec ? 'Confirm stake in your wallet' : 'Confirm swap in your wallet'
    );
    swapBtn.innerHTML = `Confirming ${actionLabel.toLowerCase()}... <a href="https://etherscan.io/tx/${escAttr(swapTx.hash)}" target="_blank" style="color:white;text-decoration:underline;font-weight:400">view tx &#8599;</a>`;

    const receipt = await waitForTx(swapTx);
    if (receipt.status === 0) throw new Error(isLidoExec ? "Stake transaction failed" : "Swap transaction failed");

    swapBtn.textContent = (isLidoExec ? "Stake" : isZOrgSwap(toSnap) ? "Swap & Stake" : "Swap") + " Complete!";
    $("fromAmount").value = "";
    $("toAmount").value = "";
    $("quoteInfo").style.display = "none";
    stopQuoteRefresh();
    setTimeout(() => {
      updateBalances();
      swapBtn.textContent = "Enter an amount";
      swapBtn.disabled = true;
    }, 1500);
  } catch (e) {
    console.error("Swap error:", e);
    let msg = "Swap failed";
    const s = String(e?.message || e?.reason || "");
    if (e.code === 4001 || /user rejected|denied/i.test(s)) msg = "Transaction cancelled";
    else if (/insufficient funds/i.test(s)) msg = "Insufficient balance";
    else if (/Too many decimals|Invalid number/i.test(s)) msg = s;

    swapBtn.textContent = msg;
    setTimeout(() => { handleAmountChange(); }, 2000);
  } finally {
    _swapBusy = false;
  }
}

// ---- Token swap direction ----
function swapTokens() {
  if (fromToken === toToken) return;
  const prevFrom = fromToken, prevTo = toToken;
  const fAmt = $("fromAmount").value;
  const tAmt = $("toAmount").value;

  fromToken = prevTo;
  toToken = prevFrom;
  $("fromAmount").value = tAmt;
  $("toAmount").value = "";
  updateTokenDisplay();
  _quoteSeq++;
  updateBalances();
  if (tAmt) handleAmountChange();
}

function fitRouteText(route) {
  const el = $("routeInfo");
  el.textContent = route;
  el.title = route;
  el.removeAttribute("data-size");
  const len = route.length;
  if (len > 48) el.setAttribute("data-size", "xs");
  else if (len > 32) el.setAttribute("data-size", "sm");
}

function computeZammPoolId(addr0, addr1, id0, id1, fee) {
  const [sortedA, sortedB] = addr0.toLowerCase() < addr1.toLowerCase() ? [addr0, addr1] : [addr1, addr0];
  const [sortedId0, sortedId1] = addr0.toLowerCase() < addr1.toLowerCase() ? [id0, id1] : [id1, id0];
  const poolKey = ethers.AbiCoder.defaultAbiCoder().encode(
    ["uint256","uint256","address","address","uint256"],
    [sortedId0, sortedId1, sortedA, sortedB, fee]
  );
  return BigInt(ethers.keccak256(poolKey));
}

function updateChartLink(quote) {
  const link = $("chartLink");
  const zammRe = /zAMM|V4 Hooked/;
  const hasZamm = zammRe.test(quote.sourceA || "") || zammRe.test(quote.sourceB || "")
    || (quote.splitLegs && quote.splitLegs.some(l => zammRe.test(l.source || "")));
  if (!hasZamm) {
    link.style.display = "none";
    return;
  }
  // Determine pool ID: for zOrg route use ZORG_ID; otherwise standard ERC20 pool
  const fromAddr = tokens[fromToken].address;
  const toAddr = tokens[toToken].address;
  const isZorg = !!(tokens[fromToken]._isZOrg || tokens[toToken]._isZOrg || tokens[fromToken]._isZammStake || tokens[toToken]._isZammStake);
  let poolId;
  if (isZorg) {
    poolId = computeZammPoolId(ZERO_ADDRESS, ZORG_TOKEN, 0n, ZORG_ID, 100n);
  } else {
    // Standard zAMM pool between the two tokens
    poolId = computeZammPoolId(fromAddr, toAddr, 0n, 0n, 100n);
  }
  link.href = "./chart/#/" + poolId.toString();
  link.style.display = "inline-flex";
}

// ---- Quick-pick popular tokens ----
const QUICK_TOKENS = ["USDC", "USDT", "DAI", "WBTC", "wstETH"];

function renderQuickTokens() {
  const el = $('quickTokens');
  if (!el) return;
  el.innerHTML = '';
  for (const sym of QUICK_TOKENS) {
    if (!tokens[sym] || sym === toToken || sym === fromToken) continue;
    const btn = document.createElement('button');
    btn.className = 'quick-token';
    btn.setAttribute('aria-label', sym);
    btn.innerHTML = `<span class="qi">${iconForSymbol(sym)}</span>`;
    // Make inner icon fill the container
    const svgOrImg = btn.querySelector('.qi > *');
    if (svgOrImg) { svgOrImg.style.width = '100%'; svgOrImg.style.height = '100%'; }
    btn.onclick = () => {
      toToken = sym;
      updateTokenDisplay();
      updateBalances();
      const amt = $("fromAmount");
      if (amt && amt.value) reQuoteDebounced();
    };
    el.appendChild(btn);
  }
}

// ---- Token display ----
function updateTokenDisplay() {
  const fSym = fromToken, tSym = toToken;
  setHTML("fromTokenIcon", iconForSymbol(fSym));
  setText("fromTokenSymbol", tokens[fSym].symbol);
  setHTML("toTokenIcon", iconForSymbol(tSym));
  setText("toTokenSymbol", tokens[tSym].symbol);
  renderQuickTokens();
}

// ---- Token modal ----
function initTokenListClick() {
  const list = $("tokenList");
  if (!list || list.dataset.inited === "1") return;
  list.dataset.inited = "1";
  list.addEventListener("click", (e) => {
    // Handle .wei list remove button
    const removeBtn = e.target.closest('.wei-list-remove');
    if (removeBtn) {
      const listName = removeBtn.getAttribute('data-list');
      if (listName) {
        removeWeiList(listName);
        renderTokenList($('tokenSearchInput')?.value || '');
      }
      return;
    }
    const row = e.target.closest(".token-list-item");
    if (!row) return;
    const symbol = row.getAttribute("data-symbol");
    if (symbol) selectToken(symbol);
  });
}

function openTokenModal(side) {
  currentModal = side;
  const searchInput = $('tokenSearchInput');
  if (searchInput) searchInput.value = '';
  const statusEl = $('weiListStatus');
  if (statusEl) { statusEl.textContent = ''; statusEl.className = 'token-search-status'; }
  renderTokenList('');
  $("tokenModal").classList.add('active');
  document.body.classList.add('modal-open');
  if (searchInput) searchInput.focus();
  // Batch-fetch all token balances via Multicall3 (single RPC)
  if (connectedAddress) fetchModalBalances();
}

function closeTokenModal() {
  $("tokenModal").classList.remove('active');
  document.body.classList.remove('modal-open');
  $("customTokenAddress").value = "";
  const searchInput = $('tokenSearchInput');
  if (searchInput) searchInput.value = '';
  const statusEl = $('weiListStatus');
  if (statusEl) { statusEl.textContent = ''; statusEl.className = 'token-search-status'; }
}

const reQuoteDebounced = debounce(handleAmountChange, 600);

function selectToken(symbol) {
  if (currentModal === "from") {
    if (symbol === toToken) toToken = fromToken;
    fromToken = symbol;
  } else {
    if (symbol === fromToken) fromToken = toToken;
    toToken = symbol;
  }
  updateTokenDisplay();
  updateBalances();
  closeTokenModal();
  currentModal = null;
  const amt = $("fromAmount");
  if (amt) amt.focus();
  if (amt && amt.value) reQuoteDebounced();
}

function setupDirectZammStake() {
  fromToken = "ZAMM";
  toToken = "zOrg";
  updateTokenDisplay();
  updateBalances();
  const amt = $("fromAmount");
  if (amt) amt.focus();
  if (amt && amt.value) reQuoteDebounced();
}

function setupRagequit() {
  fromToken = "zOrg";
  toToken = "ZAMM";
  updateTokenDisplay();
  updateBalances();
  const amt = $("fromAmount");
  if (amt) amt.focus();
  if (amt && amt.value) reQuoteDebounced();
}

async function addCustomToken() {
  let address = $("customTokenAddress").value.trim();
  if (!ethers.isAddress(address)) { showStatus("Invalid address", "error"); return; }
  address = ethers.getAddress(address);
  if (address === ZERO_ADDRESS) { showStatus("Zero address is not a valid ERC-20", "error"); return; }

  try {
    const rpc = provider || new ethers.JsonRpcProvider("https://eth.llamarpc.com");
    try {
      const code = await rpc.getCode(address);
      if (!code || code === "0x") { showStatus("That address has no contract code on Ethereum", "error"); return; }
    } catch (_) {}

    const erc20 = new ethers.Contract(address, [
      "function symbol() view returns (string)",
      "function decimals() view returns (uint8)",
    ], rpc);
    const [rawSymbol, rawDecimals] = await Promise.all([erc20.symbol(), erc20.decimals()]);

    const symbol = String(rawSymbol || "").trim().slice(0, 24) || "TKN";
    const rawDec = Number(rawDecimals);
    const decimals = Number.isInteger(rawDec) && rawDec >= 0 && rawDec <= 36 ? rawDec : 18;

    const existing = tokens[symbol];
    if (existing && existing.address.toLowerCase() !== address.toLowerCase()) {
      showStatus(`A different token with symbol ${symbol} is already listed`, "error");
      return;
    }

    tokens[symbol] = { address, symbol, decimals };
    saveCustomTokens();
    selectToken(symbol);
  } catch (e) {
    console.error("Error adding token:", e);
    showStatus("Failed to add token. Ensure it's a valid ERC-20 on Ethereum", "error");
  }
}

// ---- Keyboard shortcuts ----
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    closeTokenModal();
    closeWalletModal();
  }
});

// ---- Init ----
document.addEventListener("DOMContentLoaded", () => {
  updateTokenDisplay();
  initTokenListClick();
  initTokenSearch();
  const fromEl = $("fromAmount");
  if (fromEl) fromEl.addEventListener("input", debounce(handleAmountChange, 400));
  // Defer heavy localStorage parsing until after first render
  (window.requestIdleCallback || setTimeout)(() => loadWeiLists());
});

// Swap button click
$("swapBtn").addEventListener("click", () => {
  if (!connectedAddress) { showWalletModal(); return; }
  executeSwap();
});

// ---- Auto-reconnect (non-blocking) ----
window.addEventListener("load", () => {
  const savedWallet = localStorage.getItem('zswap_wallet');
  if (!savedWallet) return;
  setText('walletBtn', '...');
  // Fire-and-forget: don't block page interactivity
  setTimeout(async () => {
    try {
      window.dispatchEvent(new Event('eip6963:requestProvider'));
      await new Promise(r => setTimeout(r, 300));
      await connectWithWallet(savedWallet);
    } catch (e) {
      console.error("Auto-reconnect failed:", e);
      setText('walletBtn', 'connect');
    }
  }, 100);
});

</script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"8510b592df8f4a69b87bbf8e840f200c","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>
