<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Predict</title>
<meta property="og:title" content="Predict - zFi">
<meta property="og:description" content="Prediction markets on zFi - the most secure-by-default exchange">
<meta property="og:type" content="website">
<meta property="og:url" content="">
<meta property="og:image" content="">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Predict - zFi">
<meta name="twitter:description" content="Prediction markets on zFi - the most secure-by-default exchange">
<meta name="twitter:image" content="">
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 400' width='400' height='400'%3E%3Crect width='400' height='400' fill='%23000'/%3E%3CclipPath id='frame'%3E%3Crect width='400' height='400'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23frame)'%3E%3Cpath d='M-60-20L460-20L460 90L80 310L460 310L460 420L-60 420L-60 310L320 90L-60 90Z' fill='white'/%3E%3C/g%3E%3C/svg%3E" type="image/svg+xml">
<script>
(function(){var d=localStorage.getItem('dark');if(d==='1'||(d===null&&matchMedia('(prefers-color-scheme:dark)').matches))document.documentElement.classList.add('dark')})();
</script>
<style>
.zorg-bg{fill:#fff}.zorg-fg{fill:#000}
.dark .zorg-bg{fill:#000}.dark .zorg-fg{fill:#fff}
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
:root {
  --bg:#fff;--fg:#000;--fg-muted:#666;--fg-dim:#999;
  --border:#000;--border-muted:#ddd;
  --surface:#f9f9f9;--surface-hover:#f5f5f5;
  --btn-bg:#000;--btn-fg:#fff;--btn-hover:#333;
  --btn-dis-bg:transparent;--btn-dis-border:#ccc;--btn-dis-fg:#999;
  --status-error:#fff0f0;--status-success:#f0fff0;
  --link-fg:inherit;
  --modal-overlay:rgba(0,0,0,0.8);--modal-bg:#fff;--modal-border:#000;
  --card-border:#ccc;
  --green:#22c55e;--red:#ef4444;--yes:#0f0;--no:#f00;
}
.dark {
  --bg:#0a0a0a;--fg:#e8e8e0;--fg-muted:#888;--fg-dim:#666;
  --border:#333;--border-muted:#333;
  --surface:#111;--surface-hover:#151515;
  --btn-bg:#e8e8e0;--btn-fg:#0a0a0a;--btn-hover:#ccc;
  --btn-dis-bg:transparent;--btn-dis-border:#444;--btn-dis-fg:#666;
  --status-error:#1a0000;--status-success:#001a00;
  --link-fg:#e8e8e0;
  --modal-overlay:rgba(0,0,0,0.85);--modal-bg:#111;--modal-border:#333;
  --card-border:#333;
  --green:#22c55e;--red:#ef4444;--yes:#0f0;--no:#f00;
}
body {
  font-family:Helvetica,Arial,sans-serif;
  background:var(--bg);color:var(--fg);
  min-height:100vh;padding:60px 20px 20px;
  max-width:480px;margin:0 auto;
  overflow-x:hidden;
}
a { color:var(--link-fg); }
button {
  display:inline-block;font-family:inherit;cursor:pointer;
  border:1px solid var(--btn-bg);border-radius:0;
  background:var(--btn-bg);color:var(--btn-fg);
  padding:12px 24px;font-size:12px;font-weight:600;
  letter-spacing:0.1em;text-transform:uppercase;
  transition:background 0.2s, border-color 0.2s, color 0.2s;
}
button:hover { background:var(--btn-hover); }
button:disabled { background:var(--btn-dis-bg);border:1px solid var(--btn-dis-border);color:var(--btn-dis-fg);cursor:not-allowed; }
input {
  font-family:inherit;font-size:14px;background:transparent;color:var(--fg);
  border:none;border-bottom:1.5px solid var(--border);outline:none;
  padding:8px 0;width:100%;
}
.header {
  display:flex;justify-content:space-between;align-items:center;margin-bottom:24px;
}
.header h1 {
  font-size:14px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase;
}
.back-link { font-size:12px;color:var(--fg-muted);text-decoration:none;margin-bottom:16px;display:inline-block; }
.back-link:hover { color:var(--fg); }

/* Search */
.market-search {
  width:100%;padding:8px 0;font-size:13px;border:none;border-bottom:1px solid var(--border);
  outline:none;background:transparent;color:var(--fg);margin-bottom:16px;
}
.market-search::placeholder { color:var(--fg-dim); }

/* Gallery */
.market-grid {
  display:flex;flex-direction:column;gap:12px;
}
.market-card {
  border:1px solid var(--border-muted);padding:16px;
  cursor:pointer;transition:background 0.15s;text-decoration:none;color:var(--fg);display:block;
}
.market-card:hover { background:var(--surface-hover); }
.market-card-question {
  font-size:14px;font-weight:600;line-height:1.4;margin-bottom:10px;
  display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;
}
.market-card-odds {
  display:flex;height:28px;overflow:hidden;margin-bottom:8px;
}
.market-card-yes {
  background:var(--yes);color:#000;display:flex;align-items:center;justify-content:center;
  font-size:12px;font-weight:700;min-width:32px;transition:width 0.3s;
}
.market-card-no {
  background:var(--no);color:#fff;display:flex;align-items:center;justify-content:center;
  font-size:12px;font-weight:700;min-width:32px;flex:1;transition:width 0.3s;
}
.market-card-meta {
  font-size:11px;color:var(--fg-muted);display:flex;justify-content:space-between;
}
.market-card.resolved { opacity:0.6; }
.market-card.resolved .market-card-question::after {
  content:attr(data-outcome);font-size:11px;font-weight:700;margin-left:6px;
  padding:2px 6px;vertical-align:middle;
}
.market-card[data-won="yes"] .market-card-question::after { background:var(--yes);color:#000; }
.market-card[data-won="no"] .market-card-question::after { background:var(--no);color:#fff; }

/* Filter tabs */
.filter-tabs {
  display:flex;gap:0;margin-bottom:16px;
}
.filter-tab {
  flex:1;padding:8px 4px;font-size:11px;font-weight:600;letter-spacing:0.08em;text-transform:uppercase;
  border:none;border-bottom:2px solid transparent;border-radius:0;
  background:transparent;color:var(--fg-muted);
  cursor:pointer;font-family:inherit;transition:color 0.15s,border-color 0.15s;
}
.filter-tab:hover { color:var(--fg); }
.filter-tab.active { color:var(--fg);border-bottom-color:var(--fg); }

/* Detail page */
.section-card {
  border:1px solid var(--border-muted);padding:16px;margin-bottom:16px;
}
.section-title {
  font-size:11px;font-weight:600;letter-spacing:0.1em;text-transform:uppercase;
  color:var(--fg-muted);margin-bottom:12px;
}
.stat-row { display:flex;justify-content:space-between;align-items:center;font-size:13px;margin-bottom:6px; }
.stat-label { color:var(--fg-muted); }
.stat-value { font-weight:600;overflow:hidden;text-overflow:ellipsis;min-width:0; }

/* Odds bar (detail) */
.odds-bar {
  display:flex;height:48px;overflow:hidden;margin-bottom:16px;cursor:default;
}
.odds-yes {
  background:var(--yes);color:#000;display:flex;align-items:center;justify-content:center;
  font-size:18px;font-weight:700;min-width:48px;transition:width 0.3s;
}
.odds-no {
  background:var(--no);color:#fff;display:flex;align-items:center;justify-content:center;
  font-size:18px;font-weight:700;min-width:48px;flex:1;transition:width 0.3s;
}

/* Trade panel */
.trade-dir { display:flex;gap:6px;margin-bottom:14px; }
.trade-dir button {
  flex:1;padding:7px 0;font-size:11px;font-weight:600;letter-spacing:0.08em;text-transform:uppercase;
  border:none;border-bottom:2px solid transparent;border-radius:0;
  background:transparent;color:var(--fg-muted);
  cursor:pointer;font-family:inherit;transition:color 0.15s,border-color 0.15s;margin:0;
}
.trade-dir button:hover { color:var(--fg); }
.trade-dir button.active { color:var(--fg);border-bottom-color:var(--fg); }
.trade-side { display:flex;gap:6px;margin-bottom:14px; }
.trade-side button {
  flex:1;padding:7px 0;font-size:11px;font-weight:600;letter-spacing:0.08em;text-transform:uppercase;
  border:none;border-bottom:2px solid transparent;border-radius:0;
  background:transparent;color:var(--fg-muted);
  cursor:pointer;font-family:inherit;transition:color 0.15s,border-color 0.15s;margin:0;
}
.trade-side button:hover { color:var(--fg); }
.trade-side button.active { color:var(--fg);border-bottom-color:var(--fg); }
.trade-side button[data-side="yes"].active { border-bottom-color:var(--yes); }
.trade-side button[data-side="no"].active { border-bottom-color:var(--no); }

.trade-section { margin-bottom:8px; }
.trade-section-head {
  display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;
}
.trade-section-head label {
  font-size:11px;font-weight:600;letter-spacing:0.05em;text-transform:uppercase;color:var(--fg-muted);margin:0;flex-shrink:0;
}
.trade-balance {
  font-size:11px;color:var(--fg-muted);cursor:pointer;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
  flex:1;text-align:right;margin:0 8px;
}
.trade-balance:hover { color:var(--fg); }
.trade-section input {
  width:100%;padding:8px 0;font-size:22px;font-weight:400;font-family:inherit;
  border:none;border-bottom:1.5px solid var(--border);outline:none;background:transparent;color:var(--fg);
}
.trade-section input::placeholder { color:var(--fg-dim); }
.trade-section input:focus { border-bottom-width:2.5px;margin-bottom:-1px; }
.trade-quote { font-size:12px;color:var(--fg-muted);min-height:18px;margin-bottom:10px; }
.trade-pct-row { display:flex;gap:6px;margin-top:6px; }
.trade-pct-btn {
  flex:1;padding:4px 0;font-size:10px;font-weight:600;letter-spacing:0.05em;
  border:none;background:var(--surface);color:var(--fg-muted);
  cursor:pointer;font-family:inherit;transition:background 0.15s,color 0.15s;
}
.trade-pct-btn:hover { background:var(--surface-hover);color:var(--fg); }

/* Positions */
.pos-row { display:flex;justify-content:space-between;align-items:center;font-size:13px;padding:6px 0;border-bottom:1px solid var(--border-muted); }
.pos-row:last-child { border-bottom:none; }
.pos-side { font-weight:600; }
.pos-side.yes { color:var(--yes); }
.pos-side.no { color:var(--no); }

/* Resolution */
.resolve-section { margin-top:16px; }
.resolve-toggle {
  display:flex;align-items:center;justify-content:space-between;
  padding:10px 12px;border:1px solid var(--border);opacity:0.6;
  cursor:pointer;font-size:11px;text-transform:uppercase;letter-spacing:1px;
}
.resolve-toggle:hover { opacity:0.8; }
.resolve-toggle.expanded { opacity:1;border-color:#F50; }
.resolve-toggle-status { font-weight:bold; }
.resolve-toggle-status.pending { color:#F50; }
.resolve-toggle-status.ready { color:var(--yes); }
.resolve-toggle-status.resolved { color:#0FF; }
.resolve-details {
  display:none;padding:16px;border:1px solid var(--border);border-top:none;
  background:rgba(128,128,128,0.05);
}
.resolve-details.expanded { display:block; }
.resolve-details.ready { border-color:var(--yes);background:rgba(0,255,0,0.05); }
.resolve-condition { font-size:13px;margin-bottom:16px;line-height:1.5; }
.resolve-condition-target { opacity:0.7;font-size:11px; }
.resolve-condition-val { font-weight:bold;color:#0FF; }
.resolve-condition-thresh { font-weight:bold;color:var(--yes); }
.resolve-progress { margin-bottom:16px;font-family:monospace; }
.resolve-progress-bar { font-size:14px;letter-spacing:1px;margin-bottom:4px;color:var(--fg); }
.resolve-progress-bar .filled { color:var(--yes); }
.resolve-progress-bar .empty { opacity:0.3; }
.resolve-progress-bar.met .filled { color:var(--yes); }
.resolve-progress-text { display:flex;justify-content:space-between;font-size:11px;opacity:0.7; }
.resolve-status {
  text-align:center;padding:12px;font-size:13px;
  background:var(--surface);margin-bottom:12px;
}
.resolve-btn {
  width:100%;padding:12px;font-size:13px;font-weight:600;
}
.resolve-btn:disabled { opacity:0.3;cursor:not-allowed; }
.resolve-hint { font-size:10px;opacity:0.5;margin-top:8px;text-align:center; }
.inspect-toggle {
  display:block;width:100%;margin-top:12px;padding:6px;background:none;border:none;
  color:inherit;font-size:10px;opacity:0.3;cursor:pointer;text-align:center;
}
.inspect-toggle:hover { opacity:0.6; }
.inspect-panel {
  display:none;margin-top:8px;padding:8px;
  background:var(--surface);border:1px solid var(--border-muted);
  font-size:10px;font-family:monospace;
}
.inspect-panel.expanded { display:block; }
.inspect-row { display:flex;justify-content:space-between;padding:4px 0;border-bottom:1px solid var(--border-muted); }
.inspect-row:last-child { border-bottom:none; }
.inspect-label { opacity:0.5; }
.inspect-value { word-break:break-all;text-align:right;max-width:70%;color:#0FF; }
.inspect-value a { color:#0FF;text-decoration:underline; }

/* Loading */
.loading { text-align:center;padding:40px;color:var(--fg-muted);font-size:13px; }
@keyframes spin { to { transform:rotate(360deg); } }
.spinner {
  display:inline-block;width:14px;height:14px;border:2px solid var(--border-muted);
  border-top:2px solid var(--fg);border-radius:50%;animation:spin 0.8s linear infinite;
  vertical-align:middle;margin-right:8px;
}
.progress-bar { height:6px;background:var(--border-muted);overflow:hidden;margin:8px 0; }
.progress-fill { height:100%;transition:width 0.3s; }

/* Modal */
.modal-overlay {
  display:none;position:fixed;inset:0;background:var(--modal-overlay);backdrop-filter:blur(4px);z-index:200;
  justify-content:center;align-items:center;padding:20px;overflow-y:auto;-webkit-overflow-scrolling:touch;
}
.modal-overlay.active { display:flex; }
body.modal-open { overflow:hidden; }
#createModal .modal, #lpModal .modal { max-width:480px; }
.modal {
  background:var(--modal-bg);border:1px solid var(--modal-border);
  width:100%;max-width:380px;padding:16px;position:relative;
  max-height:calc(100vh - 40px);max-height:calc(100dvh - 40px);overflow-y:auto;-webkit-overflow-scrolling:touch;
}
.modal-header { display:flex;justify-content:space-between;align-items:center;margin-bottom:16px; }
.modal-title { font-size:14px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase; }
.modal-close {
  background:none;border:none;font-size:20px;color:var(--fg);cursor:pointer;line-height:1;
  padding:4px;margin:-4px;opacity:0.4;transition:opacity 0.15s;
}
.modal-close:hover { opacity:1; }
.market-type-tabs { display:flex;gap:0;margin-bottom:20px; }
.market-type-tab {
  flex:1;padding:8px 4px;font-size:11px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase;
  border:none;border-bottom:2px solid transparent;border-radius:0;
  background:transparent;color:var(--fg-muted);cursor:pointer;font-family:inherit;
  transition:color 0.15s,border-color 0.15s;
}
.market-type-tab:hover { color:var(--fg); }
.market-type-tab.active { color:var(--fg);border-bottom-color:var(--fg); }
.form-group { margin-bottom:16px; }
.form-label {
  display:block;font-size:11px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase;
  color:var(--fg-muted);margin-bottom:6px;
}
.form-input {
  width:100%;padding:8px 0;font-size:14px;font-family:inherit;
  border:none;border-bottom:1.5px solid var(--border);outline:none;background:transparent;color:var(--fg);
}
.form-input:focus { border-bottom-width:2.5px;margin-bottom:-1px; }
.form-input::placeholder { color:var(--fg-dim); }
select.form-input { border-radius:0;-webkit-appearance:none;appearance:none;cursor:pointer; }
.form-preview {
  font-size:13px;line-height:1.6;padding:12px 16px;
  background:var(--surface);margin-bottom:16px;text-align:center;
  border-left:2px solid var(--border);
}
.form-hint { font-size:11px;color:var(--fg-dim);margin-top:4px; }
.form-divider {
  font-size:11px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase;
  color:var(--fg-muted);margin:20px 0 12px;padding-top:16px;border-top:1px solid var(--border-muted);
}
.form-btn {
  width:100%;padding:14px;font-size:13px;font-weight:600;margin-top:12px;
  letter-spacing:0.02em;transition:all 0.2s;
}
.form-btn:hover:not(:disabled) { background:var(--btn-hover); }
.form-btn:disabled { background:var(--btn-dis-bg);border-color:var(--btn-dis-border);color:var(--btn-dis-fg);cursor:not-allowed; }
.liq-presets { display:flex;gap:6px;margin-bottom:10px; }
.liq-preset {
  flex:1;padding:6px 0;font-size:11px;font-weight:600;border:1px solid var(--border-muted);
  background:transparent;color:var(--fg-muted);cursor:pointer;font-family:inherit;
  transition:border-color 0.15s,color 0.15s,background 0.15s;
}
.liq-preset:hover { border-color:var(--fg);color:var(--fg); }
.liq-preset.active { border-color:var(--fg);color:var(--fg);background:var(--surface); }
.liq-split-bar { display:flex;height:6px;overflow:hidden;margin:8px 0 6px; }
.liq-split-bar > div { transition:width 0.2s; }
.liq-split-legend { display:flex;justify-content:space-between;font-size:10px;color:var(--fg-muted);margin-bottom:10px; }
.date-presets { display:flex;gap:4px;margin-top:6px; }
.date-preset {
  padding:4px 10px;font-size:10px;font-weight:600;border:1px solid var(--border-muted);
  background:transparent;color:var(--fg-muted);cursor:pointer;font-family:inherit;
  transition:border-color 0.15s,color 0.15s;
}
.date-preset:hover { border-color:var(--fg);color:var(--fg); }
.form-section { display:none; }
.form-section.active { display:block; }
.form-toggle-row { display:flex;align-items:center;gap:8px;margin-bottom:10px; }
.form-toggle-row label { font-size:11px;color:var(--fg-muted);cursor:pointer;user-select:none;margin:0;text-transform:none;letter-spacing:0; }
.form-toggle-row input[type="checkbox"] { accent-color:var(--fg);width:14px;height:14px; }
.adv-toggle {
  font-size:11px;color:var(--fg-dim);cursor:pointer;text-align:center;margin:12px 0;
  letter-spacing:0.1em;text-transform:uppercase;transition:color 0.15s;
}
.adv-toggle:hover { color:var(--fg); }
.adv-section { display:none; }
.adv-section.active { display:block; }
.balance-type-toggle { display:flex;gap:0; }
.balance-type-btn {
  flex:1;padding:7px;font-size:11px;font-weight:600;letter-spacing:0.05em;
  border:1px solid var(--border-muted);background:transparent;color:var(--fg-muted);
  cursor:pointer;font-family:inherit;transition:border-color 0.15s,color 0.15s,background 0.15s;
}
.balance-type-btn:first-child { border-right:none; }
.balance-type-btn:last-child { border-left:none; }
.balance-type-btn.active { border-color:var(--fg);color:var(--fg);background:var(--surface); }

/* LP Modal extras */
.lp-alloc-row { display:flex;align-items:center;gap:8px;margin-bottom:4px; }
.lp-alloc-label { font-size:11px;font-weight:600;width:60px; }
.lp-alloc-label.yes { color:var(--yes); }
.lp-alloc-label.no { color:var(--no); }
.lp-alloc-label.amm { color:var(--fg-muted); }
.lp-alloc-slider { flex:1;accent-color:var(--fg); }
.lp-alloc-pct { font-size:11px;width:36px;text-align:right;color:var(--fg-muted); }
.lp-alloc-hint { font-size:10px;color:var(--fg-dim);margin:0 0 8px 68px; }

/* Footer */
.site-footer {
  position:relative;text-align:center;padding:48px 20px;font-size:11px;opacity:0.55;margin-top:40px;
  letter-spacing:0.5px;font-weight:300;
}
.site-footer a { color:inherit;text-decoration:underline;margin:0 2px; }
.site-footer a:hover { opacity:0.7; }
.site-footer .tagline { opacity:1;color:#000;font-weight:500; }
.dark .site-footer .tagline { color:#fff; }

/* Wallet */
.wallet {
  position:fixed;
  top:max(20px, env(safe-area-inset-top, 0px));
  right:max(20px, env(safe-area-inset-right, 0px));
  font-size:11px; text-transform:uppercase; letter-spacing:0.05em;
  z-index:100;
}
.wallet button { margin:0; padding:8px 16px; text-transform:none; }

/* Wallet options */
.wallet-option {
  display:flex; align-items:center; gap:12px; padding:12px;
  background:var(--modal-bg); border:1px solid var(--border); color:var(--fg);
  cursor:pointer; margin-bottom:8px; transition:background 0.15s, color 0.15s;
  border-radius:0;
}
.wallet-option:hover { background:var(--btn-bg); color:var(--btn-fg); }
.wallet-option-icon { font-size:1.5rem; }
.wallet-option-name { font-weight:600; }
.wallet-option.disconnect { border-color:#f00; color:#f00; justify-content:center; }
.wallet-option.disconnect:hover { background:#f00; color:#fff; }

/* Dark toggle */
.dark-toggle {
  position:fixed;top:max(22px, env(safe-area-inset-top, 0px));left:max(20px, env(safe-area-inset-left, 0px));
  border:none;cursor:pointer;padding:13px;margin:-13px;opacity:0.5;transition:opacity 0.2s;
  z-index:100;background:#000;border-radius:50%;width:40px;height:40px;background-clip:content-box;
}
:root.dark .dark-toggle { background:#fff; }
.dark-toggle:hover { opacity:1; }

.home-btn {
  position: fixed;
  bottom: max(20px, env(safe-area-inset-bottom, 0px));
  right: max(20px, env(safe-area-inset-right, 0px));
  z-index: 100;
  opacity: 0.4;
  transition: opacity 0.2s;
  line-height: 0;
}
.home-btn:hover { opacity: 1; }

/* Mobile */
@media (max-width: 700px) {
  body { padding:80px 16px 20px; }
  .wallet { top:16px; right:16px; }
  .wallet button { padding:10px 14px; font-size:11px; }
  .header h1 { font-size:13px; }
  .market-card { padding:12px; }
  .market-card-question { font-size:13px; }
  .market-card-meta { font-size:10px; }
  .market-search { font-size:14px; }
  .section-card { padding:12px; }
  .stat-row { font-size:12px; }
  .trade-section input { font-size:18px; }
  .trade-pct-btn { font-size:9px;padding:5px 0; }
  .odds-bar { height:40px; }
  .odds-yes, .odds-no { font-size:15px; }
  .modal { max-width:100%;margin:0 10px;max-height:calc(100vh - 40px);overflow-y:auto; }
  .dark-toggle { top:18px;left:16px; }
  .market-type-tab { font-size:10px;padding:6px 2px; }
  .form-preview { font-size:12px;padding:10px 12px; }
  .form-group { margin-bottom:12px; }
}
@media (max-width: 380px) {
  body { padding:70px 12px 20px; }
  .market-card-question { font-size:12px; }
  .section-card { padding:10px; }
  .market-type-tab { font-size:9px;letter-spacing:0.05em; }
  .form-input { font-size:13px; }
  .form-preview { font-size:11px;padding:8px 10px; }
  .stat-row { font-size:11px;flex-wrap:wrap;gap:2px; }
  .trade-section input { font-size:16px; }
  .trade-dir button { font-size:10px;padding:6px 0; }
  .trade-side button { font-size:10px;padding:6px 0; }
}
</style>
</head>
<body>
<a href="../" class="home-btn" title="Home"><svg width="28" height="28" viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg"><rect class="zorg-bg" width="400" height="400"/><clipPath id="zh"><rect width="400" height="400"/></clipPath><g clip-path="url(#zh)"><path class="zorg-fg" d="M-60-20L460-20L460 90L80 310L460 310L460 420L-60 420L-60 310L320 90L-60 90Z"/></g></svg></a>
<button class="dark-toggle" onclick="toggleDark()" title="Toggle dark mode"></button>

<div class="wallet">
  <button id="walletBtn" onclick="toggleWallet()">connect</button>
</div>

<div class="modal-overlay" id="walletModal" onclick="if(event.target===this)closeWalletModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Connect Wallet</div>
      <button class="modal-close" onclick="closeWalletModal()">&times;</button>
    </div>
    <div class="modal-body" id="walletOptions"></div>
  </div>
</div>

<div id="app"></div>

<!-- Create Market Modal -->
<div class="modal-overlay" id="createModal" onclick="if(event.target===this)closeCreateModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Create Market</div>
      <button class="modal-close" onclick="closeCreateModal()">&times;</button>
    </div>
    <div class="market-type-tabs">
      <button class="market-type-tab active" onclick="switchMarketType('price')">Price</button>
      <button class="market-type-tab" onclick="switchMarketType('balance')">Balance</button>
      <button class="market-type-tab" onclick="switchMarketType('supply')">Supply</button>
      <button class="market-type-tab" onclick="switchMarketType('custom')">Custom</button>
    </div>

    <!-- PRICE FORM -->
    <div class="form-section active" id="priceForm">
      <div class="form-preview" id="pricePreview">Will ETH hit <b>$___</b> by <b>___</b>?</div>
      <div style="font-size:11px;color:var(--fg-muted);text-align:center;margin-bottom:10px">Current: ETH <b id="livePrice">...</b></div>
      <div class="form-group">
        <label class="form-label">Target Price (USD)</label>
        <input class="form-input" id="targetPrice" type="text" inputmode="numeric" placeholder="e.g. 10000" oninput="fmtTargetPrice();updatePricePreview()">
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setPricePreset(0)">current</button>
          <button type="button" class="date-preset" onclick="setPricePreset(5)">+5%</button>
          <button type="button" class="date-preset" onclick="setPricePreset(10)">+10%</button>
          <button type="button" class="date-preset" onclick="setPricePreset(100)">+100%</button>
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">Resolution Date</label>
        <input class="form-input" id="closeDate" type="datetime-local" oninput="updatePricePreview()">
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setDatePreset(7,'closeDate')">1w</button>
          <button type="button" class="date-preset" onclick="setDatePreset(30,'closeDate')">1m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(90,'closeDate')">3m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(365,'closeDate')">1y</button>
        </div>
      </div>
    </div>

    <!-- BALANCE FORM -->
    <div class="form-section" id="balanceForm">
      <div class="form-preview" id="balancePreview">Will <b>address</b> hold &ge; <b>___</b> by <b>___</b>?</div>
      <div class="form-group">
        <label class="form-label">Asset Type</label>
        <div class="balance-type-toggle">
          <button type="button" class="balance-type-btn active" onclick="setBalanceType('eth')">ETH</button>
          <button type="button" class="balance-type-btn" onclick="setBalanceType('token')">Token</button>
        </div>
      </div>
      <div class="form-group" id="balTokenGroup" style="display:none">
        <label class="form-label">Token Contract</label>
        <input class="form-input" id="balTokenAddr" type="text" placeholder="0x... (ERC20)" oninput="loadBalTokenInfo()">
        <div class="form-hint" id="balTokenHint"></div>
      </div>
      <div class="form-group">
        <label class="form-label">Wallet Address</label>
        <input class="form-input" id="balWalletAddr" type="text" placeholder="0x..." oninput="updateBalPreview()">
      </div>
      <div class="form-group">
        <label class="form-label">Minimum Balance</label>
        <input class="form-input" id="balThreshold" type="number" placeholder="e.g. 100" step="any" min="0" oninput="updateBalPreview()">
      </div>
      <div class="form-group">
        <label class="form-label">Resolution Date</label>
        <input class="form-input" id="balCloseDate" type="datetime-local" oninput="updateBalPreview()">
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setDatePreset(7,'balCloseDate')">1w</button>
          <button type="button" class="date-preset" onclick="setDatePreset(30,'balCloseDate')">1m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(90,'balCloseDate')">3m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(365,'balCloseDate')">1y</button>
        </div>
      </div>
    </div>

    <!-- SUPPLY FORM -->
    <div class="form-section" id="supplyForm">
      <div class="form-preview" id="supplyPreview">Will <b>token</b> supply reach <b>___</b> by <b>___</b>?</div>
      <div class="form-group">
        <label class="form-label">Token Contract</label>
        <input class="form-input" id="supplyTokenAddr" type="text" placeholder="0x... (ERC20)" oninput="loadSupplyTokenInfo()">
        <div class="form-hint" id="supplyTokenHint"></div>
      </div>
      <div class="form-group">
        <label class="form-label">Condition</label>
        <select class="form-input" id="supplyOp" onchange="updateSupplyPreview()">
          <option value="3">Greater than or equal (&ge;)</option>
          <option value="2">Less than or equal (&le;)</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Threshold</label>
        <input class="form-input" id="supplyThreshold" type="number" placeholder="e.g. 1000000" step="any" min="0" oninput="updateSupplyPreview()">
      </div>
      <div class="form-group">
        <label class="form-label">Resolution Date</label>
        <input class="form-input" id="supplyCloseDate" type="datetime-local" oninput="updateSupplyPreview()">
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setDatePreset(7,'supplyCloseDate')">1w</button>
          <button type="button" class="date-preset" onclick="setDatePreset(30,'supplyCloseDate')">1m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(90,'supplyCloseDate')">3m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(365,'supplyCloseDate')">1y</button>
        </div>
      </div>
    </div>

    <!-- CUSTOM FORM -->
    <div class="form-section" id="customForm">
      <div class="form-preview" id="customPreview">Custom Y/N market with your chosen resolver</div>
      <div class="form-group">
        <label class="form-label">Question</label>
        <input class="form-input" id="customQuestion" type="text" placeholder="Will X happen by Y?" oninput="updateCustomPreview()">
      </div>
      <div class="form-group">
        <label class="form-label">Resolver Address</label>
        <input class="form-input" id="customResolver" type="text" placeholder="0x... (EOA or contract that can resolve)">
        <div class="form-hint">The address that will be able to resolve this market as YES or NO</div>
      </div>
      <div class="form-toggle-row">
        <input type="checkbox" id="customCanClose" checked>
        <label for="customCanClose">Can close early (resolver can resolve before close date)</label>
      </div>
      <div class="form-group">
        <label class="form-label">Resolution Date</label>
        <input class="form-input" id="customCloseDate" type="datetime-local" oninput="updateCustomPreview()">
        <div class="date-presets">
          <button type="button" class="date-preset" onclick="setDatePreset(7,'customCloseDate')">1w</button>
          <button type="button" class="date-preset" onclick="setDatePreset(30,'customCloseDate')">1m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(90,'customCloseDate')">3m</button>
          <button type="button" class="date-preset" onclick="setDatePreset(365,'customCloseDate')">1y</button>
        </div>
      </div>
    </div>

    <!-- SEED LIQUIDITY -->
    <div class="form-divider">Seed Liquidity (ETH)</div>
    <div class="liq-presets">
      <button type="button" class="liq-preset active" onclick="setLiqPreset(0.01)">0.01</button>
      <button type="button" class="liq-preset" onclick="setLiqPreset(0.1)">0.1</button>
      <button type="button" class="liq-preset" onclick="setLiqPreset(0.5)">0.5</button>
      <button type="button" class="liq-preset" onclick="setLiqPreset(1)">1.0</button>
    </div>
    <input class="form-input" id="totalLiquidity" type="number" placeholder="0.01" step="0.001" min="0.001" value="0.01" oninput="updateLiqSplit()" style="margin-bottom:10px">
    <div class="liq-split-bar" id="liqSplitBar">
      <div style="background:var(--fg);width:100%"></div>
    </div>
    <div class="liq-split-legend">
      <span id="liqLegAmm">0.010 AMM</span>
      <span id="liqLegVault">0 Vault</span>
      <span id="liqLegBids">0 Bids</span>
    </div>

    <!-- Advanced options -->
    <div class="adv-toggle" onclick="toggleAdvanced()"><span id="advChevron" style="font-size:9px;margin-right:4px">&#9654;</span>Advanced</div>
    <div class="adv-section" id="advSection">
      <div class="form-toggle-row">
        <input type="checkbox" id="enableVault" onchange="updateLiqSplit()">
        <label for="enableVault">Vault liquidity</label>
      </div>
      <div id="vaultFields" style="display:none">
        <div class="form-group">
          <label class="form-label">Vault (ETH)</label>
          <input class="form-input" id="vaultAmount" type="number" placeholder="0" step="0.01" min="0" oninput="updateLiqSplit()">
        </div>
        <div style="display:flex;gap:8px">
          <div class="form-group" style="flex:1">
            <label class="form-label">YES %</label>
            <input class="form-input" id="vaultYesPct" type="number" value="50" step="1" min="0" max="100">
          </div>
          <div class="form-group" style="flex:1">
            <label class="form-label">NO %</label>
            <input class="form-input" id="vaultNoPct" type="number" value="50" step="1" min="0" max="100">
          </div>
        </div>
      </div>

      <div class="form-toggle-row">
        <input type="checkbox" id="enableBids" onchange="updateLiqSplit()">
        <label for="enableBids">Orderbook bids</label>
      </div>
      <div id="bidsFields" style="display:none">
        <div class="form-group">
          <label class="form-label">Bids (ETH)</label>
          <input class="form-input" id="bidsAmount" type="number" placeholder="0" step="0.01" min="0" oninput="updateLiqSplit()">
        </div>
        <div class="form-group">
          <label class="form-label">Spread</label>
          <select class="form-input" id="bidSpread">
            <option value="balanced">Balanced 25-75%</option>
            <option value="tight">Tight 35-65%</option>
            <option value="wide">Wide 15-85%</option>
            <option value="yesOnly">YES only 20-45%</option>
            <option value="noOnly">NO only 55-80%</option>
          </select>
        </div>
      </div>
    </div>

    <div style="font-size:12px;color:var(--fg-muted);text-align:center;margin:12px 0 4px;letter-spacing:0.02em" id="totalCostDisplay">Total: 0.01 ETH</div>
    <button class="form-btn" id="createBtn" onclick="createMarket()">Create Market</button>
  </div>
</div>

<!-- LP Modal -->
<div class="modal-overlay" id="lpModal" onclick="if(event.target===this)closeLPModal()">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Provide Liquidity</div>
      <button class="modal-close" onclick="closeLPModal()">&times;</button>
    </div>
    <div class="form-preview" id="lpMarketName">...</div>
    <div class="form-group">
      <label class="form-label" id="lpAmountLabel">Amount (ETH)</label>
      <input class="form-input" id="lpAmount" type="number" placeholder="0.1" step="0.01" min="0.001">
    </div>
    <div id="lpAllocSection" style="margin:12px 0">
      <div class="lp-alloc-row">
        <span class="lp-alloc-label amm">AMM</span>
        <input type="range" class="lp-alloc-slider" id="lpAmmSlider" min="0" max="100" value="100" oninput="updateLPAlloc()">
        <span class="lp-alloc-pct" id="lpAmmPct">100%</span>
      </div>
      <div class="lp-alloc-hint">Earn swap fees from both sides</div>
      <div class="lp-alloc-row">
        <span class="lp-alloc-label yes">YES Vault</span>
        <input type="range" class="lp-alloc-slider" id="lpYesSlider" min="0" max="100" value="0" oninput="updateLPAlloc()">
        <span class="lp-alloc-pct" id="lpYesPct">0%</span>
      </div>
      <div class="lp-alloc-hint">Earn from YES share sells</div>
      <div class="lp-alloc-row">
        <span class="lp-alloc-label no">NO Vault</span>
        <input type="range" class="lp-alloc-slider" id="lpNoSlider" min="0" max="100" value="0" oninput="updateLPAlloc()">
        <span class="lp-alloc-pct" id="lpNoPct">0%</span>
      </div>
      <div class="lp-alloc-hint">Earn from NO share sells</div>
    </div>
    <div id="lpLegacyHint" style="display:none;margin:12px 0;padding:10px;font-size:12px;color:var(--fg-muted);background:var(--surface);text-align:center">
      Splits collateral into YES + NO shares and adds to AMM pool. You earn swap fees from trades.
    </div>
    <button class="form-btn" id="lpBtn" onclick="provideLiquidity()">Provide Liquidity</button>
  </div>
</div>

<script src="../ethers.min.js"></script>
<script src="../walletconnect.min.js"></script>
<script>
function toggleDark() {
  const on = document.documentElement.classList.toggle('dark');
  localStorage.setItem('dark', on ? '1' : '0');
}
const $ = id => document.getElementById(id);
const _escTextMap = { '&': '&amp;', '<': '&lt;', '>': '&gt;' };
function escText(s) { return String(s).replace(/[&<>]/g, m => _escTextMap[m]); }
function escAttr(s) { return escText(s).replace(/"/g, '&quot;').replace(/'/g, '&#39;'); }

// ==================== CONFIG ====================

const RPCS = [
  'https://ethereum.publicnode.com',
  'https://1rpc.io/eth',
  'https://eth.drpc.org',
  'https://eth.llamarpc.com'
];

const WEINS = "0x0000000000696760E15f265e828DB644A0c242EB";
const WEINS_ABI = ["function reverseResolve(address) view returns (string)"];

const CONTRACTS = {
  PAMM: '0x000000000044bfe6c2BBFeD8862973E0612f07C0',
  ZAMM: '0x000000000000040470635EB91b7CE4D132D616eD',
  MASTER_ROUTER: '0x000000000088Ec6Ab5CA97A354Ce4C57dBA5B88a',
  RESOLVER: '0x0000000000FF0Dc62d07e220F273fe8cDd324127',
  PM_FEE_HOOK: '0x0000000000116D81CDDC3574e26eEa7b79410E80',
  QUOTER: '0x8F4283c327afF696789e23589c8c79306909B2Be',
  PM_HOOK_ROUTER: '0x0000000000Ff22a7FFEf88639d95C03183c5093C',
  CHAINLINK_ETH_USD: '0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419',
  BOOTSTRAPPER: '0x51157306D13fdc57a81B4b3574E04ad2e039CC88',
  GASPM: '0x0000000000ee3d4294438093EaA34308f47Bc0b4',
  LEGACY_RESOLVER: '0x9a70ca659D5E7eB41bB94a8eE56e254c9ec6b79c',
  PM_ROUTER: '0x000000000055ff709f26efb262fba8b0ae8c35dc'
};

// Op enum: 0=LT, 1=GT, 2=LTE, 3=GTE, 4=EQ, 5=NEQ
const OP = { LT: 0, GT: 1, LTE: 2, GTE: 3, EQ: 4, NEQ: 5 };

const LEGACY_FEE_BPS = 30; // 0.3% fee for legacy (non-hooked) markets

const LEGACY_MARKETS = [
  {
    marketId: '56383978532102149659860873469210631142629299157140399402201151455176223336684',
    poolId: '17419310335243632136948884904978804426555201669398494770540125786404925384443',
    collateral: '0x0000000000000000000000000000000000000000',
    close: 1775001600
  }
];

const MULTICALL3 = '0xcA11bde05977b3631167028862bE2a173976CA11';

// ==================== ABIs ====================

const PAMM_ABI = [
  'function markets(uint256) view returns (address resolver, bool resolved, bool outcome, bool canClose, uint64 close, address collateral, uint256 collateralLocked)',
  'function totalSupplyId(uint256) view returns (uint256)',
  'function getMarketId(string description, address resolver, address collateral) pure returns (uint256)',
  'function getNoId(uint256 marketId) pure returns (uint256)',
  'function balanceOf(address, uint256) view returns (uint256)',
  'function setOperator(address, bool)',
  'function isOperator(address, address) view returns (bool)',
  'function claim(uint256 marketId, address to) returns (uint256 shares, uint256 payout)',
  'function claimMany(uint256[] marketIds, address to) returns (uint256 totalPayout)',
  'function getMarkets(uint256 start, uint256 count) view returns (uint256[] marketIds, address[] resolvers, address[] collaterals, uint8[] states, uint64[] closes, uint256[] collateralAmounts, uint256[] yesSupplies, uint256[] noSupplies, string[] descs, uint256 next)',
  'function getPoolState(uint256 marketId, uint256 feeOrHook) view returns (uint256 rYes, uint256 rNo, uint256 pYesNum, uint256 pYesDen)',
  'function getMarket(uint256 marketId) view returns (address resolver, address collateral, bool resolved, bool outcome, bool canClose, uint64 close, uint256 collateralLocked, uint256 yesSupply, uint256 noSupply, string description)',
  'function splitAndAddLiquidity(uint256 marketId, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address to, uint256 deadline) payable returns (uint256 liquidity)'
];

const QUOTER_ABI = [
  'function getTWAPPrice(uint256 marketId) view returns (uint256 twapBps)',
  'function getMarketSummary(uint256 marketId) view returns (uint112 ammYesReserve, uint112 ammNoReserve, uint256 ammPriceYesBps, uint256 feeBps, uint112 vaultYesShares, uint112 vaultNoShares, uint256 totalYesVaultLP, uint256 totalNoVaultLP, uint256 vaultBudget, uint256 twapPriceYesBps, uint64 closeTime, bool resolved, bool inCloseWindow)',
  'function getUserFullPosition(uint256 marketId, address user) view returns (uint256 yesShareBalance, uint256 noShareBalance, uint112 yesVaultLP, uint112 noVaultLP, uint256 pendingYesCollateral, uint256 pendingNoCollateral)',
  'function quoteBuyWithSweep(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 maxPriceBps) view returns (uint256 totalSharesOut, uint256 poolSharesOut, uint256 poolLevelsFilled, uint256 pmSharesOut, bytes4 pmSource)',
  'function quoteSellWithSweep(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minPriceBps) view returns (uint256 totalCollateralOut, uint256 poolCollateralOut, uint256 poolLevelsFilled, uint256 pmCollateralOut, bytes4 pmSource)'
];

const MASTER_ROUTER_ABI = [
  'function buyWithSweep(uint256 marketId, bool buyYes, uint256 collateralIn, uint256 minSharesOut, uint256 maxPriceBps, address to, uint256 deadline) payable returns (uint256 totalSharesOut, uint256 poolSharesOut, uint256 poolLevelsFilled, bytes4[] sources)',
  'function sellWithSweep(uint256 marketId, bool sellYes, uint256 sharesIn, uint256 minCollateralOut, uint256 minPriceBps, address to, uint256 deadline) returns (uint256 totalCollateralOut, uint256 poolCollateralOut, uint256 poolLevelsFilled, bytes4[] sources)',
  'function multicall(bytes[] data) payable returns (bytes[] results)',
  'function permit(address token, address owner, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)'
];

const PM_ROUTER_ABI = [
  'function buy(uint256 marketId, bool isYes, uint256 collateralIn, uint256 minSharesOut, uint256 feeOrHook, address to, uint256 deadline) payable returns (uint256)',
  'function sell(uint256 marketId, bool isYes, uint256 sharesIn, uint256 minCollateralOut, uint256 feeOrHook, address to, uint256 deadline) returns (uint256)'
];

const RESOLVER_ABI = [
  'function resolveMarket(uint256 marketId)',
  'function preview(uint256 marketId) view returns (uint256 value, bool condTrue, bool ready)',
  'function conditions(uint256) view returns (address targetA, address targetB, uint8 op, bool isRatio, uint256 threshold, uint256 threshold2, bytes callDataA, bytes callDataB)',
  'function createNumericMarket(string observable, address collateral, address target, bytes callData, uint8 op, uint256 threshold, uint64 close, bool canClose) returns (uint256 marketId, uint256 noId)'
];

const LEGACY_RESOLVER_ABI = [
  'function preview(uint256 marketId) view returns (uint256 value, bool condTrue, bool ready)',
  'function conditions(uint256) view returns (address targetA, address targetB, uint8 op, bool isRatio, uint256 threshold, bytes callDataA, bytes callDataB)',
  'function resolveMarket(uint256 marketId)'
];

const BOOTSTRAPPER_ABI = [
  // Open resolver markets (custom resolver address)
  'function bootstrapMarket(string description, address resolverAddr, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, bool buyYes, uint256 collateralForBuy, uint256 minSharesOut, address to, uint256 deadline) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut)',
  'function bootstrapMarketWithVault(string description, address resolverAddr, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapMarketWithVaultAndBids(string description, address resolverAddr, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // Price markets (Chainlink)
  'function bootstrapPriceMarket(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapPriceMarketWithBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapPriceMarketWithVault(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapPriceMarketWithVaultAndBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address priceFeed, uint8 op, uint256 priceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // ETH balance markets
  'function bootstrapETHBalanceMarket(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address account, uint8 op, uint256 balanceThreshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapETHBalanceMarketWithVault(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address account, uint8 op, uint256 balanceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapETHBalanceMarketWithVaultAndBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address account, uint8 op, uint256 balanceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // Token balance markets
  'function bootstrapTokenBalanceMarket(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address token, address account, uint8 op, uint256 balanceThreshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares)',
  'function bootstrapTokenBalanceMarketWithVault(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address token, address account, uint8 op, uint256 balanceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapTokenBalanceMarketWithVaultAndBids(string description, address collateral, uint64 close, address hook, uint256 collateralForLP, address to, uint256 deadline, address token, address account, uint8 op, uint256 balanceThreshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // Generic condition
  'function bootstrapWithCondition(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, bool buyYes, uint256 collateralForBuy, uint256 minSharesOut, address to, uint256 deadline, address target, bytes callData, uint8 op, uint256 threshold) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut)',
  'function bootstrapWithConditionAndVault(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, address target, bytes callData, uint8 op, uint256 threshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  'function bootstrapWithConditionAndVaultAndBids(string description, address collateral, uint64 close, bool canClose, address hook, uint256 collateralForLP, address to, uint256 deadline, address target, bytes callData, uint8 op, uint256 threshold, tuple(uint256 collateralForVault, uint256 vaultYesShares, uint256 vaultNoShares) vault, tuple(bool buyYes, uint256 collateralForBuy) buy, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids) payable returns (uint256 marketId, uint256 poolId, uint256 lpShares, uint256 sharesOut, uint256 yesVaultShares, uint256 noVaultShares)',
  // Orderbook
  'function addOrderbookBids(uint256 marketId, address collateral, tuple(bool buyYes, uint256 priceInBps, uint256 amount, uint256 minShares)[] bids, address to) payable',
  'function computeMarketIdResolver(string description, address collateral) view returns (uint256)'
];

const CHAINLINK_ABI = [
  'function latestAnswer() view returns (int256)',
  'function decimals() view returns (uint8)'
];

const ERC20_ABI = [
  'function symbol() view returns (string)',
  'function decimals() view returns (uint8)',
  'function totalSupply() view returns (uint256)',
  'function balanceOf(address) view returns (uint256)',
  'function allowance(address owner, address spender) view returns (uint256)',
  'function approve(address spender, uint256 amount) returns (bool)'
];

const PM_HOOK_ROUTER_ABI = [
  'function addLiquidity(uint256 marketId, address collateral, uint256 collateralIn, uint256 feeOrHook, uint256 amount0Min, uint256 amount1Min, uint256 minLiquidity, address lpRecipient, uint256 deadline) payable returns (uint256 shares, uint256 liquidity)',
  'function depositToVault(uint256 marketId, address collateral, uint256 amount, bool yesVault, address to) payable returns (uint256 vaultShares)'
];

const MULTICALL3_ABI = [
  'function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])'
];

const BID_PRESETS = {
  balanced: [
    { buyYes: true, priceInBps: 2500 }, { buyYes: true, priceInBps: 3500 }, { buyYes: true, priceInBps: 4500 },
    { buyYes: false, priceInBps: 5500 }, { buyYes: false, priceInBps: 6500 }, { buyYes: false, priceInBps: 7500 }
  ],
  tight: [
    { buyYes: true, priceInBps: 3500 }, { buyYes: true, priceInBps: 4000 }, { buyYes: true, priceInBps: 4500 },
    { buyYes: false, priceInBps: 5500 }, { buyYes: false, priceInBps: 6000 }, { buyYes: false, priceInBps: 6500 }
  ],
  wide: [
    { buyYes: true, priceInBps: 1500 }, { buyYes: true, priceInBps: 2500 }, { buyYes: true, priceInBps: 3500 },
    { buyYes: false, priceInBps: 6500 }, { buyYes: false, priceInBps: 7500 }, { buyYes: false, priceInBps: 8500 }
  ],
  yesOnly: [
    { buyYes: true, priceInBps: 2000 }, { buyYes: true, priceInBps: 3000 }, { buyYes: true, priceInBps: 3500 },
    { buyYes: true, priceInBps: 4000 }, { buyYes: true, priceInBps: 4500 }
  ],
  noOnly: [
    { buyYes: false, priceInBps: 5500 }, { buyYes: false, priceInBps: 6000 }, { buyYes: false, priceInBps: 6500 },
    { buyYes: false, priceInBps: 7500 }, { buyYes: false, priceInBps: 8000 }
  ]
};

// ==================== RPC ====================

let rpcIdx = 0;
function getRPC() {
  return new ethers.JsonRpcProvider(RPCS[rpcIdx % RPCS.length], 1, { staticNetwork: true });
}
async function withRPC(fn) {
  for (let i = 0; i < RPCS.length; i++) {
    try {
      const rpc = new ethers.JsonRpcProvider(RPCS[(rpcIdx + i) % RPCS.length], 1, { staticNetwork: true });
      const result = await fn(rpc);
      rpcIdx = (rpcIdx + i) % RPCS.length;
      return result;
    } catch(e) { if (i === RPCS.length - 1) throw e; }
  }
}

async function multicall(calls, rpc) {
  if (!calls.length) return [];
  const mc = new ethers.Contract(MULTICALL3, MULTICALL3_ABI, rpc);
  const callData = calls.map(c => ({ target: c.target, allowFailure: true, callData: c.callData }));
  const results = await mc.aggregate3(callData);
  return results.map((r, i) => ({ success: r.success, data: r.returnData, decode: () => calls[i].decode(r.returnData) }));
}

// ==================== HELPERS ====================

function fmtETH(wei) {
  const v = Number(ethers.formatEther(wei));
  if (v >= 1) return v.toFixed(4) + ' ETH';
  if (v >= 0.001) return v.toFixed(6) + ' ETH';
  return v.toFixed(8) + ' ETH';
}

function fmtCountdown(closeTs) {
  const now = Math.floor(Date.now() / 1000);
  const diff = closeTs - now;
  if (diff <= 0) return 'Closed';
  const d = Math.floor(diff / 86400);
  const h = Math.floor((diff % 86400) / 3600);
  const m = Math.floor((diff % 3600) / 60);
  if (d > 0) return d + 'd ' + h + 'h';
  if (h > 0) return h + 'h ' + m + 'm';
  return m + 'm';
}

function fmtDate(ts) {
  return new Date(ts * 1000).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
}

function formatPrice(val) {
  if (val >= 1e6) return `$${(val/1e6).toFixed(val % 1e6 === 0 ? 0 : 1)}M`;
  if (val >= 1000) return `$${(val/1000).toFixed(val % 1000 === 0 ? 0 : 1)}K`;
  return `$${val}`;
}

function getCollateralSymbol(addr) {
  if (!addr || addr === ethers.ZeroAddress) return 'ETH';
  const known = {
    '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984': 'UNI',
    '0x514910771af9ca656af840dff83e8264ecf986ca': 'LINK',
    '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2': 'WETH',
    '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': 'USDC',
    '0xdac17f958d2ee523a2206206994597c13d831ec7': 'USDT',
    '0x6b175474e89094c44da98b954eedeac495271d0f': 'DAI'
  };
  return known[(addr || '').toLowerCase()] || 'ERC20';
}

function isOurLabeledMarket(description) {
  if (!description) return false;
  if (description.startsWith('PRICE|') ||
      description.startsWith('GAS|') ||
      description.startsWith('TOKBAL|') ||
      description.startsWith('NFTBAL|') ||
      description.startsWith('ETHBAL|')) return true;
  if (description.startsWith('V4 Protocol') ||
      description.startsWith('UNI balance') ||
      description.startsWith('UNI voting power') ||
      description.startsWith('UNI totalSupply') ||
      description.startsWith('UNI price')) return true;
  if (description.startsWith('zOrgz')) return true;
  return false;
}

// ==================== MARKET DESCRIPTION PARSER ====================

// Name registries (copied from ethPM.html)
const TOKEN_NAMES = {
  '0x00000000008835cef3e0d2333695f288ee6b63a6': 'zOrgz',
  '0x514910771af9ca656af840dff83e8264ecf986ca': 'LINK',
};
const ACCOUNT_NAMES = {
  '0x5e58ba0e06ed0f5558f83be732a4b899a674053e': 'zOrg DAO',
  '0xbc10f2e862ed4502144c7d632a3459f49dfcdb5e': 'Chainlink Reserve',
  '0x9a709b7b69ea42d5eeb1cebc48674c69e1569ec6': 'RBACTimelock',
};

// Token logos (copied from ethPM.html)
const ZORGZ_LOGO = `<svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px;image-rendering:pixelated"><rect width="16" height="16" fill="#0a0a0a"/><rect x="3" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="5" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="10" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="12" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="4" y="4" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="5" width="10" height="1" fill="#e8e8e0"/><rect x="2" y="6" width="12" height="3" fill="#e8e8e0"/><rect x="3" y="9" width="10" height="1" fill="#e8e8e0"/><rect x="4" y="10" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="10" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="5" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="9" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="2" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="7" y="12" width="2" height="1" fill="#e8e8e0"/><rect x="11" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="1" y="13" width="2" height="1" fill="#e8e8e0"/><rect x="13" y="13" width="2" height="1" fill="#e8e8e0"/></svg>`;
const TOKEN_LOGOS = {
  'zorgz': ZORGZ_LOGO,
  '0x00000000008835cef3e0d2333695f288ee6b63a6': ZORGZ_LOGO,
  '0x514910771af9ca656af840dff83e8264ecf986ca': `<svg width="16" height="16" viewBox="0 0 24 24" role="img" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px"><path fill="currentColor" d="M12 0 9.798 1.266l-6 3.468L1.596 6v12l2.202 1.266 6.055 3.468L12.055 24l2.202-1.266 5.945-3.468L22.404 18V6l-2.202-1.266-6-3.468zM6 15.468V8.532l6-3.468 6 3.468v6.936l-6 3.468z"/></svg>`,
  'eth': `<svg width="16" height="16" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px"><circle cx="16" cy="16" r="16" fill="#627EEA"/><g fill="#FFF" fill-rule="nonzero"><path fill-opacity=".602" d="M16.498 4v8.87l7.497 3.35z"/><path d="M16.498 4L9 16.22l7.498-3.35z"/><path fill-opacity=".602" d="M16.498 21.968v6.027L24 17.616z"/><path d="M16.498 27.995v-6.028L9 17.616z"/><path fill-opacity=".2" d="M16.498 20.573l7.497-4.353-7.497-3.348z"/><path fill-opacity=".602" d="M9 16.22l7.498 4.353v-7.701z"/></g></svg>`,
  '0x1f9840a85d5af5bf1d1762f925bdaddc4201f984': `<svg width="16" height="16" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin-right:4px"><circle fill="#FF007A" cx="16" cy="16" r="16"/><g fill="#FFF"><path d="M12.261 5.767c-.285-.044-.297-.05-.163-.07.257-.04.865.015 1.284.114.977.233 1.866.828 2.816 1.885l.252.28.36-.057c1.52-.245 3.067-.05 4.36.547.356.164.917.491.987.576.023.026.064.199.091.383.096.637.048 1.125-.146 1.49-.106.198-.112.26-.041.43a.416.416 0 00.372.236c.322 0 .668-.52.828-1.243l.064-.287.126.143c.692.784 1.235 1.853 1.328 2.613l.025.199-.117-.18c-.2-.31-.4-.522-.658-.693-.464-.307-.955-.411-2.255-.48-1.174-.062-1.839-.162-2.497-.377-1.121-.365-1.686-.852-3.018-2.599-.591-.776-.957-1.205-1.32-1.55-.827-.786-1.639-1.198-2.678-1.36z"/><path d="M22.422 7.5c.03-.52.1-.863.242-1.176.056-.124.109-.226.117-.226a.773.773 0 01-.055.204c-.103.304-.12.72-.049 1.203.09.614.142.702.79 1.365.305.311.659.703.787.872l.233.306-.233-.219c-.285-.267-.941-.79-1.086-.864-.097-.05-.112-.049-.172.01-.055.056-.067.138-.074.529-.012.608-.095 1-.296 1.39-.108.21-.125.166-.027-.073.073-.178.08-.256.08-.845 0-1.184-.141-1.468-.966-1.956a9.046 9.046 0 00-.764-.396 2.916 2.916 0 01-.374-.182c.023-.023.827.211 1.15.336.482.185.561.209.62.186.039-.015.058-.129.077-.464z"/><path d="M21.06 18.116c-.36-.773-.442-1.52-.245-2.216.021-.074.055-.135.075-.135a.73.73 0 01.189.102c.166.112.498.3 1.383.782 1.105.603 1.735 1.07 2.164 1.602.375.467.607.999.719 1.647.063.367.026 1.25-.068 1.62-.297 1.166-.988 2.082-1.972 2.616a2.53 2.53 0 01-.288.143c-.014 0 .038-.133.117-.297.33-.692.369-1.366.118-2.116-.153-.459-.466-1.02-1.097-1.966-.734-1.1-.914-1.394-1.095-1.782z"/></g></svg>`,
};

function etherscanLink(addr, opts = {}) {
  const { color = '#627EEA', type = 'address' } = opts;
  const lowerAddr = addr.toLowerCase();
  let displayName = ACCOUNT_NAMES[lowerAddr] || TOKEN_NAMES[lowerAddr];
  if (!displayName) displayName = `${addr.slice(0,6)}...${addr.slice(-4)}`;
  const logo = TOKEN_LOGOS[lowerAddr] || '';
  const baseUrl = 'https://etherscan.io';
  const url = type === 'token' ? `${baseUrl}/token/${addr}` : `${baseUrl}/address/${addr}`;
  return `<a href="${url}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${color}" title="${addr}">${logo}${displayName}</a>`;
}

const COLORS = {
  ETH: '#627EEA', BTC: '#F7931A', SOL: '#14F195', LINK: '#375BD2',
  UNI: '#FF007A', AAVE: '#B6509E', MKR: '#1AAB9B', SNX: '#00D1FF',
  COMP: '#00D395', YFI: '#006AE3', CRV: '#FF4C4C', BAL: '#1E1E1E',
  SUSHI: '#FA52A0', MATIC: '#8247E5', ARB: '#28A0F0', OP: '#FF0420'
};
const OPS = ['<', '>', '', '', '=', ''];

function parseCalldata(calldata, targetAddr) {
  if (calldata && typeof calldata !== 'string') {
    try { calldata = ethers.hexlify(calldata); } catch { calldata = ''; }
  }
  calldata = calldata || '';
  const swissKnifeUrl = calldata && calldata !== '0x' && calldata.length > 2
    ? `https://calldata.swiss-knife.xyz/decoder?calldata=${calldata}` : null;
  if (!calldata || calldata === '0x' || calldata.length < 10) {
    return { parsed: `ETH balance of ${etherscanLink(targetAddr, { color: '#627EEA' })}`, raw: '(none - ETH balance)', swissKnifeUrl: null };
  }
  const selector = calldata.slice(0, 10).toLowerCase();
  if (selector === '0x70a08231' && calldata.length >= 74) {
    const account = '0x' + calldata.slice(34, 74);
    return { parsed: `balanceOf(${etherscanLink(account)})`, raw: calldata, swissKnifeUrl };
  }
  if (selector === '0x18160ddd') return { parsed: 'totalSupply()', raw: calldata, swissKnifeUrl };
  if (selector === '0x50d25bcd') return { parsed: 'latestAnswer() <span style="opacity:0.5">(Chainlink)</span>', raw: calldata, swissKnifeUrl };
  if (selector === '0xfeaf968c') return { parsed: 'latestRoundData() <span style="opacity:0.5">(Chainlink)</span>', raw: calldata, swissKnifeUrl };
  if (selector === '0xf02de3b2') return { parsed: 'protocolFeeController() <span style="opacity:0.5">(Uniswap V4)</span>', raw: calldata, swissKnifeUrl, functionName: 'protocolFeeController' };
  return { parsed: null, raw: calldata, swissKnifeUrl };
}

function formatCalldataHtml(calldata, targetAddr, label) {
  if (calldata && typeof calldata !== 'string') {
    try { calldata = ethers.hexlify(calldata); } catch { calldata = ''; }
  }
  calldata = calldata || '';
  if (!calldata || calldata === '0x' || calldata.length < 10) {
    if (targetAddr && targetAddr !== ethers.ZeroAddress) {
      return `<div class="inspect-row"><span class="inspect-label">${label}</span><span class="inspect-value">ETH balance of ${etherscanLink(targetAddr)}</span></div>`;
    }
    return `<div class="inspect-row"><span class="inspect-label">${label}</span><span class="inspect-value">(empty)</span></div>`;
  }
  const parsed = parseCalldata(calldata, targetAddr);
  let html = '';
  if (parsed.parsed) {
    html += `<div class="inspect-row"><span class="inspect-label">${label}</span><span class="inspect-value">${parsed.parsed}</span></div>`;
  }
  const rawDisplay = parsed.raw.length > 20 ? parsed.raw.slice(0, 20) + '...' : parsed.raw;
  const swissLink = parsed.swissKnifeUrl ? ` <a href="${parsed.swissKnifeUrl}" target="_blank" rel="noopener" title="Decode on SwissKnife" style="opacity:0.7">decode</a>` : '';
  html += `<div class="inspect-row"><span class="inspect-label">${parsed.parsed ? '' : label}</span><span class="inspect-value" title="${parsed.raw}">${rawDisplay}${swissLink}</span></div>`;
  return html;
}

function formatCloseDate(timestamp) {
  const d = new Date(timestamp * 1000);
  const now = new Date();
  if (d.getFullYear() === now.getFullYear()) {
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }
  return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
}

function formatBalance(val, decimals = 1) {
  if (val >= 1e9) return `${(val/1e9).toFixed(1)}B`;
  if (val >= 1e6) return `${(val/1e6).toFixed(1)}M`;
  if (val >= 1000) return `${(val/1000).toFixed(1)}K`;
  return val.toFixed(decimals);
}

function stripHtml(s) { return s.replace(/<[^>]*>/g, ''); }
function cardHtml(s) {
  // Strip SVGs and <a> links (can't nest inside <a> cards) but keep <u> highlighting
  return s.replace(/<svg[^>]*>[\s\S]*?<\/svg>/gi, '')
          .replace(/<a[^>]*>([\s\S]*?)<\/a>/gi, '$1')
          .replace(/<span[^>]*>\.{3}<\/span>/gi, '');
}

function showRawTooltip(el, text) {
  let tooltip = document.getElementById('rawHintTooltip');
  if (!tooltip) {
    tooltip = document.createElement('div');
    tooltip.id = 'rawHintTooltip';
    tooltip.style.cssText = 'position:fixed;background:#111;border:1px solid #333;color:#888;padding:8px 12px;font-size:10px;max-width:400px;word-break:break-word;z-index:9999;border-radius:4px;box-shadow:0 2px 8px rgba(0,0,0,0.5)';
    document.body.appendChild(tooltip);
  }
  if (tooltip.style.display === 'block' && tooltip._sourceEl === el) {
    tooltip.style.display = 'none';
    return;
  }
  const rect = el.getBoundingClientRect();
  tooltip.textContent = text.replace(/&quot;/g, '"');
  tooltip.style.display = 'block';
  tooltip._sourceEl = el;
  tooltip.style.left = Math.min(rect.left, window.innerWidth - 420) + 'px';
  tooltip.style.top = (rect.bottom + 8) + 'px';
}

function parseMarketDescription(description) {
  if (!description) return { question: 'Unknown market', color: '#627EEA', threshold: 0, raw: '' };

  let displayDesc = description;
  let threshold = 0;
  const qMatch = description.match(/^(.+?\?)/);
  if (qMatch) displayDesc = qMatch[1];
  else if (description.length > 100) displayDesc = description.slice(0, 97) + '...';

  const defaults = { question: escText(displayDesc), color: '#888', threshold, raw: description };
  try {
    const p = description.split('|');
    const type = p[0];

    // PRICE|ASSET|QUOTE|OP|THRESHOLD|CLOSE
    if (type === 'PRICE' && p.length >= 6) {
      const [, asset, quote, op, thresh, close] = p;
      const t = parseInt(thresh);
      const price = formatPrice(t);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = opNum >= 2 ? 'hit' : 'drop to';
      const color = COLORS[asset] || '#627EEA';
      return {
        question: `<u style="text-decoration-color:${color}">${asset}</u> ${verb} <u style="text-decoration-color:#0F0">${price}</u> by <u style="text-decoration-color:#F50">${date}</u>?`,
        color, threshold: t, raw: description
      };
    }

    // ETHBAL|ADDRESS|OP|THRESHOLD|CLOSE
    if (type === 'ETHBAL' && p.length >= 5) {
      const [, addr, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const bal = formatBalance(t);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = opNum >= 2 ? 'hold' : 'have under';
      const addrLink = etherscanLink(addr, { color: '#627EEA' });
      return {
        question: `${addrLink} ${verb} <u style="text-decoration-color:#0F0">${bal} ETH</u> by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#627EEA', threshold: t, raw: description
      };
    }

    // TOKBAL|TOKEN|ADDRESS|OP|THRESHOLD|CLOSE
    if (type === 'TOKBAL' && p.length >= 6) {
      const [, token, addr, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const bal = formatBalance(t, 0);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = opNum >= 2 ? 'hold' : 'have under';
      const addrLink = etherscanLink(addr, { color: '#8247E5' });
      const tokenLink = etherscanLink(token, { color: '#FF007A', type: 'token' });
      return {
        question: `${addrLink} ${verb} <u style="text-decoration-color:#0F0">${bal}</u> ${tokenLink} by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#8247E5', threshold: t, raw: description
      };
    }

    // NFTBAL|TOKEN|ADDRESS|OP|THRESHOLD|CLOSE
    if (type === 'NFTBAL' && p.length >= 6) {
      const [, token, addr, op, thresh, close] = p;
      const t = parseInt(thresh);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = opNum >= 2 ? 'hold' : 'have under';
      const addrLink = etherscanLink(addr, { color: '#8247E5' });
      const tokenLink = etherscanLink(token, { color: '#e8e8e0', type: 'token' });
      return {
        question: `${addrLink} ${verb} <u style="text-decoration-color:#0F0">${t}</u> ${tokenLink} NFTs by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#8247E5', threshold: t, raw: description
      };
    }

    // GAS|SUBTYPE|...params...|CLOSE
    if (type === 'GAS' && p.length >= 4) {
      const [, subtype, ...rest] = p;
      const close = rest[rest.length - 1];
      const date = formatCloseDate(parseInt(close));
      let q, thresh = parseFloat(rest[0]);
      if (subtype === 'RANGE') {
        const [lower, upper] = rest;
        q = `<u style="text-decoration-color:#FF6B6B">GAS</u> stay in <u style="text-decoration-color:#0F0">${lower}-${upper} gwei</u> by <u style="text-decoration-color:#F50">${date}</u>?`;
        thresh = parseFloat(lower);
      } else {
        const labels = { TWAP: 'avg', PEAK: 'spike to', TROUGH: 'dip to', VOL: 'swing', VOLATILITY: 'swing' };
        const label = labels[subtype] || subtype.toLowerCase();
        q = `<u style="text-decoration-color:#FF6B6B">GAS</u> ${label} <u style="text-decoration-color:#0F0">${rest[0]} gwei</u> by <u style="text-decoration-color:#F50">${date}</u>?`;
      }
      return { question: q, color: '#FF6B6B', threshold: thresh, raw: description };
    }

    // SUPPLY|TOKEN|OP|THRESHOLD|CLOSE
    if (type === 'SUPPLY' && p.length >= 5) {
      const [, token, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const verb = opNum >= 2 ? 'exceed' : 'drop below';
      const tokenLink = etherscanLink(token, { color: '#9945FF', type: 'token' });
      return {
        question: `${tokenLink} supply ${verb} <u style="text-decoration-color:#0F0">${formatBalance(t)}</u> by <u style="text-decoration-color:#F50">${date}</u>?`,
        color: '#9945FF', threshold: t, raw: description
      };
    }

    // LEGACY|TOKEN_SYMBOL|TARGET|OP|THRESHOLD|CLOSE
    if (type === 'LEGACY' && p.length >= 6) {
      const [, tokenSym, target, op, thresh, close] = p;
      const t = parseFloat(thresh);
      const bal = formatBalance(t, 0);
      const date = formatCloseDate(parseInt(close));
      const opNum = parseInt(op);
      const opText = OPS[opNum] || '';
      const shortTarget = `${target.slice(0,6)}...${target.slice(-4)}`;
      const color = COLORS[tokenSym] || '#375BD2';
      return {
        question: `<u style="text-decoration-color:${color}">${shortTarget}</u> bal on <u style="text-decoration-color:${color}">${tokenSym}</u><br>reaches ${opText} <u style="text-decoration-color:#0F0">${bal} ${tokenSym}</u><br>by <u style="text-decoration-color:#F50">${date}</u>`,
        color, threshold: t, raw: description, isLegacy: true
      };
    }

    // totalSupply pattern: "zOrgz totalSupply >= 10000 by 1769288092 Unix time..."
    const totalSupplyMatch = description.match(/^(\w+)\s+totalSupply\s*(>=|<=|>|<|=|!=)\s*(\d+)\s*by\s*(\d+)\s*Unix time/i);
    if (totalSupplyMatch) {
      const [, name, op, value, timestamp] = totalSupplyMatch;
      const val = parseInt(value);
      const lowerName = name.toLowerCase();
      let color = '#9945FF';
      if (lowerName === 'zorgz') color = '#e8e8e0';
      const opMap = { '>=': '', '<=': '', '!=': '', '>': '>', '<': '<', '=': '=' };
      const valText = val >= 1e6 ? `${(val/1e6).toFixed(1)}M` : val >= 1000 ? `${(val/1000).toFixed(1)}K` : val.toString();
      const dateText = formatCloseDate(parseInt(timestamp));
      const nftLogo = TOKEN_LOGOS[lowerName] || '';
      const rawTooltip = description.replace(/"/g, '&quot;');
      return {
        question: `${nftLogo}<u style="text-decoration-color:${color}">${name}</u> mint ${opMap[op]||op} <u style="text-decoration-color:#0F0">${valText}</u> by <u style="text-decoration-color:#F50">${dateText}</u>? <span onclick="event.stopPropagation();showRawTooltip(this,'${rawTooltip}')" title="${rawTooltip}" style="opacity:0.4;cursor:help;font-size:9px">...</span>`,
        color, threshold: val, raw: description
      };
    }

    // uniPM patterns: V4 Protocol, UNI balance/voting/supply/price
    const uniPMPatterns = [
      { prefix: 'V4 Protocol', label: 'V4 FEE SWITCH', color: '#FF007A' },
      { prefix: 'UNI balance', label: 'UNI BALANCE', color: '#FF007A' },
      { prefix: 'UNI voting power', label: 'UNI VOTING POWER', color: '#FF007A' },
      { prefix: 'UNI totalSupply', label: 'UNI SUPPLY', color: '#FF007A' },
      { prefix: 'UNI price', label: 'UNI PRICE', color: '#FF007A' }
    ];
    for (const pattern of uniPMPatterns) {
      if (description.startsWith(pattern.prefix)) {
        const condMatch = description.match(/(.+?)\s*(!=|>=|<=|>|<|=)\s*(\d+(?:\.\d+)?)\s*(?:by\s+(.+))?$/i);
        if (condMatch) {
          const [, subject, op, value, dateStr] = condMatch;
          const val = parseFloat(value);
          let conditionHtml;
          if (val === 0 && (op === '!=' || op === '=')) {
            conditionHtml = `<u style="text-decoration-color:#0F0">${op === '!=' ? 'on' : 'off'}</u>`;
          } else {
            const opMap = { '!=': '', '>=': '', '<=': '' };
            const opText = opMap[op] || op;
            conditionHtml = `${opText} <u style="text-decoration-color:#0F0">${formatBalance(val, val < 1 ? 2 : 0)}</u>`;
          }
          let dateHtml = '';
          if (dateStr) {
            const d = new Date(dateStr);
            if (!isNaN(d)) {
              let displayDate = d;
              if (d.getDate() >= 28) displayDate = new Date(d.getFullYear(), d.getMonth() + 1, 1);
              dateHtml = ` by <u style="text-decoration-color:#F50">${displayDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })}</u>`;
            } else {
              dateHtml = ` by <u style="text-decoration-color:#F50">${dateStr}</u>`;
            }
          }
          const rawTooltip = description.replace(/"/g, '&quot;');
          return {
            question: `<u style="text-decoration-color:${pattern.color}">${pattern.label}</u> ${conditionHtml}${dateHtml}? <span onclick="event.stopPropagation();showRawTooltip(this,'${rawTooltip}')" title="${rawTooltip}" style="opacity:0.4;cursor:help;font-size:9px">...</span>`,
            color: pattern.color, threshold: val, raw: description
          };
        }
        const rest = description.slice(pattern.prefix.length).trim();
        return { question: `<u style="text-decoration-color:${pattern.color}">${pattern.label}</u> ${rest}`, color: pattern.color, threshold: 0, raw: description };
      }
    }
  } catch (e) { console.warn('Parse error:', e); }
  return defaults;
}

// ==================== AMM MATH ====================

function quoteBuyYes(collateralInWei, rYes, rNo, feeBps) {
  if (rYes === 0n || rNo === 0n) return 0n;
  feeBps = feeBps || LEGACY_FEE_BPS;
  const mintedShares = collateralInWei;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const swapInputWithFee = collateralInWei * feeMultiplier / 10000n;
  const swappedYes = (swapInputWithFee * rYes) / (rNo + swapInputWithFee);
  return mintedShares + swappedYes;
}

function quoteBuyNo(collateralInWei, rYes, rNo, feeBps) {
  if (rYes === 0n || rNo === 0n) return 0n;
  feeBps = feeBps || LEGACY_FEE_BPS;
  const mintedShares = collateralInWei;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const swapInputWithFee = collateralInWei * feeMultiplier / 10000n;
  const swappedNo = (swapInputWithFee * rNo) / (rYes + swapInputWithFee);
  return mintedShares + swappedNo;
}

function quoteSellYes(sharesInWei, rYes, rNo, feeBps) {
  if (rYes === 0n || rNo === 0n) return 0n;
  feeBps = feeBps || LEGACY_FEE_BPS;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const amountInWithFee = sharesInWei * feeMultiplier / 10000n;
  const noOut = (amountInWithFee * rNo) / (rYes + amountInWithFee);
  return noOut < sharesInWei ? noOut : sharesInWei;
}

function quoteSellNo(sharesInWei, rYes, rNo, feeBps) {
  if (rYes === 0n || rNo === 0n) return 0n;
  feeBps = feeBps || LEGACY_FEE_BPS;
  const feeMultiplier = 10000n - BigInt(feeBps);
  const amountInWithFee = sharesInWei * feeMultiplier / 10000n;
  const yesOut = (amountInWithFee * rYes) / (rNo + amountInWithFee);
  return yesOut < sharesInWei ? yesOut : sharesInWei;
}

// ==================== STATE ====================

let markets = [];
let _walletProvider = null;
let _signer = null;
let _connectedAddress = null;
let _tradeDir = 'buy';
let _tradeSide = 'yes';
let _quoteTimer = null;
let _lastQuote = null;
let _isTrading = false;
let _galleryFilter = 'active'; // 'active' | 'resolved' | 'all'
let _currentMarketType = 'price'; // 'price' | 'balance' | 'supply'
let _balanceAssetType = 'eth'; // 'eth' | 'token'
let _currentEthPrice = 0;
let _balTokenData = { address: '', symbol: '', decimals: 18 };
let _supplyTokenData = { address: '', symbol: '', decimals: 18 };

// ==================== WALLET ====================

let _connectedWalletProvider = null;
let _walletConnectProvider = null;
let _isConnecting = false;
let _walletEventHandlers = null;
let _isWalletConnect = false;
let _wcDeepLink = null;

const eip6963Providers = new Map();
window.addEventListener('eip6963:announceProvider', (event) => {
  try {
    const { info, provider } = event.detail || {};
    if (info?.uuid && provider) eip6963Providers.set(info.uuid, { info, provider });
  } catch (e) {}
});
window.dispatchEvent(new Event('eip6963:requestProvider'));

function findProvider(checkFn) {
  if (window.ethereum?.providers?.length) {
    for (const p of window.ethereum.providers) { if (checkFn(p)) return p; }
  }
  if (window.ethereum && checkFn(window.ethereum)) return window.ethereum;
  return null;
}

const WALLET_CONFIG = {
  metamask: { name: 'MetaMask', icon: '', detect: () => findProvider(p => p.isMetaMask), getProvider: () => findProvider(p => p.isMetaMask) },
  coinbase: { name: 'Coinbase', icon: '', detect: () => findProvider(p => p.isCoinbaseWallet), getProvider: () => findProvider(p => p.isCoinbaseWallet) },
  rabby: { name: 'Rabby', icon: '', detect: () => findProvider(p => p.isRabby), getProvider: () => findProvider(p => p.isRabby) },
  rainbow: { name: 'Rainbow', icon: '', detect: () => findProvider(p => p.isRainbow), getProvider: () => findProvider(p => p.isRainbow) },
  walletconnect: { name: 'WalletConnect', icon: '' }
};

function detectWallets() {
  const detected = [];
  const seenNames = new Set();
  for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
    const name = info?.name || 'Unknown';
    if (!seenNames.has(name.toLowerCase())) {
      const iconUrl = info.icon && (info.icon.startsWith('data:image/') || info.icon.startsWith('https://')) ? info.icon : null;
      const safeIconUrl = iconUrl ? iconUrl.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c])) : null;
      detected.push({ key: `eip6963_${uuid}`, name, icon: safeIconUrl ? `<img src="${safeIconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : '', getProvider: () => provider });
      seenNames.add(name.toLowerCase());
    }
  }
  if (window.ethereum?.providers?.length) {
    for (let i = 0; i < window.ethereum.providers.length; i++) {
      const p = window.ethereum.providers[i];
      const name = p.isMetaMask ? 'MetaMask' : p.isCoinbaseWallet ? 'Coinbase' : p.isRabby ? 'Rabby' : p.isRainbow ? 'Rainbow' : null;
      if (name && !seenNames.has(name.toLowerCase())) { detected.push({ key: `provider_${i}`, name, icon: '', getProvider: () => p }); seenNames.add(name.toLowerCase()); }
    }
  }
  for (const [key, config] of Object.entries(WALLET_CONFIG)) {
    if (key === 'walletconnect') continue;
    try { if (config.detect && config.detect() && !seenNames.has(config.name.toLowerCase())) { detected.push({ key, ...config }); seenNames.add(config.name.toLowerCase()); } } catch (e) {}
  }
  if (detected.length === 0 && window.ethereum) detected.push({ key: 'injected', name: 'Browser Wallet', icon: '', getProvider: () => window.ethereum });
  const wcModule = globalThis['@walletconnect/ethereum-provider'];
  if (wcModule?.EthereumProvider) detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: '' });
  return detected;
}

function showWalletModal() {
  $('walletModal').classList.add('active');
  document.body.classList.add('modal-open');
  $('walletOptions').innerHTML = '<div style="padding:12px;text-align:center;">Detecting wallets...</div>';
  window.dispatchEvent(new Event('eip6963:requestProvider'));
  const doDetect = (attempt = 1) => {
    const wallets = detectWallets();
    if (!wallets.some(w => w.key !== 'walletconnect') && attempt < 2) setTimeout(() => doDetect(attempt + 1), 250);
    else renderWalletModal(wallets);
  };
  setTimeout(() => doDetect(), 150);
}

function renderWalletModal(wallets) {
  const container = $('walletOptions');
  if (_connectedAddress) {
    const displayName = $('walletBtn').textContent;
    const showName = displayName && displayName !== 'connect' && !displayName.startsWith('0x');
    container.innerHTML = `<div style="padding:12px;border:1px solid currentColor;margin-bottom:12px;"><div style="font-weight:600;margin-bottom:6px;">Connected</div>${showName ? `<div style="font-size:16px;margin-bottom:4px;">${escText(displayName)}</div>` : ''}<div style="font-size:12px;word-break:break-all;opacity:0.6;">${escText(_connectedAddress)}</div></div><div class="wallet-option disconnect" onclick="disconnectWallet()"><span class="wallet-option-name">Disconnect</span></div>`;
  } else {
    container.innerHTML = wallets.length > 0 ? wallets.map(w => `<div class="wallet-option" data-wallet-key="${escAttr(w.key)}"><span class="wallet-option-icon">${w.icon}</span><span class="wallet-option-name">${escText(w.name)}</span></div>`).join('') : '<div style="padding:12px;text-align:center;">No wallets detected.</div>';
    container.querySelectorAll('[data-wallet-key]').forEach(el => { el.addEventListener('click', () => connectWithWallet(el.dataset.walletKey)); });
  }
}

function closeWalletModal() { $('walletModal').classList.remove('active'); document.body.classList.remove('modal-open'); }
function toggleWallet() { showWalletModal(); }

async function connectWithWallet(walletKey) {
  if (_isConnecting) return;
  _isConnecting = true;
  try {
    closeWalletModal();
    let walletProvider;
    if (walletKey === 'walletconnect') {
      const wcModule = globalThis['@walletconnect/ethereum-provider'];
      const WCProvider = wcModule?.EthereumProvider;
      if (!WCProvider?.init) throw new Error('WalletConnect not available');
      if (_walletConnectProvider) { try { await _walletConnectProvider.disconnect?.(); } catch (e) {} _walletConnectProvider = null; }
      _walletConnectProvider = await WCProvider.init({ projectId: '1e8390ef1c1d8a185e035912a1409749', chains: [1], showQrModal: true, rpcMap: { 1: 'https://1rpc.io/eth' }, metadata: { name: 'zFi Predict', description: 'Prediction markets', url: window.location.origin, icons: [] } });
      _walletConnectProvider.on('display_uri', () => { try { const s = _walletConnectProvider.session?.peer?.metadata; if (s?.redirect?.native && /^https?:\/\//i.test(s.redirect.native)) _wcDeepLink = s.redirect.native; else if (s?.redirect?.universal && /^https?:\/\//i.test(s.redirect.universal)) _wcDeepLink = s.redirect.universal; } catch (e) {} });
      await _walletConnectProvider.enable();
      walletProvider = _walletConnectProvider;
      _isWalletConnect = true;
    } else if (walletKey.startsWith('eip6963_')) {
      const uuid = walletKey.replace('eip6963_', '');
      walletProvider = eip6963Providers.get(uuid)?.provider;
      if (!walletProvider) { const savedName = localStorage.getItem('zpred_wallet_name')?.toLowerCase(); if (savedName) { for (const [, { info, provider }] of eip6963Providers) { if (info?.name?.toLowerCase() === savedName) { walletProvider = provider; break; } } } }
      _isWalletConnect = false; _wcDeepLink = null;
    } else {
      walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
      _isWalletConnect = false; _wcDeepLink = null;
    }
    if (!walletProvider) throw new Error('Wallet not found');
    if (walletKey !== 'walletconnect') await walletProvider.request({ method: 'eth_requestAccounts' });
    const chainId = await walletProvider.request({ method: 'eth_chainId' });
    if (BigInt(chainId) !== 1n) {
      try { await walletProvider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x1' }] }); const nc = await walletProvider.request({ method: 'eth_chainId' }); if (BigInt(nc) !== 1n) throw new Error('Chain switch failed'); }
      catch (switchErr) { alert('Please switch to Ethereum Mainnet'); if (walletKey === 'walletconnect') { try { _walletConnectProvider?.disconnect(); } catch (e) {} _walletConnectProvider = null; } _isWalletConnect = false; _wcDeepLink = null; return; }
    }
    _walletProvider = new ethers.BrowserProvider(walletProvider);
    _signer = await _walletProvider.getSigner();
    _connectedAddress = await _signer.getAddress();
    const oldWP = _connectedWalletProvider;
    _connectedWalletProvider = walletProvider;
    $('walletBtn').textContent = _connectedAddress.slice(0, 6) + '...' + _connectedAddress.slice(-4);
    resolveWeiName(_connectedAddress);
    updateWcBanner();
    if (oldWP && _walletEventHandlers) { try { oldWP.removeListener('accountsChanged', _walletEventHandlers.accountsChanged); oldWP.removeListener('chainChanged', _walletEventHandlers.chainChanged); } catch (e) {} }
    _walletEventHandlers = { accountsChanged: () => window.location.reload(), chainChanged: () => window.location.reload() };
    walletProvider.on('accountsChanged', _walletEventHandlers.accountsChanged);
    walletProvider.on('chainChanged', _walletEventHandlers.chainChanged);
    try { localStorage.setItem('zpred_wallet', walletKey); if (walletKey.startsWith('eip6963_')) { const uuid = walletKey.replace('eip6963_', ''); const name = eip6963Providers.get(uuid)?.info?.name; if (name) localStorage.setItem('zpred_wallet_name', name); } } catch (e) {}
  } catch (error) {
    if (error.code === 'ACTION_REJECTED' || error.code === 4001 || (error.message || '').includes('user rejected') || (error.message || '').includes('User rejected')) {
      // User cancelled - silently ignore
    } else {
      console.error('Wallet connect error:', error);
      alert(error.message || 'Connection failed');
    }
  } finally { _isConnecting = false; }
}

function disconnectWallet() {
  if (_connectedWalletProvider && _walletEventHandlers) { try { _connectedWalletProvider.removeListener('accountsChanged', _walletEventHandlers.accountsChanged); _connectedWalletProvider.removeListener('chainChanged', _walletEventHandlers.chainChanged); } catch (e) {} }
  _walletEventHandlers = null;
  if (_walletConnectProvider) { try { _walletConnectProvider.disconnect(); } catch (e) {} _walletConnectProvider = null; }
  _walletProvider = null; _signer = null; _connectedAddress = null; _connectedWalletProvider = null; _isWalletConnect = false; _wcDeepLink = null;
  $('walletBtn').textContent = 'connect';
  updateWcBanner();
  closeWalletModal();
  try { localStorage.removeItem('zpred_wallet'); localStorage.removeItem('zpred_wallet_name'); } catch (e) {}
}

// Compatibility wrapper  existing code calls connectWallet()
async function connectWallet() {
  if (_signer) return _signer;
  showWalletModal();
  return null;
}

function resolveWeiName(addr) {
  try {
    const rpc = new ethers.JsonRpcProvider(RPCS[0], 1, { staticNetwork: true });
    const ns = new ethers.Contract(WEINS, WEINS_ABI, rpc);
    ns.reverseResolve(addr).then(name => { if (name && _connectedAddress === addr) $('walletBtn').textContent = name.toLowerCase(); }).catch(() => {});
  } catch (e) {}
}

function updateWcBanner() {
  const existing = document.getElementById('wcBanner');
  if (existing) existing.remove();
  if (_isWalletConnect && _connectedAddress) {
    const banner = document.createElement('div');
    banner.id = 'wcBanner';
    banner.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#1a1a2e;color:#fff;padding:10px 16px;display:flex;justify-content:space-between;align-items:center;z-index:9000;font-size:13px;';
    banner.innerHTML = '<span> Connected via WalletConnect</span><button onclick="disconnectWallet()" style="background:#fff;color:#000;border:none;padding:6px 12px;border-radius:0;cursor:pointer;font-size:12px;">Disconnect</button>';
    document.body.prepend(banner);
    document.body.style.paddingTop = '44px';
  } else {
    document.body.style.paddingTop = '';
  }
}

async function tryAutoConnect() {
  const savedWallet = localStorage.getItem('zpred_wallet');
  if (!savedWallet) {
    if (!window.ethereum) return;
    try { const accts = await window.ethereum.request({ method: 'eth_accounts' }); if (accts && accts.length > 0) await connectWithWallet('injected'); } catch {}
    return;
  }
  $('walletBtn').textContent = '...';
  setTimeout(async () => {
    try { window.dispatchEvent(new Event('eip6963:requestProvider')); await new Promise(r => setTimeout(r, 300)); await connectWithWallet(savedWallet); }
    catch (e) { console.error('Auto-reconnect failed:', e); $('walletBtn').textContent = 'connect'; }
  }, 100);
}

// ==================== ROUTER ====================

function route() {
  const hash = location.hash.replace('#', '').trim();
  if (hash && /^\d+$/.test(hash)) {
    renderMarketPage(hash);
  } else {
    renderGallery();
  }
}

window.addEventListener('hashchange', route);

// ==================== GALLERY ====================

async function renderGallery() {
  const app = $('app');
  const createBtnHTML = '<button onclick="openCreateModal()" style="font-size:11px;padding:6px 14px">+ Create</button>';
  app.innerHTML = `
    <div class="header">
      <h1>Predict</h1>
      <div>${createBtnHTML}</div>
    </div>
    <div class="loading"><span class="spinner"></span>Loading markets...</div>
  `;

  try {
    // Check cache first for instant display
    let cached = null;
    try {
      const raw = localStorage.getItem('zfi_predict_markets');
      if (raw) {
        const parsed = JSON.parse(raw);
        if (Date.now() - parsed.ts < 120000) cached = parsed.data;
      }
    } catch {}

    if (cached && cached.length > 0) {
      markets = cached;
      renderGalleryUI();
    }

    // Fetch from chain using RPC with fallback
    let allFetched = [];
    let fetchSuccess = false;

    try {
      allFetched = await withRPC(async (rpc) => {
        const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
        const PAGE_SIZE = 50;
        let start = 0;
        let fetched = [];
        let firstPage = true;

        while (true) {
          let result;
          try {
            result = await pamm.getMarkets(start, PAGE_SIZE, { gasLimit: 5000000 });
          } catch (pageErr) {
            // First page failure = dead RPC, throw so withRPC retries next RPC
            if (firstPage) throw pageErr;
            // Later page failure = likely end of data, stop pagination
            break;
          }
          firstPage = false;
          const batchSize = result.marketIds.length;
          if (batchSize === 0) break;
          for (let i = 0; i < batchSize; i++) {
            // Accept markets with our resolver
            if (result.resolvers[i].toLowerCase() !== CONTRACTS.RESOLVER.toLowerCase()) continue;
            const marketId = result.marketIds[i].toString();
            const description = result.descs[i];
            const close = Number(result.closes[i]);
            const tvl = Number(result.collateralAmounts[i]) / 1e18;
            const states = Number(result.states[i]);
            const resolved = (states & 1) !== 0;
            const outcome = (states & 2) !== 0;
            const parsed = parseMarketDescription(description);
            fetched.push({
              marketId, description, close, tvl, resolved, outcome,
              question: parsed.question,
              collateral: result.collaterals[i],
              isLegacy: false,
              y: 50, oddsLoaded: false
            });
          }
          if (batchSize < PAGE_SIZE) break;
          const next = Number(result.next);
          if (next === 0) break;
          start = next;
        }

        // Inject legacy markets (different resolver, must be loaded individually)
        for (const legacy of LEGACY_MARKETS) {
          if (fetched.find(m => m.marketId === legacy.marketId)) continue;
          try {
            const poolState = await pamm.getPoolState(BigInt(legacy.marketId), LEGACY_FEE_BPS);
            const rYes = Number(poolState.rYes) / 1e18;
            const rNo = Number(poolState.rNo) / 1e18;
            const tvl = rYes + rNo;
            const total = rYes + rNo;
            const yPct = total > 0 ? Math.round((rNo / total) * 100) : 50;

            const marketData = await pamm.getMarket(BigInt(legacy.marketId));
            const onChainDesc = marketData.description || '';
            const parsed = parseMarketDescription(onChainDesc);

            fetched.push({
              marketId: legacy.marketId,
              description: onChainDesc,
              close: Number(marketData.close) || legacy.close,
              tvl,
              resolved: marketData.resolved,
              outcome: marketData.outcome,
              question: parsed.question,
              collateral: marketData.collateral || legacy.collateral,
              isLegacy: true,
              y: yPct,
              oddsLoaded: true
            });
          } catch (e) {
            console.warn('Failed to inject legacy market:', legacy.marketId.slice(0, 8), e.message);
          }
        }

        return fetched;
      });
      fetchSuccess = true;
    } catch (fetchErr) {
      console.warn('getMarkets failed, using cache:', fetchErr.message);
    }

    if (fetchSuccess) {
      // Sort: active first, then by TVL
      const now = Math.floor(Date.now() / 1000);
      allFetched.sort((a, b) => {
        const aActive = !a.resolved && a.close > now;
        const bActive = !b.resolved && b.close > now;
        if (aActive && !bActive) return -1;
        if (!aActive && bActive) return 1;
        return (b.tvl || 0) - (a.tvl || 0);
      });

      markets = allFetched;
      try {
        localStorage.setItem('zfi_predict_markets', JSON.stringify({ ts: Date.now(), data: markets }));
      } catch {}
      renderGalleryUI();

      // Batch fetch odds via multicall (dual path: getMarketSummary for labeled, getPoolState for legacy)
      const pammIface = new ethers.Interface(PAMM_ABI);
      const quoterIface = new ethers.Interface(QUOTER_ABI);
      const needsOdds = markets.filter(m => !m.oddsLoaded && !m.resolved);
      if (needsOdds.length > 0) {
        try {
          await withRPC(async (rpc) => {
            const calls = needsOdds.map(m => {
              if (isOurLabeledMarket(m.description)) {
                return {
                  target: CONTRACTS.QUOTER,
                  callData: quoterIface.encodeFunctionData('getMarketSummary', [m.marketId]),
                  decode: data => quoterIface.decodeFunctionResult('getMarketSummary', data),
                  market: m, isLabeled: true
                };
              } else {
                return {
                  target: CONTRACTS.PAMM,
                  callData: pammIface.encodeFunctionData('getPoolState', [BigInt(m.marketId), LEGACY_FEE_BPS]),
                  decode: data => pammIface.decodeFunctionResult('getPoolState', data),
                  market: m, isLabeled: false
                };
              }
            });
            const results = await multicall(calls, rpc);
            for (let i = 0; i < results.length; i++) {
              if (!results[i].success) continue;
              try {
                const decoded = results[i].decode();
                if (calls[i].isLabeled) {
                  calls[i].market.y = Math.round(Number(decoded.ammPriceYesBps) / 100);
                } else {
                  const rYes = Number(decoded.rYes);
                  const rNo = Number(decoded.rNo);
                  const total = rYes + rNo;
                  calls[i].market.y = total > 0 ? Math.round((rNo / total) * 100) : 50;
                }
                calls[i].market.oddsLoaded = true;
              } catch {}
            }
            return true;
          });
          try {
            localStorage.setItem('zfi_predict_markets', JSON.stringify({ ts: Date.now(), data: markets }));
          } catch {}
          renderGalleryUI();
        } catch (e) {
          console.warn('Batch odds fetch failed:', e.message);
        }
      }
    } else if (!markets.length) {
      app.innerHTML = `
        <div class="header"><h1>Predict</h1><div>${createBtnHTML}</div></div>
        <div class="loading">No markets found</div>
      `;
    }
  } catch (e) {
    console.warn('Failed to load markets:', e);
    if (!markets.length) {
      $('app').innerHTML = `
        <div class="header"><h1>Predict</h1><div>${createBtnHTML}</div></div>
        <div class="loading">Failed to load markets: ${escText(e.message || '')}</div>
      `;
    }
  }
}

function renderGalleryUI() {
  const now = Math.floor(Date.now() / 1000);
  let filtered = markets;
  if (_galleryFilter === 'active') filtered = markets.filter(m => !m.resolved && m.close > now);
  else if (_galleryFilter === 'resolved') filtered = markets.filter(m => m.resolved || m.close <= now);

  const searchVal = $('marketSearch')?.value || '';

  let cards = '';
  for (const m of filtered) {
    if (searchVal) {
      const q = searchVal.toLowerCase();
      const plainQ = stripHtml(m.question).toLowerCase();
      if (!plainQ.includes(q) && !m.marketId.includes(q) && !(m.description || '').toLowerCase().includes(q)) continue;
    }
    const yPct = m.oddsLoaded ? m.y : 50;
    const nPct = 100 - yPct;
    const isActive = !m.resolved && m.close > now;
    const resolvedClass = m.resolved ? ' resolved' : '';
    const wonAttr = m.resolved ? ` data-won="${m.outcome ? 'yes' : 'no'}"` : '';
    const outcomeLabel = m.resolved ? (m.outcome ? 'YES' : 'NO') : '';
    const tvlDisplay = m.tvl >= 1 ? m.tvl.toFixed(2) : m.tvl.toFixed(4);
    const timeDisplay = isActive ? fmtCountdown(m.close) : (m.resolved ? 'Resolved' : 'Closed');
    cards += `
      <a href="#${m.marketId}" class="market-card${resolvedClass}"${wonAttr}>
        <div class="market-card-question" data-outcome="${escText(outcomeLabel)}">${cardHtml(m.question)}</div>
        <div class="market-card-odds">
          <div class="market-card-yes" style="width:${yPct}%">Y ${yPct}%</div>
          <div class="market-card-no">N ${nPct}%</div>
        </div>
        <div class="market-card-meta">
          <span>${tvlDisplay} ${getCollateralSymbol(m.collateral)}</span>
          <span>${timeDisplay}</span>
        </div>
      </a>
    `;
  }

  if (!cards) cards = '<div class="loading">No markets found</div>';

  $('app').innerHTML = `
    <div class="header">
      <h1>Predict <span style="font-weight:400;color:var(--fg-muted)">(${filtered.length})</span></h1>
      <div>
        <button onclick="openCreateModal()" style="font-size:11px;padding:6px 14px">+ Create</button>
      </div>
    </div>
    <div class="filter-tabs">
      <button class="filter-tab${_galleryFilter === 'active' ? ' active' : ''}" onclick="setFilter('active')">Active</button>
      <button class="filter-tab${_galleryFilter === 'resolved' ? ' active' : ''}" onclick="setFilter('resolved')">Resolved</button>
      <button class="filter-tab${_galleryFilter === 'all' ? ' active' : ''}" onclick="setFilter('all')">All</button>
    </div>
    <input type="text" class="market-search" id="marketSearch" placeholder="Search markets..." oninput="renderGalleryUI()" value="${escText(searchVal)}">
    <div class="market-grid" id="marketGrid">${cards}</div>
  `;
}

function setFilter(f) {
  _galleryFilter = f;
  renderGalleryUI();
}

// ==================== MARKET DETAIL PAGE ====================

async function renderMarketPage(marketId) {
  const app = $('app');
  app.dataset.marketId = marketId;
  app.innerHTML = `
    <a href="#" class="back-link">&larr; All Markets</a>
    <div class="loading"><span class="spinner"></span>Loading market...</div>
  `;

  _tradeDir = 'buy';
  _tradeSide = 'yes';
  _lastQuote = null;

  try {
    // Load all market data with RPC fallback
    const marketData = await withRPC(async (rpc) => {
      const pammIface = new ethers.Interface(PAMM_ABI);
      const quoterIface = new ethers.Interface(QUOTER_ABI);

      // First: always load market base data
      const calls = [
        {
          target: CONTRACTS.PAMM,
          callData: pammIface.encodeFunctionData('getMarket', [marketId]),
          decode: data => pammIface.decodeFunctionResult('getMarket', data)
        }
      ];

      // Also load user positions if connected
      if (_connectedAddress) {
        calls.push({
          target: CONTRACTS.QUOTER,
          callData: quoterIface.encodeFunctionData('getUserFullPosition', [marketId, _connectedAddress]),
          decode: data => quoterIface.decodeFunctionResult('getUserFullPosition', data)
        });
      }

      const results = await multicall(calls, rpc);
      if (!results[0].success) throw new Error('Market not found');
      const mkt = results[0].decode();

      // Determine if this is a labeled (hooked) or legacy market
      const description = mkt.description || '';
      const isLabeled = isOurLabeledMarket(description);
      const resolverAddr = mkt.resolver;
      const isOurResolver = resolverAddr.toLowerCase() === CONTRACTS.RESOLVER.toLowerCase();
      // Legacy: check LEGACY_MARKETS array, resolver address match, description prefix, or gallery flag
      const isLegacyMarket = LEGACY_MARKETS.some(l => l.marketId === marketId)
        || resolverAddr.toLowerCase() === CONTRACTS.LEGACY_RESOLVER.toLowerCase()
        || description.startsWith('LEGACY|')
        || (markets.find(m => m.marketId === marketId)?.isLegacy === true);
      const isLegacyResolver = isLegacyMarket;

      // Fetch odds: getMarketSummary for labeled, getPoolState for legacy
      let yPct = 50, ammYesReserve = 0n, ammNoReserve = 0n;
      if (isLabeled) {
        try {
          const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);
          const summary = await quoter.getMarketSummary(marketId);
          yPct = Math.round(Number(summary.ammPriceYesBps) / 100);
          ammYesReserve = BigInt(summary.ammYesReserve);
          ammNoReserve = BigInt(summary.ammNoReserve);
        } catch {}
      } else {
        try {
          const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
          const poolState = await pamm.getPoolState(BigInt(marketId), LEGACY_FEE_BPS);
          ammYesReserve = BigInt(poolState.rYes);
          ammNoReserve = BigInt(poolState.rNo);
          const rY = Number(poolState.rYes);
          const rN = Number(poolState.rNo);
          const total = rY + rN;
          yPct = total > 0 ? Math.round((rN / total) * 100) : 50;
        } catch {}
      }

      // Fetch resolution preview + conditions (use correct resolver ABI)
      let resValue = null, resCond = null, resReady = false, condData = null;
      try {
        const resolverAbi = isOurResolver ? RESOLVER_ABI : LEGACY_RESOLVER_ABI;
        const resolver = new ethers.Contract(resolverAddr, resolverAbi, rpc);
        const [prev, cond] = await Promise.all([
          resolver.preview(BigInt(marketId)),
          resolver.conditions(BigInt(marketId)).catch(() => null)
        ]);
        resValue = prev[0]; // value
        resCond = prev[1]; // condTrue
        resReady = prev[2]; // ready
        condData = cond;
      } catch (e) {
        console.warn('Resolver fetch failed:', resolverAddr, e.message);
      }

      // Parse user positions
      let userYes = 0n, userNo = 0n;
      const posIdx = _connectedAddress ? 1 : -1;
      if (posIdx >= 0 && results[posIdx] && results[posIdx].success) {
        try {
          const pos = results[posIdx].decode();
          userYes = BigInt(pos.yesShareBalance);
          userNo = BigInt(pos.noShareBalance);
        } catch {}
      }

      return {
        mkt, description, isLabeled, isOurResolver, isLegacyResolver, resolverAddr,
        yPct, ammYesReserve, ammNoReserve,
        resValue, resCond, resReady, condData,
        userYes, userNo
      };
    });

    const { mkt, description, isLabeled, isOurResolver, isLegacyResolver, resolverAddr,
            yPct, ammYesReserve, ammNoReserve,
            resValue, resCond, resReady, condData,
            userYes, userNo } = marketData;

    const close = Number(mkt.close);
    const resolved = mkt.resolved;
    const outcome = mkt.outcome;
    const collateral = mkt.collateral;
    const collateralLocked = mkt.collateralLocked;
    const tvl = Number(ethers.formatEther(collateralLocked));
    const parsed = parseMarketDescription(description);
    const nPct = 100 - yPct;

    const now = Math.floor(Date.now() / 1000);
    const isActive = !resolved && close > now;
    const collSym = getCollateralSymbol(collateral);

    let html = `<a href="#" class="back-link">&larr; All Markets</a>`;

    // Question + odds bar
    html += `
      <div style="font-size:18px;font-weight:700;line-height:1.4;margin-bottom:16px">${parsed.question}</div>
      <div class="odds-bar">
        <div class="odds-yes" style="width:${yPct}%">YES ${yPct}%</div>
        <div class="odds-no">NO ${nPct}%</div>
      </div>
    `;

    // Market info card
    const resolverShort = resolverAddr.slice(0, 6) + '...' + resolverAddr.slice(-4);
    const resolverLabel = isOurResolver ? 'Onchain Resolver' : resolverShort;
    html += `
      <div class="section-card">
        <div class="section-title">Market Info</div>
        <div class="stat-row"><span class="stat-label">Status</span><span class="stat-value">${resolved ? (outcome ? '<span style="color:var(--yes)">Resolved YES</span>' : '<span style="color:var(--no)">Resolved NO</span>') : (isActive ? fmtCountdown(close) + ' left' : 'Closed')}</span></div>
        <div class="stat-row"><span class="stat-label">Closes</span><span class="stat-value">${fmtDate(close)}</span></div>
        <div class="stat-row"><span class="stat-label">Liquidity</span><span class="stat-value">${tvl >= 1 ? tvl.toFixed(2) : tvl.toFixed(4)} ${collSym}</span></div>
        <div class="stat-row"><span class="stat-label">Resolver</span><span class="stat-value" style="font-size:11px"><a href="https://etherscan.io/address/${resolverAddr}" target="_blank" rel="noopener" style="color:var(--fg-muted)">${resolverLabel}</a></span></div>
        <div class="stat-row"><span class="stat-label">Market ID</span><span class="stat-value" style="font-size:11px;word-break:break-all"><a href="https://etherscan.io/address/${CONTRACTS.PAMM}" target="_blank" rel="noopener" style="color:var(--fg-muted)">${marketId.slice(0, 12)}...${marketId.slice(-6)}</a></span></div>
      </div>
    `;

    // User positions (if any)
    if (userYes > 0n || userNo > 0n) {
      html += `
        <div class="section-card">
          <div class="section-title">Your Positions</div>
          ${userYes > 0n ? `<div class="pos-row"><span class="pos-side yes">YES</span><span>${Number(ethers.formatEther(userYes)).toFixed(4)} shares</span></div>` : ''}
          ${userNo > 0n ? `<div class="pos-row"><span class="pos-side no">NO</span><span>${Number(ethers.formatEther(userNo)).toFixed(4)} shares</span></div>` : ''}
        </div>
      `;
    }

    // Trade card (only if market is active)
    if (isActive) {
      const isETH = !collateral || collateral === ethers.ZeroAddress;
      html += `
        <div class="section-card" id="tradeCard">
          <div class="section-title">Trade</div>
          <div class="trade-dir">
            <button class="active" data-dir="buy" onclick="setTradeDir('buy')">Buy</button>
            <button data-dir="sell" onclick="setTradeDir('sell')">Sell</button>
          </div>
          <div class="trade-side">
            <button class="active" data-side="yes" onclick="setTradeSide('yes')">Yes</button>
            <button data-side="no" onclick="setTradeSide('no')">No</button>
          </div>
          <div class="trade-section">
            <div class="trade-section-head">
              <label id="tradeInputLabel">${isETH ? 'ETH' : 'Amount'}</label>
              <span class="trade-balance" id="tradeBalance" onclick="setMaxAmount()"></span>
            </div>
            <input type="number" id="tradeInput" placeholder="0.0" step="any" min="0" oninput="onTradeInput()">
            <div class="trade-pct-row" id="tradePctRow">
              <button class="trade-pct-btn" onclick="setPct(0.25)">25%</button>
              <button class="trade-pct-btn" onclick="setPct(0.5)">50%</button>
              <button class="trade-pct-btn" onclick="setPct(0.75)">75%</button>
              <button class="trade-pct-btn" onclick="setPct(1)">Max</button>
            </div>
          </div>
          <div class="trade-quote" id="tradeQuote"></div>
          <button id="tradeBtn" style="width:100%;padding:12px;font-size:13px;font-weight:600" onclick="executeTrade()" disabled>Enter amount</button>
        </div>
      `;

      // LP button
      html += `
        <div style="text-align:center;margin-bottom:16px">
          <button onclick="openLPModal('${marketId}')" style="font-size:11px;padding:6px 16px;background:transparent;border:1px solid var(--border-muted);color:var(--fg-muted)">Provide Liquidity</button>
        </div>
      `;
    }

    // Claim card (if resolved and user has winning shares)
    if (resolved && (userYes > 0n || userNo > 0n)) {
      const winningShares = outcome ? userYes : userNo;
      if (winningShares > 0n) {
        html += `
          <div class="section-card">
            <div class="section-title">Claim Winnings</div>
            <div style="text-align:center;margin-bottom:12px;font-size:14px">
              You have <b>${Number(ethers.formatEther(winningShares)).toFixed(4)}</b> winning ${outcome ? 'YES' : 'NO'} shares
            </div>
            <button class="resolve-btn" id="claimBtn" onclick="claimWinnings('${marketId}')">Claim</button>
          </div>
        `;
      }
    }

    // Resolution section
    if (isOurResolver || isLegacyResolver) {
      try {
        html += buildResolutionSection(marketId, { resolved, outcome, resValue, resCond, resReady, condData, close, canClose: mkt.canClose, resolverAddr, isOurResolver, isLegacyResolver });
      } catch (e) {
        console.error('buildResolutionSection error:', e);
        html += `<div class="section-card"><div class="section-title">Resolution</div><div class="resolve-status">Error loading resolver data</div></div>`;
      }
    } else if (!resolved && _connectedAddress && resolverAddr.toLowerCase() === _connectedAddress.toLowerCase() && (close <= now || mkt.canClose)) {
      html += `
        <div class="section-card">
          <div class="section-title">You are the Resolver</div>
          <div class="resolve-status">You can resolve this market as the designated resolver.</div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button class="resolve-btn" id="resolveYesBtn" onclick="resolveCustomMarket('${marketId}', true)" style="flex:1;background:var(--yes);color:#000">Resolve YES</button>
            <button class="resolve-btn" id="resolveNoBtn" onclick="resolveCustomMarket('${marketId}', false)" style="flex:1;background:var(--no);color:#fff">Resolve NO</button>
          </div>
        </div>
      `;
    }

    app.innerHTML = html;

    // Store market data for trading
    app.dataset.marketId = marketId;
    app.dataset.collateral = collateral;
    app.dataset.ammYesReserve = ammYesReserve.toString();
    app.dataset.ammNoReserve = ammNoReserve.toString();
    app.dataset.resolved = resolved ? '1' : '0';
    app.dataset.isLabeled = isLabeled ? '1' : '0';
    app.dataset.resolverAddr = resolverAddr;
    app.dataset.isOurResolver = isOurResolver ? '1' : '0';

    // Load balances if connected
    if (_connectedAddress && isActive) {
      loadTradeBalance(marketId, collateral, userYes, userNo);
    }

    tryAutoConnect().then(() => {
      if (_connectedAddress && isActive) {
        loadTradeBalance(marketId, collateral, userYes, userNo);
      }
    });

  } catch (e) {
    app.innerHTML = `
      <a href="#" class="back-link">&larr; All Markets</a>
      <div class="loading">Failed to load market: ${escText(e.message || '')}</div>
    `;
  }
}

// ==================== TRADE UI ====================

function setTradeDir(dir) {
  _tradeDir = dir;
  _lastQuote = null;
  document.querySelectorAll('.trade-dir button').forEach(b => {
    b.classList.toggle('active', b.dataset.dir === dir);
  });
  const tradeInput = $('tradeInput');
  if (tradeInput) { tradeInput.value = ''; }
  const tradeQuote = $('tradeQuote');
  if (tradeQuote) tradeQuote.textContent = '';
  const tradeBtn = $('tradeBtn');
  if (tradeBtn) { tradeBtn.textContent = 'Enter amount'; tradeBtn.disabled = true; }

  updateTradeLabels();
  const marketId = $('app').dataset.marketId;
  const collateral = $('app').dataset.collateral;
  if (_connectedAddress && marketId) {
    loadTradeBalance(marketId, collateral, 0n, 0n);
  }
}

function setTradeSide(side) {
  _tradeSide = side;
  _lastQuote = null;
  document.querySelectorAll('.trade-side button').forEach(b => {
    b.classList.toggle('active', b.dataset.side === side);
  });
  const tradeInput = $('tradeInput');
  if (tradeInput) { tradeInput.value = ''; }
  const tradeQuote = $('tradeQuote');
  if (tradeQuote) tradeQuote.textContent = '';
  const tradeBtn = $('tradeBtn');
  if (tradeBtn) { tradeBtn.textContent = 'Enter amount'; tradeBtn.disabled = true; }

  updateTradeLabels();
  const marketId = $('app').dataset.marketId;
  const collateral = $('app').dataset.collateral;
  if (_connectedAddress && marketId) {
    loadTradeBalance(marketId, collateral, 0n, 0n);
  }
}

function updateTradeLabels() {
  const label = $('tradeInputLabel');
  if (!label) return;
  const collateral = $('app').dataset.collateral;
  const isETH = !collateral || collateral === ethers.ZeroAddress;
  if (_tradeDir === 'buy') {
    label.textContent = isETH ? 'ETH' : getCollateralSymbol(collateral);
  } else {
    label.textContent = _tradeSide.toUpperCase() + ' shares';
  }
}

async function loadTradeBalance(marketId, collateral, userYes, userNo) {
  const balEl = $('tradeBalance');
  if (!balEl || !_connectedAddress) return;

  try {
    if (_tradeDir === 'buy') {
      const isETH = !collateral || collateral === ethers.ZeroAddress;
      if (isETH) {
        const bal = await _walletProvider.getBalance(_connectedAddress);
        balEl.textContent = 'Bal: ' + Number(ethers.formatEther(bal)).toFixed(4) + ' ETH';
        balEl.dataset.balance = bal.toString();
      } else {
        try {
          const token = new ethers.Contract(collateral, ERC20_ABI, _walletProvider);
          const [bal, dec] = await Promise.all([token.balanceOf(_connectedAddress), token.decimals()]);
          const sym = getCollateralSymbol(collateral);
          balEl.textContent = 'Bal: ' + Number(ethers.formatUnits(bal, dec)).toFixed(4) + ' ' + sym;
          balEl.dataset.balance = bal.toString();
        } catch {
          balEl.textContent = '';
          balEl.dataset.balance = '0';
        }
      }
    } else {
      // Sell: show share balance
      if (userYes > 0n || userNo > 0n) {
        const shares = _tradeSide === 'yes' ? userYes : userNo;
        balEl.textContent = 'Bal: ' + Number(ethers.formatEther(shares)).toFixed(4) + ' shares';
        balEl.dataset.balance = shares.toString();
      } else {
        // Fetch from chain
        const bal = await withRPC(async (rpc) => {
          const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
          const yesId = BigInt(marketId);
          const noId = BigInt(ethers.keccak256(ethers.solidityPacked(['string', 'uint256'], ['PMARKET:NO', yesId])));
          const shareId = _tradeSide === 'yes' ? yesId : noId;
          return await pamm.balanceOf(_connectedAddress, shareId);
        });
        balEl.textContent = 'Bal: ' + Number(ethers.formatEther(bal)).toFixed(4) + ' shares';
        balEl.dataset.balance = bal.toString();
      }
    }
  } catch {
    balEl.textContent = '';
  }
}

function setMaxAmount() {
  const balEl = $('tradeBalance');
  const input = $('tradeInput');
  if (!balEl || !input) return;
  const bal = BigInt(balEl.dataset.balance || '0');
  if (bal === 0n) return;
  // Leave small gas buffer for ETH buys
  const collateral = $('app').dataset.collateral;
  const isETH = !collateral || collateral === ethers.ZeroAddress;
  let amount = bal;
  if (_tradeDir === 'buy' && isETH && bal > ethers.parseEther('0.001')) {
    amount = bal - ethers.parseEther('0.001');
  }
  input.value = ethers.formatEther(amount);
  onTradeInput();
}

function setPct(pct) {
  const balEl = $('tradeBalance');
  const input = $('tradeInput');
  if (!balEl || !input) return;
  const bal = BigInt(balEl.dataset.balance || '0');
  if (bal === 0n) return;
  let amount = bal * BigInt(Math.round(pct * 10000)) / 10000n;
  // Gas buffer for max ETH buys
  const collateral = $('app').dataset.collateral;
  const isETH = !collateral || collateral === ethers.ZeroAddress;
  if (pct === 1 && _tradeDir === 'buy' && isETH && amount > ethers.parseEther('0.001')) {
    amount = amount - ethers.parseEther('0.001');
  }
  input.value = ethers.formatEther(amount);
  onTradeInput();
}

function onTradeInput() {
  clearTimeout(_quoteTimer);
  const input = $('tradeInput');
  const btn = $('tradeBtn');
  const quoteEl = $('tradeQuote');
  if (!input || !btn) return;

  const val = parseFloat(input.value);
  if (!val || val <= 0) {
    btn.textContent = 'Enter amount';
    btn.disabled = true;
    if (quoteEl) quoteEl.textContent = '';
    _lastQuote = null;
    return;
  }

  // Instant local estimate
  const rYes = BigInt($('app').dataset.ammYesReserve || '0');
  const rNo = BigInt($('app').dataset.ammNoReserve || '0');
  const amountWei = ethers.parseEther(val.toString());

  let estimated = 0n;
  if (_tradeDir === 'buy') {
    estimated = _tradeSide === 'yes' ? quoteBuyYes(amountWei, rYes, rNo) : quoteBuyNo(amountWei, rYes, rNo);
    if (quoteEl && estimated > 0n) {
      quoteEl.textContent = '~' + Number(ethers.formatEther(estimated)).toFixed(4) + ' ' + _tradeSide.toUpperCase() + ' shares';
    }
  } else {
    estimated = _tradeSide === 'yes' ? quoteSellYes(amountWei, rYes, rNo) : quoteSellNo(amountWei, rYes, rNo);
    const collateral = $('app').dataset.collateral;
    const collSym = getCollateralSymbol(collateral);
    if (quoteEl && estimated > 0n) {
      quoteEl.textContent = '~' + Number(ethers.formatEther(estimated)).toFixed(4) + ' ' + collSym;
    }
  }

  btn.textContent = _tradeDir === 'buy' ? 'Buy ' + _tradeSide.toUpperCase() : 'Sell ' + _tradeSide.toUpperCase();
  btn.disabled = false;

  // Debounced on-chain quote
  _quoteTimer = setTimeout(() => fetchOnchainQuote(amountWei), 400);
}

async function fetchOnchainQuote(amountWei) {
  const quoteEl = $('tradeQuote');
  const btn = $('tradeBtn');
  const marketId = $('app').dataset.marketId;
  const isLabeled = $('app').dataset.isLabeled === '1';
  if (!marketId || !quoteEl) return;

  try {
    const buyYes = _tradeSide === 'yes';

    if (isLabeled) {
      // Labeled markets: use Quoter contract for accurate sweep quotes
      await withRPC(async (rpc) => {
        const quoter = new ethers.Contract(CONTRACTS.QUOTER, QUOTER_ABI, rpc);
        if (_tradeDir === 'buy') {
          const result = await quoter.quoteBuyWithSweep(marketId, buyYes, amountWei, 9999, { gasLimit: 5000000 });
          const shares = BigInt(result.totalSharesOut);
          quoteEl.textContent = Number(ethers.formatEther(shares)).toFixed(4) + ' ' + _tradeSide.toUpperCase() + ' shares';
          _lastQuote = { marketId, dir: _tradeDir, side: _tradeSide, amount: amountWei, expectedOut: shares, ts: Date.now() };
        } else {
          const result = await quoter.quoteSellWithSweep(marketId, buyYes, amountWei, 1, { gasLimit: 5000000 });
          const collOut = BigInt(result.totalCollateralOut);
          const collateral = $('app').dataset.collateral;
          const collSym = getCollateralSymbol(collateral);
          quoteEl.textContent = Number(ethers.formatEther(collOut)).toFixed(4) + ' ' + collSym;
          _lastQuote = { marketId, dir: _tradeDir, side: _tradeSide, amount: amountWei, expectedOut: collOut, ts: Date.now() };
        }
        return true;
      });
    } else {
      // Legacy markets: fetch fresh reserves from chain (matching ethPM's fetchLegacyQuote)
      await withRPC(async (rpc) => {
        const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, rpc);
        const poolState = await pamm.getPoolState(BigInt(marketId), LEGACY_FEE_BPS);
        const rYes = poolState.rYes;
        const rNo = poolState.rNo;
        if (rYes === 0n || rNo === 0n) {
          if (quoteEl) quoteEl.textContent = 'No liquidity';
          _lastQuote = null;
          return;
        }
        // Update cached reserves
        $('app').dataset.ammYesReserve = rYes.toString();
        $('app').dataset.ammNoReserve = rNo.toString();
        const collateral = $('app').dataset.collateral;
        const collSym = getCollateralSymbol(collateral);
        if (_tradeDir === 'buy') {
          const shares = buyYes ? quoteBuyYes(amountWei, rYes, rNo, LEGACY_FEE_BPS) : quoteBuyNo(amountWei, rYes, rNo, LEGACY_FEE_BPS);
          if (quoteEl && shares > 0n) quoteEl.textContent = Number(ethers.formatEther(shares)).toFixed(4) + ' ' + _tradeSide.toUpperCase() + ' shares';
          _lastQuote = { marketId, dir: _tradeDir, side: _tradeSide, amount: amountWei, expectedOut: shares, ts: Date.now() };
        } else {
          const collOut = buyYes ? quoteSellYes(amountWei, rYes, rNo, LEGACY_FEE_BPS) : quoteSellNo(amountWei, rYes, rNo, LEGACY_FEE_BPS);
          if (quoteEl && collOut > 0n) quoteEl.textContent = Number(ethers.formatEther(collOut)).toFixed(4) + ' ' + collSym;
          _lastQuote = { marketId, dir: _tradeDir, side: _tradeSide, amount: amountWei, expectedOut: collOut, ts: Date.now() };
        }
        return true;
      });
    }

    if (btn) {
      btn.textContent = _tradeDir === 'buy' ? 'Buy ' + _tradeSide.toUpperCase() : 'Sell ' + _tradeSide.toUpperCase();
      btn.disabled = false;
    }
  } catch (e) {
    console.warn('Quote failed:', e.message);
    if (quoteEl) quoteEl.textContent = 'Quote failed';
    _lastQuote = null;
  }
}

// ==================== EXECUTE TRADE ====================

async function executeTrade() {
  if (_isTrading) return;
  const s = await connectWallet();
  if (!s) return;

  const btn = $('tradeBtn');
  const quoteEl = $('tradeQuote');
  const marketId = $('app').dataset.marketId;
  const collateral = $('app').dataset.collateral;
  const input = $('tradeInput');
  if (!btn || !marketId || !input) return;

  const val = parseFloat(input.value);
  if (!val || val <= 0) return;
  const amountWei = ethers.parseEther(val.toString());

  const isETH = !collateral || collateral === ethers.ZeroAddress;
  const buyYes = _tradeSide === 'yes';
  const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200); // 20 min
  const origText = btn.textContent;

  _isTrading = true;
  btn.disabled = true;

  const isLabeled = $('app').dataset.isLabeled === '1';

  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, s);

    if (isLabeled) {
      // ---- LABELED MARKETS: MASTER_ROUTER with buyWithSweep/sellWithSweep ----
      const router = new ethers.Contract(CONTRACTS.MASTER_ROUTER, MASTER_ROUTER_ABI, s);

      if (_tradeDir === 'buy') {
        let minSharesOut = 0n;
        if (_lastQuote && _lastQuote.marketId === marketId && _lastQuote.dir === 'buy' && (Date.now() - _lastQuote.ts) < 30000) {
          minSharesOut = _lastQuote.expectedOut * 99n / 100n;
        }

        if (!isETH) {
          btn.textContent = 'Checking approval...';
          const token = new ethers.Contract(collateral, ERC20_ABI, s);
          const allowance = await token.allowance(_connectedAddress, CONTRACTS.MASTER_ROUTER);
          if (allowance < amountWei) {
            btn.textContent = 'Approve in wallet...';
            const approveTx = await token.approve(CONTRACTS.MASTER_ROUTER, ethers.MaxUint256);
            btn.textContent = 'Confirming approval...';
            await approveTx.wait();
          }
        }

        btn.textContent = 'Confirm in wallet...';
        const tx = await router.buyWithSweep(
          marketId, buyYes, amountWei, minSharesOut, 9999,
          _connectedAddress, deadline,
          { value: isETH ? amountWei : 0n }
        );
        btn.textContent = 'Confirming...';
        await tx.wait();
        if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--green)">Buy confirmed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px">View tx</a>`;
        input.value = '';

      } else {
        btn.textContent = 'Checking approval...';
        const isOp = await pamm.isOperator(_connectedAddress, CONTRACTS.MASTER_ROUTER);
        if (!isOp) {
          btn.textContent = 'Approve operator...';
          const approveTx = await pamm.setOperator(CONTRACTS.MASTER_ROUTER, true);
          btn.textContent = 'Confirming approval...';
          await approveTx.wait();
          // Wait for state propagation after operator approval
          await new Promise(r => setTimeout(r, 1000));
        }
        let minCollOut = 0n;
        if (_lastQuote && _lastQuote.marketId === marketId && _lastQuote.dir === 'sell' && (Date.now() - _lastQuote.ts) < 30000) {
          minCollOut = _lastQuote.expectedOut * 95n / 100n; // 5% slippage buffer for sell
        }
        btn.textContent = 'Confirm in wallet...';
        const tx = await router.sellWithSweep(
          marketId, buyYes, amountWei, minCollOut, 1,
          _connectedAddress, deadline
        );
        btn.textContent = 'Confirming...';
        await tx.wait();
        if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--green)">Sell confirmed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px">View tx</a>`;
        input.value = '';
      }

    } else {
      // ---- LEGACY MARKETS: PM_ROUTER with buy/sell (30 bps fee) ----
      const pmRouter = new ethers.Contract(CONTRACTS.PM_ROUTER, PM_ROUTER_ABI, s);

      if (_tradeDir === 'buy') {
        let minSharesOut = 0n;
        if (_lastQuote && _lastQuote.marketId === marketId && _lastQuote.dir === 'buy' && (Date.now() - _lastQuote.ts) < 30000) {
          minSharesOut = _lastQuote.expectedOut * 99n / 100n;
        }

        if (!isETH) {
          btn.textContent = 'Checking approval...';
          const token = new ethers.Contract(collateral, ERC20_ABI, s);
          const allowance = await token.allowance(_connectedAddress, CONTRACTS.PM_ROUTER);
          if (allowance < amountWei) {
            btn.textContent = 'Approve in wallet...';
            const approveTx = await token.approve(CONTRACTS.PM_ROUTER, ethers.MaxUint256);
            btn.textContent = 'Confirming approval...';
            await approveTx.wait();
          }
        }

        btn.textContent = 'Confirm in wallet...';
        const tx = await pmRouter.buy(
          BigInt(marketId), buyYes, amountWei, minSharesOut,
          LEGACY_FEE_BPS, _connectedAddress, deadline,
          { value: isETH ? amountWei : 0n }
        );
        btn.textContent = 'Confirming...';
        await tx.wait();
        if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--green)">Buy confirmed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px">View tx</a>`;
        input.value = '';

      } else {
        btn.textContent = 'Checking approval...';
        const isOp = await pamm.isOperator(_connectedAddress, CONTRACTS.PM_ROUTER);
        if (!isOp) {
          btn.textContent = 'Approve operator...';
          const approveTx = await pamm.setOperator(CONTRACTS.PM_ROUTER, true);
          btn.textContent = 'Confirming approval...';
          await approveTx.wait();
          await new Promise(r => setTimeout(r, 1000));
        }
        let minCollOut = 0n;
        if (_lastQuote && _lastQuote.marketId === marketId && _lastQuote.dir === 'sell' && (Date.now() - _lastQuote.ts) < 30000) {
          minCollOut = _lastQuote.expectedOut * 95n / 100n;
        }
        btn.textContent = 'Confirm in wallet...';
        const tx = await pmRouter.sell(
          BigInt(marketId), buyYes, amountWei, minCollOut,
          LEGACY_FEE_BPS, _connectedAddress, deadline
        );
        btn.textContent = 'Confirming...';
        await tx.wait();
        if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--green)">Sell confirmed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px">View tx</a>`;
        input.value = '';
      }
    }

    // Refresh market data after trade
    setTimeout(() => renderMarketPage(marketId), 2000);

  } catch (e) {
    if (e.code === 'ACTION_REJECTED' || (e.message || '').includes('user rejected')) {
      if (quoteEl) quoteEl.textContent = 'Cancelled';
    } else {
      console.error('Trade failed:', e);
      if (quoteEl) quoteEl.textContent = 'Failed: ' + (e.shortMessage || e.reason || e.message || '').split('\n')[0].slice(0, 80);
    }
  } finally {
    btn.textContent = origText;
    btn.disabled = false;
    _isTrading = false;
  }
}

// ==================== RESOLUTION DISPLAY ====================

function buildResolutionSection(marketId, data) {
  const { resolved, outcome, resValue, resCond, resReady, condData, close, canClose, resolverAddr, isOurResolver, isLegacyResolver } = data;
  const resolverName = (isOurResolver || isLegacyResolver) ? 'Onchain Resolver' : `${resolverAddr.slice(0,6)}...${resolverAddr.slice(-4)}`;
  const resolverLink = `<a href="https://etherscan.io/address/${resolverAddr}" target="_blank" rel="noopener" onclick="event.stopPropagation()" style="color:inherit;text-decoration:underline;text-decoration-color:#0FF;">${resolverName}</a>`;

  // Determine status badge
  let statusText, statusClass;
  if (resolved) {
    const winner = outcome ? 'YES' : 'NO';
    statusText = `RESOLVED ${winner}`;
    statusClass = 'resolved';
  } else if (resReady && resCond) {
    statusText = 'READY';
    statusClass = 'ready';
  } else if (resReady && !resCond) {
    statusText = 'CLOSED';
    statusClass = 'ready';
  } else {
    statusText = 'PENDING';
    statusClass = 'pending';
  }

  let detailsHtml = '';

  if (resolved) {
    const winner = outcome ? 'YES' : 'NO';
    detailsHtml = `<div style="text-align:center;padding:12px;"><div style="font-size:24px;margin-bottom:8px;">${outcome ? '&#10003;' : '&#10007;'}</div><div style="font-weight:bold;color:${outcome ? 'var(--yes)' : 'var(--no)'}">${winner} WINS</div></div>`;
  } else if (condData) {
    detailsHtml = buildConditionDetails(marketId, data);
  } else {
    // No condition data - show basic preview
    detailsHtml = `<div class="resolve-condition" style="text-align:center;">`;
    if (resValue !== null) {
      detailsHtml += `Oracle value: <b>${Number(resValue).toLocaleString()}</b><br>`;
      detailsHtml += `Condition: <b style="color:${resCond ? 'var(--yes)' : 'var(--no)'}">${resCond ? 'TRUE' : 'FALSE'}</b>`;
    } else {
      detailsHtml += `<span style="opacity:0.5">Loading oracle data...</span>`;
    }
    detailsHtml += `</div>`;
    if (!resolved && resReady) {
      detailsHtml += `<button class="resolve-btn" id="resolveBtn" onclick="resolveMarket('${marketId}')">RESOLVE MARKET</button>`;
    }
  }

  return `
    <div class="resolve-section" id="resolveSection">
      <div class="resolve-toggle" id="resolveToggle" onclick="toggleResolveDetails()">
        <span id="resolveToggleLabel">${resolverLink}</span>
        <span class="resolve-toggle-status ${statusClass}" id="resolveToggleStatus">${statusText}</span>
      </div>
      <div class="resolve-details${resReady ? ' ready' : ''}" id="resolveDetails">
        ${detailsHtml}
      </div>
    </div>
  `;
}

function buildConditionDetails(marketId, data) {
  const { resValue, resCond, resReady, condData, close, canClose } = data;
  const value = resValue;
  const oracleAddr = condData.targetA;
  let callData = condData.callDataA;
  if (callData && typeof callData !== 'string') {
    try { callData = ethers.hexlify(callData); } catch { callData = ''; }
  }
  callData = callData || '';
  const opName = OPS[Number(condData.op)] || '?';

  const callDataLower = callData.toLowerCase();
  const isBalanceOfCall = callData.length >= 74 && callDataLower.slice(0, 10) === '0x70a08231';
  const isLatestAnswerCall = callData.length >= 10 && callDataLower.slice(0, 10) === '0x50d25bcd';
  const isTotalSupplyCall = callData.length >= 10 && callDataLower.slice(0, 10) === '0x18160ddd';
  const isETHBalanceCheck = oracleAddr && (!callData || callData === '0x' || callData.length < 10);
  const isAddressExistenceCheck = Number(condData.op) === 5 && Number(condData.threshold) === 0;

  // Determine decimals, prefix, suffix, oracleHtml
  let decimals = 8, prefix = '$', suffix = '', oracleHtml = '';

  if (isBalanceOfCall) {
    const accountAddr = '0x' + callData.slice(34, 74);
    decimals = 18;
    prefix = '';
    const accountName = ACCOUNT_NAMES[accountAddr.toLowerCase()] || `${accountAddr.slice(0,6)}...${accountAddr.slice(-4)}`;
    const tokenName = TOKEN_NAMES[oracleAddr.toLowerCase()] || `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
    const tokenLogo = TOKEN_LOGOS[oracleAddr.toLowerCase()] || '';
    const tokenColor = COLORS[tokenName?.toUpperCase()] || '#375BD2';
    suffix = ` ${tokenName}`;
    oracleHtml = `<a href="https://etherscan.io/address/${accountAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${tokenColor}" title="${accountAddr}">${accountName}</a>`;
    oracleHtml += ` <span style="opacity:0.5">bal on</span> `;
    oracleHtml += `<a href="https://etherscan.io/token/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${tokenColor}" title="${oracleAddr}">${tokenLogo}${tokenName}</a>`;
  } else if (isETHBalanceCheck) {
    // Could be ETH balance OR legacy token balance with non-standard format
    // Legacy markets store token addr in targetA with empty calldata
    const oracleLower = oracleAddr.toLowerCase();
    const knownTokenSym = TOKEN_NAMES[oracleLower];
    if (knownTokenSym) {
      // Legacy token balance market - oracleAddr is the token, targetB is the account
      const accountAddr = condData.targetB && condData.targetB !== ethers.ZeroAddress
        ? condData.targetB : oracleAddr;
      decimals = 18;
      prefix = '';
      suffix = ` ${knownTokenSym}`;
      const accountName = ACCOUNT_NAMES[accountAddr.toLowerCase()] || `${accountAddr.slice(0,6)}...${accountAddr.slice(-4)}`;
      const tokenLogo = TOKEN_LOGOS[oracleLower] || '';
      const tokenColor = COLORS[knownTokenSym.toUpperCase()] || '#375BD2';
      oracleHtml = `<a href="https://etherscan.io/address/${accountAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${tokenColor}" title="${accountAddr}">${accountName}</a>`;
      oracleHtml += ` <span style="opacity:0.5">bal on</span> `;
      oracleHtml += `<a href="https://etherscan.io/token/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:${tokenColor}" title="${oracleAddr}">${tokenLogo}${knownTokenSym}</a>`;
    } else {
      // ETH balance market
      decimals = 18;
      prefix = '';
      suffix = ' ETH';
      const shortAccount = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
      const ethLogo = TOKEN_LOGOS['eth'] || '';
      oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#627EEA" title="${oracleAddr}">${shortAccount}</a> <span style="opacity:0.5">${ethLogo}ETH bal</span>`;
    }
  } else if (isLatestAnswerCall) {
    decimals = 8;
    prefix = '$';
    suffix = '';
    const shortOracle = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
    const chainlinkLogo = TOKEN_LOGOS['0x514910771af9ca656af840dff83e8264ecf986ca'] || '';
    oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#375BD2" title="Chainlink price feed">${chainlinkLogo}${shortOracle}</a> <span style="opacity:0.5">price feed</span>`;
  } else if (isTotalSupplyCall) {
    decimals = 0;
    prefix = '';
    suffix = ' minted';
    const shortAddr = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
    const name = TOKEN_NAMES[oracleAddr.toLowerCase()] || shortAddr;
    const logo = TOKEN_LOGOS[oracleAddr.toLowerCase()] || '';
    oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#9945FF" title="${oracleAddr}">${logo}${name}</a> <span style="opacity:0.5">totalSupply</span>`;
  } else {
    // Unknown type
    const threshold = Number(condData.threshold);
    if (threshold > 1e15) { decimals = 18; prefix = ''; suffix = ' units'; }
    const shortOracle = `${oracleAddr.slice(0,6)}...${oracleAddr.slice(-4)}`;
    oracleHtml = `<a href="https://etherscan.io/address/${oracleAddr}" target="_blank" rel="noopener" style="color:inherit;text-decoration:underline;text-decoration-color:#666">${shortOracle}</a>`;
  }

  const now = Math.floor(Date.now() / 1000);
  const isClosed = close && close <= now;
  const deadlineText = isClosed
    ? '<span style="color:var(--yes)">Market closed</span>'
    : close ? `Closes ${fmtCountdown(close)}` : '';

  let conditionHtml;

  if (isAddressExistenceCheck) {
    // Special binary layout for address existence checks
    const rawValue = BigInt(value);
    const isSet = rawValue !== 0n;
    let valueDisplay;
    if (isSet && rawValue <= BigInt('0xffffffffffffffffffffffffffffffffffffffff')) {
      const addrHex = '0x' + rawValue.toString(16).padStart(40, '0');
      valueDisplay = `<a href="https://etherscan.io/address/${addrHex}" target="_blank" rel="noopener" style="color:var(--yes);text-decoration:underline">${addrHex.slice(0,6)}...${addrHex.slice(-4)}</a>`;
    } else if (isSet) {
      valueDisplay = `<span style="color:var(--yes)">${rawValue.toString()}</span>`;
    } else {
      valueDisplay = '<span style="color:var(--no);opacity:0.7">Not Set</span>';
    }
    const parsedCall = parseCalldata(callData, oracleAddr);
    let conditionLabel = 'Value';
    let functionDisplay = '';
    if (parsedCall.functionName === 'protocolFeeController') {
      conditionLabel = 'Protocol Fee Controller';
      functionDisplay = `<code style="font-size:10px;opacity:0.6;background:var(--surface);padding:2px 6px;border-radius:3px;">protocolFeeController()</code>`;
    } else if (parsedCall.parsed) {
      conditionLabel = parsedCall.parsed.replace(/<[^>]*>/g, '').replace(/\(\).*$/, '');
    }
    const statusIcon = isSet ? '&#10003;' : '&#9675;';
    const statusColor = isSet ? 'var(--yes)' : '#F50';
    const statusTextVal = isSet ? 'ENABLED' : 'NOT SET';
    conditionHtml = `
      <div class="resolve-condition" style="text-align:center;">
        <div style="font-size:10px;opacity:0.5;margin-bottom:4px;">${oracleHtml}</div>
        ${functionDisplay ? `<div style="margin-bottom:8px;">${functionDisplay}</div>` : ''}
        <div style="font-size:11px;opacity:0.6;margin-bottom:4px;">${conditionLabel}</div>
        <div style="font-size:32px;margin:8px 0;color:${statusColor}">${statusIcon}</div>
        <div style="font-weight:bold;color:${statusColor};margin-bottom:8px;">${statusTextVal}</div>
        <div style="font-size:12px;font-family:monospace;">${valueDisplay}</div>
      </div>
    `;
  } else {
    // Standard progress bar
    const valueFormatted = Number(value) / Math.pow(10, decimals);
    const thresholdFormatted = Number(condData.threshold) / Math.pow(10, decimals);
    const formatVal = (v) => {
      if (v >= 1e9) return (v / 1e9).toFixed(2) + 'B';
      if (v >= 1e6) return (v / 1e6).toFixed(2) + 'M';
      if (v >= 1e3) return (v / 1e3).toFixed(2) + 'K';
      if (v < 0.01 && v > 0) return v.toFixed(6);
      return v.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    };
    const progressPct = thresholdFormatted > 0
      ? Math.min(100, (valueFormatted / thresholdFormatted) * 100) : 0;
    const conditionVerb = Number(condData.op) >= 2 ? 'reaches' : 'falls below';
    conditionHtml = `
      <div class="resolve-condition">
        <div class="resolve-condition-target">${oracleHtml || 'Oracle value'}</div>
        <div style="margin-top:6px;">${conditionVerb} <span class="resolve-condition-thresh">${opName} ${prefix}${formatVal(thresholdFormatted)}${suffix}</span></div>
      </div>
      <div class="resolve-progress">
        <div class="resolve-progress-bar${resCond ? ' met' : ''}">
          <span class="filled">${'\u2588'.repeat(Math.round(progressPct / 5))}</span><span class="empty">${'\u2591'.repeat(20 - Math.round(progressPct / 5))}</span>
        </div>
        <div class="resolve-progress-text">
          <span><span class="resolve-condition-val">${prefix}${formatVal(valueFormatted)}${suffix}</span></span>
          <span>${progressPct.toFixed(1)}%</span>
        </div>
      </div>
    `;
  }

  // Build inspect panel
  const opNames = ['<', '>', '', '', '=', ''];
  let inspectHtml = `
    <div class="inspect-row"><span class="inspect-label">targetA</span><span class="inspect-value"><a href="https://etherscan.io/address/${condData.targetA}" target="_blank" rel="noopener">${condData.targetA}</a></span></div>
    <div class="inspect-row"><span class="inspect-label">targetB</span><span class="inspect-value">${condData.targetB === ethers.ZeroAddress ? '(none)' : `<a href="https://etherscan.io/address/${condData.targetB}" target="_blank" rel="noopener">${condData.targetB}</a>`}</span></div>
    <div class="inspect-row"><span class="inspect-label">op</span><span class="inspect-value">${condData.op} (${opNames[Number(condData.op)] || '?'})</span></div>
    <div class="inspect-row"><span class="inspect-label">isRatio</span><span class="inspect-value">${condData.isRatio}</span></div>
    <div class="inspect-row"><span class="inspect-label">threshold</span><span class="inspect-value">${condData.threshold.toString()}</span></div>
    ${formatCalldataHtml(condData.callDataA, condData.targetA, 'callDataA')}
    ${formatCalldataHtml(condData.callDataB, condData.targetB, 'callDataB')}
  `;

  return `
    ${conditionHtml}
    ${deadlineText ? `<div style="text-align:center;font-size:11px;margin-bottom:12px;font-family:monospace;opacity:0.8">[${deadlineText}]</div>` : ''}
    <button class="resolve-btn" id="resolveBtn" onclick="resolveMarket('${marketId}')" ${resReady ? '' : 'disabled'}>RESOLVE MARKET</button>
    <div class="resolve-hint">${resReady
      ? 'Condition met! Click to settle the market.'
      : isClosed ? 'Market closed - can resolve with current value' : 'Unlocks when threshold reached or market closes'}</div>
    <button class="inspect-toggle" onclick="toggleInspect()">&#9660; Inspect On-Chain Condition</button>
    <div class="inspect-panel" id="inspectPanel">${inspectHtml}</div>
  `;
}

function toggleResolveDetails() {
  const toggle = $('resolveToggle');
  const details = $('resolveDetails');
  if (toggle && details) {
    toggle.classList.toggle('expanded');
    details.classList.toggle('expanded');
  }
}

function toggleInspect() {
  const panel = $('inspectPanel');
  const toggle = panel?.previousElementSibling;
  if (panel) {
    const expanded = panel.classList.toggle('expanded');
    if (toggle) toggle.innerHTML = expanded ? '&#9650; Hide Condition Details' : '&#9660; Inspect On-Chain Condition';
  }
}

// ==================== RESOLVE & CLAIM ====================

async function resolveMarket(marketId) {
  const s = await connectWallet();
  if (!s) return;
  const btn = $('resolveBtn');
  if (!btn) return;
  const origText = btn.textContent;
  btn.textContent = 'Resolving...';
  btn.disabled = true;
  try {
    const resolverAddr = $('app').dataset.resolverAddr || CONTRACTS.RESOLVER;
    const isOurResolver = $('app').dataset.isOurResolver === '1';
    const resolverAbi = isOurResolver ? RESOLVER_ABI : LEGACY_RESOLVER_ABI;
    const resolver = new ethers.Contract(resolverAddr, resolverAbi, s);
    const tx = await resolver.resolveMarket(marketId);
    btn.textContent = 'Confirming...';
    await tx.wait();
    btn.textContent = 'Resolved!';
    setTimeout(() => renderMarketPage(marketId), 2000);
  } catch (e) {
    if (e.code === 'ACTION_REJECTED' || (e.message || '').includes('user rejected')) {
      btn.textContent = 'Cancelled';
    } else {
      btn.textContent = 'Failed';
    }
    setTimeout(() => { btn.textContent = origText; btn.disabled = false; }, 2000);
  }
}

async function claimWinnings(marketId) {
  const s = await connectWallet();
  if (!s) return;
  const btn = $('claimBtn');
  if (!btn) return;
  const origText = btn.textContent;
  btn.textContent = 'Claiming...';
  btn.disabled = true;
  try {
    const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, s);
    const tx = await pamm.claim(marketId, _connectedAddress);
    btn.textContent = 'Confirming...';
    await tx.wait();
    btn.textContent = 'Claimed!';
    setTimeout(() => renderMarketPage(marketId), 2000);
  } catch (e) {
    if (e.code === 'ACTION_REJECTED' || (e.message || '').includes('user rejected')) {
      btn.textContent = 'Cancelled';
    } else {
      btn.textContent = 'Failed';
    }
    setTimeout(() => { btn.textContent = origText; btn.disabled = false; }, 2000);
  }
}

async function resolveCustomMarket(marketId, outcomeYes) {
  const s = await connectWallet();
  if (!s) return;
  const btnId = outcomeYes ? 'resolveYesBtn' : 'resolveNoBtn';
  const btn = $(btnId);
  if (!btn) return;
  const origText = btn.textContent;
  btn.textContent = 'Resolving...';
  btn.disabled = true;
  // Disable the other button too
  const otherId = outcomeYes ? 'resolveNoBtn' : 'resolveYesBtn';
  const otherBtn = $(otherId);
  if (otherBtn) otherBtn.disabled = true;
  try {
    // For custom EOA resolvers, call PAMM.resolve directly
    // The PAMM allows the resolver address to call resolve(marketId, outcome)
    const pamm = new ethers.Contract(CONTRACTS.PAMM, [
      'function resolve(uint256 marketId, bool outcome)'
    ], s);
    const tx = await pamm.resolve(BigInt(marketId), outcomeYes);
    btn.textContent = 'Confirming...';
    await tx.wait();
    btn.textContent = outcomeYes ? 'Resolved YES!' : 'Resolved NO!';
    setTimeout(() => renderMarketPage(marketId), 2000);
  } catch (e) {
    if (e.code === 'ACTION_REJECTED' || (e.message || '').includes('user rejected')) {
      btn.textContent = 'Cancelled';
    } else {
      btn.textContent = 'Failed: ' + (e.shortMessage || e.reason || '').slice(0, 40);
    }
    setTimeout(() => { btn.textContent = origText; btn.disabled = false; if (otherBtn) otherBtn.disabled = false; }, 3000);
  }
}

// ==================== CREATE MARKET ====================

function openCreateModal() {
  $('createModal').classList.add('active');
  loadEthPrice();
  updateLiqSplit();
}
function closeCreateModal() {
  $('createModal').classList.remove('active');
}

function switchMarketType(type) {
  _currentMarketType = type;
  document.querySelectorAll('.market-type-tab').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.form-section').forEach(s => s.classList.remove('active'));
  const tabs = document.querySelectorAll('.market-type-tab');
  const idx = { price: 0, balance: 1, supply: 2, custom: 3 }[type] || 0;
  if (tabs[idx]) tabs[idx].classList.add('active');
  const formId = { price: 'priceForm', balance: 'balanceForm', supply: 'supplyForm', custom: 'customForm' }[type];
  const form = $(formId);
  if (form) form.classList.add('active');
}

async function loadEthPrice() {
  const el = $('livePrice');
  if (!el) return;
  el.textContent = '...';
  try {
    await withRPC(async rpc => {
      const chainlink = new ethers.Contract(CONTRACTS.CHAINLINK_ETH_USD, CHAINLINK_ABI, rpc);
      const price = await chainlink.latestAnswer();
      _currentEthPrice = Number(price) / 1e8;
      el.textContent = '$' + _currentEthPrice.toLocaleString('en-US', { maximumFractionDigits: 0 });
      return true;
    });
  } catch { el.textContent = '--'; }
}

function fmtTargetPrice() {
  const el = $('targetPrice');
  if (!el) return;
  const raw = el.value.replace(/[^0-9]/g, '');
  if (raw) el.value = Number(raw).toLocaleString();
}

function setPricePreset(pct) {
  if (!_currentEthPrice) return;
  const target = pct === 0 ? Math.round(_currentEthPrice) : Math.round(_currentEthPrice * (1 + pct / 100));
  $('targetPrice').value = target.toLocaleString();
  updatePricePreview();
}

function updatePricePreview() {
  const el = $('pricePreview');
  if (!el) return;
  const raw = ($('targetPrice').value || '').replace(/[^0-9]/g, '');
  const price = raw ? '$' + Number(raw).toLocaleString() : '$___';
  const dateStr = $('closeDate').value;
  const date = dateStr ? fmtDate(Math.floor(new Date(dateStr).getTime() / 1000)) : '___';
  el.innerHTML = `Will ETH hit <b>${price}</b> by <b>${date}</b>?`;
}

function setDatePreset(days, inputId) {
  const el = $(inputId);
  if (!el) return;
  const d = new Date(Date.now() + days * 86400000);
  d.setHours(23, 59, 0, 0);
  el.value = d.toISOString().slice(0, 16);
  el.dispatchEvent(new Event('input'));
}

function setBalanceType(type) {
  _balanceAssetType = type;
  document.querySelectorAll('.balance-type-btn').forEach(b => b.classList.remove('active'));
  if (type === 'eth') {
    document.querySelector('.balance-type-btn:first-child').classList.add('active');
    $('balTokenGroup').style.display = 'none';
  } else {
    document.querySelector('.balance-type-btn:last-child').classList.add('active');
    $('balTokenGroup').style.display = '';
  }
  updateBalPreview();
}

async function loadBalTokenInfo() {
  const addr = ($('balTokenAddr').value || '').trim();
  const hint = $('balTokenHint');
  if (!addr || addr.length < 42) { hint.textContent = ''; _balTokenData = { address: '', symbol: '', decimals: 18 }; return; }
  try {
    await withRPC(async rpc => {
      const token = new ethers.Contract(addr, ERC20_ABI, rpc);
      const [sym, dec] = await Promise.all([token.symbol(), token.decimals()]);
      _balTokenData = { address: addr, symbol: sym, decimals: Number(dec) };
      hint.textContent = sym + ' (' + Number(dec) + ' decimals)';
      return true;
    });
  } catch { hint.textContent = 'Could not load token info'; }
  updateBalPreview();
}

function updateBalPreview() {
  const el = $('balancePreview');
  if (!el) return;
  const addr = ($('balWalletAddr').value || '').trim();
  const short = addr.length >= 42 ? addr.slice(0, 6) + '...' + addr.slice(-4) : 'address';
  const threshold = $('balThreshold').value || '___';
  const asset = _balanceAssetType === 'eth' ? 'ETH' : (_balTokenData.symbol || 'tokens');
  const dateStr = $('balCloseDate').value;
  const date = dateStr ? fmtDate(Math.floor(new Date(dateStr).getTime() / 1000)) : '___';
  el.innerHTML = `Will <b>${short}</b> hold &ge; <b>${threshold} ${asset}</b> by <b>${date}</b>?`;
}

async function loadSupplyTokenInfo() {
  const addr = ($('supplyTokenAddr').value || '').trim();
  const hint = $('supplyTokenHint');
  if (!addr || addr.length < 42) { hint.textContent = ''; _supplyTokenData = { address: '', symbol: '', decimals: 18 }; return; }
  try {
    await withRPC(async rpc => {
      const token = new ethers.Contract(addr, ERC20_ABI, rpc);
      const [sym, dec, supply] = await Promise.all([token.symbol(), token.decimals(), token.totalSupply()]);
      _supplyTokenData = { address: addr, symbol: sym, decimals: Number(dec) };
      const fmtSupply = Number(ethers.formatUnits(supply, dec));
      hint.textContent = sym + ' | Current supply: ' + fmtSupply.toLocaleString();
      return true;
    });
  } catch { hint.textContent = 'Could not load token info'; }
  updateSupplyPreview();
}

function updateSupplyPreview() {
  const el = $('supplyPreview');
  if (!el) return;
  const sym = _supplyTokenData.symbol || 'token';
  const threshold = $('supplyThreshold').value || '___';
  const op = $('supplyOp').value;
  const verb = parseInt(op) >= 2 ? 'reach' : 'drop below';
  const dateStr = $('supplyCloseDate').value;
  const date = dateStr ? fmtDate(Math.floor(new Date(dateStr).getTime() / 1000)) : '___';
  el.innerHTML = `Will <b>${sym}</b> supply ${verb} <b>${Number(threshold).toLocaleString() || '___'}</b> by <b>${date}</b>?`;
}

function toggleAdvanced() {
  const sec = $('advSection');
  const open = sec.classList.toggle('active');
  const ch = $('advChevron');
  if (ch) ch.textContent = open ? '\u25BC' : '\u25B6';
}

function updateLiqSplit() {
  const total = parseFloat($('totalLiquidity').value) || 0;
  const vault = $('enableVault').checked ? (parseFloat($('vaultAmount').value) || 0) : 0;
  const bids = $('enableBids').checked ? (parseFloat($('bidsAmount').value) || 0) : 0;
  const amm = Math.max(0, total - vault - bids);

  // Show/hide vault and bids fields
  $('vaultFields').style.display = $('enableVault').checked ? '' : 'none';
  $('bidsFields').style.display = $('enableBids').checked ? '' : 'none';

  // Update split bar
  const bar = $('liqSplitBar');
  if (bar && total > 0) {
    const aPct = (amm / total * 100).toFixed(1);
    const vPct = (vault / total * 100).toFixed(1);
    const bPct = (bids / total * 100).toFixed(1);
    bar.innerHTML = `<div style="background:var(--fg);width:${aPct}%"></div><div style="background:var(--green);width:${vPct}%"></div><div style="background:var(--red);width:${bPct}%"></div>`;
  }

  $('liqLegAmm').textContent = amm.toFixed(3) + ' AMM';
  $('liqLegVault').textContent = vault.toFixed(3) + ' Vault';
  $('liqLegBids').textContent = bids.toFixed(3) + ' Bids';

  // Update presets
  document.querySelectorAll('.liq-preset').forEach(b => {
    b.classList.toggle('active', parseFloat(b.textContent) === total);
  });

  // Total cost
  const el = $('totalCostDisplay');
  if (el) el.textContent = 'Total: ' + total.toFixed(4) + ' ETH';
}

function setLiqPreset(val) {
  $('totalLiquidity').value = val;
  updateLiqSplit();
}

function getVaultParams() {
  if (!$('enableVault').checked) return null;
  const vaultAmount = parseFloat($('vaultAmount').value) || 0;
  if (vaultAmount <= 0) return null;
  const yesPct = parseInt($('vaultYesPct').value) || 0;
  const noPct = parseInt($('vaultNoPct').value) || 0;
  const collateralForVault = ethers.parseEther(vaultAmount.toFixed(18));
  const vaultYesShares = collateralForVault * BigInt(yesPct) / 100n;
  const vaultNoShares = collateralForVault * BigInt(noPct) / 100n;
  return { collateralForVault, vaultYesShares, vaultNoShares };
}

function getBidsParams() {
  if (!$('enableBids').checked) return null;
  const amount = parseFloat($('bidsAmount').value) || 0;
  if (amount <= 0) return null;
  const preset = $('bidSpread').value;
  const levels = BID_PRESETS[preset];
  if (!levels || !levels.length) return null;
  const totalWei = ethers.parseEther(amount.toString());
  const perLevel = totalWei / BigInt(levels.length);
  const remainder = totalWei % BigInt(levels.length);
  return levels.map((level, i) => ({
    buyYes: level.buyYes,
    priceInBps: BigInt(level.priceInBps),
    amount: i === 0 ? perLevel + remainder : perLevel,
    minShares: 0n
  }));
}

function parseMarketIdFromReceipt(receipt) {
  const sigs = [
    'MarketCreated(uint256,uint256,string,address,address,uint64,bool)',
    'MarketCreated(uint256,address,address)',
    'MarketCreated(uint256)'
  ];
  for (const log of receipt.logs) {
    try {
      for (const sig of sigs) {
        if (log.topics[0] === ethers.id(sig) && log.topics[1]) {
          return BigInt(log.topics[1]).toString();
        }
      }
    } catch {}
  }
  // Fallback: any log from PAMM
  for (const log of receipt.logs) {
    try {
      if (log.address.toLowerCase() === CONTRACTS.PAMM.toLowerCase() && log.topics[1]) {
        return BigInt(log.topics[1]).toString();
      }
    } catch {}
  }
  return null;
}

async function createMarket() {
  const s = await connectWallet();
  if (!s) return;

  const total = parseFloat($('totalLiquidity').value) || 0;
  if (total < 0.0001) { alert('Enter at least 0.0001 ETH liquidity'); return; }

  const vaultParams = getVaultParams();
  const bidsParams = getBidsParams();
  const vaultAmt = vaultParams ? parseFloat($('vaultAmount').value) || 0 : 0;
  const bidsAmt = bidsParams ? parseFloat($('bidsAmount').value) || 0 : 0;
  const ammAmt = Math.max(0, total - vaultAmt - bidsAmt);
  const collateralForLP = ethers.parseEther(ammAmt.toFixed(18));
  const totalWei = ethers.parseEther(total.toFixed(18));
  const deadline = Math.floor(Date.now() / 1000) + 3600;

  if (_currentMarketType === 'price') {
    await createPriceMarket(collateralForLP, totalWei, deadline, vaultParams, bidsParams);
  } else if (_currentMarketType === 'balance') {
    await createBalanceMarket(collateralForLP, totalWei, deadline, vaultParams, bidsParams);
  } else if (_currentMarketType === 'supply') {
    await createSupplyMarket(collateralForLP, totalWei, deadline, vaultParams, bidsParams);
  } else if (_currentMarketType === 'custom') {
    await createCustomMarket(collateralForLP, totalWei, deadline, vaultParams, bidsParams);
  }
}

async function createPriceMarket(collateralForLP, totalWei, deadline, vaultParams, bidsParams) {
  const raw = ($('targetPrice').value || '').replace(/[^0-9]/g, '');
  const targetPrice = parseInt(raw);
  const closeDateStr = $('closeDate').value;
  if (!targetPrice || targetPrice < 1) { alert('Enter a valid target price'); return; }
  if (!closeDateStr) { alert('Select a close date'); return; }

  const closeTimestamp = Math.floor(new Date(closeDateStr).getTime() / 1000);
  if (closeTimestamp < Math.floor(Date.now() / 1000) + 3600) { alert('Close date must be at least 1 hour in the future'); return; }

  const threshold = BigInt(targetPrice) * BigInt(1e8); // Chainlink 8 decimals
  const description = `PRICE|ETH|USD|3|${targetPrice}|${closeTimestamp}`;

  const btn = $('createBtn');
  btn.disabled = true; btn.textContent = 'Creating...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, _signer);
    let tx;
    const hasVault = !!vaultParams;
    const hasBids = bidsParams && bidsParams.length > 0;
    const buy = { buyYes: false, collateralForBuy: 0n };

    if (hasVault && hasBids) {
      tx = await bootstrapper.bootstrapPriceMarketWithVaultAndBids(
        description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
        collateralForLP, _connectedAddress, deadline,
        CONTRACTS.CHAINLINK_ETH_USD, OP.GTE, threshold,
        vaultParams, buy, bidsParams, { value: totalWei }
      );
    } else if (hasVault) {
      tx = await bootstrapper.bootstrapPriceMarketWithVault(
        description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
        collateralForLP, _connectedAddress, deadline,
        CONTRACTS.CHAINLINK_ETH_USD, OP.GTE, threshold,
        vaultParams, buy, { value: totalWei }
      );
    } else if (hasBids) {
      tx = await bootstrapper.bootstrapPriceMarketWithBids(
        description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
        collateralForLP, _connectedAddress, deadline,
        CONTRACTS.CHAINLINK_ETH_USD, OP.GTE, threshold,
        bidsParams, { value: totalWei }
      );
    } else {
      tx = await bootstrapper.bootstrapPriceMarket(
        description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
        collateralForLP, _connectedAddress, deadline,
        CONTRACTS.CHAINLINK_ETH_USD, OP.GTE, threshold,
        { value: collateralForLP }
      );
    }

    btn.textContent = 'Confirming...';
    const receipt = await tx.wait();
    const marketId = parseMarketIdFromReceipt(receipt);
    closeCreateModal();
    alert('Market created!' + (marketId ? ' Navigating...' : ''));
    if (marketId) { location.hash = '#' + marketId; }
    else { renderGallery(); }
  } catch (e) {
    if (e.code === 'ACTION_REJECTED' || (e.message || '').includes('user rejected')) {
      btn.textContent = 'Cancelled';
    } else {
      console.error('Create market failed:', e);
      alert('Failed: ' + (e.shortMessage || e.reason || e.message || '').split('\n')[0].slice(0, 120));
    }
    setTimeout(() => { btn.disabled = false; btn.textContent = 'Create Market'; }, 2000);
  }
}

async function createBalanceMarket(collateralForLP, totalWei, deadline, vaultParams, bidsParams) {
  const walletAddr = ($('balWalletAddr').value || '').trim();
  const threshold = parseFloat($('balThreshold').value);
  const closeDateStr = $('balCloseDate').value;

  if (!walletAddr || !ethers.isAddress(walletAddr)) { alert('Enter a valid wallet address'); return; }
  if (!threshold || threshold <= 0) { alert('Enter a valid threshold'); return; }
  if (!closeDateStr) { alert('Select a close date'); return; }

  const closeTimestamp = Math.floor(new Date(closeDateStr).getTime() / 1000);
  if (closeTimestamp < Math.floor(Date.now() / 1000) + 3600) { alert('Close date must be at least 1 hour in the future'); return; }

  const btn = $('createBtn');
  btn.disabled = true; btn.textContent = 'Creating...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, _signer);
    let tx;
    const hasVault = !!vaultParams;
    const hasBids = bidsParams && bidsParams.length > 0;
    const buy = { buyYes: false, collateralForBuy: 0n };

    if (_balanceAssetType === 'eth') {
      const thresholdWei = ethers.parseEther(threshold.toString());
      const description = `ETHBAL|${walletAddr}|3|${threshold}|${closeTimestamp}`;

      if (hasVault && hasBids) {
        tx = await bootstrapper.bootstrapETHBalanceMarketWithVaultAndBids(
          description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
          collateralForLP, _connectedAddress, deadline, walletAddr, OP.GTE, thresholdWei,
          vaultParams, buy, bidsParams, { value: totalWei }
        );
      } else if (hasVault) {
        tx = await bootstrapper.bootstrapETHBalanceMarketWithVault(
          description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
          collateralForLP, _connectedAddress, deadline, walletAddr, OP.GTE, thresholdWei,
          vaultParams, buy, { value: totalWei }
        );
      } else {
        tx = await bootstrapper.bootstrapETHBalanceMarket(
          description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
          collateralForLP, _connectedAddress, deadline, walletAddr, OP.GTE, thresholdWei,
          { value: collateralForLP }
        );
      }
    } else {
      const tokenAddr = _balTokenData.address || ($('balTokenAddr').value || '').trim();
      if (!tokenAddr || !ethers.isAddress(tokenAddr)) { alert('Enter a valid token address'); btn.disabled = false; btn.textContent = 'Create Market'; return; }
      const decimals = _balTokenData.decimals || 18;
      const thresholdUnits = ethers.parseUnits(threshold.toString(), decimals);
      const description = `TOKBAL|${tokenAddr}|${walletAddr}|3|${threshold}|${closeTimestamp}`;

      if (hasVault && hasBids) {
        tx = await bootstrapper.bootstrapTokenBalanceMarketWithVaultAndBids(
          description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
          collateralForLP, _connectedAddress, deadline, tokenAddr, walletAddr, OP.GTE, thresholdUnits,
          vaultParams, buy, bidsParams, { value: totalWei }
        );
      } else if (hasVault) {
        tx = await bootstrapper.bootstrapTokenBalanceMarketWithVault(
          description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
          collateralForLP, _connectedAddress, deadline, tokenAddr, walletAddr, OP.GTE, thresholdUnits,
          vaultParams, buy, { value: totalWei }
        );
      } else {
        tx = await bootstrapper.bootstrapTokenBalanceMarket(
          description, ethers.ZeroAddress, closeTimestamp, CONTRACTS.PM_FEE_HOOK,
          collateralForLP, _connectedAddress, deadline, tokenAddr, walletAddr, OP.GTE, thresholdUnits,
          { value: collateralForLP }
        );
      }
    }

    btn.textContent = 'Confirming...';
    const receipt = await tx.wait();
    const marketId = parseMarketIdFromReceipt(receipt);
    closeCreateModal();
    alert('Market created!');
    if (marketId) { location.hash = '#' + marketId; }
    else { renderGallery(); }
  } catch (e) {
    if (e.code === 'ACTION_REJECTED' || (e.message || '').includes('user rejected')) {
      btn.textContent = 'Cancelled';
    } else {
      console.error('Create market failed:', e);
      alert('Failed: ' + (e.shortMessage || e.reason || e.message || '').split('\n')[0].slice(0, 120));
    }
    setTimeout(() => { btn.disabled = false; btn.textContent = 'Create Market'; }, 2000);
  }
}

async function createSupplyMarket(collateralForLP, totalWei, deadline, vaultParams, bidsParams) {
  const tokenAddr = (_supplyTokenData.address || $('supplyTokenAddr').value || '').trim();
  const threshold = parseFloat($('supplyThreshold').value);
  const closeDateStr = $('supplyCloseDate').value;
  const op = parseInt($('supplyOp').value);

  if (!tokenAddr || !ethers.isAddress(tokenAddr)) { alert('Enter a valid token address'); return; }
  if (!threshold || threshold <= 0) { alert('Enter a valid threshold'); return; }
  if (!closeDateStr) { alert('Select a close date'); return; }

  const closeTimestamp = Math.floor(new Date(closeDateStr).getTime() / 1000);
  if (closeTimestamp < Math.floor(Date.now() / 1000) + 3600) { alert('Close date must be at least 1 hour in the future'); return; }

  const decimals = _supplyTokenData.decimals || 18;
  const sym = _supplyTokenData.symbol || 'TOKEN';
  const thresholdUnits = ethers.parseUnits(threshold.toString(), decimals);
  const description = `SUPPLY|${tokenAddr}|${op}|${threshold}|${closeTimestamp}`;

  // totalSupply() calldata
  const iface = new ethers.Interface(ERC20_ABI);
  const callData = iface.encodeFunctionData('totalSupply');

  const btn = $('createBtn');
  btn.disabled = true; btn.textContent = 'Creating...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, _signer);
    let tx;
    const hasVault = !!vaultParams;
    const hasBids = bidsParams && bidsParams.length > 0;
    const buy = { buyYes: false, collateralForBuy: 0n };

    if (hasVault && hasBids) {
      tx = await bootstrapper.bootstrapWithConditionAndVaultAndBids(
        description, ethers.ZeroAddress, closeTimestamp, true, CONTRACTS.PM_FEE_HOOK,
        collateralForLP, _connectedAddress, deadline,
        tokenAddr, callData, op, thresholdUnits,
        vaultParams, buy, bidsParams, { value: totalWei }
      );
    } else if (hasVault) {
      tx = await bootstrapper.bootstrapWithConditionAndVault(
        description, ethers.ZeroAddress, closeTimestamp, true, CONTRACTS.PM_FEE_HOOK,
        collateralForLP, _connectedAddress, deadline,
        tokenAddr, callData, op, thresholdUnits,
        vaultParams, buy, { value: totalWei }
      );
    } else {
      tx = await bootstrapper.bootstrapWithCondition(
        description, ethers.ZeroAddress, closeTimestamp, true, CONTRACTS.PM_FEE_HOOK,
        collateralForLP, false, 0n, 0n, _connectedAddress, deadline,
        tokenAddr, callData, op, thresholdUnits,
        { value: collateralForLP }
      );
    }

    btn.textContent = 'Confirming...';
    const receipt = await tx.wait();
    const marketId = parseMarketIdFromReceipt(receipt);
    closeCreateModal();
    alert('Market created!');
    if (marketId) { location.hash = '#' + marketId; }
    else { renderGallery(); }
  } catch (e) {
    if (e.code === 'ACTION_REJECTED' || (e.message || '').includes('user rejected')) {
      btn.textContent = 'Cancelled';
    } else {
      console.error('Create market failed:', e);
      alert('Failed: ' + (e.shortMessage || e.reason || e.message || '').split('\n')[0].slice(0, 120));
    }
    setTimeout(() => { btn.disabled = false; btn.textContent = 'Create Market'; }, 2000);
  }
}

// ==================== CUSTOM MARKET ====================

function updateCustomPreview() {
  const el = $('customPreview');
  if (!el) return;
  const q = ($('customQuestion').value || '').trim();
  const dateStr = $('customCloseDate').value;
  const date = dateStr ? fmtDate(Math.floor(new Date(dateStr).getTime() / 1000)) : '___';
  if (q) {
    el.innerHTML = `<b>${escText(q)}</b> (closes <b>${date}</b>)`;
  } else {
    el.innerHTML = 'Custom Y/N market with your chosen resolver';
  }
}

async function createCustomMarket(collateralForLP, totalWei, deadline, vaultParams, bidsParams) {
  const question = ($('customQuestion').value || '').trim();
  const resolverAddr = ($('customResolver').value || '').trim();
  const canClose = $('customCanClose').checked;
  const closeDateStr = $('customCloseDate').value;

  if (!question) { alert('Enter a question'); return; }
  if (!resolverAddr || !ethers.isAddress(resolverAddr)) { alert('Enter a valid resolver address'); return; }
  if (!closeDateStr) { alert('Select a close date'); return; }

  const closeTimestamp = Math.floor(new Date(closeDateStr).getTime() / 1000);
  if (closeTimestamp < Math.floor(Date.now() / 1000) + 3600) { alert('Close date must be at least 1 hour in the future'); return; }

  const description = question;

  const btn = $('createBtn');
  btn.disabled = true; btn.textContent = 'Creating...';

  try {
    const bootstrapper = new ethers.Contract(CONTRACTS.BOOTSTRAPPER, BOOTSTRAPPER_ABI, _signer);
    let tx;
    const hasVault = !!vaultParams;
    const hasBids = bidsParams && bidsParams.length > 0;
    const buy = { buyYes: false, collateralForBuy: 0n };

    if (hasVault && hasBids) {
      tx = await bootstrapper.bootstrapMarketWithVaultAndBids(
        description, resolverAddr, ethers.ZeroAddress, closeTimestamp, canClose, CONTRACTS.PM_FEE_HOOK,
        collateralForLP, _connectedAddress, deadline,
        vaultParams, buy, bidsParams, { value: totalWei }
      );
    } else if (hasVault) {
      tx = await bootstrapper.bootstrapMarketWithVault(
        description, resolverAddr, ethers.ZeroAddress, closeTimestamp, canClose, CONTRACTS.PM_FEE_HOOK,
        collateralForLP, _connectedAddress, deadline,
        vaultParams, buy, { value: totalWei }
      );
    } else {
      tx = await bootstrapper.bootstrapMarket(
        description, resolverAddr, ethers.ZeroAddress, closeTimestamp, canClose, CONTRACTS.PM_FEE_HOOK,
        collateralForLP, false, 0n, 0n, _connectedAddress, deadline,
        { value: collateralForLP }
      );
    }

    btn.textContent = 'Confirming...';
    const receipt = await tx.wait();
    const marketId = parseMarketIdFromReceipt(receipt);
    closeCreateModal();
    alert('Market created!' + (marketId ? ' Navigating...' : ''));
    if (marketId) { location.hash = '#' + marketId; }
    else { renderGallery(); }
  } catch (e) {
    if (e.code === 'ACTION_REJECTED' || (e.message || '').includes('user rejected')) {
      btn.textContent = 'Cancelled';
    } else {
      console.error('Create market failed:', e);
      alert('Failed: ' + (e.shortMessage || e.reason || e.message || '').split('\n')[0].slice(0, 120));
    }
    setTimeout(() => { btn.disabled = false; btn.textContent = 'Create Market'; }, 2000);
  }
}

// ==================== LP MODAL ====================

function openLPModal(marketId) {
  const m = markets.find(x => x.marketId === marketId);
  $('lpMarketName').textContent = m ? m.question : 'Market #' + marketId.slice(0, 8) + '...';
  const collateral = $('app').dataset.collateral;
  const isETH = !collateral || collateral === ethers.ZeroAddress;
  $('lpAmountLabel').textContent = 'Amount (' + (isETH ? 'ETH' : getCollateralSymbol(collateral)) + ')';
  const isLabeled = $('app').dataset.isLabeled === '1';
  // Legacy markets: hide all sliders, show simple hint
  const allocSection = $('lpAllocSection');
  const legacyHint = $('lpLegacyHint');
  if (isLabeled) {
    if (allocSection) allocSection.style.display = '';
    if (legacyHint) legacyHint.style.display = 'none';
  } else {
    if (allocSection) allocSection.style.display = 'none';
    if (legacyHint) legacyHint.style.display = '';
    $('lpAmmSlider').value = 100;
    $('lpYesSlider').value = 0;
    $('lpNoSlider').value = 0;
  }
  $('lpModal').classList.add('active');
  $('lpModal').dataset.marketId = marketId;
  $('lpModal').dataset.isLabeled = isLabeled ? '1' : '0';
  updateLPAlloc();
}

function closeLPModal() {
  $('lpModal').classList.remove('active');
}

function updateLPAlloc() {
  const amm = parseInt($('lpAmmSlider').value) || 0;
  const yes = parseInt($('lpYesSlider').value) || 0;
  const no = parseInt($('lpNoSlider').value) || 0;
  const total = amm + yes + no || 1;
  $('lpAmmPct').textContent = Math.round(amm / total * 100) + '%';
  $('lpYesPct').textContent = Math.round(yes / total * 100) + '%';
  $('lpNoPct').textContent = Math.round(no / total * 100) + '%';
}

async function provideLiquidity() {
  const s = await connectWallet();
  if (!s) return;

  const marketId = $('lpModal').dataset.marketId;
  const amount = parseFloat($('lpAmount').value) || 0;
  if (!marketId || amount <= 0) { alert('Enter an amount'); return; }

  const amountWei = ethers.parseEther(amount.toString());
  const ammVal = parseInt($('lpAmmSlider').value) || 0;
  const yesVal = parseInt($('lpYesSlider').value) || 0;
  const noVal = parseInt($('lpNoSlider').value) || 0;
  const total = ammVal + yesVal + noVal || 1;

  const ammWei = amountWei * BigInt(ammVal) / BigInt(total);
  const yesWei = amountWei * BigInt(yesVal) / BigInt(total);
  const noWei = amountWei - ammWei - yesWei; // remainder goes to NO vault

  const btn = $('lpBtn');
  btn.disabled = true; btn.textContent = 'Providing...';
  const isLabeled = $('lpModal').dataset.isLabeled === '1';

  try {
    const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

    if (!isLabeled) {
      // Legacy markets: AMM only via PAMM.splitAndAddLiquidity
      btn.textContent = 'Adding AMM LP...';
      const pamm = new ethers.Contract(CONTRACTS.PAMM, PAMM_ABI, _signer);
      const collateral = $('app').dataset.collateral;
      const isETH = !collateral || collateral === ethers.ZeroAddress;
      if (!isETH) {
        const token = new ethers.Contract(collateral, ERC20_ABI, _signer);
        const allowance = await token.allowance(_connectedAddress, CONTRACTS.PAMM);
        if (allowance < amountWei) {
          btn.textContent = 'Approve in wallet...';
          const approveTx = await token.approve(CONTRACTS.PAMM, ethers.MaxUint256);
          await approveTx.wait();
        }
      }
      btn.textContent = 'Confirm in wallet...';
      const tx = await pamm.splitAndAddLiquidity(
        BigInt(marketId), amountWei, LEGACY_FEE_BPS, 0, 0, 0, _connectedAddress, deadline,
        isETH ? { value: amountWei } : {}
      );
      await tx.wait();
    } else {
      // Labeled markets: hook router with AMM + optional vaults
      const hookRouter = new ethers.Contract(CONTRACTS.PM_HOOK_ROUTER, PM_HOOK_ROUTER_ABI, _signer);
      const txs = [];

      if (ammWei > 0n) {
        btn.textContent = 'Adding AMM LP...';
        const tx = await hookRouter.addLiquidity(
          marketId, ethers.ZeroAddress, ammWei, CONTRACTS.PM_FEE_HOOK,
          0, 0, 0, _connectedAddress, deadline, { value: ammWei }
        );
        txs.push(tx.wait());
      }
      if (yesWei > 0n) {
        btn.textContent = 'Adding YES Vault...';
        const tx = await hookRouter.depositToVault(
          marketId, ethers.ZeroAddress, yesWei, true, _connectedAddress, { value: yesWei }
        );
        txs.push(tx.wait());
      }
      if (noWei > 0n) {
        btn.textContent = 'Adding NO Vault...';
        const tx = await hookRouter.depositToVault(
          marketId, ethers.ZeroAddress, noWei, false, _connectedAddress, { value: noWei }
        );
        txs.push(tx.wait());
      }
      await Promise.all(txs);
    }

    closeLPModal();
    alert('Liquidity provided!');
    renderMarketPage(marketId);
  } catch (e) {
    if (e.code === 'ACTION_REJECTED' || (e.message || '').includes('user rejected')) {
      btn.textContent = 'Cancelled';
    } else {
      console.error('LP failed:', e);
      btn.textContent = 'Failed';
      alert('Failed: ' + (e.shortMessage || e.reason || e.message || '').split('\n')[0].slice(0, 120));
    }
  } finally {
    setTimeout(() => { btn.disabled = false; btn.textContent = 'Provide Liquidity'; }, 2000);
  }
}

// ==================== INIT ====================

tryAutoConnect();
route();
</script>
<footer class="site-footer">
  <a href="../">Swap</a> &middot; <a href="../domains/">Domains</a> &middot; <a href="../dao/">DAO</a> &middot; <a href="../coin/">Coin</a> &middot; <a href="../orderbook/">Orderbook</a> &middot; <a href="../lp/">LP</a> &middot; built by <a href="https://opensea.io/collection/zorgz" target="_blank" rel="noopener"><svg width="14" height="14" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin:0 2px;image-rendering:pixelated"><rect width="16" height="16" fill="#0a0a0a"/><rect x="3" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="5" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="10" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="12" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="4" y="4" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="5" width="10" height="1" fill="#e8e8e0"/><rect x="2" y="6" width="12" height="3" fill="#e8e8e0"/><rect x="3" y="9" width="10" height="1" fill="#e8e8e0"/><rect x="4" y="10" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="10" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="5" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="9" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="2" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="7" y="12" width="2" height="1" fill="#e8e8e0"/><rect x="11" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="1" y="13" width="2" height="1" fill="#e8e8e0"/><rect x="13" y="13" width="2" height="1" fill="#e8e8e0"/></svg></a><a href="../dao/#/dao/1/0x5E58BA0e06ED0F5558f83bE732a4b899a674053E">zOrg</a> &middot; <a href="https://x.com/z_fi_" target="_blank" rel="noopener" title="X"><svg width="14" height="14" viewBox="0 0 300 300.251" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;fill:currentColor"><path d="M178.57 127.15 290.27 0h-26.46l-97.03 110.38L89.34 0H0l117.13 166.93L0 300.25h26.46l102.4-116.59 81.8 116.59h89.34M36.01 19.54H76.66l187.13 262.13h-40.66"/></svg></a>
  <div style="margin-top:8px;letter-spacing:1px"><a href="https://github.com/z-fi/zFi" target="_blank" rel="noopener" style="text-decoration:none;color:inherit">zfi.wei</a></div>
  <div class="tagline" style="margin-top:4px;font-size:12px;letter-spacing:0.5px;font-style:italic">the most secure-by-default exchange that does everything onchain</div>
  <div style="margin-top:2px;font-size:11px;letter-spacing:0.5px;opacity:0.5">powered by $zorg the governance reward token of the zfi stack</div>
  <div style="margin-top:2px;font-size:11px;opacity:0.5"><a href="https://etherscan.io/token/0x00a6bA94BBb5474725515De88fE04F854f2dCb12" target="_blank" rel="noopener" style="color:inherit">0x00a6bA94BBb5474725515De88fE04F854f2dCb12</a></div>
</footer>
</body>
</html>
