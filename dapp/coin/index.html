<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>COIN</title>
<meta property="og:title" content="COIN">
<meta property="og:description" content="Trade coins on zFi - the most secure-by-default exchange">
<meta property="og:type" content="website">
<meta property="og:url" content="">
<meta property="og:image" content="">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="COIN">
<meta name="twitter:description" content="Trade coins on zFi - the most secure-by-default exchange">
<meta name="twitter:image" content="">
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 400 400' width='400' height='400'%3E%3Crect width='400' height='400' fill='%23000'/%3E%3CclipPath id='frame'%3E%3Crect width='400' height='400'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23frame)'%3E%3Cpath d='M-60-20L460-20L460 90L80 310L460 310L460 420L-60 420L-60 310L320 90L-60 90Z' fill='white'/%3E%3C/g%3E%3C/svg%3E" type="image/svg+xml">
<script>
(function(){var d=localStorage.getItem('dark');if(d==='1'||(d===null&&matchMedia('(prefers-color-scheme:dark)').matches))document.documentElement.classList.add('dark')})();
</script>
<style>
.zorg-bg{fill:#fff}.zorg-fg{fill:#000}
.dark .zorg-bg{fill:#000}.dark .zorg-fg{fill:#fff}
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
:root {
  --bg:#fff;--fg:#000;--fg-muted:#666;--fg-dim:#999;
  --border:#000;--border-muted:#ddd;
  --surface:#f9f9f9;--surface-hover:#f5f5f5;
  --btn-bg:#000;--btn-fg:#fff;--btn-hover:#333;
  --btn-dis-bg:transparent;--btn-dis-border:#ccc;--btn-dis-fg:#999;
  --status-error:#fff0f0;--status-success:#f0fff0;
  --link-fg:inherit;
  --modal-overlay:rgba(0,0,0,0.8);--modal-bg:#fff;--modal-border:#000;
  --green:#22c55e;--red:#ef4444;
}
.dark {
  --bg:#0a0a0a;--fg:#e8e8e0;--fg-muted:#888;--fg-dim:#666;
  --border:#333;--border-muted:#333;
  --surface:#111;--surface-hover:#151515;
  --btn-bg:#e8e8e0;--btn-fg:#0a0a0a;--btn-hover:#ccc;
  --btn-dis-bg:transparent;--btn-dis-border:#444;--btn-dis-fg:#666;
  --status-error:#1a0000;--status-success:#001a00;
  --link-fg:#e8e8e0;
  --modal-overlay:rgba(0,0,0,0.85);--modal-bg:#111;--modal-border:#333;
  --green:#22c55e;--red:#ef4444;
}
body {
  font-family:Helvetica,Arial,sans-serif;
  background:var(--bg);color:var(--fg);
  min-height:100vh;padding:60px 20px 20px;
  max-width:720px;margin:0 auto;
}
a { color:var(--link-fg); }
button {
  font-family:inherit;cursor:pointer;border:none;border-radius:0;
  background:var(--btn-bg);color:var(--btn-fg);
  padding:10px 20px;font-size:13px;font-weight:600;letter-spacing:0.05em;
}
button:hover { background:var(--btn-hover); }
button:disabled { background:var(--btn-dis-bg);border:1px solid var(--btn-dis-border);color:var(--btn-dis-fg);cursor:not-allowed; }
input {
  font-family:inherit;font-size:14px;background:transparent;color:var(--fg);
  border:none;border-bottom:1.5px solid var(--border);outline:none;
  padding:8px 0;width:100%;
}
.header {
  display:flex;justify-content:space-between;align-items:center;margin-bottom:24px;
}
.header h1 {
  font-size:14px;font-weight:400;letter-spacing:0.1em;text-transform:uppercase;
}
.nav-link { font-size:12px;color:var(--fg-muted);text-decoration:none; }
.nav-sep { margin:0 4px;font-size:10px;vertical-align:1px;color:var(--fg-muted);opacity:0.5; }
.nav-link:hover { color:var(--fg); }
.back-link { font-size:12px;color:var(--fg-muted);text-decoration:none;margin-bottom:16px;display:inline-block; }
.back-link:hover { color:var(--fg); }
.coin-search {
  width:100%;padding:8px 0;font-size:13px;border:none;border-bottom:1px solid var(--border);
  outline:none;background:transparent;color:var(--fg);margin-bottom:16px;
}
.coin-search::placeholder { color:var(--input-ph); }

/* Gallery */
.coin-grid {
  display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:16px;
}
.coin-card {
  border:1px solid var(--border);padding:16px;
  cursor:pointer;transition:background 0.15s, transform 0.15s;text-decoration:none;color:var(--fg);display:block;
}
.coin-card:hover { background:var(--surface-hover);transform:translateY(-1px); }
.coin-card-head { display:flex;align-items:center;gap:10px;margin-bottom:10px; }
.coin-logo {
  width:40px;height:40px;border-radius:50%;border:1px solid var(--border);
  display:flex;align-items:center;justify-content:center;overflow:hidden;flex-shrink:0;
  font-size:16px;font-weight:700;background:var(--surface);
}
.coin-logo img { width:100%;height:100%;object-fit:cover; }
.coin-card-name { font-size:14px;font-weight:600; }
.coin-card-symbol { font-size:12px;color:var(--fg-muted); }
.coin-card-bar { height:4px;background:var(--border-muted);margin-top:8px;overflow:hidden; }
.coin-card-bar-fill { height:100%;background:var(--green);transition:width 0.3s; }
.coin-card-stat { font-size:11px;color:var(--fg-muted);margin-top:6px; }
.coin-card-mcap { font-size:11px;font-weight:600;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);color:var(--fg); }
.coin-card-mcap .usd { font-weight:400;color:var(--fg-muted); }
.coin-tpl-badge {
  display:inline-flex;align-items:center;vertical-align:middle;margin-left:4px;
  color:var(--fg);opacity:0.7;
}
.coin-tpl-badge svg { display:block; }
.coin-tpl-simple {
  font-size:9px;font-weight:600;letter-spacing:0.05em;text-transform:uppercase;
  padding:1px 4px;border-radius:3px;
  background:var(--surface);border:1px solid var(--border-muted);
  opacity:1;color:var(--fg-muted);
}

/* Detail page */
.coin-banner {
  width:100%;height:180px;overflow:hidden;margin-bottom:-30px;
  background:var(--surface);border:1px solid var(--border);
}
.coin-banner img { width:100%;height:100%;object-fit:cover; }
.coin-detail-head {
  display:flex;align-items:flex-end;gap:16px;margin-bottom:20px;position:relative;z-index:1;
}
.coin-detail-logo {
  width:64px;height:64px;border-radius:50%;border:3px solid var(--bg);
  display:flex;align-items:center;justify-content:center;overflow:hidden;flex-shrink:0;
  font-size:24px;font-weight:700;background:var(--surface);
}
.coin-detail-logo img { width:100%;height:100%;object-fit:cover; }
.coin-detail-title h2 { font-size:18px;font-weight:600;margin:0;text-transform:none;letter-spacing:0; }
.coin-detail-title .coin-symbol-row { display:flex;align-items:center;gap:6px; }
.coin-detail-title .coin-symbol-row span { font-size:13px;color:var(--fg-muted); }
.coin-user-balance { margin-left:auto;font-size:12px;color:var(--fg-muted);white-space:nowrap; }
.coin-mcap-row { font-size:13px;color:var(--fg-muted);margin-bottom:12px;font-weight:500; }

.section-card {
  border:1px solid var(--border);padding:16px;margin-bottom:16px;
}
.section-title {
  font-size:11px;font-weight:600;letter-spacing:0.1em;text-transform:uppercase;
  color:var(--fg-muted);margin-bottom:12px;
}
.stat-row { display:flex;justify-content:space-between;align-items:center;font-size:13px;margin-bottom:6px; }
.stat-label { color:var(--fg-muted); }
.stat-value { font-weight:600;overflow:hidden;text-overflow:ellipsis;min-width:0; }
.progress-bar { height:6px;background:var(--border-muted);overflow:hidden;margin:8px 0; }
.progress-fill { height:100%;transition:width 0.3s; }

/* Swap tile */
.swap-tile { position:relative; }
.swap-mode-tabs { display:flex;gap:6px;margin-bottom:14px; }
.swap-mode-tabs button {
  flex:1;padding:7px 0;font-size:11px;font-weight:600;letter-spacing:0.08em;text-transform:uppercase;
  border:none;border-bottom:2px solid transparent;border-radius:0;
  background:transparent;color:var(--fg-muted);
  cursor:pointer;font-family:inherit;transition:color 0.15s,border-color 0.15s;margin:0;
}
.swap-mode-tabs button:hover { color:var(--fg); }
.swap-mode-tabs button.active { color:var(--fg);border-bottom-color:var(--fg); }
.swap-dir { display:flex;gap:6px;margin-bottom:14px; }
.swap-dir button {
  flex:1;padding:7px 0;font-size:11px;font-weight:600;letter-spacing:0.08em;text-transform:uppercase;
  border:none;border-bottom:2px solid transparent;border-radius:0;
  background:transparent;color:var(--fg-muted);
  cursor:pointer;font-family:inherit;transition:color 0.15s,border-color 0.15s;margin:0;
}
.swap-dir button:hover { color:var(--fg); }
.swap-dir button.active { color:var(--fg);border-bottom-color:var(--fg); }
.swap-mode-content { display:none; }
.swap-mode-content.active { display:block; }
.sale-lp-note { font-size:11px;color:var(--fg-muted);margin-top:4px; }
.rq-estimate { font-size:14px;color:var(--fg);margin:12px 0;text-align:center; }
.rq-estimate small { font-size:11px;color:var(--fg-muted);display:block;margin-top:2px; }
.swap-section { margin-bottom:8px; }
.swap-section-head {
  display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;
}
.swap-section-head label { font-size:11px;font-weight:600;letter-spacing:0.05em;text-transform:uppercase;color:var(--fg-muted);margin:0;flex-shrink:0; }
.swap-balance { font-size:11px;color:var(--fg-muted);cursor:pointer;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;flex:1;text-align:right;margin:0 8px; }
.swap-balance:hover { color:var(--fg); }
.swap-pct-row { display:flex;gap:6px;margin-top:6px; }
.swap-pct-btn {
  flex:1;padding:4px 0;font-size:10px;font-weight:600;letter-spacing:0.05em;
  border:none;border-radius:0;background:var(--surface);color:var(--fg-muted);
  cursor:pointer;font-family:inherit;transition:background 0.15s,color 0.15s;
}
.swap-pct-btn:hover { background:var(--surface-hover);color:var(--fg); }
.swap-token-tag {
  display:inline-flex;align-items:center;gap:5px;font-size:13px;font-weight:600;color:var(--fg);flex-shrink:0;
}
.swap-token-tag img { width:18px;height:18px;border-radius:50%;object-fit:cover; }
.swap-token-tag .eth-icon { width:18px;height:18px;display:inline-flex;align-items:center;justify-content:center; }
.swap-section input {
  width:100%;padding:8px 0;font-size:22px;font-weight:400;font-family:inherit;
  border:none;border-bottom:1.5px solid var(--border);outline:none;background:transparent;color:var(--fg);
}
.swap-section input::placeholder { color:var(--input-ph); }
.swap-section input:focus { border-bottom-width:2.5px;margin-bottom:-1px; }
.swap-arrow-row { display:flex;justify-content:center;margin:2px 0 8px; }
.swap-arrow-btn {
  background:var(--bg);border:1px solid var(--border);width:32px;height:32px;
  display:inline-flex;align-items:center;justify-content:center;padding:0;margin:0;
  cursor:pointer;transition:transform 0.3s ease,background 0.2s,border-color 0.2s;
}
.swap-arrow-btn:hover { transform:rotate(180deg);background:var(--btn-bg);border-color:var(--btn-bg); }
.swap-arrow-btn:hover svg { stroke:var(--btn-fg); }
.swap-arrow-btn svg { stroke:var(--fg);transition:stroke 0.2s; }
.swap-quote { font-size:12px;color:var(--fg-muted);min-height:18px;margin-bottom:10px; }
.action-btn {
  width:100%;margin:0;padding:12px;font-size:13px;font-weight:600;letter-spacing:0.05em;
  text-transform:uppercase;cursor:pointer;background:var(--btn-bg);color:var(--btn-fg);
  border:none;font-family:inherit;transition:background 0.2s;
}
.action-btn:hover:not(:disabled) { background:var(--btn-hover); }
.action-btn:disabled { background:var(--btn-dis-bg);border:1px solid var(--btn-dis-border);color:var(--btn-dis-fg);cursor:not-allowed; }

/* Collapsible drawer (tap, chart) */
.drawer { border:1px solid var(--border);margin-bottom:16px;overflow:hidden; }
.drawer-toggle {
  display:flex;align-items:center;justify-content:space-between;padding:12px 16px;cursor:pointer;
  font-size:11px;font-weight:600;letter-spacing:0.1em;text-transform:uppercase;color:var(--fg-muted);
  background:transparent;border:none;width:100%;text-align:left;
}
.drawer-toggle:hover { background:var(--surface); }
.drawer-toggle .arrow { transition:transform 0.2s;font-size:10px; }
.drawer.open .drawer-toggle .arrow { transform:rotate(180deg); }
.drawer-body { display:none;padding:0 16px 16px; }
.drawer.open .drawer-body { display:block; }

/* Chart drawer body (special: aspect-ratio iframe instead of padded content) */
.chart-body { display:none;position:relative;width:100%;background:var(--surface); }
.drawer.open .chart-body { display:block; }
.chart-type-toggle {
  display:flex;gap:0;border-bottom:1px solid var(--border-muted);
}
.chart-type-toggle button {
  font-family:inherit;font-size:11px;font-weight:600;letter-spacing:0.05em;text-transform:uppercase;
  padding:6px 14px;border:none;cursor:pointer;background:transparent;color:var(--fg-muted);
}
.chart-type-toggle button.active { background:var(--btn-bg);color:var(--btn-fg); }
.chart-type-toggle button:not(.active):hover { color:var(--fg); }
.chart-iframe-wrap { position:relative;width:100%;padding-bottom:56.25%; }
.chart-iframe-wrap iframe { position:absolute;top:0;left:0;width:100%;height:100%;border:none;background:var(--surface);color-scheme:light dark; }

/* Pool activity drawer */
.activity-body { display:none;padding:0; }
.drawer.open .activity-body { display:block; }
.activity-table { width:100%;border-collapse:collapse;font-size:12px; }
.activity-table th {
  text-align:left;padding:6px 10px;font-size:10px;font-weight:600;letter-spacing:0.05em;
  text-transform:uppercase;color:var(--fg-muted);border-bottom:1px solid var(--border-muted);
}
.activity-table td { padding:5px 10px;border-bottom:1px solid var(--border-muted);white-space:nowrap; }
.activity-table tr:last-child td { border-bottom:none; }
.activity-table .evt-buy { color:var(--green); }
.activity-table .evt-sell { color:var(--red); }
.activity-table .evt-liqadd { color:var(--green); }
.activity-table .evt-liqrem { color:var(--red); }
.activity-table .evt-type { font-weight:600;font-size:11px; }
.activity-table a { color:var(--fg-muted);font-size:11px; }
.activity-table a:hover { color:var(--fg); }
.activity-more {
  display:block;width:100%;padding:8px;font-size:11px;font-weight:600;letter-spacing:0.05em;
  text-transform:uppercase;color:var(--fg-muted);background:transparent;border:none;border-top:1px solid var(--border-muted);
  cursor:pointer;font-family:inherit;
}
.activity-more:hover { color:var(--fg);background:var(--surface); }
.activity-empty { padding:16px;text-align:center;font-size:12px;color:var(--fg-muted); }

.desc-text { font-size:13px;line-height:1.6;color:var(--fg);white-space:pre-wrap;word-break:break-word; }
.socials-row { display:flex;gap:14px;flex-wrap:wrap;font-size:12px; }
.socials-row a { color:var(--fg-muted);text-decoration:none;display:inline-flex;align-items:center;gap:4px; }
.socials-row a:hover { color:var(--fg); }
.links-row { display:flex;gap:16px;flex-wrap:wrap;font-size:12px;margin-top:8px; }
.links-row a { color:var(--fg-muted); }
.links-row a:hover { color:var(--fg); }

.loading { text-align:center;padding:40px;color:var(--fg-muted);font-size:13px; }
@keyframes spin { to { transform:rotate(360deg); } }
.spinner {
  display:inline-block;width:14px;height:14px;border:2px solid var(--border-muted);
  border-top:2px solid var(--fg);border-radius:50%;animation:spin 0.8s linear infinite;
  vertical-align:middle;margin-right:8px;
}
/* Footer */
.site-footer {
  position:relative;text-align:center;padding:48px 20px;font-size:11px;opacity:0.65;margin-top:40px;
  letter-spacing:0.5px;font-weight:300;
}
.site-footer a { color:inherit;text-decoration:underline;margin:0 2px; }
.site-footer a:hover { opacity:0.7; }
.site-footer .tagline { opacity:1;color:#000;font-weight:500; }
.dark .site-footer .tagline { color:#fff; }
/* Dark toggle */
.dark-toggle {
  position:fixed;top:max(22px, env(safe-area-inset-top, 0px));left:max(20px, env(safe-area-inset-left, 0px));
  border:none;cursor:pointer;padding:13px;margin:-13px;opacity:0.5;transition:opacity 0.2s;
  z-index:100;background:#000;border-radius:50%;width:40px;height:40px;background-clip:content-box;
}
:root.dark .dark-toggle { background:#fff; }
.dark-toggle:hover { opacity:1; }
.home-btn {
  position: fixed;
  bottom: max(20px, env(safe-area-inset-bottom, 0px));
  right: max(20px, env(safe-area-inset-right, 0px));
  z-index: 100;
  opacity: 0.4;
  transition: opacity 0.2s;
  line-height: 0;
}
.home-btn:hover { opacity: 1; }

/* Wallet */
.wallet {
  position:fixed;
  top:max(20px, env(safe-area-inset-top, 0px));
  right:max(20px, env(safe-area-inset-right, 0px));
  font-size:11px; text-transform:uppercase; letter-spacing:0.05em;
  z-index:100;
}
.wallet button { margin:0; padding:8px 16px; text-transform:none; }

/* Wallet modal */
.wallet-modal-overlay {
  display:none; position:fixed; top:0; left:0; right:0; bottom:0;
  background:var(--modal-overlay); backdrop-filter:blur(4px);
  z-index:2000; justify-content:center; align-items:center;
  padding:20px; overflow-y:auto; -webkit-overflow-scrolling:touch;
}
.wallet-modal-overlay.active { display:flex; }
body.modal-open { overflow:hidden; }
.wallet-modal {
  background:var(--modal-bg); border:1px solid var(--modal-border);
  padding:16px; width:100%; max-width:380px;
  max-height:calc(100vh - 40px); max-height:calc(100dvh - 40px);
  overflow-y:auto; -webkit-overflow-scrolling:touch;
}
.wallet-modal-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:16px; }
.wallet-modal-title { font-size:14px; text-transform:uppercase; letter-spacing:0.1em; }
.wallet-modal-close {
  background:none; border:none; color:var(--fg); font-size:20px;
  cursor:pointer; line-height:1; padding:4px; margin:-4px;
  opacity:0.4; transition:opacity 0.15s;
}
.wallet-modal-close:hover { opacity:1; }
.wallet-option {
  display:flex; align-items:center; gap:12px; padding:12px;
  background:var(--modal-bg); border:1px solid var(--border); color:var(--fg);
  cursor:pointer; margin-bottom:8px; transition:background 0.15s, color 0.15s;
}
.wallet-option:hover { background:var(--btn-bg); color:var(--btn-fg); }
.wallet-option-icon { font-size:1.5rem; }
.wallet-option-name { font-weight:600; }
.wallet-option.disconnect { border-color:#f00; color:#f00; justify-content:center; }
.wallet-option.disconnect:hover { background:#f00; color:#fff; }

/* Mobile */
@media (max-width: 600px) {
  body { padding:80px 16px 20px; }
  .header h1 { font-size:13px; }
  .coin-grid { grid-template-columns:1fr 1fr;gap:10px; }
  .coin-card { padding:12px; }
  .coin-logo { width:32px;height:32px; }
  .coin-card-name { font-size:13px; }
  .coin-card-symbol { font-size:11px; }
  .coin-card-stat { font-size:10px; }
  .coin-card-mcap { font-size:10px; }
  .coin-search { font-size:14px; }
  .coin-banner { height:130px; }
  .coin-detail-logo { width:48px;height:48px; }
  .coin-detail-title h2 { font-size:15px; }
  .coin-detail-title span { font-size:12px; }
  .section-card { padding:12px; }
  .stat-row { font-size:12px; }
  .stat-value { word-break:break-all; }
  .swap-section input { font-size:18px; }
  .swap-pct-btn { font-size:9px;padding:5px 0;border-radius:0; }
  .activity-table { font-size:11px; }
  .activity-table th, .activity-table td { padding:4px 6px; }
  .activity-body { overflow-x:auto; }
  .activity-table { min-width:480px; }
  .desc-text { font-size:12px; }
  .links-row { gap:10px;font-size:11px; }
  .drawer-toggle { padding:10px 12px; }
  .wallet { top:16px; right:16px; }
  .wallet button { padding:10px 14px; font-size:11px; }
  .wallet-modal { max-width:100%; margin:0 10px; max-height:calc(100vh - 40px); overflow-y:auto; }
}
@media (max-width: 380px) {
  body { padding:70px 12px 20px; }
  .coin-grid { grid-template-columns:1fr;gap:8px; }
  .coin-detail-head { gap:10px; }
  .coin-detail-logo { width:40px;height:40px; }
  .coin-detail-title h2 { font-size:14px; }
  .section-card { padding:10px; }
  .stat-row { font-size:11px;flex-wrap:wrap;gap:2px; }
  .swap-section input { font-size:16px; }
  .swap-dir button { font-size:10px;padding:8px 0; }
  .swap-mode-tabs button { font-size:10px;padding:8px 0; }
  .coin-banner { height:100px;margin-bottom:-20px; }
  .activity-table { min-width:420px; }
  .activity-table a { font-size:10px; }
}
</style>
</head>
<body>
<a href="../" class="home-btn" title="Home"><svg width="28" height="28" viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg"><rect class="zorg-bg" width="400" height="400"/><clipPath id="zh"><rect width="400" height="400"/></clipPath><g clip-path="url(#zh)"><path class="zorg-fg" d="M-60-20L460-20L460 90L80 310L460 310L460 420L-60 420L-60 310L320 90L-60 90Z"/></g></svg></a>
<button class="dark-toggle" onclick="toggleDark()" title="Toggle dark mode"></button>

<div class="wallet">
  <button id="walletBtn" onclick="toggleWallet()">connect</button>
</div>

<div class="wallet-modal-overlay" id="walletModal" onclick="if(event.target===this)closeWalletModal()">
  <div class="wallet-modal">
    <div class="wallet-modal-header">
      <div class="wallet-modal-title">Connect Wallet</div>
      <button class="wallet-modal-close" onclick="closeWalletModal()">&times;</button>
    </div>
    <div class="wallet-modal-body" id="walletOptions"></div>
  </div>
</div>

<div id="app"></div>
<script src="../ethers.min.js"></script>
<script src="../walletconnect.min.js"></script>
<script>
function toggleDark() {
  const on = document.documentElement.classList.toggle('dark');
  localStorage.setItem('dark', on ? '1' : '0');
  const iframe = document.querySelector('.chart-iframe-wrap iframe');
  if (iframe) {
    try { iframe.contentWindow.postMessage({ type: 'theme', value: on ? 'dark' : 'light' }, 'https://www.zamm.finance'); } catch(e) {}
  }
}
const $ = id => document.getElementById(id);
const _escTextMap = { '&': '&amp;', '<': '&lt;', '>': '&gt;' };
function escText(s) { return String(s).replace(/[&<>]/g, m => _escTextMap[m]); }
function escAttr(s) { return escText(s).replace(/"/g, '&quot;').replace(/'/g, '&#39;'); }

function zfiLoadingSVG(s=48){
const f=(i,v)=>`<g opacity="${i===0?1:0}"><animate attributeName="opacity" values="${Array.from({length:16},(_,j)=>j===i?1:0).join(';')}" dur="3.2s" repeatCount="indefinite"/>`;
return `<svg width="${s}" height="${s}" viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg" style="display:block;margin:0 auto 8px"><g><polygon points="200,80 155,160 200,135" fill="#FF6B9D" stroke="#000" stroke-width="2"/><polygon points="200,80 200,135 245,160" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="155,160 200,135 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,135 245,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="155,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 245,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="155" y1="160" x2="245" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 160,160 200,132" fill="#FF6B9D" stroke="#000" stroke-width="2"/><polygon points="200,80 200,132 240,160" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="160,160 200,132 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,132 240,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="160,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 240,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="160" y1="160" x2="240" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 170,160 200,130" fill="#FF6B9D" stroke="#000" stroke-width="2"/><polygon points="200,80 200,130 235,160" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="200,130 235,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="170,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 235,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="170" y1="160" x2="235" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 180,160 200,135" fill="#FF6B9D" stroke="#000" stroke-width="2"/><polygon points="200,80 200,135 220,160" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="200,135 220,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="180,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 220,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="180" y1="160" x2="220" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 195,160 200,140" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="200,80 200,140 205,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="195,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 205,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="195" y1="160" x2="205" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 180,160 200,135" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,80 200,135 220,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="180,160 200,135 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="180,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 220,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="180" y1="160" x2="220" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 165,160 200,130" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,80 200,130 230,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="165,160 200,130 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="165,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 230,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="165" y1="160" x2="230" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 160,160 200,132" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,80 200,132 240,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="160,160 200,132 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,132 240,160 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="160,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 240,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="160" y1="160" x2="240" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 155,160 200,135" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,80 200,135 245,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="155,160 200,135 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,135 245,160 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="155,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 245,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="155" y1="160" x2="245" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 160,160 200,132" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,80 200,132 240,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="160,160 200,132 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,132 240,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="160,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 240,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="160" y1="160" x2="240" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 170,160 200,130" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,80 200,130 235,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,130 235,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="170,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 235,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="170" y1="160" x2="235" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 180,160 200,135" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,80 200,135 220,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,135 220,160 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="180,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 220,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="180" y1="160" x2="220" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 195,160 200,140" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,80 200,140 205,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="195,160 200,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><polygon points="200,160 205,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="195" y1="160" x2="205" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 180,160 200,135" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="200,80 200,135 220,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,135 220,160 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="180,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 220,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="180" y1="160" x2="220" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 170,160 200,130" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="200,80 200,130 235,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="200,130 235,160 200,160" fill="#FFE066" stroke="#000" stroke-width="2"/><polygon points="170,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 235,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="170" y1="160" x2="235" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0" dur="3.2s" repeatCount="indefinite"/></g><g opacity="0"><polygon points="200,80 160,160 200,132" fill="#00D4FF" stroke="#000" stroke-width="2"/><polygon points="200,80 200,132 240,160" fill="#FF6B9D" stroke="#000" stroke-width="2"/><polygon points="160,160 200,132 200,160" fill="#66D9A6" stroke="#000" stroke-width="2"/><polygon points="200,132 240,160 200,160" fill="#FF6B9D" stroke="#000" stroke-width="2"/><polygon points="160,160 200,160 200,240" fill="#B967DB" stroke="#000" stroke-width="2"/><polygon points="200,160 240,160 200,240" fill="#FF9F40" stroke="#000" stroke-width="2"/><line x1="200" y1="80" x2="200" y2="240" stroke="#000" stroke-width="2"/><line x1="160" y1="160" x2="240" y2="160" stroke="#000" stroke-width="2"/><animate attributeName="opacity" values="0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1" dur="3.2s" repeatCount="indefinite"/></g></svg>`;}


const RPCS = [
  'https://ethereum.publicnode.com',
  'https://1rpc.io/eth',
  'https://eth.drpc.org',
  'https://eth.llamarpc.com'
];

const WEINS = "0x0000000000696760E15f265e828DB644A0c242EB";
const WEINS_ABI = ["function reverseResolve(address) view returns (string)"];

const VIEW_HELPER = '0x00000000006631040967E58e3430e4B77921a2db';
const DAICO_ADDR = '0x000000000033e92DB97B4B3beCD2c255126C60aC';
const SUMMONER = '0x0000000000330B8df9E3bc5E553074DA58eE9138';
const ZAMM = '0x000000000000040470635EB91b7CE4D132D616eD';
const ZQUOTER = '0x10D7e794518b45ced364FF38C0D48dfdC586f0Ef';
const CHAINLINK_ETH_USD = '0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419';
const CHAINLINK_ABI = ['function latestAnswer() view returns (int256)'];
const ZERO = ethers.ZeroAddress;
const IPFS_GW = 'https://content.wrappr.wtf/ipfs/';

// ABIs
const SCAN_ABI = [
  'function scanDAICOs(uint256 daoStart, uint256 daoCount, address[] tribTokens) view returns (tuple(address dao, tuple(string name, string symbol, string contractURI, address sharesToken, address lootToken, address badgesToken, address renderer) meta, tuple(address tribTkn, uint256 tribAmt, uint256 forAmt, address forTkn, uint40 deadline, uint256 remainingSupply, uint256 totalSupply, uint256 treasuryBalance, uint256 allowance, uint16 lpBps, uint16 maxSlipBps, uint256 feeOrHook)[] sales, tuple(address ops, address tribTkn, uint128 ratePerSec, uint64 lastClaim, uint256 claimable, uint256 pending, uint256 treasuryBalance, uint256 tapAllowance) tap)[])'
];
const GET_DAICO_ABI = [
  'function getDAICO(address dao, address[] tribTokens) view returns (tuple(address dao, tuple(string name, string symbol, string contractURI, address sharesToken, address lootToken, address badgesToken, address renderer) meta, tuple(address tribTkn, uint256 tribAmt, uint256 forAmt, address forTkn, uint40 deadline, uint256 remainingSupply, uint256 totalSupply, uint256 treasuryBalance, uint256 allowance, uint16 lpBps, uint16 maxSlipBps, uint256 feeOrHook)[] sales, tuple(address ops, address tribTkn, uint128 ratePerSec, uint64 lastClaim, uint256 claimable, uint256 pending, uint256 treasuryBalance, uint256 tapAllowance) tap))'
];
const QUOTE_ABI = [
  'function quoteZAMM(bool exactOut, uint256 feeOrHook, address tokenIn, address tokenOut, uint256 idIn, uint256 idOut, uint256 swapAmount) view returns (uint256 amountIn, uint256 amountOut)'
];
const ZAMM_ABI = [
  'function swapExactIn(tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook) key, uint256 swapAmount, uint256 amountLimit, bool zeroForOne, address to, uint256 deadline) payable returns (uint256 amountOut)',
  'function swapExactOut(tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook) key, uint256 swapAmount, uint256 amountLimit, bool zeroForOne, address to, uint256 deadline) payable returns (uint256 amountIn)'
];
const ZAMM_POOLS_ABI = [
  'function pools(uint256) view returns (uint112 reserve0, uint112 reserve1, uint32, uint256, uint256, uint256, uint256)'
];
const ZAMM_LP_ABI = [
  'function addLiquidity(tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook) key, uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min, address to, uint256 deadline) payable returns (uint256, uint256, uint256)',
  'function balanceOf(address, uint256) view returns (uint256)'
];
const V1_ZAP = '0x0000000000Ee8cD7fd26236a2e4C1505dAc0Dce9';
const V1_ZAP_ABI = ['function addSingleLiqETH(tuple(uint256 id0, uint256 id1, address token0, address token1, uint256 feeOrHook) poolKey, uint256 amountOutMin, uint256 amount0Min, uint256 amount1Min, address to, uint256 deadline) payable returns (uint256, uint256, uint256)'];
const DAO_ABI = [
  'function shares() view returns (address)',
  'function name(uint256) view returns (string)',
  'function symbol(uint256) view returns (string)',
  'function contractURI() view returns (string)'
];
const DAICO_BUY_ABI = [
  'function buy(address dao, address tribTkn, uint256 payAmt, uint256 minBuyAmt) payable',
  'function buyExactOut(address dao, address tribTkn, uint256 buyAmt, uint256 maxPayAmt) payable'
];
const RAGEQUIT_ABI = [
  'function ragequit(address[] tokens, uint256 sharesToBurn, uint256 lootToBurn)'
];
const ERC20_ABI = [
  'function balanceOf(address) view returns (uint256)',
  'function totalSupply() view returns (uint256)',
  'function approve(address,uint256) returns (bool)',
  'function allowance(address,address) view returns (uint256)'
];
const MC3 = '0xcA11bde05977b3631167028862bE2a173976CA11';
const MC3_ABI = [
  'function aggregate3(tuple(address target, bool allowFailure, bytes callData)[] calls) view returns (tuple(bool success, bytes returnData)[])',
  'function getEthBalance(address) view returns (uint256)'
];

let rpcIdx = 0;
function getRPC() {
  return new ethers.JsonRpcProvider(RPCS[rpcIdx % RPCS.length], 1, { staticNetwork: true });
}
async function withRPC(fn) {
  for (let i = 0; i < RPCS.length; i++) {
    try {
      const rpc = new ethers.JsonRpcProvider(RPCS[(rpcIdx + i) % RPCS.length], 1, { staticNetwork: true });
      const result = await fn(rpc);
      rpcIdx = (rpcIdx + i) % RPCS.length;
      return result;
    } catch(e) { if (i === RPCS.length - 1) throw e; }
  }
}

function resolveIPFS(uri) {
  if (!uri) return '';
  if (uri.startsWith('ipfs://')) return IPFS_GW + uri.slice(7);
  return uri;
}

async function fetchMetadata(contractURI) {
  if (!contractURI) return {};
  try {
    const url = resolveIPFS(contractURI);
    if (url.startsWith('data:')) {
      const json = url.split(',').slice(1).join(',');
      if (url.startsWith('data:application/json;base64,')) return JSON.parse(atob(json));
      return JSON.parse(decodeURIComponent(json));
    }
    const res = await fetch(url);
    return await res.json();
  } catch { return {}; }
}

function symbolSVG(symbol, size) {
  size = size || 40;
  const letter = (symbol || '?')[0].toUpperCase();
  return `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}"><circle cx="${size/2}" cy="${size/2}" r="${size/2}" fill="var(--surface)"/><text x="${size/2}" y="${size*0.65}" text-anchor="middle" font-size="${size*0.45}" fill="var(--fg)" font-family="Helvetica,Arial,sans-serif" font-weight="700">${escText(letter)}</text></svg>`;
}

function logoHTML(meta, metadata, size) {
  size = size || 40;
  const imgUrl = resolveIPFS(metadata.image);
  if (imgUrl) return `<img src="${escAttr(imgUrl)}" alt="" onerror="this.parentNode.innerHTML=symbolSVG(${JSON.stringify(meta.symbol).replace(/</g,'\\u003c')},${size})">`;
  return symbolSVG(meta.symbol, size);
}

function computePoolId(token0, token1, id0, id1, fee) {
  const [sA, sB] = token0.toLowerCase() < token1.toLowerCase() ? [token0, token1] : [token1, token0];
  const [sId0, sId1] = token0.toLowerCase() < token1.toLowerCase() ? [id0, id1] : [id1, id0];
  return BigInt(ethers.keccak256(ethers.AbiCoder.defaultAbiCoder().encode(
    ['uint256','uint256','address','address','uint256'], [sId0, sId1, sA, sB, fee]
  )));
}

function updateOGMeta(title, description, imageUrl) {
  document.title = title;
  const set = (prop, val, attr) => {
    attr = attr || 'property';
    const el = document.querySelector(`meta[${attr}="${prop}"]`);
    if (el) el.setAttribute('content', val || '');
  };
  set('og:title', title);
  set('og:description', description);
  set('og:image', imageUrl);
  set('og:url', window.location.href);
  set('twitter:title', title, 'name');
  set('twitter:description', description, 'name');
  set('twitter:image', imageUrl, 'name');
  // Use summary_large_image when banner available
  const cardEl = document.querySelector('meta[name="twitter:card"]');
  if (cardEl) cardEl.setAttribute('content', imageUrl ? 'summary_large_image' : 'summary');
}

var _coinChartType = 'line';

function coinChartUrl(poolId, type) {
  const theme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
  return `https://www.zamm.finance/embed/pool/1/${poolId}?type=${type}&theme=${theme}`;
}

function toggleChart() {
  const el = $('chartDrawer');
  if (!el) return;
  el.classList.toggle('open');
  if (el.classList.contains('open') && !el.dataset.loaded) {
    el.dataset.loaded = '1';
    const poolId = el.dataset.poolId;
    const body = el.querySelector('.chart-body');
    body.innerHTML = `<div class="chart-type-toggle"><button class="active" data-type="line" onclick="setCoinChartType('line')">Line</button><button data-type="candle" onclick="setCoinChartType('candle')">Candle</button></div><div class="chart-iframe-wrap"><iframe src="${coinChartUrl(poolId, _coinChartType)}" allow="clipboard-write" sandbox="allow-scripts allow-same-origin"></iframe></div>`;
  }
}

function setCoinChartType(type) {
  if (type === _coinChartType) return;
  _coinChartType = type;
  const el = $('chartDrawer');
  if (!el) return;
  const poolId = el.dataset.poolId;
  const wrap = el.querySelector('.chart-iframe-wrap');
  if (wrap) {
    const iframe = document.createElement('iframe');
    iframe.src = coinChartUrl(poolId, type);
    iframe.allow = 'clipboard-write';
    iframe.sandbox = 'allow-scripts allow-same-origin';
    wrap.replaceChildren(iframe);
  }
  el.querySelectorAll('.chart-type-toggle button').forEach(b => b.classList.toggle('active', b.dataset.type === type));
}

// ==================== POOL ACTIVITY ====================

const INDEXER = 'https://coinchan-indexer-production.up.railway.app';

const LOCKUP_CHECK_ABI = ['function lockups(bytes32) view returns (uint256)'];
const COIN_SUPPLY_TOTAL = 1_000_000_000n;

async function fetchOpsLockup(sharesAddr, opsAddr, metadata) {
  // Derive team allocation from metadata or try common defaults
  const teamBpsList = metadata.teamBps ? [metadata.teamBps] : [1500, 1000, 2000, 2500, 500, 3000];
  try {
    // Get lockup hashes from indexer (cap at 10 most recent)
    const res = await fetch(INDEXER + '/graphql', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query: `query ($address: String!) {
          account(address: $address) {
            lockupReceived(limit: 10) { items { id } }
          }
        }`,
        variables: { address: opsAddr.toLowerCase() }
      })
    });
    const { data } = await res.json();
    const items = data?.account?.lockupReceived?.items || [];
    if (items.length === 0) return null;
    // Batch: read all unlockTimes in one RPC round via Promise.all
    const hashes = items.map(i => i.id);
    const unlockTimes = await withRPC(async rpc => {
      const zamm = new ethers.Contract(ZAMM, LOCKUP_CHECK_ABI, rpc);
      return await Promise.all(hashes.map(h => zamm.lockups(h).catch(() => 0n)));
    });
    // Precompute hashes for each teamBps candidate (pure CPU, no RPC)
    const abiCoder = ethers.AbiCoder.defaultAbiCoder();
    for (let i = 0; i < hashes.length; i++) {
      const unlockTime = unlockTimes[i];
      if (unlockTime === 0n) continue;
      for (const tb of teamBpsList) {
        const teamSupply = (COIN_SUPPLY_TOTAL * BigInt(tb)) / 10000n;
        const teamSupplyWei = ethers.parseEther(teamSupply.toString());
        const encoded = abiCoder.encode(
          ['address', 'address', 'uint256', 'uint256', 'uint256'],
          [sharesAddr, opsAddr, 0n, teamSupplyWei, unlockTime]
        );
        const computed = ethers.keccak256(encoded);
        if (computed.toLowerCase() === hashes[i].toLowerCase()) {
          return { amount: teamSupplyWei.toString(), unlockTime: unlockTime.toString(), coinId: '0' };
        }
      }
    }
    return null;
  } catch { return null; }
}

let _activityCursor = null;
let _activityInterval = null;

function toggleActivity() {
  const el = $('activityDrawer');
  if (!el) return;
  el.classList.toggle('open');
  if (el.classList.contains('open') && !el.dataset.loaded) {
    el.dataset.loaded = '1';
    loadActivity(el.dataset.poolId);
    _activityInterval = setInterval(() => refreshActivity(el.dataset.poolId), 30000);
  } else if (!el.classList.contains('open') && _activityInterval) {
    clearInterval(_activityInterval);
    _activityInterval = null;
  }
}

function fmtWei(wei) {
  if (!wei || wei === '0') return '0';
  const s = wei.padStart(19, '0');
  const whole = s.slice(0, s.length - 18) || '0';
  const frac = s.slice(s.length - 18, s.length - 14);
  return whole + '.' + frac;
}

function fmtAge(ts) {
  const diff = Math.floor(Date.now() / 1000) - ts;
  if (diff < 60) return diff + 's ago';
  if (diff < 3600) return Math.floor(diff / 60) + 'm ago';
  if (diff < 86400) return Math.floor(diff / 3600) + 'h ago';
  return Math.floor(diff / 86400) + 'd ago';
}

function activityRow(e) {
  const cls = 'evt-' + e.type.toLowerCase();
  const label = { BUY: 'Buy', SELL: 'Sell', LIQADD: '+LP', LIQREM: '-LP' }[e.type] || e.type;
  const ethAmt = (e.type === 'BUY' || e.type === 'LIQADD') ? fmtWei(e.amount0_in) : fmtWei(e.amount0_out);
  const tokenAmt = (e.type === 'BUY' || e.type === 'LIQREM') ? fmtWei(e.amount1_out) : fmtWei(e.amount1_in);
  const maker = e.maker ? e.maker.slice(0, 6) + '\u2026' + e.maker.slice(-4) : '-';
  const txShort = e.txhash.slice(0, 6) + '\u2026' + e.txhash.slice(-4);
  return `<tr class="${cls}">
    <td>${fmtAge(e.timestamp)}</td>
    <td class="evt-type">${label}</td>
    <td>${ethAmt}</td>
    <td>${tokenAmt}</td>
    <td><a href="https://etherscan.io/address/${escText(e.maker)}" target="_blank">${maker}</a></td>
    <td><a href="https://etherscan.io/tx/${escText(e.txhash)}" target="_blank">${txShort}</a></td>
  </tr>`;
}

function renderActivityTable(events, append) {
  const content = $('activityContent');
  if (!content) return;
  if (!events.length && !append) {
    content.innerHTML = '<div class="activity-empty">No activity yet</div>';
    return;
  }
  const rows = events.map(activityRow).join('');
  if (append) {
    const tbody = content.querySelector('tbody');
    if (tbody) tbody.insertAdjacentHTML('beforeend', rows);
  } else {
    content.innerHTML = `<table class="activity-table">
      <thead><tr><th>Age</th><th>Type</th><th>ETH</th><th>Token</th><th>Maker</th><th>Tx</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>` + (_activityCursor ? `<button class="activity-more" onclick="loadMoreActivity()">Load More</button>` : '');
  }
}

async function loadActivity(poolId) {
  try {
    const res = await fetch(`${INDEXER}/api/events?poolId=${poolId}&limit=30`);
    const json = await res.json();
    _activityCursor = json.nextCursor || null;
    renderActivityTable(json.data, false);
  } catch(e) {
    const content = $('activityContent');
    if (content) content.innerHTML = '<div class="activity-empty">Failed to load activity</div>';
  }
}

async function refreshActivity(poolId) {
  try {
    const res = await fetch(`${INDEXER}/api/events?poolId=${poolId}&limit=30`);
    const json = await res.json();
    _activityCursor = json.nextCursor || null;
    renderActivityTable(json.data, false);
  } catch(e) { /* silent refresh failure */ }
}

async function loadMoreActivity() {
  if (!_activityCursor) return;
  const el = $('activityDrawer');
  if (!el) return;
  const poolId = el.dataset.poolId;
  const btn = el.querySelector('.activity-more');
  if (btn) { btn.textContent = 'Loading...'; btn.disabled = true; }
  try {
    const res = await fetch(`${INDEXER}/api/events?poolId=${poolId}&limit=30&before=${_activityCursor}`);
    const json = await res.json();
    _activityCursor = json.nextCursor || null;
    renderActivityTable(json.data, true);
    if (!_activityCursor && btn) btn.remove();
    else if (btn) { btn.textContent = 'Load More'; btn.disabled = false; }
  } catch(e) {
    if (btn) { btn.textContent = 'Load More'; btn.disabled = false; }
  }
}

function toggleLpList() {
  const el = $('lpDrawer');
  if (!el) return;
  el.classList.toggle('open');
  if (el.classList.contains('open') && !el.dataset.loaded) {
    el.dataset.loaded = '1';
    loadLpProviders(el.dataset.poolId);
  }
}

async function loadLpProviders(poolId) {
  const content = $('lpListContent');
  if (!content) return;
  content.innerHTML = `<div class="activity-empty">${zfiLoadingSVG(32)} Loading...</div>`;
  try {
    const allEvents = [];
    let cursor = null;
    for (;;) {
      let url = `${INDEXER}/api/events?poolId=${poolId}&limit=500`;
      if (cursor) url += `&before=${cursor}`;
      const res = await fetch(url);
      const json = await res.json();
      for (const e of json.data) {
        if (e.type === 'LIQADD' || e.type === 'LIQREM') allEvents.push(e);
      }
      cursor = json.nextCursor || null;
      if (!cursor) break;
    }
    // Aggregate net liquidity per address
    const map = {};
    for (const e of allEvents) {
      const addr = e.maker;
      if (!map[addr]) map[addr] = { addr, net: 0n, lastTs: 0 };
      const amt = BigInt(e.type === 'LIQADD' ? e.amount0_in : e.amount0_out);
      map[addr].net += e.type === 'LIQADD' ? amt : -amt;
      if (e.timestamp > map[addr].lastTs) map[addr].lastTs = e.timestamp;
    }
    const providers = Object.values(map).filter(p => p.net > 0n).sort((a, b) => a.net > b.net ? -1 : a.net < b.net ? 1 : 0);
    renderLpTable(providers);
  } catch(e) {
    content.innerHTML = '<div class="activity-empty">Failed to load LP data</div>';
  }
}

function renderLpTable(providers) {
  const content = $('lpListContent');
  if (!content) return;
  if (!providers.length) {
    content.innerHTML = '<div class="activity-empty">No liquidity providers</div>';
    return;
  }
  const rows = providers.map(p => {
    const short = p.addr.slice(0, 6) + '\u2026' + p.addr.slice(-4);
    return `<tr>
      <td><a href="https://etherscan.io/address/${escText(p.addr)}" target="_blank">${short}</a></td>
      <td>${fmtWei(p.net.toString())}</td>
      <td>${fmtAge(p.lastTs)}</td>
    </tr>`;
  }).join('');
  content.innerHTML = `<table class="activity-table">
    <thead><tr><th>Address</th><th>Liquidity (ETH)</th><th>Last Active</th></tr></thead>
    <tbody>${rows}</tbody>
  </table>`;
}

function pctBar(pct, color) {
  color = color || 'var(--green)';
  return `<div class="progress-bar"><div class="progress-fill" style="width:${Math.min(pct,100).toFixed(1)}%;background:${color}"></div></div>`;
}

function fmtETH(wei) {
  const v = Number(ethers.formatEther(wei));
  return fmtNum(v) + ' ETH';
}
function fmtNum(v) {
  if (v >= 1) return v.toFixed(4);
  if (v >= 0.001) return v.toFixed(6);
  if (v >= 0.000001) return v.toFixed(8);
  if (v > 0) return v.toExponential(2);
  return '0';
}

function fmtShares(wei) {
  const v = Number(ethers.formatEther(wei));
  if (v >= 1e6) return (v / 1e6).toFixed(2) + 'M';
  if (v >= 1e3) return (v / 1e3).toFixed(1) + 'K';
  return v.toLocaleString(undefined, { maximumFractionDigits: 0 });
}

function fmtMcap(ethVal) {
  if (ethVal >= 1000) return (ethVal / 1000).toFixed(1) + 'K ETH';
  if (ethVal >= 1) return ethVal.toFixed(2) + ' ETH';
  if (ethVal >= 0.01) return ethVal.toFixed(4) + ' ETH';
  return ethVal.toFixed(6) + ' ETH';
}

function fmtUsd(val) {
  if (val >= 1e6) return '$' + (val / 1e6).toFixed(2) + 'M';
  if (val >= 1e3) return '$' + (val / 1e3).toFixed(1) + 'K';
  if (val >= 1) return '$' + val.toFixed(2);
  return '$' + val.toFixed(2);
}

let _ethUsdPrice = 0;
let _ethUsdTs = 0;
async function getEthUsd() {
  if (_ethUsdPrice > 0 && Date.now() - _ethUsdTs < 5 * 60 * 1000) return _ethUsdPrice;
  try {
    const price = await withRPC(async rpc => {
      const cl = new ethers.Contract(CHAINLINK_ETH_USD, CHAINLINK_ABI, rpc);
      return await cl.latestAnswer();
    });
    _ethUsdPrice = Number(price) / 1e8;
    _ethUsdTs = Date.now();
  } catch(e) {}
  return _ethUsdPrice;
}

// ==================== ROUTER ====================

let _renderGen = 0;

function route() {
  if (_activityInterval) { clearInterval(_activityInterval); _activityInterval = null; }
  const hash = location.hash.replace('#','').trim();
  if (hash && hash.startsWith('0x') && hash.length === 42) {
    renderCoinPage(hash);
  } else {
    renderGallery();
  }
}

window.addEventListener('hashchange', route);

// ==================== GALLERY ====================

async function renderGallery() {
  const gen = ++_renderGen;
  updateOGMeta('COIN', 'Trade coins on zFi - the most secure-by-default exchange', '');
  const app = $('app');
  app.innerHTML = `
    <div class="header">
      <h1>Coins</h1>
      <div><a href="../" class="nav-link">Swap</a> &middot; <a href="../dao/" class="nav-link">DAO</a></div>
    </div>
    <div class="loading">${zfiLoadingSVG(48)}Scanning for coins...</div>
  `;

  try {
    const daicos = await withRPC(async rpc => {
      const helper = new ethers.Contract(VIEW_HELPER, SCAN_ABI, rpc);
      return await helper.scanDAICOs(0, 500, [ZERO]);
    });

    if (!daicos || daicos.length === 0) {
      app.innerHTML = `
        <div class="header">
          <h1>Coins</h1>
          <div><a href="../" class="nav-link">Swap</a> &middot; <a href="../dao/" class="nav-link">DAO</a></div>
        </div>
        <div class="loading">No coins found yet. <a href="../#coin">Launch one</a>.</div>
      `;
      return;
    }

    // Exclude test coins
    const EXCLUDED_COINS = new Set([
      '0xd77F85a19D242391CeEf95e2D7fe35E251593f28',
      '0x816f6f801a525eef715BF015704C2672A0abf018',
      '0x729B47e8e4fBE54268E70a169398E7a5DCA579d1',
      '0xC455Dc876E1cF371cFf6ef5af85dA7675E3d2281'
    ].map(a => a.toLowerCase()));
    const filtered = daicos.filter(d => !EXCLUDED_COINS.has(d.dao.toLowerCase()));

    // Fetch metadata, pool reserves, and ETH/USD price in parallel
    const zammI = new ethers.Interface(ZAMM_POOLS_ABI);
    const poolCalls = filtered.map(d => {
      const sale = d.sales && d.sales.length > 0 ? d.sales[0] : null;
      const feeOrHook = sale ? BigInt(sale.feeOrHook) : 30n;
      const poolId = computePoolId(ZERO, d.meta.sharesToken, 0n, 0n, feeOrHook);
      return { target: ZAMM, allowFailure: true, callData: zammI.encodeFunctionData('pools', [poolId]) };
    });

    const [allMetadata, poolResults, ethUsd] = await Promise.all([
      Promise.all(filtered.map(d => fetchMetadata(d.meta.contractURI))),
      withRPC(async rpc => {
        const mc = new ethers.Contract(MC3, MC3_ABI, rpc);
        return await mc.aggregate3(poolCalls);
      }).catch(() => poolCalls.map(() => ({ success: false }))),
      getEthUsd()
    ]);
    if (gen !== _renderGen) return;

    // Team locked: fund templates have ops with 15% (150M) locked
    const TEAM_LOCKED_DEFAULT = 150_000_000;

    let grid = '';
    for (let i = 0; i < filtered.length; i++) {
      const d = filtered[i];
      const md = allMetadata[i];
      const sale = d.sales && d.sales.length > 0 ? d.sales[0] : null;

      let salePct = 0, treasuryDisplay = '0';
      if (sale && sale.totalSupply > 0n) {
        const soldShares = sale.totalSupply - sale.remainingSupply;
        if (sale.totalSupply > 0n) salePct = Number((soldShares * 10000n) / sale.totalSupply) / 100;
        treasuryDisplay = fmtETH(sale.treasuryBalance || 0n);
      }

      // Market cap (circulating): price * circulating supply
      // Circulating = total - unsold - tokens in LP
      let mcapETH = 0;
      let poolR1 = 0n;
      const pr = poolResults[i];
      if (pr && pr.success) {
        try {
          const decoded = zammI.decodeFunctionResult('pools', pr.returnData);
          const r0 = decoded[0], r1 = decoded[1];
          poolR1 = r1;
          if (r0 > 0n && r1 > 0n) {
            const price = Number(ethers.formatEther(r0)) / Number(ethers.formatEther(r1));
            const unsold = sale ? Number(ethers.formatEther(sale.remainingSupply)) : 0;
            const inLp = Number(ethers.formatEther(r1));
            const teamLocked = (d.tap && d.tap.ops && d.tap.ops !== ZERO) ? TEAM_LOCKED_DEFAULT : 0;
            const circulating = Number(COIN_SUPPLY_TOTAL) - unsold - inLp - teamLocked;
            mcapETH = circulating > 0 ? price * circulating : 0;
          }
        } catch(e) {}
      }
      if (!mcapETH && sale && sale.tribAmt > 0n && sale.forAmt > 0n) {
        const price = Number(ethers.formatEther(sale.tribAmt)) / Number(ethers.formatEther(sale.forAmt));
        const unsold = Number(ethers.formatEther(sale.remainingSupply));
        const teamLocked = (d.tap && d.tap.ops && d.tap.ops !== ZERO) ? TEAM_LOCKED_DEFAULT : 0;
        const circulating = Number(COIN_SUPPLY_TOTAL) - unsold - teamLocked;
        mcapETH = circulating > 0 ? price * circulating : 0;
      }
      const mcapDisplay = mcapETH > 1e-6 ? fmtMcap(mcapETH) : '';
      const mcapUsd = mcapETH > 1e-6 && ethUsd > 0 ? fmtUsd(mcapETH * ethUsd) : '';

      const now = BigInt(Math.floor(Date.now() / 1000));
      const saleActive = sale && sale.remainingSupply > 0n && sale.allowance > 0n && sale.forAmt > 0n && (sale.deadline === 0n || now <= BigInt(sale.deadline));

      const cardName = (md.name || d.meta.name || '').toLowerCase();
      const cardSym = (md.symbol || d.meta.symbol || '').toLowerCase();
      const cardAddr = d.dao.toLowerCase();

      grid += `
        <a href="#${d.dao}" class="coin-card" data-name="${escText(cardName)}" data-symbol="${escText(cardSym)}" data-addr="${cardAddr}">
          <div class="coin-card-head">
            <div class="coin-logo">${logoHTML(d.meta, md)}</div>
            <div>
              <div class="coin-card-name">${escText(d.meta.name || 'Unnamed')}</div>
              <div class="coin-card-symbol">$${escText(d.meta.symbol || '???')}${md && (md.launchType === 'ez' || md.launchType === 'simple') ? `<span class="coin-tpl-badge coin-tpl-simple" title="ez launch &middot; ${md.lpBps ? (md.lpBps/100) + '% LP' : '80% LP'} &middot; ragequitable treasury &middot; no ops &middot; no tap">ez</span>` : md && md.launchType === 'fund' ? `<span class="coin-tpl-badge coin-tpl-simple" title="fund launch &middot; ops allocation &middot; tap vesting &middot; governance">fund</span>` : md && md.template ? `<span class="coin-tpl-badge" title="${escText(md.template)} template"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg></span>` : ''}</div>
            </div>
          </div>
          <div class="coin-card-bar"><div class="coin-card-bar-fill" style="width:${Math.min(salePct,100).toFixed(1)}%"></div></div>
          <div class="coin-card-stat">${saleActive ? `${salePct.toFixed(1)}% sold` : 'Sale ended'}${(sale && sale.treasuryBalance > 0n) ? ` &middot; ${treasuryDisplay} treasury` : ''}</div>
          ${mcapDisplay ? `<div class="coin-card-mcap">MCap ${mcapDisplay}${mcapUsd ? ` <span class="usd">${mcapUsd}</span>` : ''}</div>` : ''}
        </a>
      `;
    }

    app.innerHTML = `
      <div class="header">
        <h1>Coins <span style="font-weight:400;color:var(--fg-muted)">(${filtered.length})</span></h1>
        <div><a href="../#coin" class="nav-link">Launch</a><span class="nav-sep">&middot;</span><a href="../" class="nav-link">Swap</a><span class="nav-sep">&middot;</span><a href="../dao/" class="nav-link">DAO</a></div>
      </div>
      <input type="text" class="coin-search" id="coinSearch" placeholder="Search by name, symbol, or address..." oninput="filterCoins()">
      <div class="coin-grid" id="coinGrid">${grid}</div>
    `;
  } catch(e) {
    app.innerHTML = `
      <div class="header">
        <h1>Coins</h1>
        <div><a href="../" class="nav-link">Swap</a> &middot; <a href="../dao/" class="nav-link">DAO</a></div>
      </div>
      <div class="loading">Failed to load coins: ${escText(e.message || '')}</div>
    `;
  }
}

function filterCoins() {
  const q = ($('coinSearch')?.value || '').toLowerCase().trim();
  const cards = document.querySelectorAll('#coinGrid .coin-card');
  cards.forEach(c => {
    if (!q) { c.style.display = ''; return; }
    const match = c.dataset.name.includes(q) || c.dataset.symbol.includes(q) || c.dataset.addr.includes(q);
    c.style.display = match ? '' : 'none';
  });
}

// ==================== COIN DETAIL PAGE ====================

let _swapDir = 'buy'; // buy = ETHshares, sell = sharesETH
let _exactOut = false; // false = exact input, true = exact output
let _coinData = null;
let _coinMeta = null;
let _quoteTimer = null;
let _walletProvider = null;
let _signer = null;
let _tradeMode = 'swap'; // 'sale' | 'swap' | 'ragequit' | 'lp'
let _saleData = null; // sale object from getDAICO
let _saleExactOut = false; // true when user typed in receive field
let _lpSubMode = 'zap'; // 'zap' | 'pair'
let _poolReserve0 = 0n;
let _poolReserve1 = 0n;
let _lpBalance = 0n;

async function renderCoinPage(daoAddr) {
  const gen = ++_renderGen;
  const app = $('app');
  app.innerHTML = `
    <a href="#" class="back-link">&larr; All Coins</a>
    <div class="loading">${zfiLoadingSVG(48)}Loading coin data...</div>
  `;

  try {
    const data = await withRPC(async rpc => {
      const helper = new ethers.Contract(VIEW_HELPER, GET_DAICO_ABI, rpc);
      return await helper.getDAICO(daoAddr, [ZERO]);
    });
    if (gen !== _renderGen) return;
    _coinData = data;
    _saleExactOut = false;
    _cachedQuote = null;

    const sale = data.sales && data.sales.length > 0 ? data.sales[0] : null;
    const tap = data.tap;
    const sharesAddr = data.meta.sharesToken;

    // Fetch metadata + pool reserves + ops lockup in parallel
    const feeOrHookVal = sale ? BigInt(sale.feeOrHook) : 30n;
    const poolId = computePoolId(ZERO, sharesAddr, 0n, 0n, feeOrHookVal);
    const tapActive_ = tap && tap.ratePerSec > 0n;
    const [metadata, poolResult, ethUsd] = await Promise.all([
      fetchMetadata(data.meta.contractURI),
      withRPC(async rpc => {
        const z = new ethers.Contract(ZAMM, ZAMM_POOLS_ABI, rpc);
        return await z.pools(poolId);
      }).catch(() => null),
      getEthUsd()
    ]);
    if (gen !== _renderGen) return;
    _coinMeta = metadata;
    const opsLockup = tapActive_ && tap.ops ? await fetchOpsLockup(sharesAddr, tap.ops, metadata) : null;
    if (gen !== _renderGen) return;

    // Sale stats
    const lpBps = sale ? Number(sale.lpBps) : 0;
    let salePct = 0, sold = 0n, totalSale = 0n, treasuryETH = 0n, saleActive = false;
    if (sale) {
      totalSale = sale.totalSupply;
      sold = totalSale - sale.remainingSupply;
      if (totalSale > 0n) salePct = Number((sold * 10000n) / totalSale) / 100;
      treasuryETH = sale.treasuryBalance;
      const now = BigInt(Math.floor(Date.now() / 1000));
      saleActive = sale.remainingSupply > 0n && sale.allowance > 0n && sale.forAmt > 0n && (sale.deadline === 0n || now <= BigInt(sale.deadline));
    }

    // Tap stats
    let tapPct = 0, tapVested = 0, tapTotal = 0, dailyRate = 0, tapActive = false;
    if (tap && tap.ratePerSec > 0n) {
      tapActive = true;
      const budget = tap.tapAllowance;
      // pending = total owed by time (ratePerSec * elapsed), claimable = min(pending, allowance, balance)
      const vested = tap.pending || 0n;
      if (budget > 0n) tapPct = Number((vested * 10000n) / budget) / 100;
      tapVested = Number(ethers.formatEther(vested));
      tapTotal = Number(ethers.formatEther(budget));
      dailyRate = Number(ethers.formatEther(tap.ratePerSec * 86400n));
    }

    // Price per 1M shares
    let priceDisplay = '';
    if (sale && sale.tribAmt > 0n && sale.forAmt > 0n) {
      const pricePer1M = Number(ethers.formatEther(sale.tribAmt)) / Number(ethers.formatEther(sale.forAmt)) * 1e6;
      priceDisplay = pricePer1M >= 1 ? pricePer1M.toFixed(4) : pricePer1M >= 0.001 ? pricePer1M.toFixed(6) : pricePer1M.toExponential(2);
    }

    // Market cap (pool price preferred, fallback to sale price)
    let mcapETH = 0;

    // Banner + OG meta for social sharing
    const bannerUrl = resolveIPFS(metadata.banner);
    const logoUrl = resolveIPFS(metadata.image);
    const coinName = metadata.name || data.meta.name || 'Unnamed';
    const coinSymbol = data.meta.symbol || '???';
    const ogDesc = metadata.description
      ? metadata.description.slice(0, 200)
      : `$${coinSymbol} on zFi${saleActive ? '  sale live' : ''}  ${fmtETH(treasuryETH)} treasury`;
    updateOGMeta(
      `$${coinSymbol}  ${coinName}`,
      ogDesc,
      bannerUrl || logoUrl || ''
    );
    const bannerHTML = bannerUrl
      ? `<div class="coin-banner"><img src="${escText(bannerUrl)}" alt="" onerror="this.parentNode.style.display='none'"></div>`
      : '';

    // LP info
    const feeOrHook = feeOrHookVal;
    const ethIco = `<svg width="10" height="10" viewBox="0 0 256 417" fill="currentColor" opacity="0.5" style="vertical-align:-1px"><path d="M127.961 0l-2.795 9.5v275.668l2.795 2.79 127.962-75.638z"/><path d="M127.962 0L0 212.32l127.962 75.639V154.158z"/><path d="M127.961 312.187l-1.575 1.92V414.55l1.575 4.6L256 236.587z"/><path d="M127.962 419.15V312.187L0 236.587z"/></svg>`;

    // Pool reserves (already fetched in parallel above)
    const reserve0 = poolResult ? (poolResult.reserve0 ?? poolResult[0] ?? 0n) : 0n;
    const reserve1 = poolResult ? (poolResult.reserve1 ?? poolResult[1] ?? 0n) : 0n;
    const hasPool = reserve0 > 0n || reserve1 > 0n;

    // Compute market cap (circulating): price * circulating supply
    // Circulating = total - unsold - tokens in LP - locked team allocation
    const unsold = sale ? Number(ethers.formatEther(sale.remainingSupply)) : 0;
    const inLp = Number(ethers.formatEther(reserve1));
    const teamLocked = opsLockup ? Number(ethers.formatEther(BigInt(opsLockup.amount || '0'))) : 0;
    const circulating = Number(COIN_SUPPLY_TOTAL) - unsold - inLp - teamLocked;
    if (hasPool && reserve1 > 0n && circulating > 0) {
      const spotPrice = Number(ethers.formatEther(reserve0)) / Number(ethers.formatEther(reserve1));
      mcapETH = spotPrice * circulating;
    } else if (sale && sale.tribAmt > 0n && sale.forAmt > 0n && circulating > 0) {
      const salePrice = Number(ethers.formatEther(sale.tribAmt)) / Number(ethers.formatEther(sale.forAmt));
      mcapETH = circulating > 0 ? salePrice * circulating : 0;
    }
    const mcapDisplay = mcapETH > 1e-6 ? fmtMcap(mcapETH) : '';
    const mcapUsd = mcapETH > 1e-6 && ethUsd > 0 ? fmtUsd(mcapETH * ethUsd) : '';

    let html = `
      <a href="#" class="back-link">&larr; All Coins</a>
      ${bannerHTML}
      <div class="coin-detail-head">
        <div class="coin-detail-logo">${logoHTML(data.meta, metadata, 64)}</div>
        <div class="coin-detail-title" style="flex:1">
          <h2>${escText(metadata.name || data.meta.name || 'Unnamed')}</h2>
          <div class="coin-symbol-row">
            <span>$${escText(metadata.symbol || data.meta.symbol || '???')}${(metadata.launchType === 'ez' || metadata.launchType === 'simple') ? `<span class="coin-tpl-badge coin-tpl-simple" title="ez launch &middot; ${metadata.lpBps ? (metadata.lpBps/100) + '% LP' : '80% LP'} &middot; ragequitable treasury &middot; no ops &middot; no tap">ez</span>` : metadata.launchType === 'fund' ? `<span class="coin-tpl-badge coin-tpl-simple" title="fund launch &middot; ops allocation &middot; tap vesting &middot; governance">fund</span>` : metadata.template ? `<span class="coin-tpl-badge" title="${escText(metadata.template)} template"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg></span>` : ''}</span>
            <div id="coinUserBalance" class="coin-user-balance" style="display:none"></div>
          </div>
        </div>
      </div>
      ${mcapDisplay ? `<div class="coin-mcap-row">Circ. MCap: ${mcapDisplay}${mcapUsd ? ` <span style="color:var(--fg-muted);font-weight:400">(${mcapUsd})</span>` : ''}</div>` : ''}
    `;

    // Description + socials
    const hasSocials = metadata.twitter || metadata.telegram || metadata.discord;
    if (metadata.description || hasSocials) {
      html += `<div class="section-card">`;
      if (metadata.description) html += `<div class="desc-text">${escText(metadata.description)}</div>`;
      if (hasSocials) {
        html += `<div class="socials-row"${metadata.description ? ' style="margin-top:10px"' : ''}>`;
        if (metadata.twitter) html += `<a href="https://x.com/${encodeURIComponent(metadata.twitter)}" target="_blank" rel="noopener" title="X / Twitter"><svg width="14" height="14" viewBox="0 0 300 300.251" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;fill:currentColor"><path d="M178.57 127.15 290.27 0h-26.46l-97.03 110.38L89.34 0H0l117.13 166.93L0 300.25h26.46l102.4-116.59 81.8 116.59h89.34M36.01 19.54H76.66l187.13 262.13h-40.66"/></svg> @${escText(metadata.twitter)}</a>`;
        if (metadata.telegram) html += `<a href="https://t.me/${encodeURIComponent(metadata.telegram)}" target="_blank" rel="noopener" title="Telegram"><svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle"><path d="M11.99 0C5.37 0 0 5.37 0 12s5.37 12 11.99 12S24 18.63 24 12 18.62 0 11.99 0zm5.9 8.1l-1.93 9.12c-.14.65-.52.81-1.06.5l-2.93-2.16-1.41 1.36c-.16.16-.29.29-.59.29l.21-2.97 5.42-4.9c.24-.21-.05-.33-.37-.12l-6.7 4.22-2.89-.9c-.63-.2-.64-.63.13-.93l11.29-4.35c.52-.2.98.12.81.93z"/></svg> ${escText(metadata.telegram)}</a>`;
        if (metadata.discord) html += `<a href="${escText(metadata.discord)}" target="_blank" rel="noopener" title="Discord"><svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle"><path d="M20.32 4.37a19.8 19.8 0 00-4.89-1.52.07.07 0 00-.08.04c-.21.38-.45.87-.61 1.26a18.27 18.27 0 00-5.49 0 12.64 12.64 0 00-.62-1.26.07.07 0 00-.08-.04 19.74 19.74 0 00-4.89 1.52.07.07 0 00-.03.03C1.07 8.28.32 12.05.7 15.78a.08.08 0 00.03.06 19.9 19.9 0 005.99 3.03.08.08 0 00.08-.03c.46-.63.87-1.3 1.22-2a.08.08 0 00-.04-.11 13.1 13.1 0 01-1.87-.9.08.08 0 01-.01-.12c.13-.09.25-.19.37-.29a.07.07 0 01.08-.01c3.93 1.79 8.18 1.79 12.07 0a.07.07 0 01.08.01c.12.1.25.2.37.29a.08.08 0 01-.01.12c-.6.35-1.22.65-1.87.9a.08.08 0 00-.04.11c.36.7.77 1.37 1.22 2a.08.08 0 00.08.03 19.83 19.83 0 006-3.03.08.08 0 00.03-.05c.44-4.53-.73-8.46-3.1-11.95a.06.06 0 00-.03-.03zM8.02 13.33c-1.03 0-1.89-.95-1.89-2.12s.83-2.12 1.89-2.12c1.06 0 1.9.96 1.89 2.12 0 1.17-.84 2.12-1.89 2.12zm6.97 0c-1.03 0-1.89-.95-1.89-2.12s.83-2.12 1.89-2.12c1.07 0 1.9.96 1.89 2.12 0 1.17-.83 2.12-1.89 2.12z"/></svg> Discord</a>`;
        html += `</div>`;
      }
      html += `</div>`;
    }

    // ez launch info
    if (metadata.launchType === 'ez' || metadata.launchType === 'simple') {
      const simpleLpPct = metadata.lpBps ? metadata.lpBps / 100 : 80;
      const simpleTreasuryPct = 100 - simpleLpPct;
      html += `
        <div class="section-card" style="background:var(--surface)">
          <div class="section-title">ez launch</div>
          <div style="font-size:12px;line-height:1.8;color:var(--fg-muted)">
            ${simpleLpPct}% LP &middot; ${simpleTreasuryPct}% ragequitable treasury<br>
            No ops allocation &middot; No tap &middot; No vesting
          </div>
        </div>
      `;
    }

    // Sale section (drawer if ended, full card if live)
    const saleContent = `
        <div class="stat-row"><span class="stat-label">Sold</span><span class="stat-value">${fmtShares(sold)} / ${fmtShares(totalSale)}</span></div>
        ${pctBar(salePct, 'var(--green)')}
        ${treasuryETH > 0n ? `<div class="stat-row"><span class="stat-label">Treasury</span><span class="stat-value">${fmtETH(treasuryETH)} ${ethIco}</span></div>` : ''}
        ${priceDisplay ? `<div class="stat-row"><span class="stat-label">Price</span><span class="stat-value">${priceDisplay} ${ethIco}/1M shares</span></div>` : ''}
        ${lpBps > 0 ? `<div class="stat-row"><span class="stat-label">LP seeding</span><span class="stat-value">${lpBps / 100}% of buys &rarr; zAMM${feeOrHook <= 10000n ? ` (${Number(feeOrHook) / 100}% fee)` : ''}</span></div>` : ''}`
    if (saleActive) {
      html += `
        <div class="section-card">
          <div class="section-title">Sale (Live)</div>
          ${saleContent}
        </div>
      `;
    } else {
      html += `
        <div class="drawer" id="saleDrawer">
          <button class="drawer-toggle" onclick="this.parentElement.classList.toggle('open')">
            <span>Sale (Ended)</span>
            <span class="arrow">&#9660;</span>
          </button>
          <div class="drawer-body">
            ${saleContent}
          </div>
        </div>
      `;
    }

    // Treasury + Pool reserves
    if (treasuryETH > 0n || hasPool) {
      html += `
        <div class="section-card">
          <div class="section-title">Treasury</div>
          ${treasuryETH > 0n ? `<div class="stat-row"><span class="stat-label">${ethIco} Balance</span><span class="stat-value">${fmtETH(treasuryETH)} ${ethIco}</span></div>` : ''}
          ${hasPool ? `
            <div class="stat-row"><span class="stat-label">Pool ${ethIco}${saleActive ? ' <span style="font-weight:400;font-size:10px;opacity:0.6">(building...)</span>' : ''}</span><span class="stat-value">${fmtETH(reserve0)} ${ethIco}</span></div>
            <div class="stat-row"><span class="stat-label">Pool $${escText(data.meta.symbol || '???')}</span><span class="stat-value">${fmtShares(reserve1)}</span></div>
          ` : ''}
        </div>
      `;
    }

    // Tap drawer (collapsed)
    if (tapActive) {
      const claimableETH = Number(ethers.formatEther(tap.claimable || 0n));
      html += `
        <div class="drawer" id="tapDrawer">
          <button class="drawer-toggle" onclick="this.parentElement.classList.toggle('open')">
            <span>Tap</span>
            <span class="arrow">&#9660;</span>
          </button>
          <div class="drawer-body">
            <div class="stat-row"><span class="stat-label">Vested</span><span class="stat-value">${fmtNum(tapVested)} / ${fmtNum(tapTotal)} ${ethIco}</span></div>
            ${pctBar(tapPct, 'var(--green)')}
            <div class="stat-row"><span class="stat-label">Rate</span><span class="stat-value">${fmtNum(dailyRate)} ${ethIco}/day</span></div>
            <div class="stat-row"><span class="stat-label">Claimable now</span><span class="stat-value">${fmtNum(claimableETH)} ${ethIco}</span></div>
            <div class="stat-row"><span class="stat-label">Ops</span><span class="stat-value" style="font-size:11px"><a class="ops-addr-link" href="https://etherscan.io/address/${tap.ops}" target="_blank" style="color:inherit;text-decoration:none;border-bottom:1px dotted var(--fg-muted)">${tap.ops}</a></span></div>
            ${claimableETH > 0 ? `<button id="tapClaimBtn" class="action-btn" style="margin-top:10px" onclick="onTapClaim()">Claim ${claimableETH.toFixed(6)} ETH</button>` : ''}
          </div>
        </div>
      `;
    }

    // Ops Allocation drawer (only for fund launches with lockup data)
    if (tapActive && opsLockup) {
      const lockAmt = BigInt(opsLockup.amount || '0');
      const lockUnlockTime = Number(opsLockup.unlockTime || '0');
      const lockCoinId = opsLockup.coinId || '0';
      const nowSec = Math.floor(Date.now() / 1000);
      const isUnlockable = nowSec >= lockUnlockTime;
      const unlockDate = new Date(lockUnlockTime * 1000);
      const dateStr = unlockDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      const diffMs = unlockDate - Date.now();
      const absDiffMs = Math.abs(diffMs);
      const days = Math.floor(absDiffMs / 86400000);
      const relStr = diffMs > 0
        ? (days >= 30 ? `in ${Math.round(days / 30)} month${Math.round(days / 30) !== 1 ? 's' : ''}` : `in ${days} day${days !== 1 ? 's' : ''}`)
        : (days >= 30 ? `${Math.round(days / 30)} month${Math.round(days / 30) !== 1 ? 's' : ''} ago` : `${days} day${days !== 1 ? 's' : ''} ago`);
      const statusBadge = isUnlockable
        ? '<span style="font-size:11px;font-weight:600;color:#22c55e">Unlockable</span>'
        : '<span style="font-size:11px;font-weight:600;color:#f59e0b">Locked</span>';
      const isOpsWallet = _connectedAddress && _connectedAddress.toLowerCase() === tap.ops.toLowerCase();
      const opsSymbol = escText(data.meta.symbol || '???');
      html += `
        <div class="drawer" id="opsDrawer">
          <button class="drawer-toggle" onclick="this.parentElement.classList.toggle('open')">
            <span>Ops Allocation</span>
            <span class="arrow">&#9660;</span>
          </button>
          <div class="drawer-body">
            <div class="stat-row"><span class="stat-label">Amount</span><span class="stat-value">${fmtShares(lockAmt)} $${opsSymbol}</span></div>
            <div class="stat-row"><span class="stat-label">Status</span><span class="stat-value">${statusBadge}</span></div>
            <div class="stat-row"><span class="stat-label">Unlocks</span><span class="stat-value">${dateStr} (${relStr})</span></div>
            <div class="stat-row"><span class="stat-label">Recipient</span><span class="stat-value" style="font-size:11px"><a class="ops-addr-link" href="https://etherscan.io/address/${tap.ops}" target="_blank" style="color:inherit;text-decoration:none;border-bottom:1px dotted var(--fg-muted)">${tap.ops}</a></span></div>
            ${isUnlockable && isOpsWallet ? `<button id="opsUnlockBtn" class="action-btn" style="margin-top:10px" onclick="onOpsUnlock('${sharesAddr}','${tap.ops}','${lockCoinId}','${opsLockup.amount}','${opsLockup.unlockTime}')">Unlock ${fmtShares(lockAmt)} $${opsSymbol}</button>` : ''}
          </div>
        </div>
      `;
    }

    const sym = escText(data.meta.symbol || '???');

    // Swap tile  three-mode: Sale / Swap / Ragequit
    const coinLogoUrl = resolveIPFS(metadata.image);
    const coinLogoTag = coinLogoUrl
      ? `<img src="${escText(coinLogoUrl)}" alt="" onerror="this.style.display='none'">`
      : '';
    const ethSvg = `<span class="eth-icon"><svg width="14" height="14" viewBox="0 0 256 417" fill="currentColor" opacity="0.6"><path d="M127.961 0l-2.795 9.5v275.668l2.795 2.79 127.962-75.638z"/><path d="M127.962 0L0 212.32l127.962 75.639V154.158z"/><path d="M127.961 312.187l-1.575 1.92V414.55l1.575 4.6L256 236.587z"/><path d="M127.962 419.15V312.187L0 236.587z"/></svg></span>`;

    const defaultMode = saleActive ? 'sale' : 'swap';

    html += `
      <div class="section-card swap-tile">
        <div class="swap-mode-tabs">
          ${saleActive ? `<button id="modeTabSale" class="${defaultMode==='sale'?'active':''}" onclick="setTradeMode('sale')">Sale</button>` : ''}
          <button id="modeTabSwap" class="${defaultMode==='swap'?'active':''}" onclick="setTradeMode('swap')">Swap</button>
          <button id="modeTabRagequit" onclick="setTradeMode('ragequit')">Ragequit</button>
          ${hasPool ? `<button id="modeTabLp" onclick="setTradeMode('lp')">LP</button>` : ''}
        </div>

        <!-- SALE MODE -->
        ${saleActive ? `
        <div id="saleMode" class="swap-mode-content${defaultMode==='sale'?' active':''}">
          <div class="swap-section">
            <div class="swap-section-head">
              <label>From</label>
              <span id="salePayBal" class="swap-balance"></span>
              <span class="swap-token-tag">${ethSvg} ETH</span>
            </div>
            <input type="text" id="salePayInput" placeholder="0.0" oninput="onSalePayInput()" autocomplete="off">
            <div class="swap-pct-row">
              <button class="swap-pct-btn" onclick="fillPct(25)">25%</button>
              <button class="swap-pct-btn" onclick="fillPct(50)">50%</button>
              <button class="swap-pct-btn" onclick="fillPct(75)">75%</button>
              <button class="swap-pct-btn" onclick="fillPct(100)">100%</button>
            </div>
          </div>
          <div class="swap-arrow-row">
            <div style="width:32px;height:32px;display:inline-flex;align-items:center;justify-content:center"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="var(--fg)" stroke-width="2.5"><path d="M7 10L12 15L17 10"/></svg></div>
          </div>
          <div class="swap-section">
            <div class="swap-section-head">
              <label>To</label>
              <span class="swap-token-tag">${coinLogoTag} $${sym}</span>
            </div>
            <input type="text" id="saleReceiveInput" placeholder="0.0" oninput="onSaleReceiveInput()" autocomplete="off">
            <div class="sale-lp-note" id="saleLpNote"></div>
          </div>
          <div class="swap-quote" id="saleQuote">${priceDisplay ? `Sale price: ${priceDisplay} ETH / 1M shares` : ''}</div>
          <button class="swap-pct-btn" onclick="fillSweep()" style="width:100%;margin-bottom:8px;font-size:11px;padding:6px">Sweep (buy all remaining)</button>
          <button id="saleBuyBtn" class="action-btn" onclick="onSaleBuyBtn()">Connect Wallet</button>
        </div>
        ` : ''}

        <!-- SWAP MODE -->
        <div id="swapMode" class="swap-mode-content${defaultMode==='swap'?' active':''}">
          <div class="swap-dir">
            <button id="swapBuyBtn" class="active" onclick="setSwapDir('buy')">Buy</button>
            <button id="swapSellBtn" onclick="setSwapDir('sell')">Sell</button>
          </div>
          <div class="swap-section" id="swapPaySection">
            <div class="swap-section-head">
              <label>From</label>
              <span id="swapPayBal" class="swap-balance"></span>
              <span class="swap-token-tag" id="swapPayToken">${ethSvg} ETH</span>
            </div>
            <input type="text" id="swapPayInput" placeholder="0.0" oninput="onPayInput()" autocomplete="off">
            <div class="swap-pct-row">
              <button class="swap-pct-btn" onclick="fillPct(25)">25%</button>
              <button class="swap-pct-btn" onclick="fillPct(50)">50%</button>
              <button class="swap-pct-btn" onclick="fillPct(75)">75%</button>
              <button class="swap-pct-btn" onclick="fillPct(100)">100%</button>
            </div>
          </div>
          <div class="swap-arrow-row">
            <button class="swap-arrow-btn" onclick="setSwapDir(_swapDir==='buy'?'sell':'buy')" title="Flip direction"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke-width="2.5"><path d="M7 10L12 15L17 10"/></svg></button>
          </div>
          <div class="swap-section" id="swapReceiveSection">
            <div class="swap-section-head">
              <label>To</label>
              <span class="swap-token-tag" id="swapReceiveToken">${coinLogoTag} $${sym}</span>
            </div>
            <input type="text" id="swapReceiveInput" placeholder="0.0" oninput="onReceiveInput()" autocomplete="off">
          </div>
          <div class="swap-quote" id="swapQuote"></div>
          <button id="swapBtn" class="action-btn" onclick="onSwapBtn()">Connect Wallet</button>
        </div>

        <!-- RAGEQUIT MODE -->
        <div id="ragequitMode" class="swap-mode-content">
          <div class="swap-section">
            <div class="swap-section-head">
              <label>Burn shares</label>
              <span id="rqSharesBal" class="swap-balance"></span>
              <span class="swap-token-tag">${coinLogoTag} $${sym}</span>
            </div>
            <input type="text" id="rqSharesInput" placeholder="0.0" oninput="onRagequitInput()" autocomplete="off">
            <div class="swap-pct-row">
              <button class="swap-pct-btn" onclick="fillPct(25)">25%</button>
              <button class="swap-pct-btn" onclick="fillPct(50)">50%</button>
              <button class="swap-pct-btn" onclick="fillPct(75)">75%</button>
              <button class="swap-pct-btn" onclick="fillPct(100)">100%</button>
            </div>
          </div>
          <div class="rq-estimate" id="rqEstimate"></div>
          <button id="rqBtn" class="action-btn" onclick="onRagequitBtn()">Connect Wallet</button>
        </div>

        <!-- LP MODE -->
        ${hasPool ? `
        <div id="lpMode" class="swap-mode-content">
          <div class="swap-dir">
            <button id="lpZapBtn" class="active" onclick="setLpSubMode('zap')">Zap (ETH only)</button>
            <button id="lpPairBtn" onclick="setLpSubMode('pair')">Add Both</button>
          </div>
          <div id="lpZapForm">
            <div class="swap-section">
              <div class="swap-section-head">
                <label>ETH Amount</label>
                <span id="lpZapBal" class="swap-balance"></span>
                <span class="swap-token-tag">${ethSvg} ETH</span>
              </div>
              <input type="text" id="lpZapEthInput" placeholder="0.0" oninput="onLpEthInput()" autocomplete="off">
              <div class="swap-pct-row">
                <button class="swap-pct-btn" onclick="fillLpPct(25)">25%</button>
                <button class="swap-pct-btn" onclick="fillLpPct(50)">50%</button>
                <button class="swap-pct-btn" onclick="fillLpPct(75)">75%</button>
                <button class="swap-pct-btn" onclick="fillLpPct(100)">100%</button>
              </div>
            </div>
            <div class="swap-quote" id="lpZapQuote"></div>
            <div style="display:flex;align-items:center;gap:8px;margin-bottom:10px">
              <span style="font-size:11px;color:var(--fg-muted)">Slippage</span>
              <input type="text" id="lpZapSlippage" value="5" style="width:40px;font-size:12px;text-align:center;border-bottom:1px solid var(--border)" autocomplete="off">
              <span style="font-size:11px;color:var(--fg-muted)">%</span>
            </div>
            <button id="lpZapDoBtn" class="action-btn" onclick="doLpZap()">Connect Wallet</button>
          </div>
          <div id="lpPairForm" style="display:none">
            <div class="swap-section">
              <div class="swap-section-head">
                <label>ETH</label>
                <span id="lpPairEthBal" class="swap-balance"></span>
                <span class="swap-token-tag">${ethSvg} ETH</span>
              </div>
              <input type="text" id="lpPairEthInput" placeholder="0.0" oninput="onLpPairEthInput()" autocomplete="off">
            </div>
            <div class="swap-section" style="margin-top:8px">
              <div class="swap-section-head">
                <label>$${sym}</label>
                <span id="lpPairTokenBal" class="swap-balance"></span>
                <span class="swap-token-tag">${coinLogoTag} $${sym}</span>
              </div>
              <input type="text" id="lpPairTokenInput" placeholder="0.0" oninput="onLpPairTokenInput()" autocomplete="off">
            </div>
            <div style="display:flex;align-items:center;gap:8px;margin:10px 0">
              <span style="font-size:11px;color:var(--fg-muted)">Slippage</span>
              <input type="text" id="lpPairSlippage" value="2" style="width:40px;font-size:12px;text-align:center;border-bottom:1px solid var(--border)" autocomplete="off">
              <span style="font-size:11px;color:var(--fg-muted)">%</span>
            </div>
            <button id="lpPairDoBtn" class="action-btn" onclick="doLpAdd()">Connect Wallet</button>
          </div>
          <div class="swap-quote" id="lpStatus"></div>
          <div id="lpBalanceInfo" style="font-size:11px;color:var(--fg-muted);margin-top:8px"></div>
        </div>
        ` : ''}
      </div>
    `;

    // Chart drawer (only if pool has reserves; auto-open if sale ended)
    const chartOpen = hasPool && !saleActive;
    const dark = document.documentElement.classList.contains('dark');
    const chartTheme = dark ? 'dark' : 'light';
    if (hasPool) {
      html += `
        <div class="drawer${chartOpen ? ' open' : ''}" id="chartDrawer" data-pool-id="${poolId}"${chartOpen ? ' data-loaded="1"' : ''}>
          <button class="drawer-toggle" onclick="toggleChart()">
            <span>Price Chart</span>
            <span class="arrow">&#9660;</span>
          </button>
          <div class="chart-body">${chartOpen ? `<div class="chart-type-toggle"><button class="active" data-type="line" onclick="setCoinChartType('line')">Line</button><button data-type="candle" onclick="setCoinChartType('candle')">Candle</button></div><div class="chart-iframe-wrap"><iframe src="https://www.zamm.finance/embed/pool/1/${poolId}?type=line&theme=${chartTheme}" allow="clipboard-write" sandbox="allow-scripts allow-same-origin"></iframe></div>` : ''}</div>
        </div>
        <div class="drawer" id="activityDrawer" data-pool-id="${poolId}">
          <button class="drawer-toggle" onclick="toggleActivity()">
            <span>Pool Activity</span>
            <span class="arrow">&#9660;</span>
          </button>
          <div class="activity-body">
            <div id="activityContent"><div class="activity-empty">${zfiLoadingSVG(32)} Loading...</div></div>
          </div>
        </div>
        <div class="drawer" id="lpDrawer" data-pool-id="${poolId}">
          <button class="drawer-toggle" onclick="toggleLpList()">
            <span>Liquidity Providers</span>
            <span class="arrow">&#9660;</span>
          </button>
          <div class="activity-body">
            <div id="lpListContent"><div class="activity-empty">Click to load</div></div>
          </div>
        </div>
      `;
    }

    // Links
    html += `
      <div class="links-row" style="margin-top:16px;margin-bottom:24px">
        <a href="../dao/#/dao/1/${daoAddr}">Manage DAO</a>
        <a href="https://etherscan.io/address/${daoAddr}" target="_blank">Etherscan (DAO)</a>
        <a href="https://etherscan.io/address/${sharesAddr}" target="_blank">Etherscan (Token)</a>
      </div>
    `;

    // Store data for swap
    app.innerHTML = html;
    app.dataset.dao = daoAddr;
    app.dataset.shares = sharesAddr;
    app.dataset.feeOrHook = feeOrHook.toString();
    app.dataset.poolId = poolId.toString();
    app.dataset.hasPool = hasPool ? '1' : '';
    _poolReserve0 = reserve0;
    _poolReserve1 = reserve1;
    _swapDir = 'buy';
    _saleData = sale;
    _lpSubMode = 'zap';
    _tradeMode = defaultMode;
    tryAutoConnect();

    // Resolve .wei name for ops address
    if (tapActive && tap.ops) {
      try {
        const rpc = new ethers.JsonRpcProvider(RPCS[0], 1, { staticNetwork: true });
        const ns = new ethers.Contract(WEINS, WEINS_ABI, rpc);
        ns.reverseResolve(tap.ops).then(name => {
          if (name) {
            document.querySelectorAll('.ops-addr-link').forEach(el => { el.textContent = name.toLowerCase(); });
          }
        }).catch(() => {});
      } catch {}
    }

  } catch(e) {
    app.innerHTML = `
      <a href="#" class="back-link">&larr; All Coins</a>
      <div class="loading">Failed to load: ${escText(e.message || 'Unknown error')}</div>
    `;
  }
}

// ==================== SWAP ====================

function setTradeMode(mode) {
  _tradeMode = mode;
  _cachedQuote = null;
  // Update tab active states
  const tabs = ['Sale','Swap','Ragequit','Lp'];
  tabs.forEach(t => {
    const btn = $('modeTab' + t);
    if (btn) btn.classList.toggle('active', t.toLowerCase() === mode);
  });
  // Show/hide content sections
  ['saleMode','swapMode','ragequitMode','lpMode'].forEach(id => {
    const el = $(id);
    if (el) el.classList.toggle('active', id === mode + 'Mode');
  });
  // Update button text based on wallet state
  updateModeButton();
  loadBalances();
  if (mode === 'lp') loadLpBalance();
}

function updateModeButton() {
  const connected = !!_signer;
  if (_tradeMode === 'sale') {
    const btn = $('saleBuyBtn');
    if (btn) btn.textContent = connected ? 'Buy' : 'Connect Wallet';
  } else if (_tradeMode === 'swap') {
    const btn = $('swapBtn');
    if (btn) btn.textContent = connected ? 'Swap' : 'Connect Wallet';
  } else if (_tradeMode === 'ragequit') {
    const btn = $('rqBtn');
    if (btn) btn.textContent = connected ? 'Ragequit' : 'Connect Wallet';
  } else if (_tradeMode === 'lp') {
    const zapBtn = $('lpZapDoBtn');
    const pairBtn = $('lpPairDoBtn');
    if (zapBtn) zapBtn.textContent = connected ? 'Zap Liquidity' : 'Connect Wallet';
    if (pairBtn) pairBtn.textContent = connected ? 'Add Liquidity' : 'Connect Wallet';
  }
}

function setSwapDir(dir) {
  _swapDir = dir;
  _cachedQuote = null;
  $('swapBuyBtn').classList.toggle('active', dir === 'buy');
  $('swapSellBtn').classList.toggle('active', dir === 'sell');
  updateSwapLabels();
  $('swapPayInput').value = '';
  $('swapReceiveInput').value = '';
  $('swapQuote').textContent = '';
  loadBalances();
}

function updateSwapLabels() {
  if (!_coinData) return;
  const sym = '$' + (_coinData.meta.symbol || '???');
  const isBuy = _swapDir === 'buy';
  const payToken = $('swapPayToken');
  const recvToken = $('swapReceiveToken');
  if (!payToken || !recvToken) return;
  const coinLogoUrl = _coinMeta ? resolveIPFS(_coinMeta.image) : '';
  const coinTag = coinLogoUrl
    ? `<img src="${escText(coinLogoUrl)}" alt="" onerror="this.style.display='none'"> ${sym}`
    : sym;
  const ethTag = `<span class="eth-icon"><svg width="14" height="14" viewBox="0 0 256 417" fill="currentColor" opacity="0.6"><path d="M127.961 0l-2.795 9.5v275.668l2.795 2.79 127.962-75.638z"/><path d="M127.962 0L0 212.32l127.962 75.639V154.158z"/><path d="M127.961 312.187l-1.575 1.92V414.55l1.575 4.6L256 236.587z"/><path d="M127.962 419.15V312.187L0 236.587z"/></svg></span> ETH`;
  payToken.innerHTML = isBuy ? ethTag : coinTag;
  recvToken.innerHTML = isBuy ? coinTag : ethTag;
}

let _lastQuoteId = 0;
let _quoteDebounce = null;
let _cachedQuote = null; // { exactOut, tokenIn, tokenOut, amount, result, ts }

function onPayInput() {
  _exactOut = false;
  $('swapReceiveInput').value = '';
  scheduleQuote();
}

function onReceiveInput() {
  _exactOut = true;
  $('swapPayInput').value = '';
  scheduleQuote();
}

function scheduleQuote() {
  clearTimeout(_quoteDebounce);
  _quoteDebounce = setTimeout(fetchQuote, 300);
}

async function fetchQuote() {
  const raw = _exactOut ? $('swapReceiveInput').value.trim() : $('swapPayInput').value.trim();
  if (!raw || isNaN(raw) || Number(raw) <= 0) { $('swapQuote').textContent = ''; return; }

  const quoteId = ++_lastQuoteId;
  const shares = $('app').dataset.shares;
  const feeOrHook = BigInt($('app').dataset.feeOrHook || '30');

  try {
    const amount = ethers.parseEther(raw);
    const isBuy = _swapDir === 'buy';
    const tokenIn = isBuy ? ZERO : shares;
    const tokenOut = isBuy ? shares : ZERO;

    const result = await withRPC(async rpc => {
      const quoter = new ethers.Contract(ZQUOTER, QUOTE_ABI, rpc);
      return await quoter.quoteZAMM(_exactOut, feeOrHook, tokenIn, tokenOut, 0, 0, amount);
    });
    _cachedQuote = { exactOut: _exactOut, tokenIn, tokenOut, amount, result, ts: Date.now() };

    if (quoteId !== _lastQuoteId) return;

    if (_exactOut) {
      const val = Number(ethers.formatEther(result.amountIn)).toLocaleString(undefined, {maximumFractionDigits: 6});
      $('swapPayInput').value = ethers.formatEther(result.amountIn);
      $('swapQuote').textContent = `Estimated cost: ~${val}`;
    } else {
      const val = Number(ethers.formatEther(result.amountOut)).toLocaleString(undefined, {maximumFractionDigits: 6});
      $('swapReceiveInput').value = ethers.formatEther(result.amountOut);
      $('swapQuote').textContent = `Estimated output: ~${val}`;
    }
  } catch(e) {
    if (quoteId !== _lastQuoteId) return;
    $('swapQuote').textContent = 'No liquidity yet';
  }
}

// ---- Wallet state ----
let _connectedAddress = null;
let _connectedWalletProvider = null;
let _walletConnectProvider = null;
let _isConnecting = false;
let _walletEventHandlers = null;
let _isWalletConnect = false;
let _wcDeepLink = null;

const eip6963Providers = new Map();
window.addEventListener('eip6963:announceProvider', (event) => {
  try {
    const { info, provider } = event.detail || {};
    if (info?.uuid && provider) eip6963Providers.set(info.uuid, { info, provider });
  } catch (e) {}
});
window.dispatchEvent(new Event('eip6963:requestProvider'));

function findProvider(checkFn) {
  if (window.ethereum?.providers?.length) {
    for (const p of window.ethereum.providers) { if (checkFn(p)) return p; }
  }
  if (window.ethereum && checkFn(window.ethereum)) return window.ethereum;
  return null;
}

const WALLET_CONFIG = {
  metamask: { name: 'MetaMask', icon: '', detect: () => findProvider(p => p.isMetaMask), getProvider: () => findProvider(p => p.isMetaMask) },
  coinbase: { name: 'Coinbase', icon: '', detect: () => findProvider(p => p.isCoinbaseWallet), getProvider: () => findProvider(p => p.isCoinbaseWallet) },
  rabby: { name: 'Rabby', icon: '', detect: () => findProvider(p => p.isRabby), getProvider: () => findProvider(p => p.isRabby) },
  rainbow: { name: 'Rainbow', icon: '', detect: () => findProvider(p => p.isRainbow), getProvider: () => findProvider(p => p.isRainbow) },
  walletconnect: { name: 'WalletConnect', icon: '' }
};

function detectWallets() {
  const detected = [];
  const seenNames = new Set();
  for (const [uuid, { info, provider }] of eip6963Providers.entries()) {
    const name = info?.name || 'Unknown';
    if (!seenNames.has(name.toLowerCase())) {
      const iconUrl = info.icon && (info.icon.startsWith('data:image/') || info.icon.startsWith('https://')) ? info.icon : null;
      const safeIconUrl = iconUrl ? iconUrl.replace(/[<>&"']/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','"':'&quot;',"'":'&#39;'}[c])) : null;
      detected.push({ key: `eip6963_${uuid}`, name, icon: safeIconUrl ? `<img src="${safeIconUrl}" style="width:1.5rem;height:1.5rem;border-radius:4px;">` : '', getProvider: () => provider });
      seenNames.add(name.toLowerCase());
    }
  }
  if (window.ethereum?.providers?.length) {
    for (let i = 0; i < window.ethereum.providers.length; i++) {
      const p = window.ethereum.providers[i];
      const name = p.isMetaMask ? 'MetaMask' : p.isCoinbaseWallet ? 'Coinbase' : p.isRabby ? 'Rabby' : p.isRainbow ? 'Rainbow' : null;
      if (name && !seenNames.has(name.toLowerCase())) { detected.push({ key: `provider_${i}`, name, icon: '', getProvider: () => p }); seenNames.add(name.toLowerCase()); }
    }
  }
  for (const [key, config] of Object.entries(WALLET_CONFIG)) {
    if (key === 'walletconnect') continue;
    try { if (config.detect && config.detect() && !seenNames.has(config.name.toLowerCase())) { detected.push({ key, ...config }); seenNames.add(config.name.toLowerCase()); } } catch (e) {}
  }
  if (detected.length === 0 && window.ethereum) detected.push({ key: 'injected', name: 'Browser Wallet', icon: '', getProvider: () => window.ethereum });
  const wcModule = globalThis['@walletconnect/ethereum-provider'];
  if (wcModule?.EthereumProvider) detected.push({ key: 'walletconnect', name: 'WalletConnect', icon: '' });
  return detected;
}

function showWalletModal() {
  $('walletModal').classList.add('active');
  document.body.classList.add('modal-open');
  $('walletOptions').innerHTML = '<div style="padding:12px;text-align:center;">Detecting wallets...</div>';
  window.dispatchEvent(new Event('eip6963:requestProvider'));
  const doDetect = (attempt = 1) => {
    const wallets = detectWallets();
    if (!wallets.some(w => w.key !== 'walletconnect') && attempt < 2) setTimeout(() => doDetect(attempt + 1), 250);
    else renderWalletModal(wallets);
  };
  setTimeout(() => doDetect(), 150);
}

function renderWalletModal(wallets) {
  const container = $('walletOptions');
  if (_connectedAddress) {
    const displayName = $('walletBtn').textContent;
    const showName = displayName && displayName !== 'connect' && !displayName.startsWith('0x');
    container.innerHTML = `<div style="padding:12px;border:1px solid currentColor;margin-bottom:12px;"><div style="font-weight:600;margin-bottom:6px;">Connected</div>${showName ? `<div style="font-size:16px;margin-bottom:4px;">${escText(displayName)}</div>` : ''}<div style="font-size:12px;word-break:break-all;opacity:0.6;">${escText(_connectedAddress)}</div></div><div class="wallet-option disconnect" onclick="disconnectWallet()"><span class="wallet-option-name">Disconnect</span></div>`;
  } else {
    container.innerHTML = wallets.length > 0 ? wallets.map(w => `<div class="wallet-option" data-wallet-key="${escAttr(w.key)}"><span class="wallet-option-icon">${w.icon}</span><span class="wallet-option-name">${escText(w.name)}</span></div>`).join('') : '<div style="padding:12px;text-align:center;">No wallets detected.</div>';
    container.querySelectorAll('[data-wallet-key]').forEach(el => { el.addEventListener('click', () => connectWithWallet(el.dataset.walletKey)); });
  }
}

function closeWalletModal() { $('walletModal').classList.remove('active'); document.body.classList.remove('modal-open'); }
function toggleWallet() { showWalletModal(); }

async function connectWithWallet(walletKey) {
  if (_isConnecting) return;
  _isConnecting = true;
  try {
    closeWalletModal();
    let walletProvider;
    if (walletKey === 'walletconnect') {
      const wcModule = globalThis['@walletconnect/ethereum-provider'];
      const WCProvider = wcModule?.EthereumProvider;
      if (!WCProvider?.init) throw new Error('WalletConnect not available');
      if (_walletConnectProvider) { try { await _walletConnectProvider.disconnect?.(); } catch (e) {} _walletConnectProvider = null; }
      _walletConnectProvider = await WCProvider.init({ projectId: '1e8390ef1c1d8a185e035912a1409749', chains: [1], showQrModal: true, rpcMap: { 1: 'https://1rpc.io/eth' }, metadata: { name: 'zFi Coins', description: 'Onchain coin trading', url: window.location.origin, icons: [] } });
      _walletConnectProvider.on('display_uri', () => { try { const s = _walletConnectProvider.session?.peer?.metadata; if (s?.redirect?.native && /^https?:\/\//i.test(s.redirect.native)) _wcDeepLink = s.redirect.native; else if (s?.redirect?.universal && /^https?:\/\//i.test(s.redirect.universal)) _wcDeepLink = s.redirect.universal; } catch (e) {} });
      await _walletConnectProvider.enable();
      walletProvider = _walletConnectProvider;
      _isWalletConnect = true;
      try { const s = _walletConnectProvider.session?.peer?.metadata; if (s?.redirect?.native && /^https?:\/\//i.test(s.redirect.native)) _wcDeepLink = s.redirect.native; else if (s?.redirect?.universal && /^https?:\/\//i.test(s.redirect.universal)) _wcDeepLink = s.redirect.universal; } catch (e) {}
    } else if (walletKey.startsWith('eip6963_')) {
      const uuid = walletKey.replace('eip6963_', '');
      walletProvider = eip6963Providers.get(uuid)?.provider;
      if (!walletProvider) { const savedName = localStorage.getItem('zcoin_wallet_name')?.toLowerCase(); if (savedName) { for (const [, { info, provider }] of eip6963Providers) { if (info?.name?.toLowerCase() === savedName) { walletProvider = provider; break; } } } }
      _isWalletConnect = false; _wcDeepLink = null;
    } else {
      walletProvider = WALLET_CONFIG[walletKey]?.getProvider() || window.ethereum;
      _isWalletConnect = false; _wcDeepLink = null;
    }
    if (!walletProvider) throw new Error('Wallet not found');
    if (walletKey !== 'walletconnect') await walletProvider.request({ method: 'eth_requestAccounts' });
    const chainId = await walletProvider.request({ method: 'eth_chainId' });
    if (BigInt(chainId) !== 1n) {
      try { await walletProvider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: '0x1' }] }); const nc = await walletProvider.request({ method: 'eth_chainId' }); if (BigInt(nc) !== 1n) throw new Error('Chain switch failed'); }
      catch (switchErr) { alert('Please switch to Ethereum Mainnet'); if (walletKey === 'walletconnect') { try { _walletConnectProvider?.disconnect(); } catch (e) {} _walletConnectProvider = null; } _isWalletConnect = false; _wcDeepLink = null; return; }
    }
    _walletProvider = new ethers.BrowserProvider(walletProvider);
    _signer = await _walletProvider.getSigner();
    _connectedAddress = await _signer.getAddress();
    const oldWP = _connectedWalletProvider;
    _connectedWalletProvider = walletProvider;
    $('walletBtn').textContent = _connectedAddress.slice(0, 6) + '...' + _connectedAddress.slice(-4);
    resolveWeiName(_connectedAddress);
    updateWcBanner();
    if (oldWP && _walletEventHandlers) { try { oldWP.removeListener('accountsChanged', _walletEventHandlers.accountsChanged); oldWP.removeListener('chainChanged', _walletEventHandlers.chainChanged); } catch (e) {} }
    _walletEventHandlers = { accountsChanged: () => window.location.reload(), chainChanged: () => window.location.reload() };
    walletProvider.on('accountsChanged', _walletEventHandlers.accountsChanged);
    walletProvider.on('chainChanged', _walletEventHandlers.chainChanged);
    try { localStorage.setItem('zcoin_wallet', walletKey); localStorage.setItem('preferredWallet', walletKey); if (walletKey.startsWith('eip6963_')) { const uuid = walletKey.replace('eip6963_', ''); const name = eip6963Providers.get(uuid)?.info?.name; if (name) localStorage.setItem('zcoin_wallet_name', name); } } catch (e) {}
    updateModeButton();
    loadBalances();
  } catch (error) {
    console.error('Wallet connect error:', error);
    alert(error.message || 'Connection failed');
  } finally { _isConnecting = false; }
}

function disconnectWallet() {
  if (_connectedWalletProvider && _walletEventHandlers) { try { _connectedWalletProvider.removeListener('accountsChanged', _walletEventHandlers.accountsChanged); _connectedWalletProvider.removeListener('chainChanged', _walletEventHandlers.chainChanged); } catch (e) {} }
  _walletEventHandlers = null;
  if (_walletConnectProvider) { try { _walletConnectProvider.disconnect(); } catch (e) {} _walletConnectProvider = null; }
  _walletProvider = null; _signer = null; _connectedAddress = null; _connectedWalletProvider = null; _isWalletConnect = false; _wcDeepLink = null;
  $('walletBtn').textContent = 'connect';
  updateWcBanner();
  closeWalletModal();
  try { localStorage.removeItem('zcoin_wallet'); localStorage.removeItem('zcoin_wallet_name'); localStorage.removeItem('preferredWallet'); } catch (e) {}
  updateModeButton();
}

// Compatibility wrapper  existing code calls connectWallet()
async function connectWallet() {
  if (_signer) return _signer;
  showWalletModal();
  return null;
}

function resolveWeiName(addr) {
  try {
    const rpc = new ethers.JsonRpcProvider(RPCS[0], 1, { staticNetwork: true });
    const ns = new ethers.Contract(WEINS, WEINS_ABI, rpc);
    ns.reverseResolve(addr).then(name => { if (name && _connectedAddress === addr) $('walletBtn').textContent = name.toLowerCase(); }).catch(() => {});
  } catch (e) {}
}

function updateWcBanner() {
  const existing = document.getElementById('wcBanner');
  if (existing) existing.remove();
  if (_isWalletConnect && _connectedAddress) {
    const banner = document.createElement('div');
    banner.id = 'wcBanner';
    banner.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#1a1a2e;color:#fff;padding:10px 16px;display:flex;justify-content:space-between;align-items:center;z-index:9000;font-size:13px;';
    banner.innerHTML = '<span> Connected via WalletConnect</span><button onclick="disconnectWallet()" style="background:#fff;color:#000;border:none;padding:6px 12px;border-radius:0;cursor:pointer;font-size:12px;">Disconnect</button>';
    document.body.prepend(banner);
    document.body.style.paddingTop = '44px';
  } else {
    document.body.style.paddingTop = '';
  }
}

async function tryAutoConnect() {
  const savedWallet = localStorage.getItem('zcoin_wallet') || localStorage.getItem('preferredWallet');
  if (!savedWallet) {
    if (!window.ethereum) return;
    try { const accts = await window.ethereum.request({ method: 'eth_accounts' }); if (accts && accts.length > 0) await connectWithWallet('injected'); } catch {}
    return;
  }
  $('walletBtn').textContent = '...';
  setTimeout(async () => {
    try { window.dispatchEvent(new Event('eip6963:requestProvider')); await new Promise(r => setTimeout(r, 300)); await connectWithWallet(savedWallet); }
    catch (e) { console.error('Auto-reconnect failed:', e); $('walletBtn').textContent = 'connect'; }
  }, 100);
}

let _payBalance = 0n; // raw wei balance of pay-side token
let _ethBalance = 0n;
let _sharesBalance = 0n;
let _ragequitTotalSupply = 0n; // shares + loot (for pro-rata ragequit)

async function loadBalances() {
  if (!_signer || !_coinData) return;
  const addr = await _signer.getAddress();
  const shares = _coinData.meta.sharesToken;
  const loot = _coinData.meta.lootToken;
  const daoAddr = $('app').dataset.dao;
  try {
    const erc20 = new ethers.Interface(ERC20_ABI);
    const mc3i = new ethers.Interface(MC3_ABI);
    const calls = [
      { target: MC3, allowFailure: false, callData: mc3i.encodeFunctionData('getEthBalance', [addr]) },
      { target: shares, allowFailure: true, callData: erc20.encodeFunctionData('balanceOf', [addr]) },
      { target: shares, allowFailure: true, callData: erc20.encodeFunctionData('totalSupply') },
      { target: loot, allowFailure: true, callData: erc20.encodeFunctionData('totalSupply') },
      { target: MC3, allowFailure: false, callData: mc3i.encodeFunctionData('getEthBalance', [daoAddr]) }
    ];
    const results = await withRPC(async rpc => {
      const mc = new ethers.Contract(MC3, MC3_ABI, rpc);
      return await mc.aggregate3(calls);
    });
    const decode = (abi, fn, r) => r.success ? abi.decodeFunctionResult(fn, r.returnData)[0] : 0n;
    const ethBal = decode(mc3i, 'getEthBalance', results[0]);
    const tokenBal = decode(erc20, 'balanceOf', results[1]);
    const sharesTotalSupply = decode(erc20, 'totalSupply', results[2]);
    const lootTotalSupply = decode(erc20, 'totalSupply', results[3]);
    const treasuryBal = decode(mc3i, 'getEthBalance', results[4]);
    _ethBalance = ethBal;
    _sharesBalance = tokenBal;
    _ragequitTotalSupply = sharesTotalSupply + lootTotalSupply;

    // User balance display
    const balEl = $('coinUserBalance');
    if (balEl) {
      const sym = _coinData?.meta?.symbol || '???';
      if (tokenBal > 0n) {
        balEl.textContent = `Your balance: ${fmtShares(tokenBal)} $${sym}`;
        balEl.style.display = '';
      } else {
        balEl.style.display = 'none';
      }
    }

    // Swap mode balance
    const isBuy = _swapDir === 'buy';
    _payBalance = isBuy ? ethBal : tokenBal;
    const payEl = $('swapPayBal');
    if (payEl) {
      const payFmt = isBuy
        ? Number(ethers.formatEther(ethBal)).toLocaleString(undefined, {maximumFractionDigits:6}) + ' ETH'
        : fmtShares(tokenBal) + ' $' + (_coinData.meta.symbol || '???');
      payEl.textContent = payFmt;
      payEl.onclick = () => fillPct(100);
    }

    // Sale mode balance (ETH)
    const salePayEl = $('salePayBal');
    if (salePayEl) {
      salePayEl.textContent = Number(ethers.formatEther(ethBal)).toLocaleString(undefined, {maximumFractionDigits:6}) + ' ETH';
      salePayEl.onclick = () => fillPct(100);
    }

    // Ragequit mode balance (shares)
    const rqEl = $('rqSharesBal');
    if (rqEl) {
      rqEl.textContent = fmtShares(tokenBal) + ' $' + (_coinData.meta.symbol || '???');
      rqEl.onclick = () => fillPct(100);
    }

    // LP mode balances
    const ethFmt = Number(ethers.formatEther(ethBal)).toLocaleString(undefined, {maximumFractionDigits:6}) + ' ETH';
    const tokenFmtLp = fmtShares(tokenBal) + ' $' + (_coinData.meta.symbol || '???');
    const lpZapBal = $('lpZapBal');
    if (lpZapBal) { lpZapBal.textContent = ethFmt; lpZapBal.onclick = () => fillLpPct(100); }
    const lpPairEthBal = $('lpPairEthBal');
    if (lpPairEthBal) { lpPairEthBal.textContent = ethFmt; lpPairEthBal.onclick = () => fillLpPct(100); }
    const lpPairTokenBal = $('lpPairTokenBal');
    if (lpPairTokenBal) { lpPairTokenBal.textContent = tokenFmtLp; }

    // Store treasury balance for ragequit estimate
    _coinData._treasuryEthBal = treasuryBal;
  } catch {}
}

function fillPct(pct) {
  if (_tradeMode === 'sale') {
    if (_ethBalance <= 0n) return;
    let amt = _ethBalance * BigInt(pct) / 100n;
    if (pct === 100 && amt > ethers.parseEther('0.005')) amt -= ethers.parseEther('0.005');
    if (amt <= 0n) return;
    $('salePayInput').value = ethers.formatEther(amt);
    onSalePayInput();
  } else if (_tradeMode === 'ragequit') {
    if (_sharesBalance <= 0n) return;
    let amt = _sharesBalance * BigInt(pct) / 100n;
    if (amt <= 0n) return;
    $('rqSharesInput').value = ethers.formatEther(amt);
    onRagequitInput();
  } else {
    // swap mode
    if (_payBalance <= 0n) return;
    let amt = _payBalance * BigInt(pct) / 100n;
    if (_swapDir === 'buy' && pct === 100 && amt > ethers.parseEther('0.005')) {
      amt -= ethers.parseEther('0.005');
    }
    if (amt <= 0n) return;
    $('swapPayInput').value = ethers.formatEther(amt);
    _exactOut = false;
    $('swapReceiveInput').value = '';
    scheduleQuote();
  }
}

// ==================== SALE BUY ====================

function onSalePayInput() {
  _saleExactOut = false;
  if (!_saleData || !_saleData.forAmt || !_saleData.tribAmt) return;
  const raw = ($('salePayInput').value || '').trim();
  if (!raw || isNaN(raw) || Number(raw) <= 0) {
    $('saleReceiveInput').value = '';
    $('saleLpNote').textContent = '';
    return;
  }
  const payAmt = ethers.parseEther(raw);
  const gross = payAmt * _saleData.forAmt / _saleData.tribAmt;
  const lpBps = BigInt(_saleData.lpBps);
  const lpShares = gross * lpBps / 10000n;
  const net = gross - lpShares;
  $('saleReceiveInput').value = ethers.formatEther(net);
  if (lpBps > 0n) {
    $('saleLpNote').textContent = `~${fmtShares(net)} shares (${Number(lpBps)/100}% to LP)`;
  } else {
    $('saleLpNote').textContent = '';
  }
}

function onSaleReceiveInput() {
  _saleExactOut = true;
  if (!_saleData || !_saleData.forAmt || !_saleData.tribAmt) return;
  const raw = ($('saleReceiveInput').value || '').trim();
  if (!raw || isNaN(raw) || Number(raw) <= 0) {
    $('salePayInput').value = '';
    $('saleLpNote').textContent = '';
    return;
  }
  const buyAmt = ethers.parseEther(raw);
  const lpBps = BigInt(_saleData.lpBps);
  // grossNeeded = ceil(buyAmt * 10000 / (10000 - lpBps))
  const denom = 10000n - lpBps;
  if (denom === 0n) { $('salePayInput').value = ''; $('saleLpNote').textContent = ''; return; }
  const grossNeeded = (buyAmt * 10000n + denom - 1n) / denom;
  // payNeeded = ceil(grossNeeded * tribAmt / forAmt)
  const payNeeded = (grossNeeded * _saleData.tribAmt + _saleData.forAmt - 1n) / _saleData.forAmt;
  $('salePayInput').value = ethers.formatEther(payNeeded);
  if (lpBps > 0n) {
    $('saleLpNote').textContent = `~${fmtShares(buyAmt)} shares (${Number(lpBps)/100}% to LP)`;
  } else {
    $('saleLpNote').textContent = '';
  }
}

function fillSweep() {
  if (!_saleData || !_saleData.forAmt || !_saleData.tribAmt || _saleData.remainingSupply <= 0n) return;
  const lpBps = BigInt(_saleData.lpBps);
  // remainingSupply is gross (includes LP portion), net to buyer = remaining * (10000 - lpBps) / 10000
  const net = _saleData.remainingSupply * (10000n - lpBps) / 10000n;
  // cost = ceil(remainingSupply * tribAmt / forAmt)
  const payNeeded = (_saleData.remainingSupply * _saleData.tribAmt + _saleData.forAmt - 1n) / _saleData.forAmt;
  $('saleReceiveInput').value = ethers.formatEther(net);
  $('salePayInput').value = ethers.formatEther(payNeeded);
  _saleExactOut = false;
  if (lpBps > 0n) {
    $('saleLpNote').textContent = `~${fmtShares(net)} shares (${Number(lpBps)/100}% to LP)`;
  } else {
    $('saleLpNote').textContent = '';
  }
}

async function onSaleBuyBtn() {
  if (!_signer) { await connectWallet(); return; }
  executeSaleBuy();
}

async function executeSaleBuy() {
  const s = await connectWallet();
  if (!s) return;
  if (!_saleData) return;

  const payRaw = ($('salePayInput').value || '').trim();
  const recvRaw = ($('saleReceiveInput').value || '').trim();
  if (!payRaw || isNaN(payRaw) || Number(payRaw) <= 0) return;
  if (!recvRaw || isNaN(recvRaw) || Number(recvRaw) <= 0) return;

  const daoAddr = $('app').dataset.dao;
  const btn = $('saleBuyBtn');
  btn.textContent = 'Confirm in wallet...';
  btn.disabled = true;

  try {
    const daico = new ethers.Contract(DAICO_ADDR, DAICO_BUY_ABI, s);
    const payAmt = ethers.parseEther(payRaw);
    const netShares = ethers.parseEther(recvRaw);

    let tx;
    if (_saleExactOut) {
      // exact-out: get exact buyAmt, pay up to 5% more
      const maxPay = payAmt * 105n / 100n;
      tx = await daico.buyExactOut(daoAddr, ZERO, netShares, maxPay, { value: maxPay });
    } else {
      // exact-in: pay exact payAmt, get at least 95% of estimate
      const minBuyAmt = netShares * 95n / 100n;
      tx = await daico.buy(daoAddr, ZERO, payAmt, minBuyAmt, { value: payAmt });
    }
    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px;color:inherit;opacity:0.7">View tx</a>`;
    await tx.wait();

    const quoteEl = $('saleQuote');
    if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--green)">Purchase confirmed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px">View tx</a>`;
    $('salePayInput').value = '';
    $('saleReceiveInput').value = '';
    $('saleLpNote').textContent = '';

    setTimeout(() => renderCoinPage(daoAddr), 2000);
    const adEl = $('activityDrawer');
    if (adEl && adEl.dataset.loaded) setTimeout(() => refreshActivity(adEl.dataset.poolId), 4000);
  } catch(e) {
    const quoteEl = $('saleQuote');
    if (e.code === 'ACTION_REJECTED' || (e.message||'').includes('user rejected')) {
      if (quoteEl) quoteEl.textContent = 'Cancelled';
    } else {
      if (quoteEl) quoteEl.textContent = 'Buy failed: ' + (e.shortMessage || e.reason || e.message || '').split('\n')[0].slice(0, 80);
    }
  } finally {
    btn.textContent = 'Buy';
    btn.disabled = false;
  }
}

// ==================== RAGEQUIT ====================

function onRagequitInput() {
  const raw = ($('rqSharesInput').value || '').trim();
  const el = $('rqEstimate');
  if (!raw || isNaN(raw) || Number(raw) <= 0 || _ragequitTotalSupply <= 0n) {
    if (el) el.innerHTML = '';
    return;
  }
  const sharesToBurn = ethers.parseEther(raw);
  const treasuryBal = _coinData?._treasuryEthBal || 0n;
  if (treasuryBal <= 0n || sharesToBurn <= 0n) {
    if (el) el.innerHTML = '';
    return;
  }
  const ethBack = sharesToBurn * treasuryBal / _ragequitTotalSupply;
  if (el) el.innerHTML = `&asymp; ${fmtETH(ethBack)} back<small>(pro-rata of ${fmtETH(treasuryBal)} treasury)</small>`;
}

async function onRagequitBtn() {
  if (!_signer) { await connectWallet(); return; }
  executeRagequit();
}

async function executeRagequit() {
  const s = await connectWallet();
  if (!s) return;

  const raw = ($('rqSharesInput').value || '').trim();
  if (!raw || isNaN(raw) || Number(raw) <= 0) return;

  const daoAddr = $('app').dataset.dao;
  const btn = $('rqBtn');
  btn.textContent = 'Confirm in wallet...';
  btn.disabled = true;

  try {
    const dao = new ethers.Contract(daoAddr, RAGEQUIT_ABI, s);
    const sharesToBurn = ethers.parseEther(raw);

    const tx = await dao.ragequit([ZERO], sharesToBurn, 0);
    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px;color:inherit;opacity:0.7">View tx</a>`;
    await tx.wait();

    const el = $('rqEstimate');
    if (el) el.innerHTML = `<span style="color:var(--green)">Ragequit confirmed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px">View tx</a>`;
    $('rqSharesInput').value = '';

    setTimeout(() => renderCoinPage(daoAddr), 2000);
  } catch(e) {
    const el = $('rqEstimate');
    if (e.code === 'ACTION_REJECTED' || (e.message||'').includes('user rejected')) {
      if (el) el.innerHTML = 'Cancelled';
    } else {
      if (el) el.innerHTML = 'Ragequit failed: ' + escText((e.shortMessage || e.reason || e.message || '').split('\n')[0].slice(0, 80));
    }
  } finally {
    btn.textContent = 'Ragequit';
    btn.disabled = false;
  }
}

// ==================== LP ====================

function setLpSubMode(mode) {
  _lpSubMode = mode;
  const zapBtn = $('lpZapBtn');
  const pairBtn = $('lpPairBtn');
  if (zapBtn) zapBtn.classList.toggle('active', mode === 'zap');
  if (pairBtn) pairBtn.classList.toggle('active', mode === 'pair');
  const zapForm = $('lpZapForm');
  const pairForm = $('lpPairForm');
  if (zapForm) zapForm.style.display = mode === 'zap' ? '' : 'none';
  if (pairForm) pairForm.style.display = mode === 'pair' ? '' : 'none';
  const status = $('lpStatus');
  if (status) { status.textContent = ''; status.className = 'swap-quote'; }
}

function fillLpPct(pct) {
  if (_ethBalance <= 0n) return;
  let amt = _ethBalance * BigInt(pct) / 100n;
  if (pct === 100 && amt > ethers.parseEther('0.005')) amt -= ethers.parseEther('0.005');
  if (amt <= 0n) return;
  if (_lpSubMode === 'zap') {
    const max = maxZapETH();
    if (max > 0n && amt > max) amt = max;
    $('lpZapEthInput').value = ethers.formatEther(amt);
    onLpEthInput();
  } else {
    $('lpPairEthInput').value = ethers.formatEther(amt);
    onLpPairEthInput();
  }
}

function quoteLpZap(ethAmount) {
  const foh = BigInt($('app').dataset.feeOrHook || '30');
  // If feeOrHook > 10000 it's a hook address, not fee bps  fall back to 30 bps
  const feeBps = foh > 10000n ? 30n : foh;
  const isHooked = foh > 10000n;
  const halfEth = ethAmount / 2n;
  const amtInWithFee = halfEth * (10000n - feeBps);
  const tokensOut = (amtInWithFee * _poolReserve1) / (_poolReserve0 * 10000n + amtInWithFee);
  return { halfEth, tokensOut, feeBps, isHooked };
}

// Max ETH that can be zapped without exceeding slippage tolerance.
// The swap half moves the price; we find the max ethAmount such that
// price impact stays within the user's slippage %.
// After swapping halfEth, new reserve0 = R0 + halfEth, new reserve1 = R1 - tokensOut.
// For the LP add to succeed, the ratio (halfEth / tokensOut) must be close to
// (R0 + halfEth) / (R1 - tokensOut), within slippage.
// Simpler bound: price impact  halfEth / R0, so max halfEth  R0 * slipPct.
// Then max total zap  2 * R0 * slipPct.
function maxZapETH() {
  if (_poolReserve0 === 0n) return 0n;
  const slip = Number(($('lpZapSlippage')?.value || '5').trim()) || 5;
  // Use slip% of reserve as max for the swap half, then double for total zap
  return _poolReserve0 * BigInt(slip) * 2n / 100n;
}

function onLpEthInput() {
  const raw = ($('lpZapEthInput').value || '').trim();
  const quoteEl = $('lpZapQuote');
  const btn = $('lpZapDoBtn');
  if (!raw || isNaN(raw) || Number(raw) <= 0 || _poolReserve0 === 0n) {
    if (quoteEl) quoteEl.textContent = '';
    if (btn && _signer) btn.disabled = false;
    return;
  }
  const ethAmt = ethers.parseEther(raw);
  const max = maxZapETH();
  const q = quoteLpZap(ethAmt);
  const halfFmt = Number(ethers.formatEther(q.halfEth)).toFixed(6);
  const tokFmt = Number(ethers.formatEther(q.tokensOut)).toFixed(6);
  const sym = _coinData?.meta?.symbol || '???';
  const approx = q.isHooked ? '(approx) ' : '';
  if (ethAmt > max && max > 0n) {
    const maxFmt = Number(ethers.formatEther(max)).toLocaleString(undefined, {maximumFractionDigits:8});
    const maxRaw = ethers.formatEther(max);
    if (quoteEl) quoteEl.innerHTML = `<span style="color:var(--red,#e55)">Too large  max zap <a href="#" onclick="event.preventDefault();document.getElementById('lpZapEthInput').value='${maxRaw}';onLpEthInput()" style="color:inherit;text-decoration:underline;cursor:pointer">~${maxFmt} ETH</a> at current slippage</span>`;
    if (btn) btn.disabled = true;
  } else {
    if (quoteEl) quoteEl.textContent = `${approx}~${halfFmt} ETH + ~${tokFmt} $${sym}  LP`;
    if (btn && _signer) btn.disabled = false;
  }
}

function onLpPairEthInput() {
  if (_poolReserve0 === 0n || _poolReserve1 === 0n) return;
  const raw = ($('lpPairEthInput').value || '').trim();
  if (!raw || isNaN(raw) || Number(raw) <= 0) { $('lpPairTokenInput').value = ''; return; }
  const ethAmt = ethers.parseEther(raw);
  const tokenAmt = ethAmt * _poolReserve1 / _poolReserve0;
  $('lpPairTokenInput').value = ethers.formatEther(tokenAmt);
}

function onLpPairTokenInput() {
  if (_poolReserve0 === 0n || _poolReserve1 === 0n) return;
  const raw = ($('lpPairTokenInput').value || '').trim();
  if (!raw || isNaN(raw) || Number(raw) <= 0) { $('lpPairEthInput').value = ''; return; }
  const tokenAmt = ethers.parseEther(raw);
  const ethAmt = tokenAmt * _poolReserve0 / _poolReserve1;
  $('lpPairEthInput').value = ethers.formatEther(ethAmt);
}

async function loadLpBalance() {
  if (!_signer || !$('app').dataset.hasPool) return;
  try {
    const addr = await _signer.getAddress();
    const poolId = BigInt($('app').dataset.poolId);
    _lpBalance = await withRPC(async rpc => {
      const z = new ethers.Contract(ZAMM, ZAMM_LP_ABI, rpc);
      return await z.balanceOf(addr, poolId);
    });
    const el = $('lpBalanceInfo');
    if (el) {
      if (_lpBalance > 0n) {
        el.textContent = 'Your LP: ' + Number(ethers.formatEther(_lpBalance)).toLocaleString(undefined, {maximumFractionDigits:6});
      } else {
        el.textContent = '';
      }
    }
  } catch (e) {
    console.debug('loadLpBalance:', e.message);
  }
}

async function doLpZap() {
  if (!_signer) { await connectWallet(); return; }
  const raw = ($('lpZapEthInput').value || '').trim();
  if (!raw || isNaN(raw) || Number(raw) <= 0) return;

  const ethAmount = ethers.parseEther(raw);
  const max = maxZapETH();
  if (max > 0n && ethAmount > max) {
    const status = $('lpStatus');
    const maxFmt = Number(ethers.formatEther(max)).toLocaleString(undefined, {maximumFractionDigits:8});
    if (status) status.innerHTML = `<span style="color:var(--red,#e55)">Amount too large  max ~${maxFmt} ETH at current slippage</span>`;
    return;
  }
  const shares = $('app').dataset.shares;
  const feeOrHook = BigInt($('app').dataset.feeOrHook || '30');
  const poolKey = { id0: 0, id1: 0, token0: ZERO, token1: shares, feeOrHook };

  const q = quoteLpZap(ethAmount);
  const slip = Number(($('lpZapSlippage').value || '5').trim()) || 5;
  const slipMul = BigInt(Math.floor((100 - slip) * 100));
  const amountOutMin = q.tokensOut * slipMul / 10000n;
  const amount0Min = q.halfEth * slipMul / 10000n;
  const amount1Min = q.tokensOut * slipMul / 10000n;

  const btn = $('lpZapDoBtn');
  const status = $('lpStatus');
  btn.textContent = 'Confirm in wallet...';
  btn.disabled = true;

  try {
    const zap = new ethers.Contract(V1_ZAP, V1_ZAP_ABI, _signer);
    const addr = await _signer.getAddress();
    const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

    const tx = await zap.addSingleLiqETH(
      poolKey, amountOutMin, amount0Min, amount1Min,
      addr, deadline, { value: ethAmount }
    );
    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px;color:inherit;opacity:0.7">View tx</a>`;
    await tx.wait();

    if (status) status.innerHTML = `<span style="color:var(--green)">Zap LP added!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px">View tx</a>`;
    $('lpZapEthInput').value = '';
    $('lpZapQuote').textContent = '';
    loadLpBalance();
    // Refresh reserves
    refreshPoolReserves();
  } catch(e) {
    if (e.code === 'ACTION_REJECTED' || (e.message||'').includes('user rejected')) {
      if (status) status.textContent = 'Cancelled';
    } else {
      if (status) status.textContent = 'Zap failed: ' + (e.shortMessage || e.reason || e.message || '').split('\n')[0].slice(0, 80);
    }
  } finally {
    btn.textContent = 'Zap Liquidity';
    btn.disabled = false;
  }
}

async function doLpAdd() {
  if (!_signer) { await connectWallet(); return; }
  const ethRaw = ($('lpPairEthInput').value || '').trim();
  const tokenRaw = ($('lpPairTokenInput').value || '').trim();
  if (!ethRaw || isNaN(ethRaw) || Number(ethRaw) <= 0) return;
  if (!tokenRaw || isNaN(tokenRaw) || Number(tokenRaw) <= 0) return;

  const ethAmt = ethers.parseEther(ethRaw);
  const tokenAmt = ethers.parseEther(tokenRaw);
  const shares = $('app').dataset.shares;
  const feeOrHook = BigInt($('app').dataset.feeOrHook || '30');
  const poolKey = { id0: 0, id1: 0, token0: ZERO, token1: shares, feeOrHook };

  const slip = Number(($('lpPairSlippage').value || '2').trim()) || 2;
  const slipMul = BigInt(Math.floor((100 - slip) * 100));
  const min0 = ethAmt * slipMul / 10000n;
  const min1 = tokenAmt * slipMul / 10000n;

  const btn = $('lpPairDoBtn');
  const status = $('lpStatus');
  btn.textContent = 'Checking approval...';
  btn.disabled = true;

  try {
    const addr = await _signer.getAddress();
    // Approve shares token to ZAMM if needed
    const token = new ethers.Contract(shares, ERC20_ABI, _signer);
    const allow = await token.allowance(addr, ZAMM);
    if (allow < tokenAmt) {
      btn.textContent = 'Approving...';
      await (await token.approve(ZAMM, ethers.MaxUint256)).wait();
    }

    btn.textContent = 'Confirm in wallet...';
    const zamm = new ethers.Contract(ZAMM, ZAMM_LP_ABI, _signer);
    const deadline = BigInt(Math.floor(Date.now() / 1000) + 1200);

    const tx = await zamm.addLiquidity(
      poolKey, ethAmt, tokenAmt, min0, min1, addr, deadline,
      { value: ethAmt }
    );
    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px;color:inherit;opacity:0.7">View tx</a>`;
    await tx.wait();

    if (status) status.innerHTML = `<span style="color:var(--green)">Liquidity added!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px">View tx</a>`;
    $('lpPairEthInput').value = '';
    $('lpPairTokenInput').value = '';
    loadLpBalance();
    refreshPoolReserves();
  } catch(e) {
    if (e.code === 'ACTION_REJECTED' || (e.message||'').includes('user rejected')) {
      if (status) status.textContent = 'Cancelled';
    } else {
      if (status) status.textContent = 'Add LP failed: ' + (e.shortMessage || e.reason || e.message || '').split('\n')[0].slice(0, 80);
    }
  } finally {
    btn.textContent = 'Add Liquidity';
    btn.disabled = false;
  }
}

async function refreshPoolReserves() {
  try {
    const poolId = BigInt($('app').dataset.poolId);
    const result = await withRPC(async rpc => {
      const z = new ethers.Contract(ZAMM, ZAMM_POOLS_ABI, rpc);
      return await z.pools(poolId);
    });
    _poolReserve0 = result.reserve0 ?? result[0] ?? 0n;
    _poolReserve1 = result.reserve1 ?? result[1] ?? 0n;
  } catch(e) {
    console.debug('refreshPoolReserves:', e.message);
  }
}

async function onSwapBtn() {
  if (!_signer) {
    await connectWallet();
    return;
  }
  executeSwap();
}

async function executeSwap() {
  const s = await connectWallet();
  if (!s) return;

  const raw = _exactOut ? $('swapReceiveInput').value.trim() : $('swapPayInput').value.trim();
  if (!raw || isNaN(raw) || Number(raw) <= 0) return;

  const shares = $('app').dataset.shares;
  const feeOrHook = BigInt($('app').dataset.feeOrHook || '30');
  const address = await s.getAddress();
  const deadline = Math.floor(Date.now() / 1000) + 600;

  const btn = $('swapBtn');
  const origText = btn.textContent;
  btn.textContent = 'Swapping...';
  btn.disabled = true;

  try {
    const isBuy = _swapDir === 'buy';
    const amount = ethers.parseEther(raw);
    const tokenIn = isBuy ? ZERO : shares;
    const tokenOut = isBuy ? shares : ZERO;
    // ZAMM PoolKey: token0=ETH(ZERO), token1=shares. Buy=zeroForOne(true), Sell=zeroForOne(false)
    const poolKey = { id0: 0, id1: 0, token0: ZERO, token1: shares, feeOrHook: feeOrHook };

    // Reuse cached quote if fresh (<15s) and params match, otherwise re-fetch
    let quote;
    if (_cachedQuote && Date.now() - _cachedQuote.ts < 15000
        && _cachedQuote.exactOut === _exactOut
        && _cachedQuote.tokenIn === tokenIn && _cachedQuote.tokenOut === tokenOut
        && _cachedQuote.amount === amount) {
      quote = _cachedQuote.result;
    } else {
      quote = await withRPC(async rpc => {
        const quoter = new ethers.Contract(ZQUOTER, QUOTE_ABI, rpc);
        return await quoter.quoteZAMM(_exactOut, feeOrHook, tokenIn, tokenOut, 0, 0, amount);
      });
    }

    let tx;
    if (!_exactOut) {
      // Exact input: user specifies how much they pay
      const minOut = quote.amountOut * 95n / 100n; // 5% slippage

      if (!isBuy) {
        // Selling shares: approve ZAMM
        const token = new ethers.Contract(shares, ERC20_ABI, s);
        const allow = await token.allowance(address, ZAMM);
        if (allow < amount) {
          btn.textContent = 'Approving...';
          await (await token.approve(ZAMM, ethers.MaxUint256)).wait();
        }
      }

      btn.textContent = 'Confirm in wallet...';
      const pool = new ethers.Contract(ZAMM, ZAMM_ABI, s);
      tx = await pool.swapExactIn(
        poolKey, amount, minOut, isBuy, address, deadline,
        { value: isBuy ? amount : 0n }
      );
    } else {
      // Exact output: user specifies how much they receive
      const maxIn = quote.amountIn * 105n / 100n; // 5% slippage

      if (!isBuy) {
        // Selling shares: approve ZAMM for max input
        const token = new ethers.Contract(shares, ERC20_ABI, s);
        const allow = await token.allowance(address, ZAMM);
        if (allow < maxIn) {
          btn.textContent = 'Approving...';
          await (await token.approve(ZAMM, ethers.MaxUint256)).wait();
        }
      }

      btn.textContent = 'Confirm in wallet...';
      const pool = new ethers.Contract(ZAMM, ZAMM_ABI, s);
      tx = await pool.swapExactOut(
        poolKey, amount, maxIn, isBuy, address, deadline,
        { value: isBuy ? maxIn : 0n }
      );
    }

    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px;color:inherit;opacity:0.7">View tx</a>`;
    await tx.wait();

    $('swapQuote').innerHTML = `<span style="color:var(--green)">Swap confirmed!</span> <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px">View tx</a>`;
    $('swapPayInput').value = '';
    $('swapReceiveInput').value = '';

    // Refresh page data + activity feed (delay for indexer)
    setTimeout(() => renderCoinPage($('app').dataset.dao), 2000);
    const adEl = $('activityDrawer');
    if (adEl && adEl.dataset.loaded) setTimeout(() => refreshActivity(adEl.dataset.poolId), 4000);
  } catch(e) {
    if (e.code === 'ACTION_REJECTED' || (e.message||'').includes('user rejected')) {
      $('swapQuote').textContent = 'Cancelled';
    } else {
      $('swapQuote').textContent = 'Swap failed: ' + (e.shortMessage || e.reason || e.message || '').split('\n')[0].slice(0, 80);
    }
  } finally {
    btn.textContent = origText;
    btn.disabled = false;
  }
}

// ==================== TAP CLAIM ====================

const DAICO_CLAIM_ABI = ['function claimTap(address dao) returns (uint256 claimed)'];

async function onTapClaim() {
  const s = await connectWallet();
  if (!s) return;
  const btn = $('tapClaimBtn');
  if (!btn) return;
  const origText = btn.textContent;
  btn.textContent = 'Claiming...';
  btn.disabled = true;
  try {
    const daico = new ethers.Contract(DAICO_ADDR, DAICO_CLAIM_ABI, s);
    const tx = await daico.claimTap($('app').dataset.dao);
    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px;color:inherit;opacity:0.7">View tx</a>`;
    await tx.wait();
    btn.textContent = 'Claimed!';
    setTimeout(() => location.reload(), 1500);
  } catch(e) {
    if (e.code === 'ACTION_REJECTED' || (e.message||'').includes('user rejected')) {
      btn.textContent = 'Cancelled';
    } else {
      btn.textContent = 'Failed';
    }
    setTimeout(() => { btn.textContent = origText; btn.disabled = false; }, 2000);
  }
}

// ==================== OPS UNLOCK ====================

const OPS_UNLOCK_ABI = ['function unlock(address token, address to, uint256 id, uint256 amount, uint256 unlockTime)'];

async function onOpsUnlock(token, to, coinId, amount, unlockTime) {
  const s = await connectWallet();
  if (!s) return;
  const btn = $('opsUnlockBtn');
  if (!btn) return;
  const origText = btn.textContent;
  btn.textContent = 'Unlocking...';
  btn.disabled = true;
  try {
    const zamm = new ethers.Contract(ZAMM, OPS_UNLOCK_ABI, s);
    const tx = await zamm.unlock(token, to, BigInt(coinId), BigInt(amount), BigInt(unlockTime));
    btn.innerHTML = `Confirming... <a href="https://etherscan.io/tx/${tx.hash}" target="_blank" style="font-size:11px;color:inherit;opacity:0.7">View tx</a>`;
    await tx.wait();
    btn.textContent = 'Unlocked!';
    setTimeout(() => location.reload(), 1500);
  } catch(e) {
    if (e.code === 'ACTION_REJECTED' || (e.message||'').includes('user rejected')) {
      btn.textContent = 'Cancelled';
    } else {
      btn.textContent = 'Failed';
    }
    setTimeout(() => { btn.textContent = origText; btn.disabled = false; }, 2000);
  }
}

// ==================== INIT ====================
route();
</script>
<footer class="site-footer">
  <a href="../">Swap</a> &middot; <a href="../domains/">Domains</a> &middot; <a href="../dao/">DAO</a> &middot; <a href="../predict/">Predict</a> &middot; <a href="../orderbook/">Orderbook</a> &middot; <a href="../lp/">LP</a> &middot; built by <a href="https://opensea.io/collection/zorgz" target="_blank" rel="noopener"><svg width="14" height="14" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;margin:0 2px;image-rendering:pixelated"><rect width="16" height="16" fill="#0a0a0a"/><rect x="3" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="5" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="10" y="2" width="1" height="1" fill="#e8e8e0"/><rect x="12" y="1" width="1" height="1" fill="#e8e8e0"/><rect x="4" y="4" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="5" width="10" height="1" fill="#e8e8e0"/><rect x="2" y="6" width="12" height="3" fill="#e8e8e0"/><rect x="3" y="9" width="10" height="1" fill="#e8e8e0"/><rect x="4" y="10" width="8" height="1" fill="#e8e8e0"/><rect x="3" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="10" y="6" width="3" height="2" fill="#0a0a0a"/><rect x="5" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="9" y="11" width="2" height="1" fill="#e8e8e0"/><rect x="2" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="7" y="12" width="2" height="1" fill="#e8e8e0"/><rect x="11" y="12" width="3" height="1" fill="#e8e8e0"/><rect x="1" y="13" width="2" height="1" fill="#e8e8e0"/><rect x="13" y="13" width="2" height="1" fill="#e8e8e0"/></svg></a><a href="../dao/#/dao/1/0x5E58BA0e06ED0F5558f83bE732a4b899a674053E">zOrg</a> &middot; <a href="https://x.com/z_fi_" target="_blank" rel="noopener" title="X"><svg width="14" height="14" viewBox="0 0 300 300.251" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;fill:currentColor"><path d="M178.57 127.15 290.27 0h-26.46l-97.03 110.38L89.34 0H0l117.13 166.93L0 300.25h26.46l102.4-116.59 81.8 116.59h89.34M36.01 19.54H76.66l187.13 262.13h-40.66"/></svg></a>
  <div style="margin-top:8px;letter-spacing:1px"><a href="https://github.com/z-fi/zFi" target="_blank" rel="noopener" style="text-decoration:none;color:inherit">zfi.wei</a></div>
  <div class="tagline" style="margin-top:4px;font-size:12px;letter-spacing:0.5px;font-style:italic">the most secure-by-default exchange that does everything onchain</div>
</footer>
</body>
</html>
